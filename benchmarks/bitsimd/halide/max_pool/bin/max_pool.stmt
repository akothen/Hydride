module name=max_pool, target=x86-64-linux-avx-avx2-avx512-avx512_skylake-f16c-fma-no_asserts-no_bounds_query-sse41
external_plus_metadata func max_pool (input, stride_x, stride_y, filter_width, filter_height, output_min, output_max, output) {
assert((uint64)reinterpret((halide_buffer_t *)output.buffer) != (uint64)0, halide_error_buffer_argument_is_null("output"))
assert((uint64)reinterpret((halide_buffer_t *)input.buffer) != (uint64)0, halide_error_buffer_argument_is_null("input"))
let input = (void *)_halide_buffer_get_host((halide_buffer_t *)input.buffer)
let input.min.0 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 0)
let input.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 0)
let input.min.1 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 1)
let input.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 1)
let input.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 1)
let input.min.2 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 2)
let input.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)input.buffer, 2)
let input.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 2)
let input.min.3 = _halide_buffer_get_min((halide_buffer_t *)input.buffer, 3)
let input.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)input.buffer, 3)
let output = (void *)_halide_buffer_get_host((halide_buffer_t *)output.buffer)
let output.min.0 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 0)
let output.extent.0 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 0)
let output.stride.0 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 0)
let output.min.1 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 1)
let output.extent.1 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 1)
let output.stride.1 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 1)
let output.min.2 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 2)
let output.extent.2 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 2)
let output.stride.2 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 2)
let output.min.3 = _halide_buffer_get_min((halide_buffer_t *)output.buffer, 3)
let output.extent.3 = _halide_buffer_get_extent((halide_buffer_t *)output.buffer, 3)
let output.stride.3 = _halide_buffer_get_stride((halide_buffer_t *)output.buffer, 3)
assert(input.stride.0 == 1, 0)
assert(output.stride.0 == 1, 0)
produce output {
 let t102 = (output.extent.0 + 31)/32
 let t106 = (((output.min.0 - (output.min.3*output.stride.3)) - (output.min.2*output.stride.2)) - (output.min.1*output.stride.1)) - output.min.0
 let t105 = (((output.min.0 - (input.min.3*input.stride.3)) - (input.min.2*input.stride.2)) - (input.min.1*input.stride.1)) - input.min.0
 let t103 = input.extent.2 + input.min.2
 let t104 = input.extent.1 + input.min.1
 for (output.s0.y.rebased, 0, output.extent.2) {
  let t111 = output.min.2 + output.s0.y.rebased
  let t112 = stride_y*t111
  let t108 = min(t103 - t112, filter_height)
  let t107 = min(input.min.2 - t112, filter_height)
  let t110 = (output.stride.2*t111) + t106
  for (output.s0.x.rebased, 0, output.extent.1) {
   let t120 = output.min.1 + output.s0.x.rebased
   let t121 = max(t107, 0)
   let t122 = stride_x*t120
   let t113 = max(t107, t108)
   let t116 = min(t104 - t122, filter_width)
   let t115 = min(input.min.1 - t122, filter_width)
   let t117 = t112 + t121
   let t119 = (output.stride.1*t120) + t110
   for (output.s0.b.rebased, 0, output.extent.3) {
    let t129 = output.min.3 + output.s0.b.rebased
    let t130 = max(t115, 0)
    let t124 = max(t115, t116)
    let t123 = max(t113, 0) - t121
    let t127 = t122 + t130
    let t128 = (output.stride.3*t129) + t119
    let t126 = (input.stride.3*t129) + t105
    for (output.s0.c.c, 0, t102) {
     let output.s0.c.v2.base.s = min(output.s0.c.c*32, output.extent.0 + -32)
     allocate maximum[int32 * 32]
     produce maximum {
      maximum[ramp(0, 1, 32)] = x32(output_min)
      let t131 = max(t124, 0) - t130
      let t132 = output.s0.c.v2.base.s + t126
      for (maximum.s1.r12$y.rebased, 0, t123) {
       let t133 = ((maximum.s1.r12$y.rebased + t117)*input.stride.2) + t132
       for (maximum.s1.r12$x.rebased, 0, t131) {
        maximum[ramp(0, 1, 32)] = max(maximum[ramp(0, 1, 32)], input[ramp(((maximum.s1.r12$x.rebased + t127)*input.stride.1) + t133, 1, 32)])
       }
      }
     }
     consume maximum {
      output[ramp(output.s0.c.v2.base.s + t128, 1, 32)] = min(maximum[ramp(0, 1, 32)], x32(output_max))
     }
     free maximum
    }
   }
  }
 }
}
}


