<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.3" name="generator"/>
<title>AI Engine Intrinsics User Guide: Integer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script src="resize.js" type="text/javascript"></script>
<script src="navtree.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectlogo"><img alt="Logo" src="amd-logo.png"/></td>
<td style="padding-left: 0.5em;">
<div id="projectname">AI Engine Intrinsics User Guide
    <span id="projectnumber">(v2023.2)</span>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="index.html"><span>Overview</span></a></li>
<li><a href="pages.html"><span>Related Pages</span></a></li>
<li><a href="modules.html"><span>API Reference</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__intr__gpvectorop__arit__adv__int.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark"> </span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark"> </span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark"> </span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark"> </span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark"> </span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark"> </span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark"> </span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark"> </span>Pages</a></div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Integer<div class="ingroups"><a class="el" href="group__intr__gpvectorop__arit__adv.html">Advanced</a></div></div> </div>
</div><!--header-->
<div class="contents">
<a id="details" name="details"></a><h2 class="groupheader">Overview</h2>
<p>Advanced Integer Vector Arithmetic Operations. To have more information in lane selection please refer to <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae6e9ed89d28623ede37b6eba9bb4fb79"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gae6e9ed89d28623ede37b6eba9bb4fb79">abs16</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi)</td></tr>
<tr class="memdesc:gae6e9ed89d28623ede37b6eba9bb4fb79"><td class="mdescLeft"> </td><td class="mdescRight">Performs an absolute value computation between lanes of xbuff.  <a href="#gae6e9ed89d28623ede37b6eba9bb4fb79"></a><br/></td></tr>
<tr class="separator:gae6e9ed89d28623ede37b6eba9bb4fb79"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7c17adc8007dd11dd7698260e59b63ce"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga7c17adc8007dd11dd7698260e59b63ce">abs16</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi)</td></tr>
<tr class="memdesc:ga7c17adc8007dd11dd7698260e59b63ce"><td class="mdescLeft"> </td><td class="mdescRight">Performs an absolute value computation between lanes of xbuff.  <a href="#ga7c17adc8007dd11dd7698260e59b63ce"></a><br/></td></tr>
<tr class="separator:ga7c17adc8007dd11dd7698260e59b63ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga91fc38e9f2874f711a5fb78f1b56811e"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga91fc38e9f2874f711a5fb78f1b56811e">abs32</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare)</td></tr>
<tr class="memdesc:ga91fc38e9f2874f711a5fb78f1b56811e"><td class="mdescLeft"> </td><td class="mdescRight">Performs an absolute value computation between lanes of xbuff.  <a href="#ga91fc38e9f2874f711a5fb78f1b56811e"></a><br/></td></tr>
<tr class="separator:ga91fc38e9f2874f711a5fb78f1b56811e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gafff406deb20a19c4773eafae450fc0f7"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gafff406deb20a19c4773eafae450fc0f7">abs32</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare)</td></tr>
<tr class="memdesc:gafff406deb20a19c4773eafae450fc0f7"><td class="mdescLeft"> </td><td class="mdescRight">Performs an absolute value computation between lanes of xbuff.  <a href="#gafff406deb20a19c4773eafae450fc0f7"></a><br/></td></tr>
<tr class="separator:gafff406deb20a19c4773eafae450fc0f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadd7719905c75e8c137eff51b0b1a00a4"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gadd7719905c75e8c137eff51b0b1a00a4">add16</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:gadd7719905c75e8c137eff51b0b1a00a4"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#gadd7719905c75e8c137eff51b0b1a00a4"></a><br/></td></tr>
<tr class="separator:gadd7719905c75e8c137eff51b0b1a00a4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3418d4101dd22d26fdb9b065f698c77e"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga3418d4101dd22d26fdb9b065f698c77e">add16</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:ga3418d4101dd22d26fdb9b065f698c77e"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#ga3418d4101dd22d26fdb9b065f698c77e"></a><br/></td></tr>
<tr class="separator:ga3418d4101dd22d26fdb9b065f698c77e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa5da0c19880e03c7a48aac62779cbd5c"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gaa5da0c19880e03c7a48aac62779cbd5c">add16</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, v16int32 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:gaa5da0c19880e03c7a48aac62779cbd5c"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff and ybuff.  <a href="#gaa5da0c19880e03c7a48aac62779cbd5c"></a><br/></td></tr>
<tr class="separator:gaa5da0c19880e03c7a48aac62779cbd5c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac1e24cfcc30c874a40de339421a521ca"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gac1e24cfcc30c874a40de339421a521ca">add16</a> (v32cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:gac1e24cfcc30c874a40de339421a521ca"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#gac1e24cfcc30c874a40de339421a521ca"></a><br/></td></tr>
<tr class="separator:gac1e24cfcc30c874a40de339421a521ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac86fdd2ce5630ed5734d7c84d2f450da"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gac86fdd2ce5630ed5734d7c84d2f450da">add16</a> (v16cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:gac86fdd2ce5630ed5734d7c84d2f450da"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#gac86fdd2ce5630ed5734d7c84d2f450da"></a><br/></td></tr>
<tr class="separator:gac86fdd2ce5630ed5734d7c84d2f450da"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadf2a532bd91f7a22564ef1191b71d2e2"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gadf2a532bd91f7a22564ef1191b71d2e2">add16</a> (v16cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16cint16 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:gadf2a532bd91f7a22564ef1191b71d2e2"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff and ybuff.  <a href="#gadf2a532bd91f7a22564ef1191b71d2e2"></a><br/></td></tr>
<tr class="separator:gadf2a532bd91f7a22564ef1191b71d2e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga61b45da3cb0881a9dac995e645f9455b"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga61b45da3cb0881a9dac995e645f9455b">add32</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga61b45da3cb0881a9dac995e645f9455b"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#ga61b45da3cb0881a9dac995e645f9455b"></a><br/></td></tr>
<tr class="separator:ga61b45da3cb0881a9dac995e645f9455b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc">add32</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc"></a><br/></td></tr>
<tr class="separator:ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaadec9f4e0120394b33e114f6f1a137e1"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gaadec9f4e0120394b33e114f6f1a137e1">add32</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:gaadec9f4e0120394b33e114f6f1a137e1"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff and ybuff.  <a href="#gaadec9f4e0120394b33e114f6f1a137e1"></a><br/></td></tr>
<tr class="separator:gaadec9f4e0120394b33e114f6f1a137e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabcbab53f01d486e56368760efa8af4ce"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gabcbab53f01d486e56368760efa8af4ce">add8</a> (v16cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:gabcbab53f01d486e56368760efa8af4ce"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#gabcbab53f01d486e56368760efa8af4ce"></a><br/></td></tr>
<tr class="separator:gabcbab53f01d486e56368760efa8af4ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaab92df6b5fc4d31653bc62a209ec6e9a"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gaab92df6b5fc4d31653bc62a209ec6e9a">add8</a> (v8cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:gaab92df6b5fc4d31653bc62a209ec6e9a"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff.  <a href="#gaab92df6b5fc4d31653bc62a209ec6e9a"></a><br/></td></tr>
<tr class="separator:gaab92df6b5fc4d31653bc62a209ec6e9a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga51f916bb1272ba81bea9b750f26ac449"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga51f916bb1272ba81bea9b750f26ac449">add8</a> (v8cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8cint32 ybuff, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:ga51f916bb1272ba81bea9b750f26ac449"><td class="mdescLeft"> </td><td class="mdescRight">Performs an addition between lanes of xbuff and ybuff.  <a href="#ga51f916bb1272ba81bea9b750f26ac449"></a><br/></td></tr>
<tr class="separator:ga51f916bb1272ba81bea9b750f26ac449"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga155e93ebd3a0719adc1d1e96427e7816"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga155e93ebd3a0719adc1d1e96427e7816">sub16</a> (v32int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:ga155e93ebd3a0719adc1d1e96427e7816"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#ga155e93ebd3a0719adc1d1e96427e7816"></a><br/></td></tr>
<tr class="separator:ga155e93ebd3a0719adc1d1e96427e7816"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabd02aaf40bec53cb7e9d1fbcba330bd6"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gabd02aaf40bec53cb7e9d1fbcba330bd6">sub16</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:gabd02aaf40bec53cb7e9d1fbcba330bd6"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#gabd02aaf40bec53cb7e9d1fbcba330bd6"></a><br/></td></tr>
<tr class="separator:gabd02aaf40bec53cb7e9d1fbcba330bd6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabbff9a729f2df8ea77d36a502c2b2425"><td align="right" class="memItemLeft" valign="top">v16int32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gabbff9a729f2df8ea77d36a502c2b2425">sub16</a> (v16int32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, v16int32 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi)</td></tr>
<tr class="memdesc:gabbff9a729f2df8ea77d36a502c2b2425"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff and ybuff.  <a href="#gabbff9a729f2df8ea77d36a502c2b2425"></a><br/></td></tr>
<tr class="separator:gabbff9a729f2df8ea77d36a502c2b2425"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga41a1822ea528b7b57b32d573c60ede0e"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga41a1822ea528b7b57b32d573c60ede0e">sub16</a> (v32cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga41a1822ea528b7b57b32d573c60ede0e"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#ga41a1822ea528b7b57b32d573c60ede0e"></a><br/></td></tr>
<tr class="separator:ga41a1822ea528b7b57b32d573c60ede0e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7160f0e87fe2721b0f23a0aa00dd6eb4"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga7160f0e87fe2721b0f23a0aa00dd6eb4">sub16</a> (v16cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga7160f0e87fe2721b0f23a0aa00dd6eb4"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#ga7160f0e87fe2721b0f23a0aa00dd6eb4"></a><br/></td></tr>
<tr class="separator:ga7160f0e87fe2721b0f23a0aa00dd6eb4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga33731ee0454a4f58b1f76af36877a260"><td align="right" class="memItemLeft" valign="top">v16cint16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga33731ee0454a4f58b1f76af36877a260">sub16</a> (v16cint16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v16cint16 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga33731ee0454a4f58b1f76af36877a260"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff and ybuff.  <a href="#ga33731ee0454a4f58b1f76af36877a260"></a><br/></td></tr>
<tr class="separator:ga33731ee0454a4f58b1f76af36877a260"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa35ed9015e4dabc051a887d503ab6a5e"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gaa35ed9015e4dabc051a887d503ab6a5e">sub32</a> (v64int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:gaa35ed9015e4dabc051a887d503ab6a5e"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#gaa35ed9015e4dabc051a887d503ab6a5e"></a><br/></td></tr>
<tr class="separator:gaa35ed9015e4dabc051a887d503ab6a5e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga26980d005e43376f0f6b264479d6b388"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga26980d005e43376f0f6b264479d6b388">sub32</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga26980d005e43376f0f6b264479d6b388"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#ga26980d005e43376f0f6b264479d6b388"></a><br/></td></tr>
<tr class="separator:ga26980d005e43376f0f6b264479d6b388"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga623d9f8c9117df94ec3e070b44db8725"><td align="right" class="memItemLeft" valign="top">v32int16 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga623d9f8c9117df94ec3e070b44db8725">sub32</a> (v32int16 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, unsigned int xoffsets_hi, unsigned int xsquare, v32int16 ybuff, int ystart, unsigned int yoffsets, unsigned int yoffsets_hi, unsigned int ysquare)</td></tr>
<tr class="memdesc:ga623d9f8c9117df94ec3e070b44db8725"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff and ybuff.  <a href="#ga623d9f8c9117df94ec3e070b44db8725"></a><br/></td></tr>
<tr class="separator:ga623d9f8c9117df94ec3e070b44db8725"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2eb87ad35a5b0d8038f0d6581c0e1ddd"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#ga2eb87ad35a5b0d8038f0d6581c0e1ddd">sub8</a> (v16cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:ga2eb87ad35a5b0d8038f0d6581c0e1ddd"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#ga2eb87ad35a5b0d8038f0d6581c0e1ddd"></a><br/></td></tr>
<tr class="separator:ga2eb87ad35a5b0d8038f0d6581c0e1ddd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadecbca2c3143ff6344ecd4951b77ad7b"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gadecbca2c3143ff6344ecd4951b77ad7b">sub8</a> (v8cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:gadecbca2c3143ff6344ecd4951b77ad7b"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff.  <a href="#gadecbca2c3143ff6344ecd4951b77ad7b"></a><br/></td></tr>
<tr class="separator:gadecbca2c3143ff6344ecd4951b77ad7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac1628d4084d3b80a0fd9f65d1af6ae82"><td align="right" class="memItemLeft" valign="top">v8cint32 </td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr__gpvectorop__arit__adv__int.html#gac1628d4084d3b80a0fd9f65d1af6ae82">sub8</a> (v8cint32 xbuff, int <a class="el" href="group__intr__gpvectorop__bit__cmp__flt.html#ga2f5c88c0c138b27d78ec9efd83b861df">xstart</a>, unsigned int xoffsets, v8cint32 ybuff, int ystart, unsigned int yoffsets)</td></tr>
<tr class="memdesc:gac1628d4084d3b80a0fd9f65d1af6ae82"><td class="mdescLeft"> </td><td class="mdescRight">Performs a subtraction between lanes of xbuff and ybuff.  <a href="#gac1628d4084d3b80a0fd9f65d1af6ae82"></a><br/></td></tr>
<tr class="separator:gac1628d4084d3b80a0fd9f65d1af6ae82"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae6e9ed89d28623ede37b6eba9bb4fb79"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 abs16 </td>
<td>(</td>
<td class="paramtype">v32int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an absolute value computation between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    o[i] = abs(x[idx])</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an absolute value computation between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga7c17adc8007dd11dd7698260e59b63ce"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 abs16 </td>
<td>(</td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an absolute value computation between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    o[i] = abs(x[idx])</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an absolute value computation between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga91fc38e9f2874f711a5fb78f1b56811e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 abs32 </td>
<td>(</td>
<td class="paramtype">v64int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an absolute value computation between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    o[i] = abs(x[idx])</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an absolute value computation between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 64 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gafff406deb20a19c4773eafae450fc0f7"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 abs32 </td>
<td>(</td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an absolute value computation between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    o[i] = abs(x[idx])</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an absolute value computation between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gadd7719905c75e8c137eff51b0b1a00a4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 add16 </td>
<td>(</td>
<td class="paramtype">v32int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga3418d4101dd22d26fdb9b065f698c77e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 add16 </td>
<td>(</td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gaa5da0c19880e03c7a48aac62779cbd5c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 add16 </td>
<td>(</td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gac1e24cfcc30c874a40de339421a521ca"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 add16 </td>
<td>(</td>
<td class="paramtype">v32cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gac86fdd2ce5630ed5734d7c84d2f450da"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 add16 </td>
<td>(</td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gadf2a532bd91f7a22564ef1191b71d2e2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 add16 </td>
<td>(</td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga61b45da3cb0881a9dac995e645f9455b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 add32 </td>
<td>(</td>
<td class="paramtype">v64int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 64 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga2bd8ba1cd81ce0aa0aa2d5d737e8eddc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 add32 </td>
<td>(</td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gaadec9f4e0120394b33e114f6f1a137e1"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 add32 </td>
<td>(</td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] + y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gabcbab53f01d486e56368760efa8af4ce"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 add8 </td>
<td>(</td>
<td class="paramtype">v16cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the xbuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gaab92df6b5fc4d31653bc62a209ec6e9a"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 add8 </td>
<td>(</td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the xbuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga51f916bb1272ba81bea9b750f26ac449"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 add8 </td>
<td>(</td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs an addition between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] + y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of an addition between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the ybuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex add instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga155e93ebd3a0719adc1d1e96427e7816"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 sub16 </td>
<td>(</td>
<td class="paramtype">v32int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gabd02aaf40bec53cb7e9d1fbcba330bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 sub16 </td>
<td>(</td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gabbff9a729f2df8ea77d36a502c2b2425"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16int32 sub16 </td>
<td>(</td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v16int32 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 8th lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff is the left operand and data from ybuff is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga41a1822ea528b7b57b32d573c60ede0e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 sub16 </td>
<td>(</td>
<td class="paramtype">v32cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga7160f0e87fe2721b0f23a0aa00dd6eb4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 sub16 </td>
<td>(</td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga33731ee0454a4f58b1f76af36877a260"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v16cint16 sub16 </td>
<td>(</td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v16cint16 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 16 elements with 16-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 8th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff is the left operand and data from ybuff is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gaa35ed9015e4dabc051a887d503ab6a5e"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 sub32 </td>
<td>(</td>
<td class="paramtype">v64int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 64 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga26980d005e43376f0f6b264479d6b388"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 sub32 </td>
<td>(</td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga623d9f8c9117df94ec3e070b44db8725"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v32int16 sub32 </td>
<td>(</td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xsquare</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v32int16 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets_hi</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>ysquare</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i],xsquare);</div>
<div class="line">    idy = f( ystart, yoffsets[i],ysquare);</div>
<div class="line">    o[i] = x[idx] - y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0],xsquare)</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7],xsquare)</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">xoffsets_hi</td><td>4b offset for each lane, applied to the xbuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">xsquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs to be less than 4. max value for this field is (0x3333) </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 32 elements with 16-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">yoffsets_hi</td><td>4b offset for each lane, applied to the ybuffer. LSB apply to 16th lane </td></tr>
<tr><td class="paramname">ysquare</td><td>Select order of the mini-permute square (default=0x3210). LSB apply to first element. Value per lane needs be less than 4. max value for this field is (0x3333) </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This intrinsic uses the 'square' parameter, to have more information on how to use this please go <a class="el" href="group__vect__mult__intrinsics__explained.html#data_selection_adv">here</a></li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff is the left operand and data from ybuff is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="ga2eb87ad35a5b0d8038f0d6581c0e1ddd"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 sub8 </td>
<td>(</td>
<td class="paramtype">v16cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 16 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the xbuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gadecbca2c3143ff6344ecd4951b77ad7b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 sub8 </td>
<td>(</td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - x[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from xbuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the xbuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff using 'xstart','xoffsets(_hi)' params is the left operand and data from xbuff using 'ystart','yoffsets(_hi)' params is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
<a class="anchor" id="gac1628d4084d3b80a0fd9f65d1af6ae82"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">v8cint32 sub8 </td>
<td>(</td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>xbuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>xstart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>xoffsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">v8cint32 </td>
<td class="paramname"><em>ybuff</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ystart</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">unsigned int </td>
<td class="paramname"><em>yoffsets</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Performs a subtraction between lanes of xbuff and ybuff. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div>
<div class="line">    idx = f( xstart, xoffsets[i]);</div>
<div class="line">    idy = f( ystart, yoffsets[i]);</div>
<div class="line">    o[i] = x[idx] - y[idy]</div>
<div class="line"></div>
<div class="line">xoffsets, xoffsets_hi, yoffsets, yoffsets_hi have 8 offset values each. 4 bits per offset.</div>
<div class="line">For Example: <span class="keywordflow">for</span> v16int32 output type, idx <span class="keywordflow">for</span> output_lane_0 = f(xstart,xoffsets[0])</div>
<div class="line">For Example: for v16int32 output type, idx for output_lane_15 = f(xstart,xoffsets_hi[7])</div>
<div class="line">In case of v32int16, 1 offset is used for 2 adjacent lanes.</div>
<div class="line">For more information on how the function f() selects data from the buffers refer to Lane selection note below.</div>
</div><!-- fragment --> <dl class="section return"><dt>Returns</dt><dd>Value of each lane is the result of a subtraction between lanes of xbuff where the result of lane 0 goes to lane 0 of the output. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">xbuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">xstart</td><td>Starting position offset applied to all lanes of input from X buffer </td></tr>
<tr><td class="paramname">xoffsets</td><td>3b (aligned to 4b) offset for each lane, applied to the xbuffer. LSB apply to first lane </td></tr>
<tr><td class="paramname">ybuff</td><td>Input buffer of 8 elements with 32-bit precision </td></tr>
<tr><td class="paramname">ystart</td><td>Starting position offset applied to all lanes of input from ybuffer for the second input </td></tr>
<tr><td class="paramname">yoffsets</td><td>3b (aligned to 4b) offset for each lane in the ybuffer for the second input. LSB apply to first lane </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When xoffsets or yoffsets is a runtime parameter, it might be more efficient to use a non-complex sub instuction and calculate the offsets accordingly. Therefore both, real and imaginary (real+1) lane must be considered in the offsets</li>
<li>For more information on how the function f() selects data from the buffers go <a class="el" href="group__intr__lanesel__cmp.html#data_selection_cmp">here</a>.</li>
<li>Data from xbuff is the left operand and data from ybuff is the right operand. </li>
</ul>
</dd></dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<div class="navpath" id="nav-path"><!-- id is needed for treeview function! -->
<ul class="foot">
<li class="footer"> UG1078 © 2023 Advanced Micro Devices, Inc. All rights reserved.
    </li>
</ul>
</div>
</body>
</html>
