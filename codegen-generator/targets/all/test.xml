<intrinsics_list>
<intrinsic tech="AVX" name="_mm256_extractf128_si256">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m256i" varname="a" etype="M128" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTF128" form="xmm, ymm, imm8" xed="VEXTRACTF128_XMMdq_YMMdq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_extract_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__int32" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="index" etype="IMM" immwidth="3" />
	<description>Extract a 32-bit integer from "a", selected with "index", and store the result in "dst".</description>
	<operation>
dst[31:0] := (a[255:0] &gt;&gt; (index[2:0] * 32))[31:0]
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_extract_epi64">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="index" etype="IMM" immwidth="2" />
	<description>Extract a 64-bit integer from "a", selected with "index", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[255:0] &gt;&gt; (index[1:0] * 64))[63:0]
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" name="_mm256_insertf128_si256">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 128 bits from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTF128" form="ymm, ymm, xmm, imm8" xed="VINSERTF128_YMMqq_YMMqq_XMMdq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst". This intrinsic may generate the "vpbroadcastb".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast 16-bit integer "a" to all all elements of "dst". This intrinsic may generate the "vpbroadcastw".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst". This intrinsic may generate the "vpbroadcastd".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" sequence="TRUE" name="_mm256_set1_epi64x">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="long long" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst". This intrinsic may generate the "vpbroadcastq".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epi8">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Divide packed signed 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epi16">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Divide packed signed 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Divide packed signed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epi64">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Divide packed signed 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epu8">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epu16">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epu32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_div_epu64">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_idiv_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_irem_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epi8">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Divide packed 8-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 31
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epi16">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Divide packed 16-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epi64">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Divide packed 64-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epu8">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 31
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epu16">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epu32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_rem_epu64">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_udiv_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm256_urem_epi32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" vexEq="TRUE" name="_mm256_cvtsi256_si32">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Convert</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<operation>
dst[31:0] := a[31:0]
	</operation>
	<instruction name="VMOVD" form="r32, xmm" xed="VMOVD_GPR32d_XMMd" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" sequence="TRUE" name="_mm256_extract_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="const int" varname="index" etype="IMM" immwidth="5" />
	<description>Extract an 8-bit integer from "a", selected with "index", and store the result in "dst".</description>
	<operation>
dst[7:0] := (a[255:0] &gt;&gt; (index[4:0] * 8))[7:0]
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" sequence="TRUE" name="_mm256_extract_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="const int" varname="index" etype="IMM" immwidth="4" />
	<description>Extract a 16-bit integer from "a", selected with "index", and store the result in "dst".</description>
	<operation>
dst[15:0] := (a[255:0] &gt;&gt; (index[3:0] * 16))[15:0]
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSB" form="ymm, ymm" xed="VPABSB_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSW" form="ymm, ymm" xed="VPABSW_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSD" form="ymm, ymm" xed="VPABSD_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_add_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDB" form="ymm, ymm, ymm" xed="VPADDB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_add_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDW" form="ymm, ymm, ymm" xed="VPADDW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_add_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDD" form="ymm, ymm, ymm" xed="VPADDD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_add_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDQ" form="ymm, ymm, ymm" xed="VPADDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Add packed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSB" form="ymm, ymm, ymm" xed="VPADDSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Add packed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSW" form="ymm, ymm, ymm" xed="VPADDSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSB" form="ymm, ymm, ymm" xed="VPADDUSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSW" form="ymm, ymm, ymm" xed="VPADDUSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_and_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="M256" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m256i" varname="b" etype="M256" />
	<description>Compute the bitwise AND of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[255:0] := (a[255:0] AND b[255:0])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAND" form="ymm, ymm, ymm" xed="VPAND_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_andnot_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="M256" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m256i" varname="b" etype="M256" />
	<description>Compute the bitwise NOT of 256 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".</description>
	<operation>
dst[255:0] := ((NOT a[255:0]) AND b[255:0])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDN" form="ymm, ymm, ymm" xed="VPANDN_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGB" form="ymm, ymm, ymm" xed="VPAVGB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGW" form="ymm, ymm, ymm" xed="VPAVGW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blend_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Blend packed 16-bit integers from "a" and "b" within 128-bit lanes using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[j%8]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDW" form="ymm, ymm, ymm, imm8" xed="VPBLENDW_YMMqq_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4" />
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDD" form="xmm, xmm, xmm, imm8" xed="VPBLENDD_XMMdq_XMMdq_XMMdq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDD" form="ymm, ymm, ymm, imm8" xed="VPBLENDD_YMMqq_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blendv_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<parameter type="__m256i" varname="mask" etype="MASK" />
	<description>Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDVB" form="ymm, ymm, ymm, ymm" xed="VPBLENDVB_YMMqq_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="xmm, xmm" xed="VPBROADCASTB_XMMdq_XMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="ymm, xmm" xed="VPBROADCASTB_YMMqq_XMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="xmm, xmm" xed="VPBROADCASTD_XMMdq_XMMd" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="ymm, xmm" xed="VPBROADCASTD_YMMqq_XMMd" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="xmm, xmm" xed="VPBROADCASTQ_XMMdq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="ymm, xmm" xed="VPBROADCASTQ_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_broadcastsi128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<description>Broadcast 128 bits of integer data from "a" to all 128-bit lanes in "dst".</description>
	<operation>
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI128" form="ymm, m128" xed="VBROADCASTI128_YMMqq_MEMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_broadcastsi128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<description>Broadcast 128 bits of integer data from "a" to all 128-bit lanes in "dst".</description>
	<operation>
dst[127:0] := a[127:0]
dst[255:128] := a[127:0]
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI128" form="ymm, m128" xed="VBROADCASTI128_YMMqq_MEMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="xmm, xmm" xed="VPBROADCASTW_XMMdq_XMMw" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="ymm, xmm" xed="VPBROADCASTW_YMMqq_XMMw" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpeq_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPEQB" form="ymm, ymm, ymm" xed="VPCMPEQB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpeq_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPEQW" form="ymm, ymm, ymm" xed="VPCMPEQW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpeq_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPEQD" form="ymm, ymm, ymm" xed="VPCMPEQD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpeq_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPEQQ" form="ymm, ymm, ymm" xed="VPCMPEQQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpgt_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPGTB" form="ymm, ymm, ymm" xed="VPCMPGTB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpgt_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPGTW" form="ymm, ymm, ymm" xed="VPCMPGTW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpgt_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPGTD" form="ymm, ymm, ymm" xed="VPCMPGTD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cmpgt_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ( a[i+63:i] &gt; b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCMPGTQ" form="ymm, ymm, ymm" xed="VPCMPGTQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j:= 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="ymm, xmm" xed="VPMOVSXWD_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="ymm, xmm" xed="VPMOVSXWQ_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="ymm, xmm" xed="VPMOVSXDQ_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="ymm, xmm" xed="VPMOVSXBW_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="ymm, xmm" xed="VPMOVSXBD_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="ymm, xmm" xed="VPMOVSXBQ_YMMqq_XMMd" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend32(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="ymm, xmm" xed="VPMOVZXWD_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j:= 0 to 3
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend64(a[k+15:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="ymm, xmm" xed="VPMOVZXWQ_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j:= 0 to 3
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend64(a[k+31:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="ymm, xmm" xed="VPMOVZXDQ_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend16(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="ymm, xmm" xed="VPMOVZXBW_YMMqq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend32(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="ymm, xmm" xed="VPMOVZXBD_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 byte sof "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend64(a[k+7:k])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="ymm, xmm" xed="VPMOVZXBQ_YMMqq_XMMd" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_extracti128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m256i" varname="a" etype="M128" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI128" form="xmm, ymm, imm8" xed="VEXTRACTI128_XMMdq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hadd_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]
dst[143:128] := a[159:144] + a[143:128]
dst[159:144] := a[191:176] + a[175:160]
dst[175:160] := a[223:208] + a[207:192]
dst[191:176] := a[255:240] + a[239:224]
dst[207:192] := b[159:144] + b[143:128]
dst[223:208] := b[191:176] + b[175:160]
dst[239:224] := b[223:208] + b[207:192]
dst[255:240] := b[255:240] + b[239:224]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHADDW" form="ymm, ymm, ymm" xed="VPHADDW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hadd_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Horizontally add adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
dst[159:128] := a[191:160] + a[159:128]
dst[191:160] := a[255:224] + a[223:192]
dst[223:192] := b[191:160] + b[159:128]
dst[255:224] := b[255:224] + b[223:192]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHADDD" form="ymm, ymm, ymm" xed="VPHADDD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hadds_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Horizontally add adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:16] + a[15:0])
dst[31:16] := Saturate16(a[63:48] + a[47:32])
dst[47:32] := Saturate16(a[95:80] + a[79:64])
dst[63:48] := Saturate16(a[127:112] + a[111:96])
dst[79:64] := Saturate16(b[31:16] + b[15:0])
dst[95:80] := Saturate16(b[63:48] + b[47:32])
dst[111:96] := Saturate16(b[95:80] + b[79:64])
dst[127:112] := Saturate16(b[127:112] + b[111:96])
dst[143:128] := Saturate16(a[159:144] + a[143:128])
dst[159:144] := Saturate16(a[191:176] + a[175:160])
dst[175:160] := Saturate16(a[223:208] + a[207:192])
dst[191:176] := Saturate16(a[255:240] + a[239:224])
dst[207:192] := Saturate16(b[159:144] + b[143:128])
dst[223:208] := Saturate16(b[191:176] + b[175:160])
dst[239:224] := Saturate16(b[223:208] + b[207:192])
dst[255:240] := Saturate16(b[255:240] + b[239:224])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHADDSW" form="ymm, ymm, ymm" xed="VPHADDSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hsub_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]
dst[143:128] := a[143:128] - a[159:144]
dst[159:144] := a[175:160] - a[191:176]
dst[175:160] := a[207:192] - a[223:208]
dst[191:176] := a[239:224] - a[255:240]
dst[207:192] := b[143:128] - b[159:144]
dst[223:208] := b[175:160] - b[191:176]
dst[239:224] := b[207:192] - b[223:208]
dst[255:240] := b[239:224] - b[255:240]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHSUBW" form="ymm, ymm, ymm" xed="VPHSUBW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hsub_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Horizontally subtract adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
dst[159:128] := a[159:128] - a[191:160]
dst[191:160] := a[223:192] - a[255:224]
dst[223:192] := b[159:128] - b[191:160]
dst[255:224] := b[223:192] - b[255:224]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHSUBD" form="ymm, ymm, ymm" xed="VPHSUBD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_hsubs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Horizontally subtract adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[15:0] - a[31:16])
dst[31:16] := Saturate16(a[47:32] - a[63:48])
dst[47:32] := Saturate16(a[79:64] - a[95:80])
dst[63:48] := Saturate16(a[111:96] - a[127:112])
dst[79:64] := Saturate16(b[15:0] - b[31:16])
dst[95:80] := Saturate16(b[47:32] - b[63:48])
dst[111:96] := Saturate16(b[79:64] - b[95:80])
dst[127:112] := Saturate16(b[111:96] - b[127:112])
dst[143:128] := Saturate16(a[143:128] - a[159:144])
dst[159:144] := Saturate16(a[175:160] - a[191:176])
dst[175:160] := Saturate16(a[207:192] - a[223:208])
dst[191:176] := Saturate16(a[239:224] - a[255:240])
dst[207:192] := Saturate16(b[143:128] - b[159:144])
dst[223:208] := Saturate16(b[175:160] - b[191:176])
dst[239:224] := Saturate16(b[207:192] - b[223:208])
dst[255:240] := Saturate16(b[239:224] - b[255:240])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPHSUBSW" form="ymm, ymm, ymm" xed="VPHSUBSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_inserti128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 128 bits (composed of integer data) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI128" form="ymm, ymm, xmm, imm8" xed="VINSERTI128_YMMqq_YMMqq_XMMdq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDWD" form="ymm, ymm, ymm" xed="VPMADDWD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="ymm, ymm, ymm" xed="VPMADDUBSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSB" form="ymm, ymm, ymm" xed="VPMAXSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSW" form="ymm, ymm, ymm" xed="VPMAXSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSD" form="ymm, ymm, ymm" xed="VPMAXSD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUB" form="ymm, ymm, ymm" xed="VPMAXUB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUW" form="ymm, ymm, ymm" xed="VPMAXUW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_max_epu32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUD" form="ymm, ymm, ymm" xed="VPMAXUD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSB" form="ymm, ymm, ymm" xed="VPMINSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSW" form="ymm, ymm, ymm" xed="VPMINSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSD" form="ymm, ymm, ymm" xed="VPMINSD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUB" form="ymm, ymm, ymm" xed="VPMINUB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUW" form="ymm, ymm, ymm" xed="VPMINUW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_min_epu32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUD" form="ymm, ymm, ymm" xed="VPMINUD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_movemask_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[j] := a[i+7]
ENDFOR
	</operation>
	<instruction name="VPMOVMSKB" form="r32, ymm" xed="VPMOVMSKB_GPR32d_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULDQ" form="ymm, ymm, ymm" xed="VPMULDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULUDQ" form="ymm, ymm, ymm" xed="VPMULUDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHW" form="ymm, ymm, ymm" xed="VPMULHW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHUW" form="ymm, ymm, ymm" xed="VPMULHUW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHRSW" form="ymm, ymm, ymm" xed="VPMULHRSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[15:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLW" form="ymm, ymm, ymm" xed="VPMULLW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Multiply the packed signed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLD" form="ymm, ymm, ymm" xed="VPMULLD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_or_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="M256" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m256i" varname="b" etype="M256" />
	<description>Compute the bitwise OR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[255:0] := (a[255:0] OR b[255:0])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOR" form="ymm, ymm, ymm" xed="VPOR_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := Saturate8(a[15:0])
dst[15:8] := Saturate8(a[31:16])
dst[23:16] := Saturate8(a[47:32])
dst[31:24] := Saturate8(a[63:48])
dst[39:32] := Saturate8(a[79:64])
dst[47:40] := Saturate8(a[95:80])
dst[55:48] := Saturate8(a[111:96])
dst[63:56] := Saturate8(a[127:112])
dst[71:64] := Saturate8(b[15:0])
dst[79:72] := Saturate8(b[31:16])
dst[87:80] := Saturate8(b[47:32])
dst[95:88] := Saturate8(b[63:48])
dst[103:96] := Saturate8(b[79:64])
dst[111:104] := Saturate8(b[95:80])
dst[119:112] := Saturate8(b[111:96])
dst[127:120] := Saturate8(b[127:112])
dst[135:128] := Saturate8(a[143:128])
dst[143:136] := Saturate8(a[159:144])
dst[151:144] := Saturate8(a[175:160])
dst[159:152] := Saturate8(a[191:176])
dst[167:160] := Saturate8(a[207:192])
dst[175:168] := Saturate8(a[223:208])
dst[183:176] := Saturate8(a[239:224])
dst[191:184] := Saturate8(a[255:240])
dst[199:192] := Saturate8(b[143:128])
dst[207:200] := Saturate8(b[159:144])
dst[215:208] := Saturate8(b[175:160])
dst[223:216] := Saturate8(b[191:176])
dst[231:224] := Saturate8(b[207:192])
dst[239:232] := Saturate8(b[223:208])
dst[247:240] := Saturate8(b[239:224])
dst[255:248] := Saturate8(b[255:240])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSWB" form="ymm, ymm, ymm" xed="VPACKSSWB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:0])
dst[31:16] := Saturate16(a[63:32])
dst[47:32] := Saturate16(a[95:64])
dst[63:48] := Saturate16(a[127:96])
dst[79:64] := Saturate16(b[31:0])
dst[95:80] := Saturate16(b[63:32])
dst[111:96] := Saturate16(b[95:64])
dst[127:112] := Saturate16(b[127:96])
dst[143:128] := Saturate16(a[159:128])
dst[159:144] := Saturate16(a[191:160])
dst[175:160] := Saturate16(a[223:192])
dst[191:176] := Saturate16(a[255:224])
dst[207:192] := Saturate16(b[159:128])
dst[223:208] := Saturate16(b[191:160])
dst[239:224] := Saturate16(b[223:192])
dst[255:240] := Saturate16(b[255:224])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSDW" form="ymm, ymm, ymm" xed="VPACKSSDW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := SaturateU8(a[15:0])
dst[15:8] := SaturateU8(a[31:16])
dst[23:16] := SaturateU8(a[47:32])
dst[31:24] := SaturateU8(a[63:48])
dst[39:32] := SaturateU8(a[79:64])
dst[47:40] := SaturateU8(a[95:80])
dst[55:48] := SaturateU8(a[111:96])
dst[63:56] := SaturateU8(a[127:112])
dst[71:64] := SaturateU8(b[15:0])
dst[79:72] := SaturateU8(b[31:16])
dst[87:80] := SaturateU8(b[47:32])
dst[95:88] := SaturateU8(b[63:48])
dst[103:96] := SaturateU8(b[79:64])
dst[111:104] := SaturateU8(b[95:80])
dst[119:112] := SaturateU8(b[111:96])
dst[127:120] := SaturateU8(b[127:112])
dst[135:128] := SaturateU8(a[143:128])
dst[143:136] := SaturateU8(a[159:144])
dst[151:144] := SaturateU8(a[175:160])
dst[159:152] := SaturateU8(a[191:176])
dst[167:160] := SaturateU8(a[207:192])
dst[175:168] := SaturateU8(a[223:208])
dst[183:176] := SaturateU8(a[239:224])
dst[191:184] := SaturateU8(a[255:240])
dst[199:192] := SaturateU8(b[143:128])
dst[207:200] := SaturateU8(b[159:144])
dst[215:208] := SaturateU8(b[175:160])
dst[223:216] := SaturateU8(b[191:176])
dst[231:224] := SaturateU8(b[207:192])
dst[239:232] := SaturateU8(b[223:208])
dst[247:240] := SaturateU8(b[239:224])
dst[255:248] := SaturateU8(b[255:240])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSWB" form="ymm, ymm, ymm" xed="VPACKUSWB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := SaturateU16(a[31:0])
dst[31:16] := SaturateU16(a[63:32])
dst[47:32] := SaturateU16(a[95:64])
dst[63:48] := SaturateU16(a[127:96])
dst[79:64] := SaturateU16(b[31:0])
dst[95:80] := SaturateU16(b[63:32])
dst[111:96] := SaturateU16(b[95:64])
dst[127:112] := SaturateU16(b[127:96])
dst[143:128] := SaturateU16(a[159:128])
dst[159:144] := SaturateU16(a[191:160])
dst[175:160] := SaturateU16(a[223:192])
dst[191:176] := SaturateU16(a[255:224])
dst[207:192] := SaturateU16(b[159:128])
dst[223:208] := SaturateU16(b[191:160])
dst[239:224] := SaturateU16(b[223:192])
dst[255:240] := SaturateU16(b[255:224])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSDW" form="ymm, ymm, ymm" xed="VPACKUSDW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Negate packed signed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGNB" form="ymm, ymm, ymm" xed="VPSIGNB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Negate packed signed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGNW" form="ymm, ymm, ymm" xed="VPSIGNW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Negate packed signed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGND" form="ymm, ymm, ymm" xed="VPSIGND_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm, ymm, xmm" xed="VPSLLW_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm, ymm, imm8" xed="VPSLLW_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm, ymm, xmm" xed="VPSLLD_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm, ymm, imm8" xed="VPSLLD_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm, ymm, xmm" xed="VPSLLQ_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm, ymm, imm8" xed="VPSLLQ_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm, xmm, xmm" xed="VPSLLVD_XMMdq_XMMdq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm, ymm, ymm" xed="VPSLLVD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm, xmm, xmm" xed="VPSLLVQ_XMMdq_XMMdq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm, ymm, ymm" xed="VPSLLVQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm, ymm, xmm" xed="VPSRAW_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm, ymm, imm8" xed="VPSRAW_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm, ymm, xmm" xed="VPSRAD_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm, ymm, imm8" xed="VPSRAD_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm, xmm, xmm" xed="VPSRAVD_XMMdq_XMMdq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm, ymm, ymm" xed="VPSRAVD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm, ymm, xmm" xed="VPSRLW_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm, ymm, imm8" xed="VPSRLW_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm, ymm, xmm" xed="VPSRLD_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm, ymm, imm8" xed="VPSRLD_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm, ymm, xmm" xed="VPSRLQ_YMMqq_YMMqq_XMMq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm, ymm, imm8" xed="VPSRLQ_YMMqq_YMMqq_IMMb" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm, xmm, xmm" xed="VPSRLVD_XMMdq_XMMdq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm, ymm, ymm" xed="VPSRLVD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm, xmm, xmm" xed="VPSRLVQ_XMMdq_XMMdq_XMMdq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm, ymm, ymm" xed="VPSRLVQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBB" form="ymm, ymm, ymm" xed="VPSUBB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBW" form="ymm, ymm, ymm" xed="VPSUBW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBD" form="ymm, ymm, ymm" xed="VPSUBD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBQ" form="ymm, ymm, ymm" xed="VPSUBQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSB" form="ymm, ymm, ymm" xed="VPSUBSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSW" form="ymm, ymm, ymm" xed="VPSUBSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSB" form="ymm, ymm, ymm" xed="VPSUBUSB_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSW" form="ymm, ymm, ymm" xed="VPSUBUSW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_xor_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="M256" />
	<parameter type="__m256i" varname="a" etype="M256" />
	<parameter type="__m256i" varname="b" etype="M256" />
	<description>Compute the bitwise XOR of 256 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[255:0] := (a[255:0] XOR b[255:0])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXOR" form="ymm, ymm, ymm" xed="VPXOR_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="ymm, ymm, ymm" xed="VPUNPCKHBW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="ymm, ymm, ymm" xed="VPUNPCKHWD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="ymm, ymm, ymm" xed="VPUNPCKHDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="ymm, ymm, ymm" xed="VPUNPCKHQDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="ymm, ymm, ymm" xed="VPUNPCKLBW_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="ymm, ymm, ymm" xed="VPUNPCKLWD_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="ymm, ymm, ymm" xed="VPUNPCKLDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="ymm, ymm, ymm" xed="VPUNPCKLQDQ_YMMqq_YMMqq_YMMqq" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU16" form="ymm {k}, ymm" xed="VMOVDQU16_YMMu16_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU16" form="ymm {z}, ymm" xed="VMOVDQU16_YMMu16_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU16" form="zmm {k}, zmm" xed="VMOVDQU16_ZMMu16_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU16" form="zmm {z}, zmm" xed="VMOVDQU16_ZMMu16_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU16" form="xmm {k}, xmm" xed="VMOVDQU16_XMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU16" form="xmm {z}, xmm" xed="VMOVDQU16_XMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU8" form="ymm {k}, ymm" xed="VMOVDQU8_YMMu8_MASKmskw_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU8" form="ymm {z}, ymm" xed="VMOVDQU8_YMMu8_MASKmskw_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU8" form="zmm {k}, zmm" xed="VMOVDQU8_ZMMu8_MASKmskw_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU8" form="zmm {z}, zmm" xed="VMOVDQU8_ZMMu8_MASKmskw_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU8" form="xmm {k}, xmm" xed="VMOVDQU8_XMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU8" form="xmm {z}, xmm" xed="VMOVDQU8_XMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSB" form="ymm {k}, ymm" xed="VPABSB_YMMi8_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSB" form="ymm {z}, ymm" xed="VPABSB_YMMi8_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSB" form="zmm, zmm" xed="VPABSB_ZMMi8_MASKmskw_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSB" form="zmm {k}, zmm" xed="VPABSB_ZMMi8_MASKmskw_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSB" form="zmm {z}, zmm" xed="VPABSB_ZMMi8_MASKmskw_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSB" form="xmm {k}, xmm" xed="VPABSB_XMMi8_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSB" form="xmm {z}, xmm" xed="VPABSB_XMMi8_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSW" form="ymm {k}, ymm" xed="VPABSW_YMMi16_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSW" form="ymm {z}, ymm" xed="VPABSW_YMMi16_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSW" form="zmm, zmm" xed="VPABSW_ZMMi16_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSW" form="zmm {k}, zmm" xed="VPABSW_ZMMi16_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSW" form="zmm {z}, zmm" xed="VPABSW_ZMMi16_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSW" form="xmm {k}, xmm" xed="VPABSW_XMMi16_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSW" form="xmm {z}, xmm" xed="VPABSW_XMMi16_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="src" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSDW" form="ymm {k}, ymm, ymm" xed="VPACKSSDW_YMMi16_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSDW" form="ymm {z}, ymm, ymm" xed="VPACKSSDW_YMMi16_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="src" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
tmp_dst[271:256] := Saturate16(a[287:256])
tmp_dst[287:272] := Saturate16(a[319:288])
tmp_dst[303:288] := Saturate16(a[351:320])
tmp_dst[319:304] := Saturate16(a[383:352])
tmp_dst[335:320] := Saturate16(b[287:256])
tmp_dst[351:336] := Saturate16(b[319:288])
tmp_dst[367:352] := Saturate16(b[351:320])
tmp_dst[383:368] := Saturate16(b[383:352])
tmp_dst[399:384] := Saturate16(a[415:384])
tmp_dst[415:400] := Saturate16(a[447:416])
tmp_dst[431:416] := Saturate16(a[479:448])
tmp_dst[447:432] := Saturate16(a[511:480])
tmp_dst[463:448] := Saturate16(b[415:384])
tmp_dst[479:464] := Saturate16(b[447:416])
tmp_dst[495:480] := Saturate16(b[479:448])
tmp_dst[511:496] := Saturate16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSDW" form="zmm {k}, zmm, zmm" xed="VPACKSSDW_ZMMi16_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
tmp_dst[271:256] := Saturate16(a[287:256])
tmp_dst[287:272] := Saturate16(a[319:288])
tmp_dst[303:288] := Saturate16(a[351:320])
tmp_dst[319:304] := Saturate16(a[383:352])
tmp_dst[335:320] := Saturate16(b[287:256])
tmp_dst[351:336] := Saturate16(b[319:288])
tmp_dst[367:352] := Saturate16(b[351:320])
tmp_dst[383:368] := Saturate16(b[383:352])
tmp_dst[399:384] := Saturate16(a[415:384])
tmp_dst[415:400] := Saturate16(a[447:416])
tmp_dst[431:416] := Saturate16(a[479:448])
tmp_dst[447:432] := Saturate16(a[511:480])
tmp_dst[463:448] := Saturate16(b[415:384])
tmp_dst[479:464] := Saturate16(b[447:416])
tmp_dst[495:480] := Saturate16(b[479:448])
tmp_dst[511:496] := Saturate16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSDW" form="zmm {z}, zmm, zmm" xed="VPACKSSDW_ZMMi16_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:0])
dst[31:16] := Saturate16(a[63:32])
dst[47:32] := Saturate16(a[95:64])
dst[63:48] := Saturate16(a[127:96])
dst[79:64] := Saturate16(b[31:0])
dst[95:80] := Saturate16(b[63:32])
dst[111:96] := Saturate16(b[95:64])
dst[127:112] := Saturate16(b[127:96])
dst[143:128] := Saturate16(a[159:128])
dst[159:144] := Saturate16(a[191:160])
dst[175:160] := Saturate16(a[223:192])
dst[191:176] := Saturate16(a[255:224])
dst[207:192] := Saturate16(b[159:128])
dst[223:208] := Saturate16(b[191:160])
dst[239:224] := Saturate16(b[223:192])
dst[255:240] := Saturate16(b[255:224])
dst[271:256] := Saturate16(a[287:256])
dst[287:272] := Saturate16(a[319:288])
dst[303:288] := Saturate16(a[351:320])
dst[319:304] := Saturate16(a[383:352])
dst[335:320] := Saturate16(b[287:256])
dst[351:336] := Saturate16(b[319:288])
dst[367:352] := Saturate16(b[351:320])
dst[383:368] := Saturate16(b[383:352])
dst[399:384] := Saturate16(a[415:384])
dst[415:400] := Saturate16(a[447:416])
dst[431:416] := Saturate16(a[479:448])
dst[447:432] := Saturate16(a[511:480])
dst[463:448] := Saturate16(b[415:384])
dst[479:464] := Saturate16(b[447:416])
dst[495:480] := Saturate16(b[479:448])
dst[511:496] := Saturate16(b[511:480])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSDW" form="zmm, zmm, zmm" xed="VPACKSSDW_ZMMi16_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSDW" form="xmm {k}, xmm, xmm" xed="VPACKSSDW_XMMi16_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSDW" form="xmm {z}, xmm, xmm" xed="VPACKSSDW_XMMi16_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="src" etype="SI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSWB" form="ymm {k}, ymm, ymm" xed="VPACKSSWB_YMMi8_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSWB" form="ymm {z}, ymm, ymm" xed="VPACKSSWB_YMMi8_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI8" />
	<parameter type="__m512i" varname="src" etype="SI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
tmp_dst[263:256] := Saturate8(a[271:256])
tmp_dst[271:264] := Saturate8(a[287:272])
tmp_dst[279:272] := Saturate8(a[303:288])
tmp_dst[287:280] := Saturate8(a[319:304])
tmp_dst[295:288] := Saturate8(a[335:320])
tmp_dst[303:296] := Saturate8(a[351:336])
tmp_dst[311:304] := Saturate8(a[367:352])
tmp_dst[319:312] := Saturate8(a[383:368])
tmp_dst[327:320] := Saturate8(b[271:256])
tmp_dst[335:328] := Saturate8(b[287:272])
tmp_dst[343:336] := Saturate8(b[303:288])
tmp_dst[351:344] := Saturate8(b[319:304])
tmp_dst[359:352] := Saturate8(b[335:320])
tmp_dst[367:360] := Saturate8(b[351:336])
tmp_dst[375:368] := Saturate8(b[367:352])
tmp_dst[383:376] := Saturate8(b[383:368])
tmp_dst[391:384] := Saturate8(a[399:384])
tmp_dst[399:392] := Saturate8(a[415:400])
tmp_dst[407:400] := Saturate8(a[431:416])
tmp_dst[415:408] := Saturate8(a[447:432])
tmp_dst[423:416] := Saturate8(a[463:448])
tmp_dst[431:424] := Saturate8(a[479:464])
tmp_dst[439:432] := Saturate8(a[495:480])
tmp_dst[447:440] := Saturate8(a[511:496])
tmp_dst[455:448] := Saturate8(b[399:384])
tmp_dst[463:456] := Saturate8(b[415:400])
tmp_dst[471:464] := Saturate8(b[431:416])
tmp_dst[479:472] := Saturate8(b[447:432])
tmp_dst[487:480] := Saturate8(b[463:448])
tmp_dst[495:488] := Saturate8(b[479:464])
tmp_dst[503:496] := Saturate8(b[495:480])
tmp_dst[511:504] := Saturate8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSWB" form="zmm {k}, zmm, zmm" xed="VPACKSSWB_ZMMi8_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
tmp_dst[263:256] := Saturate8(a[271:256])
tmp_dst[271:264] := Saturate8(a[287:272])
tmp_dst[279:272] := Saturate8(a[303:288])
tmp_dst[287:280] := Saturate8(a[319:304])
tmp_dst[295:288] := Saturate8(a[335:320])
tmp_dst[303:296] := Saturate8(a[351:336])
tmp_dst[311:304] := Saturate8(a[367:352])
tmp_dst[319:312] := Saturate8(a[383:368])
tmp_dst[327:320] := Saturate8(b[271:256])
tmp_dst[335:328] := Saturate8(b[287:272])
tmp_dst[343:336] := Saturate8(b[303:288])
tmp_dst[351:344] := Saturate8(b[319:304])
tmp_dst[359:352] := Saturate8(b[335:320])
tmp_dst[367:360] := Saturate8(b[351:336])
tmp_dst[375:368] := Saturate8(b[367:352])
tmp_dst[383:376] := Saturate8(b[383:368])
tmp_dst[391:384] := Saturate8(a[399:384])
tmp_dst[399:392] := Saturate8(a[415:400])
tmp_dst[407:400] := Saturate8(a[431:416])
tmp_dst[415:408] := Saturate8(a[447:432])
tmp_dst[423:416] := Saturate8(a[463:448])
tmp_dst[431:424] := Saturate8(a[479:464])
tmp_dst[439:432] := Saturate8(a[495:480])
tmp_dst[447:440] := Saturate8(a[511:496])
tmp_dst[455:448] := Saturate8(b[399:384])
tmp_dst[463:456] := Saturate8(b[415:400])
tmp_dst[471:464] := Saturate8(b[431:416])
tmp_dst[479:472] := Saturate8(b[447:432])
tmp_dst[487:480] := Saturate8(b[463:448])
tmp_dst[495:488] := Saturate8(b[479:464])
tmp_dst[503:496] := Saturate8(b[495:480])
tmp_dst[511:504] := Saturate8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSWB" form="zmm {z}, zmm, zmm" xed="VPACKSSWB_ZMMi8_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI8" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := Saturate8(a[15:0])
dst[15:8] := Saturate8(a[31:16])
dst[23:16] := Saturate8(a[47:32])
dst[31:24] := Saturate8(a[63:48])
dst[39:32] := Saturate8(a[79:64])
dst[47:40] := Saturate8(a[95:80])
dst[55:48] := Saturate8(a[111:96])
dst[63:56] := Saturate8(a[127:112])
dst[71:64] := Saturate8(b[15:0])
dst[79:72] := Saturate8(b[31:16])
dst[87:80] := Saturate8(b[47:32])
dst[95:88] := Saturate8(b[63:48])
dst[103:96] := Saturate8(b[79:64])
dst[111:104] := Saturate8(b[95:80])
dst[119:112] := Saturate8(b[111:96])
dst[127:120] := Saturate8(b[127:112])
dst[135:128] := Saturate8(a[143:128])
dst[143:136] := Saturate8(a[159:144])
dst[151:144] := Saturate8(a[175:160])
dst[159:152] := Saturate8(a[191:176])
dst[167:160] := Saturate8(a[207:192])
dst[175:168] := Saturate8(a[223:208])
dst[183:176] := Saturate8(a[239:224])
dst[191:184] := Saturate8(a[255:240])
dst[199:192] := Saturate8(b[143:128])
dst[207:200] := Saturate8(b[159:144])
dst[215:208] := Saturate8(b[175:160])
dst[223:216] := Saturate8(b[191:176])
dst[231:224] := Saturate8(b[207:192])
dst[239:232] := Saturate8(b[223:208])
dst[247:240] := Saturate8(b[239:224])
dst[255:248] := Saturate8(b[255:240])
dst[263:256] := Saturate8(a[271:256])
dst[271:264] := Saturate8(a[287:272])
dst[279:272] := Saturate8(a[303:288])
dst[287:280] := Saturate8(a[319:304])
dst[295:288] := Saturate8(a[335:320])
dst[303:296] := Saturate8(a[351:336])
dst[311:304] := Saturate8(a[367:352])
dst[319:312] := Saturate8(a[383:368])
dst[327:320] := Saturate8(b[271:256])
dst[335:328] := Saturate8(b[287:272])
dst[343:336] := Saturate8(b[303:288])
dst[351:344] := Saturate8(b[319:304])
dst[359:352] := Saturate8(b[335:320])
dst[367:360] := Saturate8(b[351:336])
dst[375:368] := Saturate8(b[367:352])
dst[383:376] := Saturate8(b[383:368])
dst[391:384] := Saturate8(a[399:384])
dst[399:392] := Saturate8(a[415:400])
dst[407:400] := Saturate8(a[431:416])
dst[415:408] := Saturate8(a[447:432])
dst[423:416] := Saturate8(a[463:448])
dst[431:424] := Saturate8(a[479:464])
dst[439:432] := Saturate8(a[495:480])
dst[447:440] := Saturate8(a[511:496])
dst[455:448] := Saturate8(b[399:384])
dst[463:456] := Saturate8(b[415:400])
dst[471:464] := Saturate8(b[431:416])
dst[479:472] := Saturate8(b[447:432])
dst[487:480] := Saturate8(b[463:448])
dst[495:488] := Saturate8(b[479:464])
dst[503:496] := Saturate8(b[495:480])
dst[511:504] := Saturate8(b[511:496])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSWB" form="zmm, zmm, zmm" xed="VPACKSSWB_ZMMi8_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSWB" form="xmm {k}, xmm, xmm" xed="VPACKSSWB_XMMi8_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSWB" form="xmm {z}, xmm, xmm" xed="VPACKSSWB_XMMi8_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSDW" form="ymm {k}, ymm, ymm" xed="VPACKUSDW_YMMu16_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSDW" form="ymm {z}, ymm, ymm" xed="VPACKUSDW_YMMu16_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
tmp_dst[271:256] := SaturateU16(a[287:256])
tmp_dst[287:272] := SaturateU16(a[319:288])
tmp_dst[303:288] := SaturateU16(a[351:320])
tmp_dst[319:304] := SaturateU16(a[383:352])
tmp_dst[335:320] := SaturateU16(b[287:256])
tmp_dst[351:336] := SaturateU16(b[319:288])
tmp_dst[367:352] := SaturateU16(b[351:320])
tmp_dst[383:368] := SaturateU16(b[383:352])
tmp_dst[399:384] := SaturateU16(a[415:384])
tmp_dst[415:400] := SaturateU16(a[447:416])
tmp_dst[431:416] := SaturateU16(a[479:448])
tmp_dst[447:432] := SaturateU16(a[511:480])
tmp_dst[463:448] := SaturateU16(b[415:384])
tmp_dst[479:464] := SaturateU16(b[447:416])
tmp_dst[495:480] := SaturateU16(b[479:448])
tmp_dst[511:496] := SaturateU16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSDW" form="zmm {k}, zmm, zmm" xed="VPACKUSDW_ZMMu16_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
tmp_dst[271:256] := SaturateU16(a[287:256])
tmp_dst[287:272] := SaturateU16(a[319:288])
tmp_dst[303:288] := SaturateU16(a[351:320])
tmp_dst[319:304] := SaturateU16(a[383:352])
tmp_dst[335:320] := SaturateU16(b[287:256])
tmp_dst[351:336] := SaturateU16(b[319:288])
tmp_dst[367:352] := SaturateU16(b[351:320])
tmp_dst[383:368] := SaturateU16(b[383:352])
tmp_dst[399:384] := SaturateU16(a[415:384])
tmp_dst[415:400] := SaturateU16(a[447:416])
tmp_dst[431:416] := SaturateU16(a[479:448])
tmp_dst[447:432] := SaturateU16(a[511:480])
tmp_dst[463:448] := SaturateU16(b[415:384])
tmp_dst[479:464] := SaturateU16(b[447:416])
tmp_dst[495:480] := SaturateU16(b[479:448])
tmp_dst[511:496] := SaturateU16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSDW" form="zmm {z}, zmm, zmm" xed="VPACKUSDW_ZMMu16_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := SaturateU16(a[31:0])
dst[31:16] := SaturateU16(a[63:32])
dst[47:32] := SaturateU16(a[95:64])
dst[63:48] := SaturateU16(a[127:96])
dst[79:64] := SaturateU16(b[31:0])
dst[95:80] := SaturateU16(b[63:32])
dst[111:96] := SaturateU16(b[95:64])
dst[127:112] := SaturateU16(b[127:96])
dst[143:128] := SaturateU16(a[159:128])
dst[159:144] := SaturateU16(a[191:160])
dst[175:160] := SaturateU16(a[223:192])
dst[191:176] := SaturateU16(a[255:224])
dst[207:192] := SaturateU16(b[159:128])
dst[223:208] := SaturateU16(b[191:160])
dst[239:224] := SaturateU16(b[223:192])
dst[255:240] := SaturateU16(b[255:224])
dst[271:256] := SaturateU16(a[287:256])
dst[287:272] := SaturateU16(a[319:288])
dst[303:288] := SaturateU16(a[351:320])
dst[319:304] := SaturateU16(a[383:352])
dst[335:320] := SaturateU16(b[287:256])
dst[351:336] := SaturateU16(b[319:288])
dst[367:352] := SaturateU16(b[351:320])
dst[383:368] := SaturateU16(b[383:352])
dst[399:384] := SaturateU16(a[415:384])
dst[415:400] := SaturateU16(a[447:416])
dst[431:416] := SaturateU16(a[479:448])
dst[447:432] := SaturateU16(a[511:480])
dst[463:448] := SaturateU16(b[415:384])
dst[479:464] := SaturateU16(b[447:416])
dst[495:480] := SaturateU16(b[479:448])
dst[511:496] := SaturateU16(b[511:480])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSDW" form="zmm, zmm, zmm" xed="VPACKUSDW_ZMMu16_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSDW" form="xmm {k}, xmm, xmm" xed="VPACKUSDW_XMMu16_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSDW" form="xmm {z}, xmm, xmm" xed="VPACKUSDW_XMMu16_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSWB" form="ymm {k}, ymm, ymm" xed="VPACKUSWB_YMMu8_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSWB" form="ymm {z}, ymm, ymm" xed="VPACKUSWB_YMMu8_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
tmp_dst[263:256] := SaturateU8(a[271:256])
tmp_dst[271:264] := SaturateU8(a[287:272])
tmp_dst[279:272] := SaturateU8(a[303:288])
tmp_dst[287:280] := SaturateU8(a[319:304])
tmp_dst[295:288] := SaturateU8(a[335:320])
tmp_dst[303:296] := SaturateU8(a[351:336])
tmp_dst[311:304] := SaturateU8(a[367:352])
tmp_dst[319:312] := SaturateU8(a[383:368])
tmp_dst[327:320] := SaturateU8(b[271:256])
tmp_dst[335:328] := SaturateU8(b[287:272])
tmp_dst[343:336] := SaturateU8(b[303:288])
tmp_dst[351:344] := SaturateU8(b[319:304])
tmp_dst[359:352] := SaturateU8(b[335:320])
tmp_dst[367:360] := SaturateU8(b[351:336])
tmp_dst[375:368] := SaturateU8(b[367:352])
tmp_dst[383:376] := SaturateU8(b[383:368])
tmp_dst[391:384] := SaturateU8(a[399:384])
tmp_dst[399:392] := SaturateU8(a[415:400])
tmp_dst[407:400] := SaturateU8(a[431:416])
tmp_dst[415:408] := SaturateU8(a[447:432])
tmp_dst[423:416] := SaturateU8(a[463:448])
tmp_dst[431:424] := SaturateU8(a[479:464])
tmp_dst[439:432] := SaturateU8(a[495:480])
tmp_dst[447:440] := SaturateU8(a[511:496])
tmp_dst[455:448] := SaturateU8(b[399:384])
tmp_dst[463:456] := SaturateU8(b[415:400])
tmp_dst[471:464] := SaturateU8(b[431:416])
tmp_dst[479:472] := SaturateU8(b[447:432])
tmp_dst[487:480] := SaturateU8(b[463:448])
tmp_dst[495:488] := SaturateU8(b[479:464])
tmp_dst[503:496] := SaturateU8(b[495:480])
tmp_dst[511:504] := SaturateU8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSWB" form="zmm {k}, zmm, zmm" xed="VPACKUSWB_ZMMu8_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
tmp_dst[263:256] := SaturateU8(a[271:256])
tmp_dst[271:264] := SaturateU8(a[287:272])
tmp_dst[279:272] := SaturateU8(a[303:288])
tmp_dst[287:280] := SaturateU8(a[319:304])
tmp_dst[295:288] := SaturateU8(a[335:320])
tmp_dst[303:296] := SaturateU8(a[351:336])
tmp_dst[311:304] := SaturateU8(a[367:352])
tmp_dst[319:312] := SaturateU8(a[383:368])
tmp_dst[327:320] := SaturateU8(b[271:256])
tmp_dst[335:328] := SaturateU8(b[287:272])
tmp_dst[343:336] := SaturateU8(b[303:288])
tmp_dst[351:344] := SaturateU8(b[319:304])
tmp_dst[359:352] := SaturateU8(b[335:320])
tmp_dst[367:360] := SaturateU8(b[351:336])
tmp_dst[375:368] := SaturateU8(b[367:352])
tmp_dst[383:376] := SaturateU8(b[383:368])
tmp_dst[391:384] := SaturateU8(a[399:384])
tmp_dst[399:392] := SaturateU8(a[415:400])
tmp_dst[407:400] := SaturateU8(a[431:416])
tmp_dst[415:408] := SaturateU8(a[447:432])
tmp_dst[423:416] := SaturateU8(a[463:448])
tmp_dst[431:424] := SaturateU8(a[479:464])
tmp_dst[439:432] := SaturateU8(a[495:480])
tmp_dst[447:440] := SaturateU8(a[511:496])
tmp_dst[455:448] := SaturateU8(b[399:384])
tmp_dst[463:456] := SaturateU8(b[415:400])
tmp_dst[471:464] := SaturateU8(b[431:416])
tmp_dst[479:472] := SaturateU8(b[447:432])
tmp_dst[487:480] := SaturateU8(b[463:448])
tmp_dst[495:488] := SaturateU8(b[479:464])
tmp_dst[503:496] := SaturateU8(b[495:480])
tmp_dst[511:504] := SaturateU8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSWB" form="zmm {z}, zmm, zmm" xed="VPACKUSWB_ZMMu8_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := SaturateU8(a[15:0])
dst[15:8] := SaturateU8(a[31:16])
dst[23:16] := SaturateU8(a[47:32])
dst[31:24] := SaturateU8(a[63:48])
dst[39:32] := SaturateU8(a[79:64])
dst[47:40] := SaturateU8(a[95:80])
dst[55:48] := SaturateU8(a[111:96])
dst[63:56] := SaturateU8(a[127:112])
dst[71:64] := SaturateU8(b[15:0])
dst[79:72] := SaturateU8(b[31:16])
dst[87:80] := SaturateU8(b[47:32])
dst[95:88] := SaturateU8(b[63:48])
dst[103:96] := SaturateU8(b[79:64])
dst[111:104] := SaturateU8(b[95:80])
dst[119:112] := SaturateU8(b[111:96])
dst[127:120] := SaturateU8(b[127:112])
dst[135:128] := SaturateU8(a[143:128])
dst[143:136] := SaturateU8(a[159:144])
dst[151:144] := SaturateU8(a[175:160])
dst[159:152] := SaturateU8(a[191:176])
dst[167:160] := SaturateU8(a[207:192])
dst[175:168] := SaturateU8(a[223:208])
dst[183:176] := SaturateU8(a[239:224])
dst[191:184] := SaturateU8(a[255:240])
dst[199:192] := SaturateU8(b[143:128])
dst[207:200] := SaturateU8(b[159:144])
dst[215:208] := SaturateU8(b[175:160])
dst[223:216] := SaturateU8(b[191:176])
dst[231:224] := SaturateU8(b[207:192])
dst[239:232] := SaturateU8(b[223:208])
dst[247:240] := SaturateU8(b[239:224])
dst[255:248] := SaturateU8(b[255:240])
dst[263:256] := SaturateU8(a[271:256])
dst[271:264] := SaturateU8(a[287:272])
dst[279:272] := SaturateU8(a[303:288])
dst[287:280] := SaturateU8(a[319:304])
dst[295:288] := SaturateU8(a[335:320])
dst[303:296] := SaturateU8(a[351:336])
dst[311:304] := SaturateU8(a[367:352])
dst[319:312] := SaturateU8(a[383:368])
dst[327:320] := SaturateU8(b[271:256])
dst[335:328] := SaturateU8(b[287:272])
dst[343:336] := SaturateU8(b[303:288])
dst[351:344] := SaturateU8(b[319:304])
dst[359:352] := SaturateU8(b[335:320])
dst[367:360] := SaturateU8(b[351:336])
dst[375:368] := SaturateU8(b[367:352])
dst[383:376] := SaturateU8(b[383:368])
dst[391:384] := SaturateU8(a[399:384])
dst[399:392] := SaturateU8(a[415:400])
dst[407:400] := SaturateU8(a[431:416])
dst[415:408] := SaturateU8(a[447:432])
dst[423:416] := SaturateU8(a[463:448])
dst[431:424] := SaturateU8(a[479:464])
dst[439:432] := SaturateU8(a[495:480])
dst[447:440] := SaturateU8(a[511:496])
dst[455:448] := SaturateU8(b[399:384])
dst[463:456] := SaturateU8(b[415:400])
dst[471:464] := SaturateU8(b[431:416])
dst[479:472] := SaturateU8(b[447:432])
dst[487:480] := SaturateU8(b[463:448])
dst[495:488] := SaturateU8(b[479:464])
dst[503:496] := SaturateU8(b[495:480])
dst[511:504] := SaturateU8(b[511:496])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSWB" form="zmm, zmm, zmm" xed="VPACKUSWB_ZMMu8_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSWB" form="xmm {k}, xmm, xmm" xed="VPACKUSWB_XMMu8_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSWB" form="xmm {z}, xmm, xmm" xed="VPACKUSWB_XMMu8_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDB" form="ymm {k}, ymm, ymm" xed="VPADDB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDB" form="ymm {z}, ymm, ymm" xed="VPADDB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDB" form="zmm, zmm, zmm" xed="VPADDB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDB" form="zmm {k}, zmm, zmm" xed="VPADDB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDB" form="zmm {z}, zmm, zmm" xed="VPADDB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDB" form="xmm {k}, xmm, xmm" xed="VPADDB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDB" form="xmm {z}, xmm, xmm" xed="VPADDB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSB" form="ymm {k}, ymm, ymm" xed="VPADDSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSB" form="ymm {z}, ymm, ymm" xed="VPADDSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSB" form="zmm, zmm, zmm" xed="VPADDSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSB" form="zmm {k}, zmm, zmm" xed="VPADDSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSB" form="zmm {z}, zmm, zmm" xed="VPADDSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSB" form="xmm {k}, xmm, xmm" xed="VPADDSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSB" form="xmm {z}, xmm, xmm" xed="VPADDSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSW" form="ymm {k}, ymm, ymm" xed="VPADDSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSW" form="ymm {z}, ymm, ymm" xed="VPADDSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSW" form="zmm, zmm, zmm" xed="VPADDSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSW" form="zmm {k}, zmm, zmm" xed="VPADDSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSW" form="zmm {z}, zmm, zmm" xed="VPADDSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSW" form="xmm {k}, xmm, xmm" xed="VPADDSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSW" form="xmm {z}, xmm, xmm" xed="VPADDSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSB" form="ymm {k}, ymm, ymm" xed="VPADDUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSB" form="ymm {z}, ymm, ymm" xed="VPADDUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSB" form="zmm, zmm, zmm" xed="VPADDUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSB" form="zmm {k}, zmm, zmm" xed="VPADDUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSB" form="zmm {z}, zmm, zmm" xed="VPADDUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSB" form="xmm {k}, xmm, xmm" xed="VPADDUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSB" form="xmm {z}, xmm, xmm" xed="VPADDUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSW" form="ymm {k}, ymm, ymm" xed="VPADDUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSW" form="ymm {z}, ymm, ymm" xed="VPADDUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSW" form="zmm, zmm, zmm" xed="VPADDUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSW" form="zmm {k}, zmm, zmm" xed="VPADDUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSW" form="zmm {z}, zmm, zmm" xed="VPADDUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSW" form="xmm {k}, xmm, xmm" xed="VPADDUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSW" form="xmm {z}, xmm, xmm" xed="VPADDUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDW" form="ymm {k}, ymm, ymm" xed="VPADDW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDW" form="ymm {z}, ymm, ymm" xed="VPADDW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDW" form="zmm, zmm, zmm" xed="VPADDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDW" form="zmm {k}, zmm, zmm" xed="VPADDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDW" form="zmm {z}, zmm, zmm" xed="VPADDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDW" form="xmm {k}, xmm, xmm" xed="VPADDW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDW" form="xmm {z}, xmm, xmm" xed="VPADDW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGB" form="ymm {k}, ymm, ymm" xed="VPAVGB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGB" form="ymm {z}, ymm, ymm" xed="VPAVGB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGB" form="zmm, zmm, zmm" xed="VPAVGB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGB" form="zmm {k}, zmm, zmm" xed="VPAVGB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGB" form="zmm {z}, zmm, zmm" xed="VPAVGB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPAVGB" form="xmm {k}, xmm, xmm" xed="VPAVGB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_avg_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPAVGB" form="xmm {z}, xmm, xmm" xed="VPAVGB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGW" form="ymm {k}, ymm, ymm" xed="VPAVGW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPAVGW" form="ymm {z}, ymm, ymm" xed="VPAVGW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGW" form="zmm, zmm, zmm" xed="VPAVGW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGW" form="zmm {k}, zmm, zmm" xed="VPAVGW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPAVGW" form="zmm {z}, zmm, zmm" xed="VPAVGW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPAVGW" form="xmm {k}, xmm, xmm" xed="VPAVGW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_avg_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPAVGW" form="xmm {z}, xmm, xmm" xed="VPAVGW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_blend_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Blend packed 8-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDMB" form="ymm {k}, ymm, ymm" xed="VPBLENDMB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_blend_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Blend packed 8-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBLENDMB" form="zmm {k}, zmm, zmm" xed="VPBLENDMB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_blend_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Blend packed 8-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDMB" form="xmm {k}, xmm, xmm" xed="VPBLENDMB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_blend_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDMW" form="ymm {k}, ymm, ymm" xed="VPBLENDMW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_blend_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBLENDMW" form="zmm {k}, zmm, zmm" xed="VPBLENDMW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_blend_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDMW" form="xmm {k}, xmm, xmm" xed="VPBLENDMW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="ymm {k}, xmm" xed="VPBROADCASTB_YMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="ymm {k}, r8" xed="VPBROADCASTB_YMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="ymm {z}, xmm" xed="VPBROADCASTB_YMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="ymm {z}, r8" xed="VPBROADCASTB_YMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm, xmm" xed="VPBROADCASTB_ZMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm {k}, xmm" xed="VPBROADCASTB_ZMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm {k}, r8" xed="VPBROADCASTB_ZMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm {z}, xmm" xed="VPBROADCASTB_ZMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm {z}, r8" xed="VPBROADCASTB_ZMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="xmm {k}, xmm" xed="VPBROADCASTB_XMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="xmm {k}, r8" xed="VPBROADCASTB_XMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_broadcastb_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Broadcast the low packed 8-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="xmm {z}, xmm" xed="VPBROADCASTB_XMMu8_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[7:0]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="xmm {z}, r8" xed="VPBROADCASTB_XMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="ymm {k}, xmm" xed="VPBROADCASTW_YMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="ymm {k}, r16" xed="VPBROADCASTW_YMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="ymm {z}, xmm" xed="VPBROADCASTW_YMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast 16-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="ymm {z}, r16" xed="VPBROADCASTW_YMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm, xmm" xed="VPBROADCASTW_ZMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm {k}, xmm" xed="VPBROADCASTW_ZMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast 16-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm {k}, r16" xed="VPBROADCASTW_ZMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm {z}, xmm" xed="VPBROADCASTW_ZMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm {z}, r16" xed="VPBROADCASTW_ZMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="xmm {k}, xmm" xed="VPBROADCASTW_XMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="xmm {k}, r16" xed="VPBROADCASTW_XMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_broadcastw_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="xmm {z}, xmm" xed="VPBROADCASTW_XMMu16_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="xmm {z}, r16" xed="VPBROADCASTW_XMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, ymm, ymm" xed="VPCMPB_MASKmskw_MASKmskw_YMMi8_YMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, zmm, zmm" xed="VPCMPB_MASKmskw_MASKmskw_ZMMi8_ZMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPB" form="k {k}, xmm, xmm" xed="VPCMPB_MASKmskw_MASKmskw_XMMi8_XMMi8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, ymm, ymm" xed="VPCMPUB_MASKmskw_MASKmskw_YMMu8_YMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, zmm, zmm" xed="VPCMPUB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] == b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &gt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt;= b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] &lt; b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epu8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ( a[i+7:i] != b[i+7:i] ) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUB" form="k {k}, xmm, xmm" xed="VPCMPUB_MASKmskw_MASKmskw_XMMu8_XMMu8_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, ymm, ymm" xed="VPCMPUW_MASKmskw_MASKmskw_YMMu16_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, zmm, zmm" xed="VPCMPUW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epu16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUW" form="k {k}, xmm, xmm" xed="VPCMPUW_MASKmskw_MASKmskw_XMMu16_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, ymm, ymm" xed="VPCMPW_MASKmskw_MASKmskw_YMMi16_YMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, zmm, zmm" xed="VPCMPW_MASKmskw_MASKmskw_ZMMi16_ZMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] == b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &gt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt;= b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] &lt; b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ( a[i+15:i] != b[i+15:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPW" form="k {k}, xmm, xmm" xed="VPCMPW_MASKmskw_MASKmskw_XMMi16_XMMi16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="src" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="ymm {k}, ymm, ymm" xed="VPMADDUBSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="ymm {z}, ymm, ymm" xed="VPMADDUBSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="zmm, zmm, zmm" xed="VPMADDUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="src" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="zmm {k}, zmm, zmm" xed="VPMADDUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="zmm {z}, zmm, zmm" xed="VPMADDUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="xmm {k}, xmm, xmm" xed="VPMADDUBSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_maddubs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply packed unsigned 8-bit integers in "a" by packed signed 8-bit integers in "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADDUBSW" form="xmm {z}, xmm, xmm" xed="VPMADDUBSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDWD" form="ymm {k}, ymm, ymm" xed="VPMADDWD_YMMi32_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADDWD" form="ymm {z}, ymm, ymm" xed="VPMADDWD_YMMi32_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDWD" form="zmm, zmm, zmm" xed="VPMADDWD_ZMMi32_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDWD" form="zmm {k}, zmm, zmm" xed="VPMADDWD_ZMMi32_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADDWD" form="zmm {z}, zmm, zmm" xed="VPMADDWD_ZMMi32_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADDWD" form="xmm {k}, xmm, xmm" xed="VPMADDWD_XMMi32_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_madd_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADDWD" form="xmm {z}, xmm, xmm" xed="VPMADDWD_XMMi32_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSB" form="ymm {k}, ymm, ymm" xed="VPMAXSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSB" form="ymm {z}, ymm, ymm" xed="VPMAXSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSB" form="zmm {k}, zmm, zmm" xed="VPMAXSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSB" form="zmm {z}, zmm, zmm" xed="VPMAXSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSB" form="zmm, zmm, zmm" xed="VPMAXSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSB" form="xmm {k}, xmm, xmm" xed="VPMAXSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSB" form="xmm {z}, xmm, xmm" xed="VPMAXSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSW" form="ymm {k}, ymm, ymm" xed="VPMAXSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSW" form="ymm {z}, ymm, ymm" xed="VPMAXSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSW" form="zmm {k}, zmm, zmm" xed="VPMAXSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSW" form="zmm {z}, zmm, zmm" xed="VPMAXSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSW" form="zmm, zmm, zmm" xed="VPMAXSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSW" form="xmm {k}, xmm, xmm" xed="VPMAXSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSW" form="xmm {z}, xmm, xmm" xed="VPMAXSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUB" form="ymm {k}, ymm, ymm" xed="VPMAXUB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUB" form="ymm {z}, ymm, ymm" xed="VPMAXUB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUB" form="zmm {k}, zmm, zmm" xed="VPMAXUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUB" form="zmm {z}, zmm, zmm" xed="VPMAXUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUB" form="zmm, zmm, zmm" xed="VPMAXUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUB" form="xmm {k}, xmm, xmm" xed="VPMAXUB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUB" form="xmm {z}, xmm, xmm" xed="VPMAXUB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUW" form="ymm {k}, ymm, ymm" xed="VPMAXUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUW" form="ymm {z}, ymm, ymm" xed="VPMAXUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUW" form="zmm {k}, zmm, zmm" xed="VPMAXUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUW" form="zmm {z}, zmm, zmm" xed="VPMAXUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUW" form="zmm, zmm, zmm" xed="VPMAXUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUW" form="xmm {k}, xmm, xmm" xed="VPMAXUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUW" form="xmm {z}, xmm, xmm" xed="VPMAXUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSB" form="ymm {k}, ymm, ymm" xed="VPMINSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSB" form="ymm {z}, ymm, ymm" xed="VPMINSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSB" form="zmm {k}, zmm, zmm" xed="VPMINSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSB" form="zmm {z}, zmm, zmm" xed="VPMINSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSB" form="zmm, zmm, zmm" xed="VPMINSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSB" form="xmm {k}, xmm, xmm" xed="VPMINSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSB" form="xmm {z}, xmm, xmm" xed="VPMINSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSW" form="ymm {k}, ymm, ymm" xed="VPMINSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSW" form="ymm {z}, ymm, ymm" xed="VPMINSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSW" form="zmm {k}, zmm, zmm" xed="VPMINSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSW" form="zmm {z}, zmm, zmm" xed="VPMINSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSW" form="zmm, zmm, zmm" xed="VPMINSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSW" form="xmm {k}, xmm, xmm" xed="VPMINSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSW" form="xmm {z}, xmm, xmm" xed="VPMINSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUB" form="ymm {k}, ymm, ymm" xed="VPMINUB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUB" form="ymm {z}, ymm, ymm" xed="VPMINUB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUB" form="zmm {k}, zmm, zmm" xed="VPMINUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUB" form="zmm {z}, zmm, zmm" xed="VPMINUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUB" form="zmm, zmm, zmm" xed="VPMINUB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUB" form="xmm {k}, xmm, xmm" xed="VPMINUB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUB" form="xmm {z}, xmm, xmm" xed="VPMINUB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUW" form="ymm {k}, ymm, ymm" xed="VPMINUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUW" form="ymm {z}, ymm, ymm" xed="VPMINUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUW" form="zmm {k}, zmm, zmm" xed="VPMINUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUW" form="zmm {z}, zmm, zmm" xed="VPMINUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUW" form="zmm, zmm, zmm" xed="VPMINUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUW" form="xmm {k}, xmm, xmm" xed="VPMINUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUW" form="xmm {z}, xmm, xmm" xed="VPMINUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movepi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 8-bit integer in "a".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF a[i+7]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPMOVB2M" form="k, ymm" xed="VPMOVB2M_MASKmskw_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movepi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 8-bit integer in "a".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF a[i+7]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPMOVB2M" form="k, zmm" xed="VPMOVB2M_MASKmskw_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movepi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 8-bit integer in "a".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF a[i+7]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPMOVB2M" form="k, xmm" xed="VPMOVB2M_MASKmskw_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movm_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<description>Set each packed 8-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := 0xFF
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVM2B" form="ymm" xed="VPMOVM2B_YMMu8_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movm_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<description>Set each packed 8-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := 0xFF
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVM2B" form="zmm" xed="VPMOVM2B_ZMMu8_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movm_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Set each packed 8-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := 0xFF
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVM2B" form="xmm" xed="VPMOVM2B_XMMu8_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movm_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Set each packed 16-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := 0xFFFF
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVM2W" form="ymm" xed="VPMOVM2W_YMMu16_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movm_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<description>Set each packed 16-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := 0xFFFF
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVM2W" form="zmm" xed="VPMOVM2W_ZMMu16_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movm_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 16-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := 0xFFFF
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVM2W" form="xmm" xed="VPMOVM2W_XMMu16_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	dst[l+7:l] := Saturate8(a[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm, ymm" xed="VPMOVSWB_XMMi8_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm {k}, ymm" xed="VPMOVSWB_XMMi8_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm {z}, ymm" xed="VPMOVSWB_XMMi8_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	dst[l+7:l] := Saturate8(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSWB" form="ymm, zmm" xed="VPMOVSWB_YMMi8_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="src" etype="SI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSWB" form="ymm {k}, zmm" xed="VPMOVSWB_YMMi8_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSWB" form="ymm {z}, zmm" xed="VPMOVSWB_YMMi8_MASKmskw_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	dst[l+7:l] := Saturate8(a[i+15:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm, xmm" xed="VPMOVSWB_XMMi8_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm {k}, xmm" xed="VPMOVSWB_XMMi8_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Convert packed signed 16-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSWB" form="xmm {z}, xmm" xed="VPMOVSWB_XMMi8_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="src" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="ymm {k}, xmm" xed="VPMOVSXBW_YMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="ymm {z}, xmm" xed="VPMOVSXBW_YMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend16(a[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="zmm, ymm" xed="VPMOVSXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="src" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="zmm {k}, ymm" xed="VPMOVSXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="zmm {z}, ymm" xed="VPMOVSXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="xmm {k}, xmm" xed="VPMOVSXBW_XMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := SignExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBW" form="xmm {z}, xmm" xed="VPMOVSXBW_XMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	dst[l+7:l] := SaturateU8(a[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm, ymm" xed="VPMOVUSWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm {k}, ymm" xed="VPMOVUSWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm {z}, ymm" xed="VPMOVUSWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	dst[l+7:l] := SaturateU8(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="ymm, zmm" xed="VPMOVUSWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="ymm {k}, zmm" xed="VPMOVUSWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="ymm {z}, zmm" xed="VPMOVUSWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	dst[l+7:l] := SaturateU8(a[i+15:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm, xmm" xed="VPMOVUSWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm {k}, xmm" xed="VPMOVUSWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed unsigned 16-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSWB" form="xmm {z}, xmm" xed="VPMOVUSWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movepi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 16-bit integer in "a".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF a[i+15]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPMOVW2M" form="k, ymm" xed="VPMOVW2M_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movepi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 16-bit integer in "a".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF a[i+15]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPMOVW2M" form="k, zmm" xed="VPMOVW2M_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movepi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 16-bit integer in "a".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF a[i+15]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPMOVW2M" form="k, xmm" xed="VPMOVW2M_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	dst[l+7:l] := Truncate8(a[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm, ymm" xed="VPMOVWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm {k}, ymm" xed="VPMOVWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm {z}, ymm" xed="VPMOVWB_XMMu8_MASKmskw_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	dst[l+7:l] := Truncate8(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVWB" form="ymm, zmm" xed="VPMOVWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVWB" form="ymm {k}, zmm" xed="VPMOVWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVWB" form="ymm {z}, zmm" xed="VPMOVWB_YMMu8_MASKmskw_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	dst[l+7:l] := Truncate8(a[i+15:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm, xmm" xed="VPMOVWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm {k}, xmm" xed="VPMOVWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi16_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Convert packed 16-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+15:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVWB" form="xmm {z}, xmm" xed="VPMOVWB_XMMu8_MASKmskw_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="ymm {k}, xmm" xed="VPMOVZXBW_YMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="ymm {z}, xmm" xed="VPMOVZXBW_YMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend16(a[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="zmm, ymm" xed="VPMOVZXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="zmm {k}, ymm" xed="VPMOVZXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="zmm {z}, ymm" xed="VPMOVZXBW_ZMMi16_MASKmskw_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="xmm {k}, xmm" xed="VPMOVZXBW_XMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	IF k[j]
		dst[l+15:l] := ZeroExtend16(a[i+7:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBW" form="xmm {z}, xmm" xed="VPMOVZXBW_XMMi16_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHRSW" form="ymm {k}, ymm, ymm" xed="VPMULHRSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHRSW" form="ymm {z}, ymm, ymm" xed="VPMULHRSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHRSW" form="zmm {k}, zmm, zmm" xed="VPMULHRSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHRSW" form="zmm {z}, zmm, zmm" xed="VPMULHRSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHRSW" form="zmm, zmm, zmm" xed="VPMULHRSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHRSW" form="xmm {k}, xmm, xmm" xed="VPMULHRSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
		dst[i+15:i] := tmp[16:1]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHRSW" form="xmm {z}, xmm, xmm" xed="VPMULHRSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHUW" form="ymm {k}, ymm, ymm" xed="VPMULHUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHUW" form="ymm {z}, ymm, ymm" xed="VPMULHUW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUW" form="zmm {k}, zmm, zmm" xed="VPMULHUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUW" form="zmm {z}, zmm, zmm" xed="VPMULHUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUW" form="zmm, zmm, zmm" xed="VPMULHUW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHUW" form="xmm {k}, xmm, xmm" xed="VPMULHUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mulhi_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := a[i+15:i] * b[i+15:i]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHUW" form="xmm {z}, xmm, xmm" xed="VPMULHUW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHW" form="ymm {k}, ymm, ymm" xed="VPMULHW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULHW" form="ymm {z}, ymm, ymm" xed="VPMULHW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHW" form="zmm {k}, zmm, zmm" xed="VPMULHW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHW" form="zmm {z}, zmm, zmm" xed="VPMULHW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHW" form="zmm, zmm, zmm" xed="VPMULHW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHW" form="xmm {k}, xmm, xmm" xed="VPMULHW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mulhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULHW" form="xmm {z}, xmm, xmm" xed="VPMULHW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLW" form="ymm {k}, ymm, ymm" xed="VPMULLW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLW" form="ymm {z}, ymm, ymm" xed="VPMULLW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLW" form="zmm {k}, zmm, zmm" xed="VPMULLW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLW" form="zmm {z}, zmm, zmm" xed="VPMULLW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[15:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLW" form="zmm, zmm, zmm" xed="VPMULLW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLW" form="xmm {k}, xmm, xmm" xed="VPMULLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mullo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
		dst[i+15:i] := tmp[15:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLW" form="xmm {z}, xmm, xmm" xed="VPMULLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm {k}, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm {z}, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm {k}, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm {z}, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVW" form="xmm {k}, xmm, xmm" xed="VPSLLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVW" form="xmm {z}, xmm, xmm" xed="VPSLLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVW" form="xmm, xmm, xmm" xed="VPSLLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {k}, ymm, xmm" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {k}, ymm, imm8" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {z}, ymm, xmm" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {z}, ymm, imm8" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {k}, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {k}, zmm, imm8" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {z}, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {z}, zmm, imm8" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm, zmm, imm8" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {k}, xmm, xmm" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {k}, xmm, imm8" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {z}, xmm, xmm" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {z}, xmm, imm8" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm {k}, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" name="_mm256_set_m128i">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="hi" etype="M128"/>
	<parameter type="__m128i" varname="lo" etype="M128"/>
	<description>Set packed __m256i vector "dst" with the supplied values.</description>
	<operation>
dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTF128" form="ymm, ymm, xmm, imm8" xed="VINSERTF128_YMMqq_YMMqq_XMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm {z}, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm {k}, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm {z}, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm {k}, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm {z}, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {k}, ymm, xmm" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {k}, ymm, imm8" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {z}, ymm, xmm" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {z}, ymm, imm8" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {k}, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {k}, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {z}, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {z}, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {k}, xmm, xmm" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {k}, xmm, imm8" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {z}, xmm, xmm" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {z}, xmm, imm8" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm {k}, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm {z}, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm {k}, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm {z}, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVW" form="xmm {k}, xmm, xmm" xed="VPSRLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVW" form="xmm {z}, xmm, xmm" xed="VPSRLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVW" form="xmm, xmm, xmm" xed="VPSRLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {k}, ymm, xmm" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {k}, ymm, imm8" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {z}, ymm, xmm" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {z}, ymm, imm8" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {k}, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {k}, zmm, imm8" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {z}, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {z}, zmm, imm8" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm, zmm, imm8" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {k}, xmm, xmm" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {k}, xmm, imm8" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {z}, xmm, xmm" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {z}, xmm, imm8" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBB" form="ymm {k}, ymm, ymm" xed="VPSUBB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBB" form="ymm {z}, ymm, ymm" xed="VPSUBB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBB" form="zmm {k}, zmm, zmm" xed="VPSUBB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBB" form="zmm {z}, zmm, zmm" xed="VPSUBB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBB" form="zmm, zmm, zmm" xed="VPSUBB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBB" form="xmm {k}, xmm, xmm" xed="VPSUBB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sub_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] - b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBB" form="xmm {z}, xmm, xmm" xed="VPSUBB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSB" form="ymm {k}, ymm, ymm" xed="VPSUBSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSB" form="ymm {z}, ymm, ymm" xed="VPSUBSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSB" form="zmm {k}, zmm, zmm" xed="VPSUBSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSB" form="zmm {z}, zmm, zmm" xed="VPSUBSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSB" form="zmm, zmm, zmm" xed="VPSUBSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBSB" form="xmm {k}, xmm, xmm" xed="VPSUBSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_subs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBSB" form="xmm {z}, xmm, xmm" xed="VPSUBSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSW" form="ymm {k}, ymm, ymm" xed="VPSUBSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBSW" form="ymm {z}, ymm, ymm" xed="VPSUBSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSW" form="zmm {k}, zmm, zmm" xed="VPSUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSW" form="zmm {z}, zmm, zmm" xed="VPSUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBSW" form="zmm, zmm, zmm" xed="VPSUBSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBSW" form="xmm {k}, xmm, xmm" xed="VPSUBSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_subs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBSW" form="xmm {z}, xmm, xmm" xed="VPSUBSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSB" form="ymm {k}, ymm, ymm" xed="VPSUBUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSB" form="ymm {z}, ymm, ymm" xed="VPSUBUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSB" form="zmm {k}, zmm, zmm" xed="VPSUBUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSB" form="zmm {z}, zmm, zmm" xed="VPSUBUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSB" form="zmm, zmm, zmm" xed="VPSUBUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBUSB" form="xmm {k}, xmm, xmm" xed="VPSUBUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_subs_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBUSB" form="xmm {z}, xmm, xmm" xed="VPSUBUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSW" form="ymm {k}, ymm, ymm" xed="VPSUBUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBUSW" form="ymm {z}, ymm, ymm" xed="VPSUBUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSW" form="zmm {k}, zmm, zmm" xed="VPSUBUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSW" form="zmm {z}, zmm, zmm" xed="VPSUBUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBUSW" form="zmm, zmm, zmm" xed="VPSUBUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBUSW" form="xmm {k}, xmm, xmm" xed="VPSUBUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_subs_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBUSW" form="xmm {z}, xmm, xmm" xed="VPSUBUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBW" form="ymm {k}, ymm, ymm" xed="VPSUBW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBW" form="ymm {z}, ymm, ymm" xed="VPSUBW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBW" form="zmm {k}, zmm, zmm" xed="VPSUBW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBW" form="zmm {z}, zmm, zmm" xed="VPSUBW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBW" form="zmm, zmm, zmm" xed="VPSUBW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBW" form="xmm {k}, xmm, xmm" xed="VPSUBW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sub_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] - b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBW" form="xmm {z}, xmm, xmm" xed="VPSUBW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTMB" form="k {k}, ymm, ymm" xed="VPTESTMB_MASKmskw_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTMB" form="k, ymm, ymm" xed="VPTESTMB_MASKmskw_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPTESTMB" form="k {k}, zmm, zmm" xed="VPTESTMB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPTESTMB" form="k, zmm, zmm" xed="VPTESTMB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMB" form="k {k}, xmm, xmm" xed="VPTESTMB_MASKmskw_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_test_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compute the bitwise AND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMB" form="k, xmm, xmm" xed="VPTESTMB_MASKmskw_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMW" form="k {k}, ymm, ymm" xed="VPTESTMW_MASKmskw_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMW" form="k, ymm, ymm" xed="VPTESTMW_MASKmskw_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTMW" form="k {k}, zmm, zmm" xed="VPTESTMW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTMW" form="k, zmm, zmm" xed="VPTESTMW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMW" form="k {k}, xmm, xmm" xed="VPTESTMW_MASKmskw_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_test_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compute the bitwise AND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMW" form="k, xmm, xmm" xed="VPTESTMW_MASKmskw_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k {k}, ymm, ymm" xed="VPTESTNMB_MASKmskw_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k, ymm, ymm" xed="VPTESTNMB_MASKmskw_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__mmask64" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k {k}, zmm, zmm" xed="VPTESTNMB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:64] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k, zmm, zmm" xed="VPTESTNMB_MASKmskw_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k1[j]
		k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k {k}, xmm, xmm" xed="VPTESTNMB_MASKmskw_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_testn_epi8_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compute the bitwise NAND of packed 8-bit integers in "a" and "b", producing intermediate 8-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	k[j] := ((a[i+7:i] AND b[i+7:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMB" form="k, xmm, xmm" xed="VPTESTNMB_MASKmskw_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k {k}, ymm, ymm" xed="VPTESTNMW_MASKmskw_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k, ymm, ymm" xed="VPTESTNMW_MASKmskw_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__mmask32" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k {k}, zmm, zmm" xed="VPTESTNMW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:32] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k, zmm, zmm" xed="VPTESTNMW_MASKmskw_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k1[j]
		k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k {k}, xmm, xmm" xed="VPTESTNMW_MASKmskw_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_testn_epi16_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compute the bitwise NAND of packed 16-bit integers in "a" and "b", producing intermediate 16-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	k[j] := ((a[i+15:i] AND b[i+15:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMW" form="k, xmm, xmm" xed="VPTESTNMW_MASKmskw_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="ymm {k}, ymm, ymm" xed="VPUNPCKHBW_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="ymm {z}, ymm, ymm" xed="VPUNPCKHBW_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_BYTES(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_BYTES(a[511:384], b[511:384])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="zmm {k}, zmm, zmm" xed="VPUNPCKHBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_BYTES(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_BYTES(a[511:384], b[511:384])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="zmm {z}, zmm, zmm" xed="VPUNPCKHBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_BYTES(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_BYTES(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_BYTES(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="zmm, zmm, zmm" xed="VPUNPCKHBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="xmm {k}, xmm, xmm" xed="VPUNPCKHBW_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHBW" form="xmm {z}, xmm, xmm" xed="VPUNPCKHBW_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="ymm {k}, ymm, ymm" xed="VPUNPCKHWD_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="ymm {z}, ymm, ymm" xed="VPUNPCKHWD_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_WORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_WORDS(a[511:384], b[511:384])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="zmm {k}, zmm, zmm" xed="VPUNPCKHWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_WORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_WORDS(a[511:384], b[511:384])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="zmm {z}, zmm, zmm" xed="VPUNPCKHWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_WORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_WORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_WORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="zmm, zmm, zmm" xed="VPUNPCKHWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="xmm {k}, xmm, xmm" xed="VPUNPCKHWD_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHWD" form="xmm {z}, xmm, xmm" xed="VPUNPCKHWD_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="src" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="ymm {k}, ymm, ymm" xed="VPUNPCKLBW_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="ymm {z}, ymm, ymm" xed="VPUNPCKLBW_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="src" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_BYTES(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_BYTES(a[511:384], b[511:384])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="zmm {k}, zmm, zmm" xed="VPUNPCKLBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__mmask64" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_BYTES(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_BYTES(a[511:384], b[511:384])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="zmm {z}, zmm, zmm" xed="VPUNPCKLBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_BYTES(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_BYTES(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_BYTES(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="zmm, zmm, zmm" xed="VPUNPCKLBW_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="xmm {k}, xmm, xmm" xed="VPUNPCKLBW_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLBW" form="xmm {z}, xmm, xmm" xed="VPUNPCKLBW_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="ymm {k}, ymm, ymm" xed="VPUNPCKLWD_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<parameter type="__m256i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="ymm {z}, ymm, ymm" xed="VPUNPCKLWD_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="src" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_WORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_WORDS(a[511:384], b[511:384])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="zmm {k}, zmm, zmm" xed="VPUNPCKLWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__mmask32" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_WORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_WORDS(a[511:384], b[511:384])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="zmm {z}, zmm, zmm" xed="VPUNPCKLWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_WORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_WORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_WORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="zmm, zmm, zmm" xed="VPUNPCKLWD_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="xmm {k}, xmm, xmm" xed="VPUNPCKLWD_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLWD" form="xmm {z}, xmm, xmm" xed="VPUNPCKLWD_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_broadcastmb_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Broadcast the low 8-bits from input mask "k" to all 64-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ZeroExtend64(k[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTMB2Q" form="ymm" xed="VPBROADCASTMB2Q_YMMu64_MASKu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_broadcastmb_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Broadcast the low 8-bits from input mask "k" to all 64-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ZeroExtend64(k[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTMB2Q" form="xmm" xed="VPBROADCASTMB2Q_XMMu64_MASKu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_broadcastmw_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Broadcast the low 16-bits from input mask "k" to all 32-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ZeroExtend32(k[15:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTMW2D" form="ymm" xed="VPBROADCASTMW2D_YMMu32_MASKu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_broadcastmw_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Broadcast the low 16-bits from input mask "k" to all 32-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ZeroExtend32(k[15:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTMW2D" form="xmm" xed="VPBROADCASTMW2D_XMMu32_MASKu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastmb_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Broadcast the low 8-bits from input mask "k" to all 64-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ZeroExtend64(k[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTMB2Q" form="zmm" xed="VPBROADCASTMB2Q_ZMMu64_MASKu64_AVX512CD" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastmw_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Broadcast the low 16-bits from input mask "k" to all 32-bit elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ZeroExtend32(k[15:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTMW2D" form="zmm" xed="VPBROADCASTMW2D_ZMMu32_MASKu32_AVX512CD" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 2)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="ymm, xmm" xed="VBROADCASTI32X2_YMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="ymm {k}, xmm" xed="VBROADCASTI32X2_YMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="ymm {z}, xmm" xed="VBROADCASTI32X2_YMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcast_i32x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst.</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 2)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="zmm, xmm" xed="VBROADCASTI32X2_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcast_i32x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="zmm {k}, xmm" xed="VBROADCASTI32X2_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcast_i32x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="zmm {z}, xmm" xed="VBROADCASTI32X2_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	n := (j % 2)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="xmm, xmm" xed="VBROADCASTI32X2_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="xmm {k}, xmm" xed="VBROADCASTI32X2_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_broadcast_i32x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the lower 2 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	n := (j % 2)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VBROADCASTI32X2" form="xmm {z}, xmm" xed="VBROADCASTI32X2_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_broadcast_i32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Broadcast the 8 packed 32-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 8)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X8" form="zmm, m256" xed="VBROADCASTI32X8_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_mask_broadcast_i32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Broadcast the 8 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 8)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X8" form="zmm {k}, m256" xed="VBROADCASTI32X8_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_maskz_broadcast_i32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Broadcast the 8 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 8)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X8" form="zmm {z}, m256" xed="VBROADCASTI32X8_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_broadcast_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	n := (j % 2)*64
	dst[i+63:i] := a[n+63:n]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="ymm, m128" xed="VBROADCASTI64X2_YMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_mask_broadcast_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	n := (j % 2)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="ymm {k}, m128" xed="VBROADCASTI64X2_YMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_maskz_broadcast_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	n := (j % 2)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="ymm {z}, m128" xed="VBROADCASTI64X2_YMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_broadcast_i64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 2)*64
	dst[i+63:i] := a[n+63:n]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="zmm, m128" xed="VBROADCASTI64X2_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_mask_broadcast_i64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 2)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="zmm {k}, m128" xed="VBROADCASTI64X2_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_maskz_broadcast_i64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the 2 packed 64-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 2)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X2" form="zmm {z}, m128" xed="VBROADCASTI64X2_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[255:0] := a[255:0]
1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm {k}, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm {z}, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {k}, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {z}, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[1:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
2: dst[127:0] := a[383:256]
3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {k}, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {z}, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE imm8[0] OF
0: dst[255:0] := b[255:0]
1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm {k}, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm {z}, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE imm8[0] OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm {k}, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm {z}, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "dst", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE imm8[1:0] OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
2: dst[383:256] := b[127:0]
3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm {k}, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm {z}, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movepi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 32-bit integer in "a".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF a[i+31]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPMOVD2M" form="k, ymm" xed="VPMOVD2M_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movepi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 32-bit integer in "a".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF a[i+31]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPMOVD2M" form="k, zmm" xed="VPMOVD2M_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movepi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 32-bit integer in "a".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF a[i+31]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPMOVD2M" form="k, xmm" xed="VPMOVD2M_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movm_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 32-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := 0xFFFFFFFF
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVM2D" form="ymm" xed="VPMOVM2D_YMMu32_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movm_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Set each packed 32-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := 0xFFFFFFFF
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVM2D" form="zmm" xed="VPMOVM2D_ZMMu32_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movm_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 32-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := 0xFFFFFFFF
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVM2D" form="xmm" xed="VPMOVM2D_XMMu32_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movm_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 64-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := 0xFFFFFFFFFFFFFFFF
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVM2Q" form="ymm" xed="VPMOVM2Q_YMMu64_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movm_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 64-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := 0xFFFFFFFFFFFFFFFF
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVM2Q" form="zmm" xed="VPMOVM2Q_ZMMu64_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movm_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<description>Set each packed 64-bit integer in "dst" to all ones or all zeros based on the value of the corresponding bit in "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := 0xFFFFFFFFFFFFFFFF
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVM2Q" form="xmm" xed="VPMOVM2Q_XMMu64_MASKmskw_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_movepi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 64-bit integer in "a".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF a[i+63]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPMOVQ2M" form="k, ymm" xed="VPMOVQ2M_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_movepi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 64-bit integer in "a".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF a[i+63]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPMOVQ2M" form="k, zmm" xed="VPMOVQ2M_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_movepi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Set each bit of mask register "k" based on the most significant bit of the corresponding packed 64-bit integer in "a".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF a[i+63]
		k[j] := 1
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPMOVQ2M" form="k, xmm" xed="VPMOVQ2M_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLQ" form="ymm {k}, ymm, ymm" xed="VPMULLQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLQ" form="ymm {z}, ymm, ymm" xed="VPMULLQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp[127:0] := a[i+63:i] * b[i+63:i]
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLQ" form="ymm, ymm, ymm" xed="VPMULLQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLQ" form="zmm {k}, zmm, zmm" xed="VPMULLQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLQ" form="zmm {z}, zmm, zmm" xed="VPMULLQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp[127:0] := a[i+63:i] * b[i+63:i]
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLQ" form="zmm, zmm, zmm" xed="VPMULLQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLQ" form="xmm {k}, xmm, xmm" xed="VPMULLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := a[i+63:i] * b[i+63:i]
		dst[i+63:i] := tmp[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLQ" form="xmm {z}, xmm, xmm" xed="VPMULLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mullo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Multiply the packed 64-bit integers in "a" and "b", producing intermediate 128-bit integers, and store the low 64 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp[127:0] := a[i+63:i] * b[i+63:i]
	dst[i+63:i] := tmp[63:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLQ" form="xmm, xmm, xmm" xed="VPMULLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_broadcast_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 4)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="ymm, m128" xed="VBROADCASTI32X4_YMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_mask_broadcast_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="ymm {k}, m128" xed="VBROADCASTI32X4_YMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm256_maskz_broadcast_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="ymm {z}, m128" xed="VBROADCASTI32X4_YMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {k}, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {z}, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm {k}, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm {z}, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQA32" form="ymm {k}, ymm" xed="VMOVDQA32_YMMu32_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQA32" form="ymm {z}, ymm" xed="VMOVDQA32_YMMu32_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQA32" form="xmm {k}, xmm" xed="VMOVDQA32_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQA32" form="xmm {z}, xmm" xed="VMOVDQA32_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQA64" form="ymm {k}, ymm" xed="VMOVDQA64_YMMu64_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQA64" form="ymm {z}, ymm" xed="VMOVDQA64_YMMu64_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQA64" form="xmm {k}, xmm" xed="VMOVDQA64_XMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQA64" form="xmm {z}, xmm" xed="VMOVDQA64_XMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSD" form="ymm {k}, ymm" xed="VPABSD_YMMi32_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSD" form="ymm {z}, ymm" xed="VPABSD_YMMi32_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSD" form="xmm {k}, xmm" xed="VPABSD_XMMi32_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSD" form="xmm {z}, xmm" xed="VPABSD_XMMi32_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSQ" form="ymm, ymm" xed="VPABSQ_YMMi64_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSQ" form="ymm {k}, ymm" xed="VPABSQ_YMMi64_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSQ" form="ymm {z}, ymm" xed="VPABSQ_YMMi64_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSQ" form="xmm, xmm" xed="VPABSQ_XMMi64_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSQ" form="xmm {k}, xmm" xed="VPABSQ_XMMi64_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSQ" form="xmm {z}, xmm" xed="VPABSQ_XMMi64_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDD" form="ymm {k}, ymm, ymm" xed="VPADDD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDD" form="ymm {z}, ymm, ymm" xed="VPADDD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDD" form="xmm {k}, xmm, xmm" xed="VPADDD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDD" form="xmm {z}, xmm, xmm" xed="VPADDD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDQ" form="ymm {k}, ymm, ymm" xed="VPADDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] :=0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDQ" form="ymm {z}, ymm, ymm" xed="VPADDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDQ" form="xmm {k}, xmm, xmm" xed="VPADDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDQ" form="xmm {z}, xmm, xmm" xed="VPADDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDD" form="ymm {k}, ymm, ymm" xed="VPANDD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDD" form="ymm {z}, ymm, ymm" xed="VPANDD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDD" form="xmm {k}, xmm, xmm" xed="VPANDD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDD" form="xmm {z}, xmm, xmm" xed="VPANDD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDND" form="ymm {k}, ymm, ymm" xed="VPANDND_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDND" form="ymm {z}, ymm, ymm" xed="VPANDND_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDND" form="xmm {k}, xmm, xmm" xed="VPANDND_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDND" form="xmm {z}, xmm, xmm" xed="VPANDND_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDNQ" form="ymm {k}, ymm, ymm" xed="VPANDNQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := (NOT a[i+63:i]) AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDNQ" form="ymm {z}, ymm, ymm" xed="VPANDNQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDNQ" form="xmm {k}, xmm, xmm" xed="VPANDNQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := (NOT a[i+63:i]) AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDNQ" form="xmm {z}, xmm, xmm" xed="VPANDNQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDQ" form="ymm {k}, ymm, ymm" xed="VPANDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPANDQ" form="ymm {z}, ymm, ymm" xed="VPANDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDQ" form="xmm {k}, xmm, xmm" xed="VPANDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPANDQ" form="xmm {z}, xmm, xmm" xed="VPANDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDMD" form="ymm {k}, ymm, ymm" xed="VPBLENDMD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDMD" form="xmm {k}, xmm, xmm" xed="VPBLENDMD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_blend_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Blend packed 64-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDMQ" form="ymm {k}, ymm, ymm" xed="VPBLENDMQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_blend_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Blend packed 64-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDMQ" form="xmm {k}, xmm, xmm" xed="VPBLENDMQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="ymm {k}, xmm" xed="VPBROADCASTD_YMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="ymm {k}, r32" xed="VPBROADCASTD_YMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="ymm {z}, xmm" xed="VPBROADCASTD_YMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="ymm {z}, r32" xed="VPBROADCASTD_YMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="xmm {k}, xmm" xed="VPBROADCASTD_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="xmm {k}, r32" xed="VPBROADCASTD_XMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="xmm {z}, xmm" xed="VPBROADCASTD_XMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="xmm {z}, r32" xed="VPBROADCASTD_XMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="ymm {k}, xmm" xed="VPBROADCASTQ_YMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="ymm {k}, r64" xed="VPBROADCASTQ_YMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="ymm {z}, xmm" xed="VPBROADCASTQ_YMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="ymm {z}, r64" xed="VPBROADCASTQ_YMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="xmm {k}, xmm" xed="VPBROADCASTQ_XMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="xmm {k}, r64" xed="VPBROADCASTQ_XMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="xmm {z}, xmm" xed="VPBROADCASTQ_XMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="xmm {z}, r64" xed="VPBROADCASTQ_XMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, ymm, ymm" xed="VPCMPD_MASKmskw_MASKmskw_YMMi32_YMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, xmm, xmm" xed="VPCMPD_MASKmskw_MASKmskw_XMMi32_XMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, ymm, ymm" xed="VPCMPQ_MASKmskw_MASKmskw_YMMi64_YMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, xmm, xmm" xed="VPCMPQ_MASKmskw_MASKmskw_XMMi64_XMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, ymm, ymm" xed="VPCMPUD_MASKmskw_MASKmskw_YMMu32_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, xmm, xmm" xed="VPCMPUD_MASKmskw_MASKmskw_XMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, ymm, ymm" xed="VPCMPUQ_MASKmskw_MASKmskw_YMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, xmm, xmm" xed="VPCMPUQ_MASKmskw_MASKmskw_XMMu64_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSD" form="ymm {k}, ymm, ymm" xed="VPMAXSD_YMMi32_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSD" form="ymm {z}, ymm, ymm" xed="VPMAXSD_YMMi32_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSD" form="xmm {k}, xmm, xmm" xed="VPMAXSD_XMMi32_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSD" form="xmm {z}, xmm, xmm" xed="VPMAXSD_XMMi32_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSQ" form="ymm {k}, ymm, ymm" xed="VPMAXSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSQ" form="ymm {z}, ymm, ymm" xed="VPMAXSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXSQ" form="ymm, ymm, ymm" xed="VPMAXSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSQ" form="xmm {k}, xmm, xmm" xed="VPMAXSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSQ" form="xmm {z}, xmm, xmm" xed="VPMAXSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXSQ" form="xmm, xmm, xmm" xed="VPMAXSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUD" form="ymm {k}, ymm, ymm" xed="VPMAXUD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUD" form="ymm {z}, ymm, ymm" xed="VPMAXUD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUD" form="xmm {k}, xmm, xmm" xed="VPMAXUD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUD" form="xmm {z}, xmm, xmm" xed="VPMAXUD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUQ" form="ymm {k}, ymm, ymm" xed="VPMAXUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUQ" form="ymm {z}, ymm, ymm" xed="VPMAXUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMAXUQ" form="ymm, ymm, ymm" xed="VPMAXUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUQ" form="xmm {k}, xmm, xmm" xed="VPMAXUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUQ" form="xmm {z}, xmm, xmm" xed="VPMAXUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMAXUQ" form="xmm, xmm, xmm" xed="VPMAXUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSD" form="ymm {k}, ymm, ymm" xed="VPMINSD_YMMi32_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSD" form="ymm {z}, ymm, ymm" xed="VPMINSD_YMMi32_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSD" form="xmm {k}, xmm, xmm" xed="VPMINSD_XMMi32_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSD" form="xmm {z}, xmm, xmm" xed="VPMINSD_XMMi32_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSQ" form="ymm {k}, ymm, ymm" xed="VPMINSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSQ" form="ymm {z}, ymm, ymm" xed="VPMINSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINSQ" form="ymm, ymm, ymm" xed="VPMINSQ_YMMi64_MASKmskw_YMMi64_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSQ" form="xmm {k}, xmm, xmm" xed="VPMINSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSQ" form="xmm {z}, xmm, xmm" xed="VPMINSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINSQ" form="xmm, xmm, xmm" xed="VPMINSQ_XMMi64_MASKmskw_XMMi64_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUD" form="ymm {k}, ymm, ymm" xed="VPMINUD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUD" form="ymm {z}, ymm, ymm" xed="VPMINUD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUD" form="xmm {k}, xmm, xmm" xed="VPMINUD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUD" form="xmm {z}, xmm, xmm" xed="VPMINUD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUQ" form="ymm {k}, ymm, ymm" xed="VPMINUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUQ" form="ymm {z}, ymm, ymm" xed="VPMINUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMINUQ" form="ymm, ymm, ymm" xed="VPMINUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUQ" form="xmm {k}, xmm, xmm" xed="VPMINUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUQ" form="xmm {z}, xmm, xmm" xed="VPMINUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMINUQ" form="xmm, xmm, xmm" xed="VPMINUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm, ymm" xed="VPMOVDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {k}, ymm" xed="VPMOVDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {z}, ymm" xed="VPMOVDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+31:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm, xmm" xed="VPMOVDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {k}, xmm" xed="VPMOVDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {z}, xmm" xed="VPMOVDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm, ymm" xed="VPMOVDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm {k}, ymm" xed="VPMOVDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm {z}, ymm" xed="VPMOVDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm, xmm" xed="VPMOVDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm {k}, xmm" xed="VPMOVDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVDW" form="xmm {z}, xmm" xed="VPMOVDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm, ymm" xed="VPMOVQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {k}, ymm" xed="VPMOVQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {z}, ymm" xed="VPMOVQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm, xmm" xed="VPMOVQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {k}, xmm" xed="VPMOVQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {z}, xmm" xed="VPMOVQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[k+31:k] := Truncate32(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm, ymm" xed="VPMOVQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm {k}, ymm" xed="VPMOVQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm {z}, ymm" xed="VPMOVQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[k+31:k] := Truncate32(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm, xmm" xed="VPMOVQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm {k}, xmm" xed="VPMOVQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQD" form="xmm {z}, xmm" xed="VPMOVQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm, ymm" xed="VPMOVQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {k}, ymm" xed="VPMOVQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {z}, ymm" xed="VPMOVQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+63:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm, xmm" xed="VPMOVQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {k}, xmm" xed="VPMOVQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {z}, xmm" xed="VPMOVQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm, ymm" xed="VPMOVSDB_XMMi8_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {k}, ymm" xed="VPMOVSDB_XMMi8_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {z}, ymm" xed="VPMOVSDB_XMMi8_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+31:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm, xmm" xed="VPMOVSDB_XMMi8_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {k}, xmm" xed="VPMOVSDB_XMMi8_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {z}, xmm" xed="VPMOVSDB_XMMi8_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm, ymm" xed="VPMOVSDW_XMMi16_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm {k}, ymm" xed="VPMOVSDW_XMMi16_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm {z}, ymm" xed="VPMOVSDW_XMMi16_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm, xmm" xed="VPMOVSDW_XMMi16_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm {k}, xmm" xed="VPMOVSDW_XMMi16_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSDW" form="xmm {z}, xmm" xed="VPMOVSDW_XMMi16_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+63:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm, ymm" xed="VPMOVSQB_XMMi8_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {k}, ymm" xed="VPMOVSQB_XMMi8_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {z}, ymm" xed="VPMOVSQB_XMMi8_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+63:i])
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm, xmm" xed="VPMOVSQB_XMMi8_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {k}, xmm" xed="VPMOVSQB_XMMi8_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {z}, xmm" xed="VPMOVSQB_XMMi8_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[k+31:k] := Saturate32(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm, ymm" xed="VPMOVSQD_XMMi32_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm {k}, ymm" xed="VPMOVSQD_XMMi32_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm {z}, ymm" xed="VPMOVSQD_XMMi32_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[k+31:k] := Saturate32(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm, xmm" xed="VPMOVSQD_XMMi32_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm {k}, xmm" xed="VPMOVSQD_XMMi32_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQD" form="xmm {z}, xmm" xed="VPMOVSQD_XMMi32_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm, ymm" xed="VPMOVSQW_XMMi16_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {k}, ymm" xed="VPMOVSQW_XMMi16_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {z}, ymm" xed="VPMOVSQW_XMMi16_MASKmskw_YMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+63:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm, xmm" xed="VPMOVSQW_XMMi16_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {k}, xmm" xed="VPMOVSQW_XMMi16_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {z}, xmm" xed="VPMOVSQW_XMMi16_MASKmskw_XMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="ymm {k}, xmm" xed="VPMOVSXBD_YMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="ymm {z}, xmm" xed="VPMOVSXBD_YMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 4 bytes of "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="xmm {k}, xmm" xed="VPMOVSXBD_XMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 4 bytes of "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="xmm {z}, xmm" xed="VPMOVSXBD_XMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="ymm {k}, xmm" xed="VPMOVSXBQ_YMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="ymm {z}, xmm" xed="VPMOVSXBQ_YMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 2 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="xmm {k}, xmm" xed="VPMOVSXBQ_XMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 2 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="xmm {z}, xmm" xed="VPMOVSXBQ_XMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="ymm {k}, xmm" xed="VPMOVSXDQ_YMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="ymm {z}, xmm" xed="VPMOVSXDQ_YMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="xmm {k}, xmm" xed="VPMOVSXDQ_XMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="xmm {z}, xmm" xed="VPMOVSXDQ_XMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	l := j*16
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="ymm {k}, xmm" xed="VPMOVSXWD_YMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="ymm {z}, xmm" xed="VPMOVSXWD_YMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	l := j*16
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="xmm {k}, xmm" xed="VPMOVSXWD_XMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="xmm {z}, xmm" xed="VPMOVSXWD_XMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="ymm {k}, xmm" xed="VPMOVSXWQ_YMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="ymm {z}, xmm" xed="VPMOVSXWQ_YMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="xmm {k}, xmm" xed="VPMOVSXWQ_XMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="xmm {z}, xmm" xed="VPMOVSXWQ_XMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm, ymm" xed="VPMOVUSDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {k}, ymm" xed="VPMOVUSDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {z}, ymm" xed="VPMOVUSDB_XMMu8_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+31:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm, xmm" xed="VPMOVUSDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {k}, xmm" xed="VPMOVUSDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {z}, xmm" xed="VPMOVUSDB_XMMu8_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm, ymm" xed="VPMOVUSDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm {k}, ymm" xed="VPMOVUSDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm {z}, ymm" xed="VPMOVUSDW_XMMu16_MASKmskw_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+31:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm, xmm" xed="VPMOVUSDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm {k}, xmm" xed="VPMOVUSDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="xmm {z}, xmm" xed="VPMOVUSDW_XMMu16_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+63:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm, ymm" xed="VPMOVUSQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {k}, ymm" xed="VPMOVUSQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {z}, ymm" xed="VPMOVUSQB_XMMu8_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+63:i])
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm, xmm" xed="VPMOVUSQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {k}, xmm" xed="VPMOVUSQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {z}, xmm" xed="VPMOVUSQB_XMMu8_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 32*j
	dst[k+31:k] := SaturateU32(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm, ymm" xed="VPMOVUSQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm {k}, ymm" xed="VPMOVUSQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm {z}, ymm" xed="VPMOVUSQD_XMMu32_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[k+31:k] := SaturateU32(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm, xmm" xed="VPMOVUSQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm {k}, xmm" xed="VPMOVUSQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="xmm {z}, xmm" xed="VPMOVUSQD_XMMu32_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm, ymm" xed="VPMOVUSQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {k}, ymm" xed="VPMOVUSQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {z}, ymm" xed="VPMOVUSQW_XMMu16_MASKmskw_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+63:i])
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm, xmm" xed="VPMOVUSQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {k}, xmm" xed="VPMOVUSQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {z}, xmm" xed="VPMOVUSQW_XMMu16_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="ymm {k}, xmm" xed="VPMOVZXBD_YMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="ymm {z}, xmm" xed="VPMOVZXBD_YMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 4 bytes of "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="xmm {k}, xmm" xed="VPMOVZXBD_XMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in th elow 4 bytes of "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="xmm {z}, xmm" xed="VPMOVZXBD_XMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="ymm {k}, xmm" xed="VPMOVZXBQ_YMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="ymm {z}, xmm" xed="VPMOVZXBQ_YMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 2 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="xmm {k}, xmm" xed="VPMOVZXBQ_XMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 2 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="xmm {z}, xmm" xed="VPMOVZXBQ_XMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="ymm {k}, xmm" xed="VPMOVZXDQ_YMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE 
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="ymm {z}, xmm" xed="VPMOVZXDQ_YMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="xmm {k}, xmm" xed="VPMOVZXDQ_XMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE 
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="xmm {z}, xmm" xed="VPMOVZXDQ_XMMi64_MASKmskw_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="ymm {k}, xmm" xed="VPMOVZXWD_YMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="ymm {z}, xmm" xed="VPMOVZXWD_YMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="xmm {k}, xmm" xed="VPMOVZXWD_XMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="xmm {z}, xmm" xed="VPMOVZXWD_XMMi32_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="ymm {k}, xmm" xed="VPMOVZXWQ_YMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="ymm {z}, xmm" xed="VPMOVZXWQ_YMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="xmm {k}, xmm" xed="VPMOVZXWQ_XMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in the low 4 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="xmm {z}, xmm" xed="VPMOVZXWQ_XMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULDQ" form="ymm {k}, ymm, ymm" xed="VPMULDQ_YMMi64_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULDQ" form="ymm {z}, ymm, ymm" xed="VPMULDQ_YMMi64_MASKmskw_YMMi32_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULDQ" form="xmm {k}, xmm, xmm" xed="VPMULDQ_XMMi64_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULDQ" form="xmm {z}, xmm, xmm" xed="VPMULDQ_XMMi64_MASKmskw_XMMi32_XMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLD" form="ymm {k}, ymm, ymm" xed="VPMULLD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULLD" form="ymm {z}, ymm, ymm" xed="VPMULLD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLD" form="zmm {z}, zmm, zmm" xed="VPMULLD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLD" form="xmm {k}, xmm, xmm" xed="VPMULLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULLD" form="xmm {z}, xmm, xmm" xed="VPMULLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULUDQ" form="ymm {k}, ymm, ymm" xed="VPMULUDQ_YMMu64_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULUDQ" form="ymm {z}, ymm, ymm" xed="VPMULUDQ_YMMu64_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULUDQ" form="xmm {k}, xmm, xmm" xed="VPMULUDQ_XMMu64_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULUDQ" form="xmm {z}, xmm, xmm" xed="VPMULUDQ_XMMu64_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORD" form="ymm {k}, ymm, ymm" xed="VPORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORD" form="ymm {z}, ymm, ymm" xed="VPORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORD" form="xmm {k}, xmm, xmm" xed="VPORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORD" form="xmm {z}, xmm, xmm" xed="VPORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORQ" form="ymm {k}, ymm, ymm" xed="VPORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORQ" form="ymm {z}, ymm, ymm" xed="VPORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORQ" form="xmm {k}, xmm, xmm" xed="VPORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORQ" form="xmm {z}, xmm, xmm" xed="VPORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm {k}, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm {z}, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm {k}, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm {z}, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm {k}, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm {z}, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm {k}, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm {z}, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm {k}, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm {z}, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm {k}, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm {z}, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm {k}, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm {z}, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm {k}, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm {z}, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm {k}, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm {z}, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm {k}, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm {z}, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm {k}, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm {z}, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm {k}, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm {z}, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm {k}, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm {z}, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm {k}, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm {z}, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm {k}, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm {z}, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm {k}, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm {z}, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {k}, ymm, xmm" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {k}, ymm, imm8" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {z}, ymm, xmm" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {z}, ymm, imm8" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {k}, xmm, xmm" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {k}, xmm, imm8" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {z}, xmm, xmm" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {z}, xmm, imm8" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {k}, ymm, xmm" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {k}, ymm, imm8" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {z}, ymm, xmm" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {z}, ymm, imm8" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {k}, xmm, xmm" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {k}, xmm, imm8" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {z}, xmm, xmm" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {z}, xmm, imm8" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm {k}, ymm, ymm" xed="VPSLLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm {z}, ymm, ymm" xed="VPSLLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm {k}, xmm, xmm" xed="VPSLLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm {z}, xmm, xmm" xed="VPSLLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm {k}, ymm, ymm" xed="VPSLLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm {z}, ymm, ymm" xed="VPSLLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm {k}, xmm, xmm" xed="VPSLLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm {z}, xmm, xmm" xed="VPSLLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {k}, ymm, xmm" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {k}, ymm, imm8" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {z}, ymm, xmm" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {z}, ymm, imm8" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {k}, xmm, xmm" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {k}, xmm, imm8" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {z}, xmm, xmm" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {z}, xmm, imm8" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {k}, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {k}, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {z}, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {z}, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {k}, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {k}, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {z}, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {z}, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm {k}, ymm, ymm" xed="VPSRAVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm {z}, ymm, ymm" xed="VPSRAVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm {k}, xmm, xmm" xed="VPSRAVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm {z}, xmm, xmm" xed="VPSRAVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm {k}, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm {z}, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="SI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm {k}, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm {z}, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {k}, ymm, xmm" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {k}, ymm, imm8" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {z}, ymm, xmm" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {z}, ymm, imm8" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {k}, xmm, xmm" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {k}, xmm, imm8" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {z}, xmm, xmm" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {z}, xmm, imm8" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {k}, ymm, xmm" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {k}, ymm, imm8" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {z}, ymm, xmm" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {z}, ymm, imm8" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {k}, xmm, xmm" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {k}, xmm, imm8" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {z}, xmm, xmm" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {z}, xmm, imm8" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm {k}, ymm, ymm" xed="VPSRLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm {z}, ymm, ymm" xed="VPSRLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm {k}, xmm, xmm" xed="VPSRLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm {z}, xmm, xmm" xed="VPSRLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm {k}, ymm, ymm" xed="VPSRLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm {z}, ymm, ymm" xed="VPSRLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm {k}, xmm, xmm" xed="VPSRLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm {z}, xmm, xmm" xed="VPSRLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBD" form="ymm {k}, ymm, ymm" xed="VPSUBD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBD" form="ymm {z}, ymm, ymm" xed="VPSUBD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBD" form="xmm {k}, xmm, xmm" xed="VPSUBD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBD" form="xmm {z}, xmm, xmm" xed="VPSUBD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBQ" form="ymm {k}, ymm, ymm" xed="VPSUBQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSUBQ" form="ymm {z}, ymm, ymm" xed="VPSUBQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBQ" form="xmm {k}, xmm, xmm" xed="VPSUBQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSUBQ" form="xmm {z}, xmm, xmm" xed="VPSUBQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMD" form="k {k}, ymm, ymm" xed="VPTESTMD_MASKmskw_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMD" form="k, ymm, ymm" xed="VPTESTMD_MASKmskw_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTMD" form="k {k}, xmm, xmm" xed="VPTESTMD_MASKmskw_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTMD" form="k, xmm, xmm" xed="VPTESTMD_MASKmskw_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k {k}, ymm, ymm" xed="VPTESTMQ_MASKmskw_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k, ymm, ymm" xed="VPTESTMQ_MASKmskw_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k {k}, xmm, xmm" xed="VPTESTMQ_MASKmskw_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k, xmm, xmm" xed="VPTESTMQ_MASKmskw_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k {k}, ymm, ymm" xed="VPTESTNMD_MASKmskw_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k, ymm, ymm" xed="VPTESTNMD_MASKmskw_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k {k}, xmm, xmm" xed="VPTESTNMD_MASKmskw_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k, xmm, xmm" xed="VPTESTNMD_MASKmskw_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k {k}, ymm, ymm" xed="VPTESTNMQ_MASKmskw_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:4] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k, ymm, ymm" xed="VPTESTNMQ_MASKmskw_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k {k}, xmm, xmm" xed="VPTESTNMQ_MASKmskw_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:2] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k, xmm, xmm" xed="VPTESTNMQ_MASKmskw_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="ymm {k}, ymm, ymm" xed="VPUNPCKHDQ_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="ymm {z}, ymm, ymm" xed="VPUNPCKHDQ_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="xmm {k}, xmm, xmm" xed="VPUNPCKHDQ_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="xmm {z}, xmm, xmm" xed="VPUNPCKHDQ_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="ymm {k}, ymm, ymm" xed="VPUNPCKHQDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="ymm {z}, ymm, ymm" xed="VPUNPCKHQDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="xmm {k}, xmm, xmm" xed="VPUNPCKHQDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="xmm {z}, xmm, xmm" xed="VPUNPCKHQDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="ymm {k}, ymm, ymm" xed="VPUNPCKLDQ_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="ymm {z}, ymm, ymm" xed="VPUNPCKLDQ_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="xmm {k}, xmm, xmm" xed="VPUNPCKLDQ_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="xmm {z}, xmm, xmm" xed="VPUNPCKLDQ_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="ymm {k}, ymm, ymm" xed="VPUNPCKLQDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="ymm {z}, ymm, ymm" xed="VPUNPCKLQDQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="xmm {k}, xmm, xmm" xed="VPUNPCKLQDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="xmm {z}, xmm, xmm" xed="VPUNPCKLQDQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORD" form="ymm {k}, ymm, ymm" xed="VPXORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORD" form="ymm {z}, ymm, ymm" xed="VPXORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORD" form="xmm {k}, xmm, xmm" xed="VPXORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORD" form="xmm {z}, xmm, xmm" xed="VPXORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORQ" form="ymm {k}, ymm, ymm" xed="VPXORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORQ" form="ymm {z}, ymm, ymm" xed="VPXORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORQ" form="xmm {k}, xmm, xmm" xed="VPXORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORQ" form="xmm {z}, xmm, xmm" xed="VPXORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORQ" form="ymm, ymm" xed="VPXORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPXORD" form="ymm, ymm" xed="VPXORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORQ" form="xmm, xmm" xed="VPXORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPXORD" form="xmm, xmm" xed="VPXORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORQ" form="ymm, ymm" xed="VPORQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<parameter type="__m256i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPORD" form="ymm, ymm" xed="VPORD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORQ" form="xmm, xmm" xed="VPORQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPORD" form="xmm, xmm" xed="VPORD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 4)*32
	dst[i+31:i] := a[n+31:n]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="zmm, m128" xed="VBROADCASTI32X4_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="zmm {k}, m128" xed="VBROADCASTI32X4_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="zmm {z}, m128" xed="VBROADCASTI32X4_ZMMu32_MASKmskw_MEMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 4)*64
	dst[i+63:i] := a[n+63:n]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X4" form="zmm, m256" xed="VBROADCASTI64X4_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X4" form="zmm {k}, m256" xed="VBROADCASTI64X4_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X4" form="zmm {z}, m256" xed="VBROADCASTI64X4_ZMMu64_MASKmskw_MEMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[1:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
2: dst[127:0] := a[383:256]
3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {k}, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {z}, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[255:0] := a[255:0]
1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm {k}, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm {z}, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
2: dst[383:256] := b[127:0]
3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm {k}, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm {z}, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "dst", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE (imm8[0]) OF
0: dst[255:0] := b[255:0]
1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm {k}, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm {z}, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQA32" form="zmm {z}, zmm" xed="VMOVDQA32_ZMMu32_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQA64" form="zmm {z}, zmm" xed="VMOVDQA64_ZMMu64_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSD" form="zmm, zmm" xed="VPABSD_ZMMi32_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSD" form="zmm {k}, zmm" xed="VPABSD_ZMMi32_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSD" form="zmm {z}, zmm" xed="VPABSD_ZMMi32_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSQ" form="zmm, zmm" xed="VPABSQ_ZMMi64_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSQ" form="zmm {k}, zmm" xed="VPABSQ_ZMMi64_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Compute the absolute value of packed signed 64-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSQ" form="zmm {z}, zmm" xed="VPABSQ_ZMMi64_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDD" form="zmm {z}, zmm, zmm" xed="VPADDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDQ" form="zmm, zmm, zmm" xed="VPADDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDQ" form="zmm {k}, zmm, zmm" xed="VPADDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDQ" form="zmm {z}, zmm, zmm" xed="VPADDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDD" form="zmm {z}, zmm, zmm" xed="VPANDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDND" form="zmm {z}, zmm, zmm" xed="VPANDND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := (NOT a[i+63:i]) AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDNQ" form="zmm {z}, zmm, zmm" xed="VPANDNQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDQ" form="zmm {z}, zmm, zmm" xed="VPANDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_set1_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTB" form="zmm, r8" xed="VPBROADCASTB_ZMMu8_MASKmskw_GPR32u8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm, xmm" xed="VPBROADCASTD_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm {k}, xmm" xed="VPBROADCASTD_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm {k}, r32" xed="VPBROADCASTD_ZMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcastd_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Broadcast the low packed 32-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm {z}, xmm" xed="VPBROADCASTD_ZMMu32_MASKmskw_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[31:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm {z}, r32" xed="VPBROADCASTD_ZMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_set1_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTD" form="zmm, r32" xed="VPBROADCASTD_ZMMu32_MASKmskw_GPR32u32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm, xmm" xed="VPBROADCASTQ_ZMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm {k}, xmm" xed="VPBROADCASTQ_ZMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm {k}, r64" xed="VPBROADCASTQ_ZMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcastq_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Broadcast the low packed 64-bit integer from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm {z}, xmm" xed="VPBROADCASTQ_ZMMu64_MASKmskw_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[63:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm {z}, r64" xed="VPBROADCASTQ_ZMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_set1_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTQ" form="zmm, r64" xed="VPBROADCASTQ_ZMMu64_MASKmskw_GPR64u64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" sequence="TRUE" name="_mm512_set1_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Set</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast the low packed 16-bit integer from "a" to all all elements of "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBROADCASTW" form="zmm, r16" xed="VPBROADCASTW_ZMMu16_MASKmskw_GPR32u16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPEQQ" form="k, zmm, zmm" xed="VPCMPEQQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPGTQ" form="k, zmm, zmm" xed="VPCMPGTQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPEQQ" form="k {k}, zmm, zmm" xed="VPCMPEQQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPGTQ" form="k {k}, zmm, zmm" xed="VPCMPGTQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPQ_MASKmskw_MASKmskw_ZMMi64_ZMMi64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpeq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] == b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpge_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpgt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &gt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmple_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt;= b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmplt_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] &lt; b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cmpneq_epu64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Compare</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ( a[i+63:i] != b[i+63:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPCMPUQ" form="k {k}, zmm, zmm, imm8" xed="VPCMPUQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0 
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSD" form="zmm {z}, zmm, zmm" xed="VPMAXSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSQ" form="zmm {k}, zmm, zmm" xed="VPMAXSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSQ" form="zmm {z}, zmm, zmm" xed="VPMAXSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSQ" form="zmm, zmm, zmm" xed="VPMAXSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUD" form="zmm {z}, zmm, zmm" xed="VPMAXUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUQ" form="zmm {k}, zmm, zmm" xed="VPMAXUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUQ" form="zmm {z}, zmm, zmm" xed="VPMAXUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_max_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MAX(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUQ" form="zmm, zmm, zmm" xed="VPMAXUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSD" form="zmm {z}, zmm, zmm" xed="VPMINSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSQ" form="zmm {k}, zmm, zmm" xed="VPMINSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSQ" form="zmm {z}, zmm, zmm" xed="VPMINSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSQ" form="zmm, zmm, zmm" xed="VPMINSQ_ZMMi64_MASKmskw_ZMMi64_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUD" form="zmm {z}, zmm, zmm" xed="VPMINUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUQ" form="zmm {k}, zmm, zmm" xed="VPMINUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUQ" form="zmm {z}, zmm, zmm" xed="VPMINUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_min_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compare packed unsigned 64-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := MIN(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUQ" form="zmm, zmm, zmm" xed="VPMINUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm, zmm" xed="VPMOVDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {k}, zmm" xed="VPMOVDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVDB" form="xmm {z}, zmm" xed="VPMOVDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVDW" form="ymm, zmm" xed="VPMOVDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVDW" form="ymm {k}, zmm" xed="VPMOVDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed 32-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVDW" form="ymm {z}, zmm" xed="VPMOVDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := Truncate8(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm, zmm" xed="VPMOVQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {k}, zmm" xed="VPMOVQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 8-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Truncate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQB" form="xmm {z}, zmm" xed="VPMOVQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := Truncate32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVQD" form="ymm, zmm" xed="VPMOVQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVQD" form="ymm {k}, zmm" xed="VPMOVQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 32-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Truncate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVQD" form="ymm {z}, zmm" xed="VPMOVQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := Truncate16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm, zmm" xed="VPMOVQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {k}, zmm" xed="VPMOVQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed 64-bit integers in "a" to packed 16-bit integers with truncation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Truncate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVQW" form="xmm {z}, zmm" xed="VPMOVQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm, zmm" xed="VPMOVSDB_XMMi8_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {k}, zmm" xed="VPMOVSDB_XMMi8_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSDB" form="xmm {z}, zmm" xed="VPMOVSDB_XMMi8_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSDW" form="ymm, zmm" xed="VPMOVSDW_YMMi16_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__m256i" varname="src" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSDW" form="ymm {k}, zmm" xed="VPMOVSDW_YMMi16_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<description>Convert packed signed 32-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSDW" form="ymm {z}, zmm" xed="VPMOVSDW_YMMi16_MASKmskw_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := Saturate8(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm, zmm" xed="VPMOVSQB_XMMi8_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="src" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {k}, zmm" xed="VPMOVSQB_XMMi8_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 8-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := Saturate8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVSQB" form="xmm {z}, zmm" xed="VPMOVSQB_XMMi8_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := Saturate32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSQD" form="ymm, zmm" xed="VPMOVSQD_YMMi32_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSQD" form="ymm {k}, zmm" xed="VPMOVSQD_YMMi32_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 32-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := Saturate32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVSQD" form="ymm {z}, zmm" xed="VPMOVSQD_YMMi32_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := Saturate16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm, zmm" xed="VPMOVSQW_XMMi16_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="src" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {k}, zmm" xed="VPMOVSQW_XMMi16_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtsepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<description>Convert packed signed 64-bit integers in "a" to packed 16-bit integers with signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := Saturate16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVSQW" form="xmm {z}, zmm" xed="VPMOVSQW_XMMi16_MASKmskw_ZMMi64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend32(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="zmm, xmm" xed="VPMOVSXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="zmm {k}, xmm" xed="VPMOVSXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBD" form="zmm {z}, xmm" xed="VPMOVSXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend64(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="zmm, xmm" xed="VPMOVSXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m512i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="zmm {k}, xmm" xed="VPMOVSXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXBQ" form="zmm {z}, xmm" xed="VPMOVSXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend64(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="zmm, ymm" xed="VPMOVSXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m512i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="zmm {k}, ymm" xed="VPMOVSXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXDQ" form="zmm {z}, ymm" xed="VPMOVSXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend32(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="zmm, ymm" xed="VPMOVSXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	l := j*16
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="zmm {k}, ymm" xed="VPMOVSXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := SignExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWD" form="zmm {z}, ymm" xed="VPMOVSXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend64(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="zmm, xmm" xed="VPMOVSXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m512i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="zmm {k}, xmm" xed="VPMOVSXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := SignExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVSXWQ" form="zmm {z}, xmm" xed="VPMOVSXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm, zmm" xed="VPMOVUSDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {k}, zmm" xed="VPMOVUSDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi32_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+31:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSDB" form="xmm {z}, zmm" xed="VPMOVUSDB_XMMu8_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="ymm, zmm" xed="VPMOVUSDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__m256i" varname="src" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="ymm {k}, zmm" xed="VPMOVUSDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi32_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI16" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Convert packed unsigned 32-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+31:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSDW" form="ymm {z}, zmm" xed="VPMOVUSDW_YMMu16_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[k+7:k] := SaturateU8(a[i+63:i])
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm, zmm" xed="VPMOVUSQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="src" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := src[l+7:l]
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {k}, zmm" xed="VPMOVUSQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi64_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 8-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[l+7:l] := SaturateU8(a[i+63:i])
	ELSE
		dst[l+7:l] := 0
	FI
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPMOVUSQB" form="xmm {z}, zmm" xed="VPMOVUSQB_XMMu8_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[k+31:k] := SaturateU32(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="ymm, zmm" xed="VPMOVUSQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="src" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := src[l+31:l]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="ymm {k}, zmm" xed="VPMOVUSQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi64_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m256i" varname="dst" etype="UI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 32-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[l+31:l] := SaturateU32(a[i+63:i])
	ELSE
		dst[l+31:l] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMOVUSQD" form="ymm {z}, zmm" xed="VPMOVUSQD_YMMu32_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[k+15:k] := SaturateU16(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm, zmm" xed="VPMOVUSQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="src" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := src[l+15:l]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {k}, zmm" xed="VPMOVUSQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtusepi64_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Convert packed unsigned 64-bit integers in "a" to packed unsigned 16-bit integers with unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[l+15:l] := SaturateU16(a[i+63:i])
	ELSE
		dst[l+15:l] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMOVUSQW" form="xmm {z}, zmm" xed="VPMOVUSQW_XMMu16_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend32(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="zmm, xmm" xed="VPMOVZXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="zmm {k}, xmm" xed="VPMOVZXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 8*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+7:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBD" form="zmm {z}, xmm" xed="VPMOVZXBD_ZMMi32_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 byte sof "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend64(a[k+7:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="zmm, xmm" xed="VPMOVZXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="zmm {k}, xmm" xed="VPMOVZXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 8*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+7:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXBQ" form="zmm {z}, xmm" xed="VPMOVZXBQ_ZMMi64_MASKmskw_XMMi8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend64(a[k+31:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="zmm, ymm" xed="VPMOVZXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="zmm {k}, ymm" xed="VPMOVZXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 32*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+31:l])
	ELSE 
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXDQ" form="zmm {z}, ymm" xed="VPMOVZXDQ_ZMMi64_MASKmskw_YMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend32(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="zmm, ymm" xed="VPMOVZXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="zmm {k}, ymm" xed="VPMOVZXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	l := 16*j
	IF k[j]
		dst[i+31:i] := ZeroExtend32(a[l+15:l])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWD" form="zmm {z}, ymm" xed="VPMOVZXWD_ZMMi32_MASKmskw_YMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend64(a[k+15:k])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="zmm, xmm" xed="VPMOVZXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="zmm {k}, xmm" xed="VPMOVZXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	l := 16*j
	IF k[j]
		dst[i+63:i] := ZeroExtend64(a[l+15:l])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMOVZXWQ" form="zmm {z}, xmm" xed="VPMOVZXWQ_ZMMi64_MASKmskw_XMMi16_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m512i" varname="src" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULDQ" form="zmm {k}, zmm, zmm" xed="VPMULDQ_ZMMi64_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULDQ" form="zmm {z}, zmm, zmm" xed="VPMULDQ_ZMMi64_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mul_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI64" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULDQ" form="zmm, zmm, zmm" xed="VPMULDQ_ZMMi64_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULUDQ" form="zmm {k}, zmm, zmm" xed="VPMULUDQ_ZMMu64_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+31:i] * b[i+31:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULUDQ" form="zmm {z}, zmm, zmm" xed="VPMULUDQ_ZMMu64_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mul_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULUDQ" form="zmm, zmm, zmm" xed="VPMULUDQ_ZMMu64_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORD" form="zmm {z}, zmm, zmm" xed="VPORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORQ" form="zmm {z}, zmm, zmm" xed="VPORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm {k}, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm {z}, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm {k}, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm {z}, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm {k}, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm {z}, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm {k}, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm {z}, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm {k}, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm {z}, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm {k}, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm {z}, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm {k}, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm {z}, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm {k}, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm {z}, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {k}, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {z}, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {z}, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {k}, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {k}, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {z}, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {z}, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm {z}, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm {k}, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm {z}, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {k}, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {z}, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {z}, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {k}, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {k}, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {z}, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {z}, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm {z}, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm {k}, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm {z}, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {k}, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {z}, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {z}, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {k}, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {k}, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {z}, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {z}, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm {z}, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm {k}, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm {z}, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBD" form="zmm {z}, zmm, zmm" xed="VPSUBD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBQ" form="zmm {k}, zmm, zmm" xed="VPSUBQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBQ" form="zmm {z}, zmm, zmm" xed="VPSUBQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBQ" form="zmm, zmm, zmm" xed="VPSUBQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k {k}, zmm, zmm" xed="VPTESTMQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_test_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTMQ" form="k, zmm, zmm" xed="VPTESTMQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k {k}, zmm, zmm" xed="VPTESTNMD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_testn_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise NAND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTNMD" form="k, zmm, zmm" xed="VPTESTNMD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__mmask8" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k1[j]
		k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k {k}, zmm, zmm" xed="VPTESTNMQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_testn_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise NAND of packed 64-bit integers in "a" and "b", producing intermediate 64-bit values, and set the corresponding bit in result mask "k" if the intermediate value is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	k[j] := ((a[i+63:i] AND b[i+63:i]) == 0) ? 1 : 0
ENDFOR
k[MAX:8] := 0
	</operation>
	<instruction name="VPTESTNMQ" form="k, zmm, zmm" xed="VPTESTNMQ_MASKmskw_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="zmm {k}, zmm, zmm" xed="VPUNPCKHDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="zmm {z}, zmm, zmm" xed="VPUNPCKHDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHDQ" form="zmm, zmm, zmm" xed="VPUNPCKHDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="zmm {k}, zmm, zmm" xed="VPUNPCKHQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
tmp_dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="zmm {z}, zmm, zmm" xed="VPUNPCKHQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_HIGH_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_HIGH_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_HIGH_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKHQDQ" form="zmm, zmm, zmm" xed="VPUNPCKHQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="zmm {k}, zmm, zmm" xed="VPUNPCKLDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
tmp_dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="zmm {z}, zmm, zmm" xed="VPUNPCKLDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_DWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_DWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_DWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLDQ" form="zmm, zmm, zmm" xed="VPUNPCKLDQ_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="zmm {k}, zmm, zmm" xed="VPUNPCKLQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
tmp_dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
tmp_dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
tmp_dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
tmp_dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="zmm {z}, zmm, zmm" xed="VPUNPCKLQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of each 128-bit lane in "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
dst[255:128] := INTERLEAVE_QWORDS(a[255:128], b[255:128])
dst[383:256] := INTERLEAVE_QWORDS(a[383:256], b[383:256])
dst[511:384] := INTERLEAVE_QWORDS(a[511:384], b[511:384])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPUNPCKLQDQ" form="zmm, zmm, zmm" xed="VPUNPCKLQDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORD" form="zmm {z}, zmm, zmm" xed="VPXORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORQ" form="zmm {z}, zmm, zmm" xed="VPXORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Divide packed signed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_mask_div_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Divide packed signed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		IF b[i+31:i] == 0
			#DE
		FI
		dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="SI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Divide packed signed 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Divide packed signed 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="SI64" />
	<parameter type="__m512i" varname="b" etype="SI64" />
	<description>Divide packed signed 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_mask_rem_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epi8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Divide packed 8-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 63
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epi16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Divide packed 16-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 31
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Divide packed 64-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_mask_div_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := 32*j
	IF k[j]
		IF b[i+31:i] == 0
			#DE
		FI
		dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epu8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epu16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_div_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_mask_rem_epu32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>FOR j := 0 to 15
	i := 32*j
	IF k[j]
		dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epu8">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 63
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epu16">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16" />
	<parameter type="__m512i" varname="a" etype="UI16" />
	<parameter type="__m512i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 31
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm512_rem_epu64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_cvtsi512_si32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Convert</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<operation>
dst[31:0] := a[31:0]
	</operation>
	<instruction name="VMOVD" form="r32, xmm" xed="VMOVD_GPR32u32_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_mov_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<description>Move packed 32-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQA32" form="zmm {k}, zmm" xed="VMOVDQA32_ZMMu32_MASKmskw_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_mov_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<description>Move packed 64-bit integers from "a" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQA64" form="zmm {k}, zmm" xed="VMOVDQA64_ZMMu64_MASKmskw_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDD" form="zmm, zmm, zmm" xed="VPADDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_add_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDD" form="zmm {k}, zmm, zmm" xed="VPADDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] AND b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDD" form="zmm, zmm, zmm" xed="VPANDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_and_si512">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="M512" />
	<parameter type="__m512i" varname="a" etype="M512" />
	<parameter type="__m512i" varname="b" etype="M512" />
	<description>Compute the bitwise AND of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[511:0] := (a[511:0] AND b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDD" form="zmm, zmm, zmm" xed="VPANDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (NOT a[i+31:i]) AND b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDND" form="zmm, zmm, zmm" xed="VPANDND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_andnot_si512">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="M512" />
	<parameter type="__m512i" varname="a" etype="M512" />
	<parameter type="__m512i" varname="b" etype="M512" />
	<description>Compute the bitwise NOT of 512 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".</description>
	<operation>
dst[511:0] := ((NOT a[511:0]) AND b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDND" form="zmm, zmm, zmm" xed="VPANDND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_andnot_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise NOT of packed 32-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((NOT a[i+31:i]) AND b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDND" form="zmm {k}, zmm, zmm" xed="VPANDND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of 512 bits (composed of packed 64-bit integers) in "a" and then AND with "b", and store the results in "dst".</description>
	<operation>
dst[511:0] := ((NOT a[511:0]) AND b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDNQ" form="zmm, zmm, zmm" xed="VPANDNQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_andnot_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of packed 64-bit integers in "a" and then AND with "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((NOT a[i+63:i]) AND b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDNQ" form="zmm {k}, zmm, zmm" xed="VPANDNQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of 512 bits (composed of packed 64-bit integers) in "a" and "b", and store the results in "dst".</description>
	<operation>
dst[511:0] := (a[511:0] AND b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDQ" form="zmm, zmm, zmm" xed="VPANDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_and_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] AND b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDQ" form="zmm {k}, zmm, zmm" xed="VPANDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBLENDMD" form="zmm {k}, zmm, zmm" xed="VPBLENDMD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_blend_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Blend packed 64-bit integers from "a" and "b" using control mask "k", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := b[i+63:i]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPBLENDMQ" form="zmm {k}, zmm, zmm" xed="VPBLENDMQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPEQD" form="k, zmm, zmm" xed="VPCMPEQD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPGTD" form="k, zmm, zmm" xed="VPCMPGTD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpeq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPEQD" form="k {k}, zmm, zmm" xed="VPCMPEQD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpge_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpgt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPGTD" form="k {k}, zmm, zmm" xed="VPCMPGTD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmple_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpneq_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPD" form="k {k}, zmm, zmm, imm8" xed="VPCMPD_MASKmskw_MASKmskw_ZMMi32_ZMMi32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpeq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for equality, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] == b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpge_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpgt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for greater-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &gt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmple_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt;= b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmplt_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_cmpneq_epu32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b" for not-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] != b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPUD" form="k {k}, zmm, zmm, imm8" xed="VPCMPUD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSD" form="zmm {k}, zmm, zmm" xed="VPMAXSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_max_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXSD" form="zmm, zmm, zmm" xed="VPMAXSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUD" form="zmm {k}, zmm, zmm" xed="VPMAXUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_max_epu32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMAXUD" form="zmm, zmm, zmm" xed="VPMAXUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSD" form="zmm {k}, zmm, zmm" xed="VPMINSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_min_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINSD" form="zmm, zmm, zmm" xed="VPMINSD_ZMMi32_MASKmskw_ZMMi32_ZMMi32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUD" form="zmm {k}, zmm, zmm" xed="VPMINUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_min_epu32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Special Math Functions</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMINUD" form="zmm, zmm, zmm" xed="VPMINUD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := a[i+31:i] * b[i+31:i]
		dst[i+31:i] := tmp[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLD" form="zmm {k}, zmm, zmm" xed="VPMULLD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mullo_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULLD" form="zmm, zmm, zmm" xed="VPMULLD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] OR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORD" form="zmm {k}, zmm, zmm" xed="VPORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_or_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise OR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] OR b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORD" form="zmm, zmm, zmm" xed="VPORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_or_si512">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="M512" />
	<parameter type="__m512i" varname="a" etype="M512" />
	<parameter type="__m512i" varname="b" etype="M512" />
	<description>Compute the bitwise OR of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[511:0] := (a[511:0] OR b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORD" form="zmm, zmm, zmm" xed="VPORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] OR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORQ" form="zmm {k}, zmm, zmm" xed="VPORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_or_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of packed 64-bit integers in "a" and "b", and store the resut in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] OR b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPORQ" form="zmm, zmm, zmm" xed="VPORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {k}, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm {k}, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {k}, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm {k}, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {k}, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm {k}, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBD" form="zmm {k}, zmm, zmm" xed="VPSUBD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBD" form="zmm, zmm, zmm" xed="VPSUBD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" (subject to writemask "k") if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
	ELSE
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMD" form="k {k}, zmm, zmm" xed="VPTESTMD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_test_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise AND of packed 32-bit integers in "a" and "b", producing intermediate 32-bit values, and set the corresponding bit in result mask "k" if the intermediate value is non-zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ((a[i+31:i] AND b[i+31:i]) != 0) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPTESTMD" form="k, zmm, zmm" xed="VPTESTMD_MASKmskw_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORD" form="zmm {k}, zmm, zmm" xed="VPXORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_xor_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Compute the bitwise XOR of packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] XOR b[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORD" form="zmm, zmm, zmm" xed="VPXORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_xor_si512">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="M512" />
	<parameter type="__m512i" varname="a" etype="M512" />
	<parameter type="__m512i" varname="b" etype="M512" />
	<description>Compute the bitwise XOR of 512 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[511:0] := (a[511:0] XOR b[511:0])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORD" form="zmm, zmm, zmm" xed="VPXORD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="src" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORQ" form="zmm {k}, zmm, zmm" xed="VPXORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_xor_epi64">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] XOR b[i+63:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPXORQ" form="zmm, zmm, zmm" xed="VPXORQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_and_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="v2" etype="UI32" />
	<parameter type="__m512i" varname="v3" etype="UI32" />
	<description>Performs element-by-element bitwise AND between packed 32-bit integer elements of "v2" and "v3", storing the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := v2[i+31:i] &amp; v3[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPANDD" form="zmm {k}, zmm, zmm" xed="VPANDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="zmm, zmm, zmm" xed="VPMADD52LUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="zmm {k}, zmm, zmm" xed="VPMADD52LUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="zmm {z}, zmm, zmm" xed="VPMADD52LUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="ymm, ymm, ymm" xed="VPMADD52LUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="ymm {k}, ymm, ymm" xed="VPMADD52LUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="ymm {z}, ymm, ymm" xed="VPMADD52LUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="xmm, xmm, xmm" xed="VPMADD52LUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="xmm {k}, xmm, xmm" xed="VPMADD52LUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_madd52lo_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the low 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[51:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52LUQ" form="xmm {z}, xmm, xmm" xed="VPMADD52LUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="zmm, zmm, zmm" xed="VPMADD52HUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="zmm {k}, zmm, zmm" xed="VPMADD52HUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI64" />
	<parameter type="__m512i" varname="b" etype="UI64" />
	<parameter type="__m512i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="zmm {z}, zmm, zmm" xed="VPMADD52HUQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="ymm, ymm, ymm" xed="VPMADD52HUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="ymm {k}, ymm, ymm" xed="VPMADD52HUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI64" />
	<parameter type="__m256i" varname="b" etype="UI64" />
	<parameter type="__m256i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="ymm {z}, ymm, ymm" xed="VPMADD52HUQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
	dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="xmm, xmm, xmm" xed="VPMADD52HUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="xmm {k}, xmm, xmm" xed="VPMADD52HUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_madd52hi_epu64">
	<CPUID>AVX512IFMA52</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<parameter type="__m128i" varname="c" etype="UI64" />
	<description>Multiply packed unsigned 52-bit integers in each 64-bit element of "b" and "c" to form a 104-bit intermediate result. Add the high 52-bit unsigned integer from the intermediate result with the corresponding unsigned 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ZeroExtend64(b[i+51:i]) * ZeroExtend64(c[i+51:i])
		dst[i+63:i] := a[i+63:i] + ZeroExtend64(tmp[103:52])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMADD52HUQ" form="xmm {z}, xmm, xmm" xed="VPMADD52HUQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm {z}, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm {k}, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm {z}, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm {k}, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm {z}, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm {k}, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm {z}, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm {k}, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="SI16" />
	<parameter type="__m512i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm {z}, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm {k}, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="SI16" />
	<parameter type="__m256i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm {z}, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm {k}, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm {z}, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm {k}, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm {z}, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm {k}, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm {z}, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm {k}, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm {z}, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm {k}, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32" />
	<parameter type="__m512i" varname="src" etype="SI32" />
	<parameter type="__m512i" varname="a" etype="UI8" />
	<parameter type="__m512i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm {z}, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm {k}, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32" />
	<parameter type="__m256i" varname="src" etype="SI32" />
	<parameter type="__m256i" varname="a" etype="UI8" />
	<parameter type="__m256i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm {z}, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__mmask8" varname="k" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm {k}, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="src" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in mask vector "k".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPLTD" form="k, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_cmplt_epi32_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>KNCNI</CPUID>
	<category>Compare</category>
	<return type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__mmask16" varname="k1" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="SI32" />
	<parameter type="__m512i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than-or-equal, and store the results in mask vector "k" using zeromask "k1" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k[j] := ( a[i+31:i] &lt; b[i+31:i] ) ? 1 : 0
	ELSE 
		k[j] := 0
	FI
ENDFOR
k[MAX:16] := 0
	</operation>
	<instruction name="VPCMPLTD" form="k {k}, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_subr_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="v2" etype="UI32" />
	<parameter type="__m512i" varname="v3" etype="UI32" />
	<description>Performs element-by-element subtraction of packed 32-bit integer elements in "v2" from "v3" storing the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := v3[i+31:i] - v2[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBRD" form="zmm, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_subr_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="v2" etype="UI32" />
	<parameter type="__m512i" varname="v3" etype="UI32" />
	<description>Performs element-by-element subtraction of packed 32-bit integer elements in "v2" from "v3" storing the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set)</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := v3[i+31:i] - v2[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBRD" form="zmm {k}, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_fmadd_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<parameter type="__m512i" varname="c" etype="UI32" />
	<description>Multiply packed 32-bit integer elements in "a" and "b", add the intermediate result to packed elements in "c" and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD231D" form="zmm, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_fmadd_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<parameter type="__m512i" varname="c" etype="UI32" />
	<description>Multiply packed 32-bit integer elements in "a" and "b", add the intermediate result to packed elements in "c" and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD231D" form="zmm {k}, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask3_fmadd_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<parameter type="__m512i" varname="c" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<description>Multiply packed 32-bit integer elements in "a" and "b", add the intermediate result to packed elements in "c" and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD231D" form="zmm {k}, zmm, zmm" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mulhi_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Performs element-by-element multiplication between packed 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHD" form="zmm, zmm, m512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_mulhi_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Performs element-by-element multiplication between packed 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHD" form="zmm {k}, zmm, m512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mulhi_epu32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Performs element-by-element multiplication between packed unsigned 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUD" form="zmm, zmm, m512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_mulhi_epu32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32" />
	<parameter type="__m512i" varname="src" etype="UI32" />
	<parameter type="__mmask16" varname="k" etype="MASK" />
	<parameter type="__m512i" varname="a" etype="UI32" />
	<parameter type="__m512i" varname="b" etype="UI32" />
	<description>Performs element-by-element multiplication between packed unsigned 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUD" form="zmm {k}, zmm, m512" />
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_from_int64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Copy 64-bit integer "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="mm, r64" xed="MOVQ_MMXq_GPR64" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_to_int64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m64" varname="a" etype="FP32" />
	<description>Copy 64-bit integer "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="r64, mm" xed="MOVQ_GPR64_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_from_int">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Copy 32-bit integer "a" to the lower elements of "dst", and zero the upper element of "dst".</description>
	<operation>
dst[31:0] := a[31:0]
dst[63:32] := 0
	</operation>
	<instruction name="MOVD" form="mm, r32" xed="MOVD_MMXq_GPR32" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_to_int">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m64" varname="a" etype="FP32" />
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<operation>
dst[31:0] := a[31:0]
	</operation>
	<instruction name="MOVD" form="r32, mm" xed="MOVD_GPR32_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_packsswb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="SI8" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := Saturate8(a[15:0])
dst[15:8] := Saturate8(a[31:16])
dst[23:16] := Saturate8(a[47:32])
dst[31:24] := Saturate8(a[63:48])
dst[39:32] := Saturate8(b[15:0])
dst[47:40] := Saturate8(b[31:16])
dst[55:48] := Saturate8(b[47:32])
dst[63:56] := Saturate8(b[63:48])
	</operation>
	<instruction name="PACKSSWB" form="mm, mm" xed="PACKSSWB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_packssdw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:0])
dst[31:16] := Saturate16(a[63:32])
dst[47:32] := Saturate16(b[31:0])
dst[63:48] := Saturate16(b[63:32])
	</operation>
	<instruction name="PACKSSDW" form="mm, mm" xed="PACKSSDW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_packuswb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := SaturateU8(a[15:0])
dst[15:8] := SaturateU8(a[31:16])
dst[23:16] := SaturateU8(a[47:32])
dst[31:24] := SaturateU8(a[63:48])
dst[39:32] := SaturateU8(b[15:0])
dst[47:40] := SaturateU8(b[31:16])
dst[55:48] := SaturateU8(b[47:32])
dst[63:56] := SaturateU8(b[63:48])
	</operation>
	<instruction name="PACKUSWB" form="mm, mm" xed="PACKUSWB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpckhbw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[39:32]
	dst[15:8] := src2[39:32] 
	dst[23:16] := src1[47:40]
	dst[31:24] := src2[47:40]
	dst[39:32] := src1[55:48]
	dst[47:40] := src2[55:48]
	dst[55:48] := src1[63:56]
	dst[63:56] := src2[63:56]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKHBW" form="mm, mm" xed="PUNPCKHBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpckhwd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[47:32]
	dst[31:16] := src2[47:32]
	dst[47:32] := src1[63:48]
	dst[63:48] := src2[63:48]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLBW" form="mm, mm" xed="PUNPCKLBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpckhdq">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
dst[31:0] := a[63:32]
dst[63:32] := b[63:32]
	</operation>
	<instruction name="PUNPCKHDQ" form="mm, mm" xed="PUNPCKHDQ_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpcklbw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLBW" form="mm, mm" xed="PUNPCKLBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpcklwd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLWD" form="mm, mm" xed="PUNPCKLWD_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_punpckldq">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
dst[31:0] := a[31:0]
dst[63:32] := b[31:0]
	</operation>
	<instruction name="PUNPCKLDQ" form="mm, mm" xed="PUNPCKLDQ_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" name="_mm256_setr_m128i">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Set</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="lo" etype="M128"/>
	<parameter type="__m128i" varname="hi" etype="M128"/>
	<description>Set packed __m256i vector "dst" with the supplied values.</description>
	<operation>
dst[127:0] := lo[127:0]
dst[255:128] := hi[127:0]
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTF128" form="ymm, ymm, xmm, imm8" xed="VINSERTF128_YMMqq_YMMqq_XMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PADDB" form="mm, mm" xed="PADDB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PADDW" form="mm, mm" xed="PADDW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PADDD" form="mm, mm" xed="PADDD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddsb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDSB" form="mm, mm" xed="PADDSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddsw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDSW" form="mm, mm" xed="PADDSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddusb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSB" form="mm, mm" xed="PADDUSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_paddusw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSW" form="mm, mm" xed="PADDUSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubb">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PSUBB" form="mm, mm" xed="PSUBB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PSUBW" form="mm, mm" xed="PSUBW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubd">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PSUBD" form="mm, mm" xed="PSUBD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubsb">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBSB" form="mm, mm" xed="PSUBSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubsw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PSUBSW" form="mm, mm" xed="PSUBSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubusb">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSB" form="mm, mm" xed="PSUBUSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psubusw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSW" form="mm, mm" xed="PSUBUSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pmaddwd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMADDWD" form="mm, mm" xed="PMADDWD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pmulhw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHW" form="mm, mm" xed="PMULHW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pmullw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR
	</operation>
	<instruction name="PMULLW" form="mm, mm" xed="PMULLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psllw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, mm" xed="PSLLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psllwi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, imm8" xed="PSLLW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pslld">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, mm" xed="PSLLD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pslldi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, imm8" xed="PSLLD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psraw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, mm" xed="PSRAW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrawi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, imm8" xed="PSRAW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrad">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, mm" xed="PSRAD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psradi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, imm8" xed="PSRAD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrlw">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, mm" xed="PSRLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrlwi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, imm8" xed="PSRLW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrld">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="count" etype="UI64" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, mm" xed="PSRLD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_psrldi">
	<type>Floating Point</type>
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, imm8" xed="PSRLD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pand">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] AND b[63:0])
	</operation>
	<instruction name="PAND" form="mm, mm" xed="PAND_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pandn">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of 64 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := ((NOT a[63:0]) AND b[63:0])
	</operation>
	<instruction name="PANDN" form="mm, mm" xed="PANDN_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_por">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] OR b[63:0])
	</operation>
	<instruction name="POR" form="mm, mm" xed="POR_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pxor">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] XOR b[63:0])
	</operation>
	<instruction name="PXOR" form="mm, mm" xed="PXOR_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpeqb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQB" form="mm, mm" xed="PCMPEQB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpeqw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQW" form="mm, mm" xed="PCMPEQW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpeqd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQD" form="mm, mm" xed="PCMPEQD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpgtb">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Compare packed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTB" form="mm, mm" xed="PCMPGTB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpgtw">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Compare packed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTW" form="mm, mm" xed="PCMPGTW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_m_pcmpgtd">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI64" />
	<parameter type="__m64" varname="b" etype="SI64" />
	<description>Compare packed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTD" form="mm, mm" xed="PCMPGTD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_add_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PADDB" form="mm, mm" xed="PADDB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_add_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PADDW" form="mm, mm" xed="PADDW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_add_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PADDD" form="mm, mm" xed="PADDD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_adds_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI8" />
	<parameter type="__m64" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDSB" form="mm, mm" xed="PADDSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_adds_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDSW" form="mm, mm" xed="PADDSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_adds_pu8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSB" form="mm, mm" xed="PADDUSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_adds_pu16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSW" form="mm, mm" xed="PADDUSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sub_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PSUBB" form="mm, mm" xed="PSUBB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sub_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PSUBW" form="mm, mm" xed="PSUBW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sub_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PSUBD" form="mm, mm" xed="PSUBD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_subs_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI8" />
	<parameter type="__m64" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBSB" form="mm, mm" xed="PSUBSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_subs_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PSUBSW" form="mm, mm" xed="PSUBSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_subs_pu8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSB" form="mm, mm" xed="PSUBUSB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_subs_pu16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSW" form="mm, mm" xed="PSUBUSW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_madd_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMADDWD" form="mm, mm" xed="PMADDWD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_mulhi_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHW" form="mm, mm" xed="PMULHW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_mullo_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[15:0]
ENDFOR
	</operation>
	<instruction name="PMULLW" form="mm, mm" xed="PMULLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sll_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, mm" xed="PSLLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_slli_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, imm8" xed="PSLLW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sll_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, mm" xed="PSLLD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_slli_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, imm8" xed="PSLLD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sra_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, mm" xed="PSRAW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srai_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, imm8" xed="PSRAW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sra_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, mm" xed="PSRAD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srai_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, imm8" xed="PSRAD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srl_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, mm" xed="PSRLW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srli_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, imm8" xed="PSRLW_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srl_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, mm" xed="PSRLD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srli_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, imm8" xed="PSRLD_MMXq_IMMb" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_and_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise AND of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] AND b[63:0])
	</operation>
	<instruction name="PAND" form="mm, mm" xed="PAND_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_andnot_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise NOT of 64 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := ((NOT a[63:0]) AND b[63:0])
	</operation>
	<instruction name="PANDN" form="mm, mm" xed="PANDN_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_or_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise OR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] OR b[63:0])
	</operation>
	<instruction name="POR" form="mm, mm" xed="POR_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_xor_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Logical</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Compute the bitwise XOR of 64 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[63:0] XOR b[63:0])
	</operation>
	<instruction name="PXOR" form="mm, mm" xed="PXOR_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpeq_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQB" form="mm, mm" xed="PCMPEQB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpeq_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQW" form="mm, mm" xed="PCMPEQW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpeq_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQD" form="mm, mm" xed="PCMPEQD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpgt_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI8" />
	<parameter type="__m64" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTB" form="mm, mm" xed="PCMPGTB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpgt_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTW" form="mm, mm" xed="PCMPGTW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cmpgt_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Compare</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTD" form="mm, mm" xed="PCMPGTD_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cvtsi32_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Copy 32-bit integer "a" to the lower elements of "dst", and zero the upper element of "dst".</description>
	<operation>
dst[31:0] := a[31:0]
dst[63:32] := 0
	</operation>
	<instruction name="MOVD" form="mm, r32" xed="MOVD_MMXq_GPR32" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cvtsi64_si32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m64" varname="a" etype="FP32" />
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<operation>
dst[31:0] := a[31:0]
	</operation>
	<instruction name="MOVD" form="r32, mm" xed="MOVD_GPR32_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cvtm64_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m64" varname="a" etype="FP32" />
	<description>Copy 64-bit integer "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="r64, mm" xed="MOVQ_GPR64_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_cvtsi64_m64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Convert</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Copy 64-bit integer "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="mm, r64" xed="MOVQ_MMXq_GPR64" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" sequence="TRUE" name="_mm_set1_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
	</operation>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" sequence="TRUE" name="_mm_set1_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast 16-bit integer "a" to all all elements of "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
	</operation>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" sequence="TRUE" name="_mm_set1_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Set</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
	</operation>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_packs_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="SI8" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := Saturate8(a[15:0])
dst[15:8] := Saturate8(a[31:16])
dst[23:16] := Saturate8(a[47:32])
dst[31:24] := Saturate8(a[63:48])
dst[39:32] := Saturate8(b[15:0])
dst[47:40] := Saturate8(b[31:16])
dst[55:48] := Saturate8(b[47:32])
dst[63:56] := Saturate8(b[63:48])
	</operation>
	<instruction name="PACKSSWB" form="mm, mm" xed="PACKSSWB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_packs_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:0])
dst[31:16] := Saturate16(a[63:32])
dst[47:32] := Saturate16(b[31:0])
dst[63:48] := Saturate16(b[63:32])
	</operation>
	<instruction name="PACKSSDW" form="mm, mm" xed="PACKSSDW_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_packs_pu16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := SaturateU8(a[15:0])
dst[15:8] := SaturateU8(a[31:16])
dst[23:16] := SaturateU8(a[47:32])
dst[31:24] := SaturateU8(a[63:48])
dst[39:32] := SaturateU8(b[15:0])
dst[47:40] := SaturateU8(b[31:16])
dst[55:48] := SaturateU8(b[47:32])
dst[63:56] := SaturateU8(b[63:48])
	</operation>
	<instruction name="PACKUSWB" form="mm, mm" xed="PACKUSWB_MMXq_MMXq" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpackhi_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[39:32]
	dst[15:8] := src2[39:32] 
	dst[23:16] := src1[47:40]
	dst[31:24] := src2[47:40]
	dst[39:32] := src1[55:48]
	dst[47:40] := src2[55:48]
	dst[55:48] := src1[63:56]
	dst[63:56] := src2[63:56]
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_HIGH_BYTES(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKHBW" form="mm, mm" xed="PUNPCKHBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpackhi_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[47:32]
	dst[31:16] := src2[47:32]
	dst[47:32] := src1[63:48]
	dst[63:48] := src2[63:48]
	RETURN dst[63:0]
}
dst[63:0] := INTERLEAVE_HIGH_WORDS(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLBW" form="mm, mm" xed="PUNPCKLBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpackhi_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
dst[31:0] := a[63:32]
dst[63:32] := b[63:32]
	</operation>
	<instruction name="PUNPCKHDQ" form="mm, mm" xed="PUNPCKHDQ_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpacklo_pi8">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[63:0], src2[63:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_BYTES(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLBW" form="mm, mm" xed="PUNPCKLBW_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpacklo_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[63:0], src2[63:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	RETURN dst[63:0]	
}
dst[63:0] := INTERLEAVE_WORDS(a[63:0], b[63:0])
	</operation>
	<instruction name="PUNPCKLWD" form="mm, mm" xed="PUNPCKLWD_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_unpacklo_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
dst[31:0] := a[31:0]
dst[63:32] := b[31:0]
	</operation>
	<instruction name="PUNPCKLDQ" form="mm, mm" xed="PUNPCKLDQ_MMXq_MMXd" />
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_max_pi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMAXSW" form="mm, mm" xed="PMAXSW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pmaxsw">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMAXSW" form="mm, mm" xed="PMAXSW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_max_pu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMAXUB" form="mm, mm" xed="PMAXUB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pmaxub">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMAXUB" form="mm, mm" xed="PMAXUB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_min_pi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMINSW" form="mm, mm" xed="PMINSW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pminsw">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMINSW" form="mm, mm" xed="PMINSW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_min_pu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMINUB" form="mm, mm" xed="PMINUB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pminub">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMINUB" form="mm, mm" xed="PMINUB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_mulhi_pu16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHUW" form="mm, mm" xed="PMULHUW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pmulhuw">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHUW" form="mm, mm" xed="PMULHUW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_avg_pu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGB" form="mm, mm" xed="PAVGB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pavgb">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGB" form="mm, mm" xed="PAVGB_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_avg_pu16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGW" form="mm, mm" xed="PAVGW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pavgw">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="__m64" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGW" form="mm, mm" xed="PAVGW_MMXq_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_extract_pi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract a 16-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[15:0] := (a[63:0] &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := 0
	</operation>
	<instruction name="PEXTRW" form="r32, mm, imm8" xed="PEXTRW_GPR32_MMXq_IMMb" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pextrw">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract a 16-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[15:0] := (a[63:0] &gt;&gt; (imm8[1:0] * 16))[15:0]
dst[31:16] := 0
	</operation>
	<instruction name="PEXTRW" form="r32, mm, imm8" xed="PEXTRW_GPR32_MMXq_IMMb" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_movemask_pi8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Miscellaneous</category>
	<return type="int" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<description>Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:8] := 0
	</operation>
	<instruction name="PMOVMSKB" form="r32, mm" xed="PMOVMSKB_GPR32_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_m_pmovmskb">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Miscellaneous</category>
	<return type="int" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<description>Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:8] := 0
	</operation>
	<instruction name="PMOVMSKB" form="r32, mm" xed="PMOVMSKB_GPR32_MMXq" />
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epi8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Divide packed signed 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Divide packed signed 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epi64">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Divide packed signed 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := 8*j
	IF b[i+7:i] == 0
		#DE
	FI
	dst[i+7:i] := Truncate8(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epu16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := 16*j
	IF b[i+15:i] == 0
		#DE
	FI
	dst[i+15:i] := Truncate16(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epu32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	IF b[i+31:i] == 0
		#DE
	FI
	dst[i+31:i] := Truncate32(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_div_epu64">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	IF b[i+63:i] == 0
		#DE
	FI
	dst[i+63:i] := Truncate64(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_idiv_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_irem_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epi8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Divide packed 8-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Divide packed 16-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed 32-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epi64">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Divide packed 64-bit integers in "a" by packed elements in "b", and store the remainders as packed 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 1
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Divide packed unsigned 8-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 15
	i := 8*j
	dst[i+7:i] := REMAINDER(a[i+7:i] / b[i+7:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epu16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Divide packed unsigned 16-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 7
	i := 16*j
	dst[i+15:i] := REMAINDER(a[i+15:i] / b[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epu32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_rem_epu64">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Divide packed unsigned 64-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 1
	i := 64*j
	dst[i+63:i] := REMAINDER(a[i+63:i] / b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_udiv_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the truncated results in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := TRUNCATE(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SVML" sequence="TRUE" name="_mm_urem_epi32">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Divide packed unsigned 32-bit integers in "a" by packed elements in "b", and store the remainders as packed unsigned 32-bit integers in "dst".</description>
	<operation>FOR j := 0 to 3
	i := 32*j
	dst[i+31:i] := REMAINDER(a[i+31:i] / b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_add_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PADDB" form="xmm, xmm" xed="PADDB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_add_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PADDW" form="xmm, xmm" xed="PADDW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_add_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Add packed 32-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PADDD" form="xmm, xmm" xed="PADDD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" name="_mm_add_si64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Add 64-bit integers "a" and "b", and store the result in "dst".</description>
	<operation>
dst[63:0] := a[63:0] + b[63:0]
	</operation>
	<instruction name="PADDQ" form="mm, mm" xed="PADDQ_MMXq_MMXq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_add_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Add packed 64-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
	</operation>
	<instruction name="PADDQ" form="xmm, xmm" xed="PADDQ_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_adds_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDSB" form="xmm, xmm" xed="PADDSB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_adds_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDSW" form="xmm, xmm" xed="PADDSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_adds_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSB" form="xmm, xmm" xed="PADDUSB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_adds_epu16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
ENDFOR
	</operation>
	<instruction name="PADDUSW" form="xmm, xmm" xed="PADDUSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_avg_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Average packed unsigned 8-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := (a[i+7:i] + b[i+7:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGB" form="xmm, xmm" xed="PAVGB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_avg_epu16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Probability/Statistics</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Average packed unsigned 16-bit integers in "a" and "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := (a[i+15:i] + b[i+15:i] + 1) &gt;&gt; 1
ENDFOR
	</operation>
	<instruction name="PAVGW" form="xmm, xmm" xed="PAVGW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_madd_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Horizontally add adjacent pairs of intermediate 32-bit integers, and pack the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := SignExtend32(a[i+31:i+16]*b[i+31:i+16]) + SignExtend32(a[i+15:i]*b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMADDWD" form="xmm, xmm" xed="PMADDWD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_max_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMAXSW" form="xmm, xmm" xed="PMAXSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_max_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMAXUB" form="xmm, xmm" xed="PMAXUB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_min_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMINSW" form="xmm, xmm" xed="PMINSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_min_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed unsigned 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMINUB" form="xmm, xmm" xed="PMINUB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_mulhi_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply the packed signed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHW" form="xmm, xmm" xed="PMULHW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_mulhi_epu16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed unsigned 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the high 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := a[i+15:i] * b[i+15:i]
	dst[i+15:i] := tmp[31:16]
ENDFOR
	</operation>
	<instruction name="PMULHUW" form="xmm, xmm" xed="PMULHUW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_mullo_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Multiply the packed 16-bit integers in "a" and "b", producing intermediate 32-bit integers, and store the low 16 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])
	dst[i+15:i] := tmp[15:0]
ENDFOR
	</operation>
	<instruction name="PMULLW" form="xmm, xmm" xed="PMULLW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" name="_mm_mul_su32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI32" />
	<parameter type="__m64" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from "a" and "b", and store the unsigned 64-bit result in "dst".</description>
	<operation>
dst[63:0] := a[31:0] * b[31:0]
	</operation>
	<instruction name="PMULUDQ" form="mm, mm" xed="PMULUDQ_MMXq_MMXq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_mul_epu32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the low unsigned 32-bit integers from each packed 64-bit element in "a" and "b", and store the unsigned 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+31:i] * b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PMULUDQ" form="xmm, xmm" xed="PMULUDQ_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sub_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed 8-bit integers in "b" from packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[i+7:i] - b[i+7:i]
ENDFOR
	</operation>
	<instruction name="PSUBB" form="xmm, xmm" xed="PSUBB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sub_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed 16-bit integers in "b" from packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[i+15:i] - b[i+15:i]
ENDFOR
	</operation>
	<instruction name="PSUBW" form="xmm, xmm" xed="PSUBW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sub_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] - b[i+31:i]
ENDFOR
	</operation>
	<instruction name="PSUBD" form="xmm, xmm" xed="PSUBD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sub_si64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<parameter type="__m64" varname="b" etype="UI64" />
	<description>Subtract 64-bit integer "b" from 64-bit integer "a", and store the result in "dst".</description>
	<operation>
dst[63:0] := a[63:0] - b[63:0]
	</operation>
	<instruction name="PSUBQ" form="mm, mm" xed="PSUBQ_MMXq_MMXq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sub_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] - b[i+63:i]
ENDFOR
	</operation>
	<instruction name="PSUBQ" form="xmm, xmm" xed="PSUBQ_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_subs_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Subtract packed signed 8-bit integers in "b" from packed 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBSB" form="xmm, xmm" xed="PSUBSB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_subs_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Subtract packed signed 16-bit integers in "b" from packed 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate16(a[i+15:i] - b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PSUBSW" form="xmm, xmm" xed="PSUBSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_subs_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Subtract packed unsigned 8-bit integers in "b" from packed unsigned 8-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := SaturateU8(a[i+7:i] - b[i+7:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSB" form="xmm, xmm" xed="PSUBUSB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_subs_epu16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Subtract packed unsigned 16-bit integers in "b" from packed unsigned 16-bit integers in "a" using saturation, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := SaturateU16(a[i+15:i] - b[i+15:i])	
ENDFOR
	</operation>
	<instruction name="PSUBUSW" form="xmm, xmm" xed="PSUBUSW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="xmm, imm8" xed="PSLLW_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="xmm, xmm" xed="PSLLW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="xmm, imm8" xed="PSLLD_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="xmm, xmm" xed="PSLLD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLQ" form="xmm, imm8" xed="PSLLQ_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLQ" form="xmm, xmm" xed="PSLLQ_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srai_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="xmm, imm8" xed="PSRAW_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sra_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="xmm, xmm" xed="PSRAW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srai_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="xmm, imm8" xed="PSRAD_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sra_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="xmm, xmm" xed="PSRAD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="xmm, imm8" xed="PSRLW_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="count" etype="UI16" />
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="xmm, xmm" xed="PSRLW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="xmm, imm8" xed="PSRLD_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="count" etype="UI32" />
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="xmm, xmm" xed="PSRLD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLQ" form="xmm, imm8" xed="PSRLQ_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="count" etype="UI64" />
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLQ" form="xmm, xmm" xed="PSRLQ_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_and_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<description>Compute the bitwise AND of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[127:0] := (a[127:0] AND b[127:0])
	</operation>
	<instruction name="PAND" form="xmm, xmm" xed="PAND_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_andnot_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<description>Compute the bitwise NOT of 128 bits (representing integer data) in "a" and then AND with "b", and store the result in "dst".</description>
	<operation>
dst[127:0] := ((NOT a[127:0]) AND b[127:0])
	</operation>
	<instruction name="PANDN" form="xmm, xmm" xed="PANDN_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_or_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<description>Compute the bitwise OR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[127:0] := (a[127:0] OR b[127:0])
	</operation>
	<instruction name="POR" form="xmm, xmm" xed="POR_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_xor_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="M128" />
	<parameter type="__m128i" varname="a" etype="M128" />
	<parameter type="__m128i" varname="b" etype="M128" />
	<description>Compute the bitwise XOR of 128 bits (representing integer data) in "a" and "b", and store the result in "dst".</description>
	<operation>
dst[127:0] := (a[127:0] XOR b[127:0])
	</operation>
	<instruction name="PXOR" form="xmm, xmm" xed="PXOR_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpeq_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Compare packed 8-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] == b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQB" form="xmm, xmm" xed="PCMPEQB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpeq_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed 16-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] == b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQW" form="xmm, xmm" xed="PCMPEQW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpeq_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed 32-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] == b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQD" form="xmm, xmm" xed="PCMPEQD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpgt_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &gt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTB" form="xmm, xmm" xed="PCMPGTB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpgt_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &gt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTW" form="xmm, xmm" xed="PCMPGTW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmpgt_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &gt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTD" form="xmm, xmm" xed="PCMPGTD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmplt_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b" for less-than, and store the results in "dst". Note: This intrinsic emits the pcmpgtb instruction with the order of the operands switched.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ( a[i+7:i] &lt; b[i+7:i] ) ? 0xFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTB" form="xmm, xmm" xed="PCMPGTB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmplt_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Compare packed signed 16-bit integers in "a" and "b" for less-than, and store the results in "dst". Note: This intrinsic emits the pcmpgtw instruction with the order of the operands switched.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ( a[i+15:i] &lt; b[i+15:i] ) ? 0xFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTW" form="xmm, xmm" xed="PCMPGTW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cmplt_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b" for less-than, and store the results in "dst". Note: This intrinsic emits the pcmpgtd instruction with the order of the operands switched.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ( a[i+31:i] &lt; b[i+31:i] ) ? 0xFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTD" form="xmm, xmm" xed="PCMPGTD_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi32_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Copy 32-bit integer "a" to the lower elements of "dst", and zero the upper elements of "dst".</description>
	<operation>
dst[31:0] := a[31:0]
dst[127:32] := 0
	</operation>
	<instruction name="MOVD" form="xmm, r32" xed="MOVD_XMMdq_GPR32" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi64_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Copy 64-bit integer "a" to the lower element of "dst", and zero the upper element.</description>
	<operation>
dst[63:0] := a[63:0]
dst[127:64] := 0
	</operation>
	<instruction name="MOVQ" form="xmm, r64" xed="MOVQ_XMMdq_GPR64" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi64x_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Copy 64-bit integer "a" to the lower element of "dst", and zero the upper element.</description>
	<operation>
dst[63:0] := a[63:0]
dst[127:64] := 0
	</operation>
	<instruction name="MOVQ" form="xmm, r64" xed="MOVQ_XMMdq_GPR64" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi128_si32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Copy the lower 32-bit integer in "a" to "dst".</description>
	<operation>
dst[31:0] := a[31:0]
	</operation>
	<instruction name="MOVD" form="r32, xmm" xed="MOVD_GPR32_XMMd" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi128_si64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Copy the lower 64-bit integer in "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="r64, xmm" xed="MOVQ_GPR64_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_cvtsi128_si64x">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Convert</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Copy the lower 64-bit integer in "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVQ" form="r64, xmm" xed="MOVQ_GPR64_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" sequence="TRUE" name="_mm_set1_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
	</operation>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" sequence="TRUE" name="_mm_set1_epi64x">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__int64" varname="a" etype="UI64" />
	<description>Broadcast 64-bit integer "a" to all elements of "dst". This intrinsic may generate the "vpbroadcastq".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[63:0]
ENDFOR
	</operation>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" sequence="TRUE" name="_mm_set1_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="int" varname="a" etype="UI32" />
	<description>Broadcast 32-bit integer "a" to all elements of "dst". This intrinsic may generate "vpbroadcastd".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[31:0]
ENDFOR
	</operation>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" sequence="TRUE" name="_mm_set1_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="short" varname="a" etype="UI16" />
	<description>Broadcast 16-bit integer "a" to all all elements of "dst". This intrinsic may generate "vpbroadcastw".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[15:0]
ENDFOR
	</operation>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" sequence="TRUE" name="_mm_set1_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Set</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="char" varname="a" etype="UI8" />
	<description>Broadcast 8-bit integer "a" to all elements of "dst". This intrinsic may generate "vpbroadcastb".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[7:0]
ENDFOR
	</operation>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" name="_mm_movepi64_pi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="FP32" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Copy the lower 64-bit integer in "a" to "dst".</description>
	<operation>
dst[63:0] := a[63:0]
	</operation>
	<instruction name="MOVDQ2Q" form="mm, xmm" xed="MOVDQ2Q_MMXq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" name="_mm_movpi64_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m64" varname="a" etype="UI64" />
	<description>Copy the 64-bit integer "a" to the lower element of "dst", and zero the upper element.</description>
	<operation>
dst[63:0] := a[63:0]
dst[127:64] := 0
	</operation>
	<instruction name="MOVQ2DQ" form="xmm, mm" xed="MOVQ2DQ_XMMdq_MMXq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_move_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<description>Copy the lower 64-bit integer in "a" to the lower element of "dst", and zero the upper element.</description>
	<operation>
dst[63:0] := a[63:0]
dst[127:64] := 0
	</operation>
	<instruction name="MOVQ" form="xmm, xmm" xed="MOVQ_XMMdq_XMMq_0F7E" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_packs_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI8" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := Saturate8(a[15:0])
dst[15:8] := Saturate8(a[31:16])
dst[23:16] := Saturate8(a[47:32])
dst[31:24] := Saturate8(a[63:48])
dst[39:32] := Saturate8(a[79:64])
dst[47:40] := Saturate8(a[95:80])
dst[55:48] := Saturate8(a[111:96])
dst[63:56] := Saturate8(a[127:112])
dst[71:64] := Saturate8(b[15:0])
dst[79:72] := Saturate8(b[31:16])
dst[87:80] := Saturate8(b[47:32])
dst[95:88] := Saturate8(b[63:48])
dst[103:96] := Saturate8(b[79:64])
dst[111:104] := Saturate8(b[95:80])
dst[119:112] := Saturate8(b[111:96])
dst[127:120] := Saturate8(b[127:112])
	</operation>
	<instruction name="PACKSSWB" form="xmm, xmm" xed="PACKSSWB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_packs_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:0])
dst[31:16] := Saturate16(a[63:32])
dst[47:32] := Saturate16(a[95:64])
dst[63:48] := Saturate16(a[127:96])
dst[79:64] := Saturate16(b[31:0])
dst[95:80] := Saturate16(b[63:32])
dst[111:96] := Saturate16(b[95:64])
dst[127:112] := Saturate16(b[127:96])
	</operation>
	<instruction name="PACKSSDW" form="xmm, xmm" xed="PACKSSDW_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_packus_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[7:0] := SaturateU8(a[15:0])
dst[15:8] := SaturateU8(a[31:16])
dst[23:16] := SaturateU8(a[47:32])
dst[31:24] := SaturateU8(a[63:48])
dst[39:32] := SaturateU8(a[79:64])
dst[47:40] := SaturateU8(a[95:80])
dst[55:48] := SaturateU8(a[111:96])
dst[63:56] := SaturateU8(a[127:112])
dst[71:64] := SaturateU8(b[15:0])
dst[79:72] := SaturateU8(b[31:16])
dst[87:80] := SaturateU8(b[47:32])
dst[95:88] := SaturateU8(b[63:48])
dst[103:96] := SaturateU8(b[79:64])
dst[111:104] := SaturateU8(b[95:80])
dst[119:112] := SaturateU8(b[111:96])
dst[127:120] := SaturateU8(b[127:112])
	</operation>
	<instruction name="PACKUSWB" form="xmm, xmm" xed="PACKUSWB_XMMdq_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_extract_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="int" varname="imm8" etype="IMM" immwidth="3" />
	<description>Extract a 16-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[15:0] := (a[127:0] &gt;&gt; (imm8[2:0] * 16))[15:0]
dst[31:16] := 0
	</operation>
	<instruction name="PEXTRW" form="r32, xmm, imm8" xed="PEXTRW_GPR32_XMMdq_IMMb" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_movemask_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Miscellaneous</category>
	<return type="int" varname="dst" etype="MASK" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Create mask from the most significant bit of each 8-bit element in "a", and store the result in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[j] := a[i+7]
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="PMOVMSKB" form="r32, xmm" xed="PMOVMSKB_GPR32_XMMdq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpackhi_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[71:64] 
	dst[15:8] := src2[71:64] 
	dst[23:16] := src1[79:72] 
	dst[31:24] := src2[79:72] 
	dst[39:32] := src1[87:80] 
	dst[47:40] := src2[87:80] 
	dst[55:48] := src1[95:88] 
	dst[63:56] := src2[95:88] 
	dst[71:64] := src1[103:96] 
	dst[79:72] := src2[103:96] 
	dst[87:80] := src1[111:104] 
	dst[95:88] := src2[111:104] 
	dst[103:96] := src1[119:112] 
	dst[111:104] := src2[119:112] 
	dst[119:112] := src1[127:120] 
	dst[127:120] := src2[127:120] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_BYTES(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKHBW" form="xmm, xmm" xed="PUNPCKHBW_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpackhi_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[79:64]
	dst[31:16] := src2[79:64] 
	dst[47:32] := src1[95:80] 
	dst[63:48] := src2[95:80] 
	dst[79:64] := src1[111:96] 
	dst[95:80] := src2[111:96] 
	dst[111:96] := src1[127:112] 
	dst[127:112] := src2[127:112] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_HIGH_WORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKHWD" form="xmm, xmm" xed="PUNPCKHWD_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpackhi_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[95:64] 
	dst[63:32] := src2[95:64] 
	dst[95:64] := src1[127:96] 
	dst[127:96] := src2[127:96] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_DWORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKHDQ" form="xmm, xmm" xed="PUNPCKHDQ_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpackhi_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the high half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_HIGH_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[127:64] 
	dst[127:64] := src2[127:64] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_HIGH_QWORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKHQDQ" form="xmm, xmm" xed="PUNPCKHQDQ_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpacklo_epi8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<description>Unpack and interleave 8-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_BYTES(src1[127:0], src2[127:0]) {
	dst[7:0] := src1[7:0] 
	dst[15:8] := src2[7:0] 
	dst[23:16] := src1[15:8] 
	dst[31:24] := src2[15:8] 
	dst[39:32] := src1[23:16] 
	dst[47:40] := src2[23:16] 
	dst[55:48] := src1[31:24] 
	dst[63:56] := src2[31:24] 
	dst[71:64] := src1[39:32]
	dst[79:72] := src2[39:32] 
	dst[87:80] := src1[47:40] 
	dst[95:88] := src2[47:40] 
	dst[103:96] := src1[55:48] 
	dst[111:104] := src2[55:48] 
	dst[119:112] := src1[63:56] 
	dst[127:120] := src2[63:56] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_BYTES(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKLBW" form="xmm, xmm" xed="PUNPCKLBW_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpacklo_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Unpack and interleave 16-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_WORDS(src1[127:0], src2[127:0]) {
	dst[15:0] := src1[15:0] 
	dst[31:16] := src2[15:0] 
	dst[47:32] := src1[31:16] 
	dst[63:48] := src2[31:16] 
	dst[79:64] := src1[47:32] 
	dst[95:80] := src2[47:32] 
	dst[111:96] := src1[63:48] 
	dst[127:112] := src2[63:48] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_WORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKLWD" form="xmm, xmm" xed="PUNPCKLWD_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpacklo_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Unpack and interleave 32-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_DWORDS(src1[127:0], src2[127:0]) {
	dst[31:0] := src1[31:0] 
	dst[63:32] := src2[31:0] 
	dst[95:64] := src1[63:32] 
	dst[127:96] := src2[63:32] 
	RETURN dst[127:0]	
}
dst[127:0] := INTERLEAVE_DWORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKLDQ" form="xmm, xmm" xed="PUNPCKLDQ_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_unpacklo_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Unpack and interleave 64-bit integers from the low half of "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE INTERLEAVE_QWORDS(src1[127:0], src2[127:0]) {
	dst[63:0] := src1[63:0] 
	dst[127:64] := src2[63:0] 
	RETURN dst[127:0]
}
dst[127:0] := INTERLEAVE_QWORDS(a[127:0], b[127:0])
	</operation>
	<instruction name="PUNPCKLQDQ" form="xmm, xmm" xed="PUNPCKLQDQ_XMMdq_XMMq" />
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_blendv_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="UI8" />
	<parameter type="__m128i" varname="mask" etype="UI8" />
	<description>Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PBLENDVB" form="xmm, xmm" xed="PBLENDVB_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_blend_epi16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8" />
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PBLENDW" form="xmm, xmm, imm8" xed="PBLENDW_XMMdq_XMMdq_IMMb" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4" />
	<description>Extract an 8-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[7:0] := (a[127:0] &gt;&gt; (imm8[3:0] * 8))[7:0]
dst[31:8] := 0
	</operation>
	<instruction name="PEXTRB" form="r32, xmm, imm8" xed="PEXTRB_GPR32d_XMMdq_IMMb" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2" />
	<description>Extract a 32-bit integer from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
dst[31:0] := (a[127:0] &gt;&gt; (imm8[1:0] * 32))[31:0]
	</operation>
	<instruction name="PEXTRD" form="r32, xmm, imm8" xed="PEXTRD_GPR32d_XMMdq_IMMb" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__int64" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1" />
	<description>Extract a 64-bit integer from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[127:0] &gt;&gt; (imm8[0] * 64))[63:0]
	</operation>
	<instruction name="PEXTRQ" form="r64, xmm, imm8" xed="PEXTRQ_GPR64q_XMMdq_IMMb" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_max_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := MAX(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMAXSB" form="xmm, xmm" xed="PMAXSB_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_max_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
	</operation>
	<instruction name="PMAXSD" form="xmm, xmm" xed="PMAXSD_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_max_epu32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MAX(a[i+31:i], b[i+31:i])
ENDFOR
	</operation>
	<instruction name="PMAXUD" form="xmm, xmm" xed="PMAXUD_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_max_epu16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed maximum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := MAX(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMAXUW" form="xmm, xmm" xed="PMAXUW_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_min_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Compare packed signed 8-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := MIN(a[i+7:i], b[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMINSB" form="xmm, xmm" xed="PMINSB_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_min_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Compare packed signed 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
	</operation>
	<instruction name="PMINSD" form="xmm, xmm" xed="PMINSD_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_min_epu32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Compare packed unsigned 32-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := MIN(a[i+31:i], b[i+31:i])
ENDFOR
	</operation>
	<instruction name="PMINUD" form="xmm, xmm" xed="PMINUD_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_min_epu16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<parameter type="__m128i" varname="b" etype="UI16" />
	<description>Compare packed unsigned 16-bit integers in "a" and "b", and store packed minimum values in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := MIN(a[i+15:i], b[i+15:i])
ENDFOR
	</operation>
	<instruction name="PMINUW" form="xmm, xmm" xed="PMINUW_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_packus_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst".</description>
	<operation>
dst[15:0] := SaturateU16(a[31:0])
dst[31:16] := SaturateU16(a[63:32])
dst[47:32] := SaturateU16(a[95:64])
dst[63:48] := SaturateU16(a[127:96])
dst[79:64] := SaturateU16(b[31:0])
dst[95:80] := SaturateU16(b[63:32])
dst[111:96] := SaturateU16(b[95:64])
dst[127:112] := SaturateU16(b[127:96])
	</operation>
	<instruction name="PACKUSDW" form="xmm, xmm" xed="PACKUSDW_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cmpeq_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI64" />
	<parameter type="__m128i" varname="b" etype="UI64" />
	<description>Compare packed 64-bit integers in "a" and "b" for equality, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] == b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPEQQ" form="xmm, xmm" xed="PCMPEQQ_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi8_epi16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	dst[l+15:l] := SignExtend16(a[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMOVSXBW" form="xmm, xmm" xed="PMOVSXBW_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi8_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[i+31:i] := SignExtend32(a[k+7:k])
ENDFOR
	</operation>
	<instruction name="PMOVSXBD" form="xmm, xmm" xed="PMOVSXBD_XMMdq_XMMd" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi8_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Sign extend packed 8-bit integers in the low 8 bytes of "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[i+63:i] := SignExtend64(a[k+7:k])
ENDFOR
	</operation>
	<instruction name="PMOVSXBQ" form="xmm, xmm" xed="PMOVSXBQ_XMMdq_XMMw" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi16_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[i+31:i] := SignExtend32(a[k+15:k])
ENDFOR
	</operation>
	<instruction name="PMOVSXWD" form="xmm, xmm" xed="PMOVSXWD_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi16_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Sign extend packed 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[i+63:i] := SignExtend64(a[k+15:k])
ENDFOR
	</operation>
	<instruction name="PMOVSXWQ" form="xmm, xmm" xed="PMOVSXWQ_XMMdq_XMMd" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepi32_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Sign extend packed 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[i+63:i] := SignExtend64(a[k+31:k])
ENDFOR
	</operation>
	<instruction name="PMOVSXDQ" form="xmm, xmm" xed="PMOVSXDQ_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu8_epi16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 16-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	l := j*16
	dst[l+15:l] := ZeroExtend16(a[i+7:i])
ENDFOR
	</operation>
	<instruction name="PMOVZXBW" form="xmm, xmm" xed="PMOVZXBW_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu8_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 8*j
	dst[i+31:i] := ZeroExtend32(a[k+7:k])
ENDFOR
	</operation>
	<instruction name="PMOVZXBD" form="xmm, xmm" xed="PMOVZXBD_XMMdq_XMMd" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu8_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<description>Zero extend packed unsigned 8-bit integers in the low 8 byte sof "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 8*j
	dst[i+63:i] := ZeroExtend64(a[k+7:k])
ENDFOR
	</operation>
	<instruction name="PMOVZXBQ" form="xmm, xmm" xed="PMOVZXBQ_XMMdq_XMMw" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu16_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 32-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := 32*j
	k := 16*j
	dst[i+31:i] := ZeroExtend32(a[k+15:k])
ENDFOR
	</operation>
	<instruction name="PMOVZXWD" form="xmm, xmm" xed="PMOVZXWD_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu16_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI16" />
	<description>Zero extend packed unsigned 16-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 16*j
	dst[i+63:i] := ZeroExtend64(a[k+15:k])
ENDFOR
	</operation>
	<instruction name="PMOVZXWQ" form="xmm, xmm" xed="PMOVZXWQ_XMMdq_XMMd" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_cvtepu32_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Convert</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<description>Zero extend packed unsigned 32-bit integers in "a" to packed 64-bit integers, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := 64*j
	k := 32*j
	dst[i+63:i] := ZeroExtend64(a[k+31:k])
ENDFOR
	</operation>
	<instruction name="PMOVZXDQ" form="xmm, xmm" xed="PMOVZXDQ_XMMdq_XMMq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_mul_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI64" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Multiply the low signed 32-bit integers from each packed 64-bit element in "a" and "b", and store the signed 64-bit results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := SignExtend64(a[i+31:i]) * SignExtend64(b[i+31:i])
ENDFOR
	</operation>
	<instruction name="PMULDQ" form="xmm, xmm" xed="PMULDQ_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_mullo_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="UI32" />
	<parameter type="__m128i" varname="b" etype="UI32" />
	<description>Multiply the packed 32-bit integers in "a" and "b", producing intermediate 64-bit integers, and store the low 32 bits of the intermediate integers in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	tmp[63:0] := a[i+31:i] * b[i+31:i]
	dst[i+31:i] := tmp[31:0]
ENDFOR
	</operation>
	<instruction name="PMULLD" form="xmm, xmm" xed="PMULLD_XMMdq_XMMdq" />
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.2" vexEq="TRUE" name="_mm_cmpgt_epi64">
	<type>Integer</type>
	<CPUID>SSE4.2</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI64" />
	<parameter type="__m128i" varname="a" etype="SI64" />
	<parameter type="__m128i" varname="b" etype="SI64" />
	<description>Compare packed signed 64-bit integers in "a" and "b" for greater-than, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ( a[i+63:i] &gt; b[i+63:i] ) ? 0xFFFFFFFFFFFFFFFF : 0
ENDFOR
	</operation>
	<instruction name="PCMPGTQ" form="xmm, xmm" xed="PCMPGTQ_XMMdq_XMMdq" />
	<header>nmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_abs_pi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ABS(Int(a[i+7:i]))
ENDFOR
	</operation>
	<instruction name="PABSB" form="mm, mm" xed="PABSB_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_abs_epi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
	</operation>
	<instruction name="PABSB" form="xmm, xmm" xed="PABSB_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_abs_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ABS(Int(a[i+15:i]))
ENDFOR
	</operation>
	<instruction name="PABSW" form="mm, mm" xed="PABSW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_abs_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
	</operation>
	<instruction name="PABSW" form="xmm, xmm" xed="PABSW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_abs_pi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m64" varname="dst" etype="UI32" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
	</operation>
	<instruction name="PABSD" form="mm, mm" xed="PABSD_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_abs_epi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Special Math Functions</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<description>Compute the absolute value of packed signed 32-bit integers in "a", and store the unsigned results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
	</operation>
	<instruction name="PABSD" form="xmm, xmm" xed="PABSD_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hadd_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := a[95:80] + a[79:64]
dst[63:48] := a[127:112] + a[111:96]
dst[79:64] := b[31:16] + b[15:0]
dst[95:80] := b[63:48] + b[47:32]
dst[111:96] := b[95:80] + b[79:64]
dst[127:112] := b[127:112] + b[111:96]
	</operation>
	<instruction name="PHADDW" form="xmm, xmm" xed="PHADDW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hadds_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Horizontally add adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:16] + a[15:0])
dst[31:16] := Saturate16(a[63:48] + a[47:32])
dst[47:32] := Saturate16(a[95:80] + a[79:64])
dst[63:48] := Saturate16(a[127:112] + a[111:96])
dst[79:64] := Saturate16(b[31:16] + b[15:0])
dst[95:80] := Saturate16(b[63:48] + b[47:32])
dst[111:96] := Saturate16(b[95:80] + b[79:64])
dst[127:112] := Saturate16(b[127:112] + b[111:96])
	</operation>
	<instruction name="PHADDSW" form="xmm, xmm" xed="PHADDSW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hadd_epi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Horizontally add adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := a[127:96] + a[95:64]
dst[95:64] := b[63:32] + b[31:0]
dst[127:96] := b[127:96] + b[95:64]
	</operation>
	<instruction name="PHADDD" form="xmm, xmm" xed="PHADDD_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hadd_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Horizontally add adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[31:16] + a[15:0]
dst[31:16] := a[63:48] + a[47:32]
dst[47:32] := b[31:16] + b[15:0]
dst[63:48] := b[63:48] + b[47:32]
	</operation>
	<instruction name="PHADDW" form="mm, mm" xed="PHADDW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hadd_pi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI32" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Horizontally add adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[63:32] + a[31:0]
dst[63:32] := b[63:32] + b[31:0]
	</operation>
	<instruction name="PHADDW" form="mm, mm" xed="PHADDW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hadds_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Horizontally add adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[31:16] + a[15:0])
dst[31:16] := Saturate16(a[63:48] + a[47:32])
dst[47:32] := Saturate16(b[31:16] + b[15:0])
dst[63:48] := Saturate16(b[63:48] + b[47:32])
	</operation>
	<instruction name="PHADDSW" form="mm, mm" xed="PHADDSW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hsub_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := a[79:64] - a[95:80]
dst[63:48] := a[111:96] - a[127:112]
dst[79:64] := b[15:0] - b[31:16]
dst[95:80] := b[47:32] - b[63:48]
dst[111:96] := b[79:64] - b[95:80]
dst[127:112] := b[111:96] - b[127:112]
	</operation>
	<instruction name="PHSUBW" form="xmm, xmm" xed="PHSUBW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hsubs_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Horizontally subtract adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[15:0] - a[31:16])
dst[31:16] := Saturate16(a[47:32] - a[63:48])
dst[47:32] := Saturate16(a[79:64] - a[95:80])
dst[63:48] := Saturate16(a[111:96] - a[127:112])
dst[79:64] := Saturate16(b[15:0] - b[31:16])
dst[95:80] := Saturate16(b[47:32] - b[63:48])
dst[111:96] := Saturate16(b[79:64] - b[95:80])
dst[127:112] := Saturate16(b[111:96] - b[127:112])
	</operation>
	<instruction name="PHSUBSW" form="xmm, xmm" xed="PHSUBSW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_hsub_epi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Horizontally subtract adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := a[95:64] - a[127:96]
dst[95:64] := b[31:0] - b[63:32]
dst[127:96] := b[95:64] - b[127:96]
	</operation>
	<instruction name="PHSUBD" form="xmm, xmm" xed="PHSUBD_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hsub_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Horizontally subtract adjacent pairs of 16-bit integers in "a" and "b", and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := a[15:0] - a[31:16]
dst[31:16] := a[47:32] - a[63:48]
dst[47:32] := b[15:0] - b[31:16]
dst[63:48] := b[47:32] - b[63:48]
	</operation>
	<instruction name="PHSUBW" form="mm, mm" xed="PHSUBW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hsub_pi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI32" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Horizontally subtract adjacent pairs of 32-bit integers in "a" and "b", and pack the signed 32-bit results in "dst".</description>
	<operation>
dst[31:0] := a[31:0] - a[63:32]
dst[63:32] := b[31:0] - b[63:32]
	</operation>
	<instruction name="PHSUBD" form="mm, mm" xed="PHSUBD_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_hsubs_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Horizontally subtract adjacent pairs of signed 16-bit integers in "a" and "b" using saturation, and pack the signed 16-bit results in "dst".</description>
	<operation>
dst[15:0] := Saturate16(a[15:0] - a[31:16])
dst[31:16] := Saturate16(a[47:32] - a[63:48])
dst[47:32] := Saturate16(b[15:0] - b[31:16])
dst[63:48] := Saturate16(b[47:32] - b[63:48])
	</operation>
	<instruction name="PHSUBSW" form="mm, mm" xed="PHSUBSW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_maddubs_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI16" />
	<parameter type="__m128i" varname="a" etype="UI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PMADDUBSW" form="xmm, xmm" xed="PMADDUBSW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_maddubs_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="SI16" />
	<parameter type="__m64" varname="a" etype="UI8" />
	<parameter type="__m64" varname="b" etype="SI8" />
	<description>Vertically multiply each unsigned 8-bit integer from "a" with the corresponding signed 8-bit integer from "b", producing intermediate signed 16-bit integers. Horizontally add adjacent pairs of intermediate signed 16-bit integers, and pack the saturated results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := Saturate16( a[i+15:i+8]*b[i+15:i+8] + a[i+7:i]*b[i+7:i] )
ENDFOR
	</operation>
	<instruction name="PMADDUBSW" form="mm, mm" xed="PMADDUBSW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_mulhrs_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
	</operation>
	<instruction name="PMULHRSW" form="xmm, xmm" xed="PMULHRSW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_mulhrs_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Multiply packed signed 16-bit integers in "a" and "b", producing intermediate signed 32-bit integers. Truncate each intermediate integer to the 18 most significant bits, round by adding 1, and store bits [16:1] to "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	tmp[31:0] := ((SignExtend32(a[i+15:i]) * SignExtend32(b[i+15:i])) &gt;&gt; 14) + 1
	dst[i+15:i] := tmp[16:1]
ENDFOR
	</operation>
	<instruction name="PMULHRSW" form="mm, mm" xed="PMULHRSW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8" />
	<parameter type="__m128i" varname="a" etype="SI8" />
	<parameter type="__m128i" varname="b" etype="SI8" />
	<description>Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNB" form="xmm, xmm" xed="PSIGNB_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16" />
	<parameter type="__m128i" varname="a" etype="SI16" />
	<parameter type="__m128i" varname="b" etype="SI16" />
	<description>Negate packed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNW" form="xmm, xmm" xed="PSIGNW_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32" />
	<parameter type="__m128i" varname="a" etype="SI32" />
	<parameter type="__m128i" varname="b" etype="SI32" />
	<description>Negate packed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGND" form="xmm, xmm" xed="PSIGND_XMMdq_XMMdq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI8" />
	<parameter type="__m64" varname="a" etype="SI8" />
	<parameter type="__m64" varname="b" etype="SI8" />
	<description>Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNB" form="mm, mm" xed="PSIGNB_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI16" />
	<parameter type="__m64" varname="a" etype="SI16" />
	<parameter type="__m64" varname="b" etype="SI16" />
	<description>Negate packed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNW" form="mm, mm" xed="PSIGNW_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI32" />
	<parameter type="__m64" varname="a" etype="SI32" />
	<parameter type="__m64" varname="b" etype="SI32" />
	<description>Negate packed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGND" form="mm, mm" xed="PSIGND_MMXq_MMXq" />
	<header>tmmintrin.h</header>
</intrinsic>
</intrinsics_list>

