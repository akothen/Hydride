TAG:notice:asl
////////////////////////////////////////////////////////////////////////
// Proprietary Notice
//
//     This document is protected by copyright and other related rights
// and the practice or implementation of the information contained in
// this document may be protected by one or more patents or pending
// patent applications. No part of this document may be reproduced in any
// form by any means without the express prior written permission of
// Arm. No license, express or implied, by estoppel or otherwise to
// any intellectual property rights is granted by this document unless
// specifically stated.
//
//     Your access to the information in this document is conditional upon
// your acceptance that you will not use or permit others to use the
// information for the purposes of determining whether implementations
// infringe any third party patents.
//
//     THIS DOCUMENT IS PROVIDED "AS IS". ARM PROVIDES NO REPRESENTATIONS
// AND NO WARRANTIES, EXPRESS, IMPLIED OR STATUTORY, INCLUDING, WITHOUT
// LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
// QUALITY, NON-INFRINGEMENT OR FITNESS FOR A PARTICULAR PURPOSE WITH
// RESPECT TO THE DOCUMENT. For the avoidance of doubt, Arm makes no
// representation with respect to, and has undertaken no analysis to
// identify or understand the scope and content of, patents, copyrights,
// trade secrets, or other rights.
//
//     This document may include technical inaccuracies or typographical
// errors.
//
//     TO THE EXTENT NOT PROHIBITED BY LAW, IN NO EVENT WILL ARM BE
// LIABLE FOR ANY DAMAGES, INCLUDING WITHOUT LIMITATION ANY DIRECT,
// INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL DAMAGES,
// HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF LIABILITY, ARISING OUT
// OF ANY USE OF THIS DOCUMENT, EVEN IF ARM HAS BEEN ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGES.
//
//     This document consists solely of commercial items. You shall be
// responsible for ensuring that any use, duplication or disclosure of
// this document complies fully with any relevant export laws and
// regulations to assure that this document or any portion thereof is not
// exported, directly or indirectly, in violation of such export
// laws. Use of the word "partner" in reference to Arm's customers is not
// intended to create or refer to any partnership relationship with any
// other company. Arm may make changes to this document at any time and
// without notice.
//
//     If any of the provisions contained in these terms conflict with
// any of the provisions of any click through or signed written agreement
// covering this document with Arm, then the click through or signed
// written agreement prevails over and supersedes the conflicting
// provisions of these terms. This document may be translated into other
// languages for convenience, and you agree that if there is any conflict
// between the English version of this document and any translation, the
// terms of the English version of the Agreement shall prevail.
//
//     The Arm corporate logo and words marked with (R) or (TM)(TM)
// are registered trademarks or trademarks of Arm Limited (or its
// subsidiaries) in the US and/or elsewhere. All rights reserved.  Other
// brands and names mentioned in this document may be the trademarks of
// their respective owners. Please follow Arm's trademark usage
// guidelines at
// http://www.arm.com/company/policies/trademarks.
//
//     Copyright (C) 2019 Arm Limited (or its affiliates). All rights reserved.
//
//     Arm Limited. Company 02557590 registered in England.
//
//     110 Fulbourn Road, Cambridge, England CB1 9NJ.
//
//     LES-PRE-20349
////////////////////////////////////////////////////////////////////////
TAG:aarch32/USUB8/A:execute
diff1 = UInt(R[n][7:0]) - UInt(R[m][7:0]);
diff2 = UInt(R[n][15:8]) - UInt(R[m][15:8]);
diff3 = UInt(R[n][23:16]) - UInt(R[m][23:16]);
diff4 = UInt(R[n][31:24]) - UInt(R[m][31:24]);
R[d][7:0]   = diff1[7:0];
R[d][15:8]  = diff2[7:0];
R[d][23:16] = diff3[7:0];
R[d][31:24] = diff4[7:0];
PSTATE.GE[0]  = if diff1 >= 0 then '1' else '0';
PSTATE.GE[1]  = if diff2 >= 0 then '1' else '0';
PSTATE.GE[2]  = if diff3 >= 0 then '1' else '0';
PSTATE.GE[3]  = if diff4 >= 0 then '1' else '0';
TAG:aarch32/USUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/USUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/USUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/USUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USUB8/A:index
Execute: aarch32/USUB8/A:execute
Decode: aarch32/USUB8/A1_A:decode@aarch32/USUB8/A1_A:diagram
Decode: aarch32/USUB8/T1_A:decode@aarch32/USUB8/T1_A:diagram
TAG:aarch32/VFMAL/A:execute
CheckAdvSIMDEnabled();
bits(datasize) operand1 ;
bits(datasize) operand2 ;
bits(64) operand3;
bits(64) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;

if Q=='0' then
    operand1 = S[n][datasize-1:0];
    operand2 = S[m][datasize-1:0];
else
    operand1 = D[n][datasize-1:0];
    operand2 = D[m][datasize-1:0];
for r = 0 to regs-1
    operand3 = D[d+r];
    for e = 0 to 1
        element1 = Elem[operand1, 2*r+e, esize DIV 2];
        element2 = Elem[operand2, 2*r+e, esize DIV 2];
        if sub_op then element1 = FPNeg(element1);
        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
    D[d+r] = result;
TAG:aarch32/VFMAL/A1_A:diagram
A32
31:25 _ 1111110
24:24 _ 0
23:23 S 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMAL/A1_A:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
if Q == '1' && Vd[0] == '1' then UNDEFINED;

integer d = UInt(D:Vd);
integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
integer esize = 32;
integer regs = if Q=='1' then 2 else 1;
integer datasize = if Q=='1' then 64 else 32;
boolean sub_op = S=='1';

TAG:aarch32/VFMAL/T1_A:diagram
T32
31:25 _ 1111110
24:24 _ 0
23:23 S 0
22:22 D x
21:20 op2 1x
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMAL/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
if Q == '1' && Vd[0] == '1' then UNDEFINED;

integer d = UInt(D:Vd);
integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
integer m = if Q == '1' then UInt(M:Vm) else UInt(Vm:M);
integer esize = 32;
integer regs = if Q=='1' then 2 else 1;
integer datasize = if Q=='1' then 64 else 32;
boolean sub_op = S=='1';

TAG:aarch32/VFMAL/A:index
Execute: aarch32/VFMAL/A:execute
Decode: aarch32/VFMAL/A1_A:decode@aarch32/VFMAL/A1_A:diagram
Decode: aarch32/VFMAL/T1_A:decode@aarch32/VFMAL/T1_A:diagram
TAG:aarch32/SUB_SP_i/A:execute
(result, nzcv) = AddWithCarry(SP, NOT(imm32), '1');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SUB_SP_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 010
20:20 S x
19:16 _ 1101
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/SUB_SP_i/A1_A:decode
d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/SUB_SP_i/T1_A:diagram
T16
31:24 _ 10110000
23:23 _ 1
22:16 imm7 xxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/SUB_SP_i/T1_A:decode
d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

TAG:aarch32/SUB_SP_i/T2_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1101
20:20 S x
19:16 _ 1101
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/SUB_SP_i/T2_A:decode
if Rd == '1111' && S == '1' then SEE "CMP (immediate)";
d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if d == 15 && !setflags then UNPREDICTABLE;

TAG:aarch32/SUB_SP_i/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 _ 1101
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/SUB_SP_i/T3_A:decode
d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE;

TAG:aarch32/SUB_SP_i/A:index
Execute: aarch32/SUB_SP_i/A:execute
Decode: aarch32/SUB_SP_i/A1_A:decode@aarch32/SUB_SP_i/A1_A:diagram
Decode: aarch32/SUB_SP_i/T1_A:decode@aarch32/SUB_SP_i/T1_A:diagram
Decode: aarch32/SUB_SP_i/T2_A:decode@aarch32/SUB_SP_i/T2_A:diagram
Decode: aarch32/SUB_SP_i/T3_A:decode@aarch32/SUB_SP_i/T3_A:diagram
TAG:aarch32/STRB_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,1] = R[t][7:0];
    if wback then R[n] = offset_addr;
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,1] = R[t][7:0];
    if wback then R[n] = offset_addr;
TAG:aarch32/STRB_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STRB_i/A1_A:decode
if P == '0' && W == '1' then SEE "STRBT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STRB_i/T1_A:diagram
T16
31:29 _ 011
28:28 _ 1
27:27 _ 0
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STRB_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/STRB_i/T2_A:diagram
T32
31:23 _ 111110001
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STRB_i/T2_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRB_i/T3_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/STRB_i/T3_A:decode
if P == '1' && U == '1' && W == '0' then SEE "STRBT";
if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRB_i/A:index
Execute: aarch32/STRB_i/A:execute
Decode: aarch32/STRB_i/A1_A:decode@aarch32/STRB_i/A1_A:diagram
Decode: aarch32/STRB_i/T1_A:decode@aarch32/STRB_i/T1_A:diagram
Decode: aarch32/STRB_i/T2_A:decode@aarch32/STRB_i/T2_A:diagram
Decode: aarch32/STRB_i/T3_A:decode@aarch32/STRB_i/T3_A:diagram
TAG:aarch32/MSR_i/AS:execute
if write_spsr then
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;
    else
        SPSRWriteByInstr(imm32, mask);
else
    // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
    CPSRWriteByInstr(imm32, mask);
TAG:aarch32/MSR_i/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 R x
21:20 _ 10
19:16 mask xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/MSR_i/A1_AS:decode
if mask == '0000' && R == '0' then SEE "Related encodings";
imm32 = A32ExpandImm(imm12);  write_spsr = (R == '1');
if mask == '0000' then UNPREDICTABLE;

TAG:aarch32/MSR_i/AS:index
Execute: aarch32/MSR_i/AS:execute
Decode: aarch32/MSR_i/A1_AS:decode@aarch32/MSR_i/A1_AS:diagram
TAG:aarch32/LDRB_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    R[t] = ZeroExtend(MemU[address,1], 32);
    if wback then R[n] = offset_addr;
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    R[t] = ZeroExtend(MemU[address,1], 32);
    if wback then R[n] = offset_addr;
TAG:aarch32/LDRB_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRB_i/A1_A:decode
if Rn == '1111' then SEE "LDRB (literal)";
if P == '0' && W == '1' then SEE "LDRBT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE;

TAG:aarch32/LDRB_i/T1_A:diagram
T16
31:29 _ 011
28:28 _ 1
27:27 _ 1
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRB_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5, 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/LDRB_i/T2_A:diagram
T32
31:23 _ 111110001
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRB_i/T2_A:decode
if Rt == '1111' then SEE "PLD";
if Rn == '1111' then SEE "LDRB (literal)";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRB_i/T3_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRB_i/T3_A:decode
if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLD, PLDW (immediate)";
if Rn == '1111' then SEE "LDRB (literal)";
if P == '1' && U == '1' && W == '0' then SEE "LDRBT";
if P == '0' && W == '0' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if  (t == 15 &&  W == '1') || (wback && n == t) then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRB_i/A:index
Execute: aarch32/LDRB_i/A:execute
Decode: aarch32/LDRB_i/A1_A:decode@aarch32/LDRB_i/A1_A:diagram
Decode: aarch32/LDRB_i/T1_A:decode@aarch32/LDRB_i/T1_A:diagram
Decode: aarch32/LDRB_i/T2_A:decode@aarch32/LDRB_i/T2_A:diagram
Decode: aarch32/LDRB_i/T3_A:decode@aarch32/LDRB_i/T3_A:diagram
TAG:aarch32/VADD_f/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            Elem[D[d+r],e,esize] = FPAdd(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize],
                                         StandardFPSCRValue());
else             // VFP instruction
    case esize of
        when 16
            S[d] = Zeros(16) : FPAdd(S[n][15:0], S[m][15:0], FPSCR);
        when 32
            S[d] = FPAdd(S[n], S[m], FPSCR);
        when 64
            D[d] = FPAdd(D[n], D[m], FPSCR);
TAG:aarch32/VADD_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADD_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VADD_f/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADD_f/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VADD_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADD_f/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VADD_f/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADD_f/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VADD_f/A:index
Execute: aarch32/VADD_f/A:execute
Decode: aarch32/VADD_f/A1_A:decode@aarch32/VADD_f/A1_A:diagram
Decode: aarch32/VADD_f/A2_A:decode@aarch32/VADD_f/A2_A:diagram
Decode: aarch32/VADD_f/T1_A:decode@aarch32/VADD_f/T1_A:diagram
Decode: aarch32/VADD_f/T2_A:decode@aarch32/VADD_f/T2_A:diagram
TAG:aarch32/QSUB16/A:execute
diff1 = SInt(R[n][15:0]) - SInt(R[m][15:0]);
diff2 = SInt(R[n][31:16]) - SInt(R[m][31:16]);
R[d][15:0]  = SignedSat(diff1, 16);
R[d][31:16] = SignedSat(diff2, 16);
TAG:aarch32/QSUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QSUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QSUB16/A:index
Execute: aarch32/QSUB16/A:execute
Decode: aarch32/QSUB16/A1_A:decode@aarch32/QSUB16/A1_A:diagram
Decode: aarch32/QSUB16/T1_A:decode@aarch32/QSUB16/T1_A:diagram
TAG:aarch32/AESIMC/A:execute
CheckCryptoEnabled32();
Q[d>>1] = AESInvMixColumns(Q[m>>1]);
TAG:aarch32/AESIMC/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESIMC/A1_A:decode
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESIMC/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESIMC/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESIMC/A:index
Execute: aarch32/AESIMC/A:execute
Decode: aarch32/AESIMC/A1_A:decode@aarch32/AESIMC/A1_A:diagram
Decode: aarch32/AESIMC/T1_A:decode@aarch32/AESIMC/T1_A:diagram
TAG:aarch32/VSEL/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        S[d] = Zeros(16) : (if ConditionHolds(cond) then S[n] else S[m])[15:0];
    when 32
        S[d] = if ConditionHolds(cond) then S[n] else S[m];
    when 64
        D[d] = if ConditionHolds(cond) then D[n] else D[m];
TAG:aarch32/VSEL/A1_A:diagram
A32
31:23 _ 111111100
22:22 D x
21:20 cc xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSEL/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
cond = cc:(cc[1] EOR cc[0]):'0';

TAG:aarch32/VSEL/T1_A:diagram
T32
31:23 _ 111111100
22:22 D x
21:20 cc xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSEL/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
cond = cc:(cc[1] EOR cc[0]):'0';

TAG:aarch32/VSEL/A:index
Execute: aarch32/VSEL/A:execute
Decode: aarch32/VSEL/A1_A:decode@aarch32/VSEL/A1_A:diagram
Decode: aarch32/VSEL/T1_A:decode@aarch32/VSEL/T1_A:diagram
TAG:aarch32/UQSUB16/A:execute
diff1 = UInt(R[n][15:0]) - UInt(R[m][15:0]);
diff2 = UInt(R[n][31:16]) - UInt(R[m][31:16]);
R[d][15:0]  = UnsignedSat(diff1, 16);
R[d][31:16] = UnsignedSat(diff2, 16);
TAG:aarch32/UQSUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQSUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQSUB16/A:index
Execute: aarch32/UQSUB16/A:execute
Decode: aarch32/UQSUB16/A1_A:decode@aarch32/UQSUB16/A1_A:diagram
Decode: aarch32/UQSUB16/T1_A:decode@aarch32/UQSUB16/T1_A:diagram
TAG:aarch32/VEXT/A:execute
CheckAdvSIMDEnabled();
if quadword_operation then
    Q[d>>1] = (Q[m>>1]:Q[n>>1])[position+127:position];
else
    D[d] = (D[m]:D[n])[position+63:position];
TAG:aarch32/VEXT/T1A1_A:diagram
A32
31:23 _ 111100101
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:8 imm4 xxxx
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VEXT/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if Q == '0' && imm4[3] == '1' then UNDEFINED;
quadword_operation = (Q == '1');  position = 8 * UInt(imm4);
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VEXT/A:index
Execute: aarch32/VEXT/A:execute
Decode: aarch32/VEXT/T1A1_A:decode@aarch32/VEXT/T1A1_A:diagram
Decode: aarch32/VEXT/T1A1_A:decode@aarch32/VEXT/T1A1_A:diagram
TAG:aarch32/CMN_i/A:execute
(result, nzcv) = AddWithCarry(R[n], imm32, '0');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMN_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/CMN_i/A1_A:decode
n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

TAG:aarch32/CMN_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1000
20:20 _ 1
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 _ 1111
7:0 imm8 xxxxxxxx
TAG:aarch32/CMN_i/T1_A:decode
n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/CMN_i/A:index
Execute: aarch32/CMN_i/A:execute
Decode: aarch32/CMN_i/A1_A:decode@aarch32/CMN_i/A1_A:diagram
Decode: aarch32/CMN_i/T1_A:decode@aarch32/CMN_i/T1_A:diagram
TAG:aarch32/VMLA_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        product = Int(Elem[Din[n+r],e,esize],unsigned) * Int(Elem[Din[m+r],e,esize],unsigned);
        addend = if add then product else -product;
        if long_destination then
            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
        else
            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;
TAG:aarch32/VMLA_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 op 0
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_i/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
add = (op == '0');  long_destination = FALSE;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMLA_i/A:index
Execute: aarch32/VMLA_i/A:execute
Decode: aarch32/VMLA_i/T1A1_A:decode@aarch32/VMLA_i/T1A1_A:diagram
Decode: aarch32/VMLA_i/T1A1_A:decode@aarch32/VMLA_i/T1A1_A:diagram
TAG:aarch32/USAX/A:execute
sum  = UInt(R[n][15:0]) + UInt(R[m][31:16]);
diff = UInt(R[n][31:16]) - UInt(R[m][15:0]);
R[d][15:0]  = sum[15:0];
R[d][31:16] = diff[15:0];
PSTATE.GE[1:0] = if sum  >= 0x10000 then '11' else '00';
PSTATE.GE[3:2] = if diff >= 0 then '11' else '00';
TAG:aarch32/USAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/USAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/USAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/USAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USAX/A:index
Execute: aarch32/USAX/A:execute
Decode: aarch32/USAX/A1_A:decode@aarch32/USAX/A1_A:diagram
Decode: aarch32/USAX/T1_A:decode@aarch32/USAX/T1_A:diagram
TAG:aarch32/SHA1SU0/A:execute
CheckCryptoEnabled32();
op1 = Q[d>>1]; op2 = Q[n>>1]; op3 = Q[m>>1];
op2 = op2[63:0] : op1[127:64];
Q[d>>1] = op1 EOR op2 EOR op3;
TAG:aarch32/SHA1SU0/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1SU0/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1SU0/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1SU0/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1SU0/A:index
Execute: aarch32/SHA1SU0/A:execute
Decode: aarch32/SHA1SU0/A1_A:decode@aarch32/SHA1SU0/A1_A:diagram
Decode: aarch32/SHA1SU0/T1_A:decode@aarch32/SHA1SU0/T1_A:diagram
TAG:aarch32/LDR_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    data = MemU[address,4];
    if wback then R[n] = offset_addr;
    if t == 15 then
        if address[1:0] == '00' then
            LoadWritePC(data);
        else
            UNPREDICTABLE;
    else
        R[t] = data;
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    data = MemU[address,4];
    if wback then R[n] = offset_addr;
    if t == 15 then
        if address[1:0] == '00' then
            LoadWritePC(data);
        else
            UNPREDICTABLE;
    else
        R[t] = data;
TAG:aarch32/LDR_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDR_i/A1_A:decode
if Rn == '1111' then SEE "LDR (literal)";
if P == '0' && W == '1' then SEE "LDRT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if wback && n == t then UNPREDICTABLE;

TAG:aarch32/LDR_i/T1_A:diagram
T16
31:29 _ 011
28:28 _ 0
27:27 _ 1
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDR_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/LDR_i/T2_A:diagram
T16
31:28 _ 1001
27:27 _ 1
26:24 Rt xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/LDR_i/T2_A:decode
t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/LDR_i/T3_A:diagram
T32
31:23 _ 111110001
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDR_i/T3_A:decode
if Rn == '1111' then SEE "LDR (literal)";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32); index = TRUE;  add = TRUE;
wback = FALSE; if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/LDR_i/T4_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/LDR_i/T4_A:decode
if Rn == '1111' then SEE "LDR (literal)";
if P == '1' && U == '1' && W == '0' then SEE "LDRT";
if P == '0' && W == '0' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);
imm32 = ZeroExtend(imm8, 32); index = (P == '1');  add = (U == '1');  wback = (W == '1');
if (wback && n == t) || (t == 15 && InITBlock() && !LastInITBlock()) then UNPREDICTABLE;

TAG:aarch32/LDR_i/A:index
Execute: aarch32/LDR_i/A:execute
Decode: aarch32/LDR_i/A1_A:decode@aarch32/LDR_i/A1_A:diagram
Decode: aarch32/LDR_i/T1_A:decode@aarch32/LDR_i/T1_A:diagram
Decode: aarch32/LDR_i/T2_A:decode@aarch32/LDR_i/T2_A:diagram
Decode: aarch32/LDR_i/T3_A:decode@aarch32/LDR_i/T3_A:diagram
Decode: aarch32/LDR_i/T4_A:decode@aarch32/LDR_i/T4_A:diagram
TAG:aarch32/VCVTA_asimd/A:execute
CheckAdvSIMDEnabled();
bits(esize) result;
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = FPToFixed(Elem[D[m+r],e,esize], 0, unsigned,
                                         StandardFPSCRValue(), rounding);
TAG:aarch32/VCVTA_asimd/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:10 _ 0
9:8 RM 11
7:7 op x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTA_asimd/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPDecodeRM(RM);  unsigned = (op == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVTA_asimd/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:10 _ 0
9:8 RM 11
7:7 op x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTA_asimd/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPDecodeRM(RM);  unsigned = (op == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVTA_asimd/A:index
Execute: aarch32/VCVTA_asimd/A:execute
Decode: aarch32/VCVTA_asimd/A1_A:decode@aarch32/VCVTA_asimd/A1_A:diagram
Decode: aarch32/VCVTA_asimd/T1_A:decode@aarch32/VCVTA_asimd/T1_A:diagram
TAG:aarch32/VMOV_d/A:execute
CheckVFPEnabled(TRUE);
if to_arm_registers then
    R[t] = D[m][31:0];
    R[t2] = D[m][63:32];
else
    D[m][31:0] = R[t];
    D[m][63:32] = R[t2];
TAG:aarch32/VMOV_d/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11000
22:22 _ 1
21:21 _ 0
20:20 op x
19:16 Rt2 xxxx
15:12 Rt xxxx
11:10 _ 10
9:8 _ 11
7:6 _ 00
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMOV_d/T1A1_A:decode
to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(M:Vm);
if t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if to_arm_registers && t == t2 then UNPREDICTABLE;

TAG:aarch32/VMOV_d/A:index
Execute: aarch32/VMOV_d/A:execute
Decode: aarch32/VMOV_d/T1A1_A:decode@aarch32/VMOV_d/T1A1_A:diagram
Decode: aarch32/VMOV_d/T1A1_A:decode@aarch32/VMOV_d/T1A1_A:diagram
TAG:aarch32/SMLAL/A:execute
result = SInt(R[n]) * SInt(R[m]) + SInt(R[dHi]:R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
if setflags then
    PSTATE.N = result[63];
    PSTATE.Z = IsZeroBit(result[63:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/SMLAL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 111
20:20 S x
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/SMLAL/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLAL/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 100
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:4 _ 0000
3:0 Rm xxxx
TAG:aarch32/SMLAL/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLAL/A:index
Execute: aarch32/SMLAL/A:execute
Decode: aarch32/SMLAL/A1_A:decode@aarch32/SMLAL/A1_A:diagram
Decode: aarch32/SMLAL/T1_A:decode@aarch32/SMLAL/T1_A:diagram
TAG:aarch32/LDMDA/A:execute
address = R[n] - 4*BitCount(registers) + 4;
for i = 0 to 14
    if registers[i] == '1' then
        R[i] = MemA[address,4];  address = address + 4;
if registers[15] == '1' then
    LoadWritePC(MemA[address,4]);
if wback && registers[n] == '0' then R[n] = R[n] - 4*BitCount(registers);
if wback && registers[n] == '1' then R[n] = bits(32) UNKNOWN;
TAG:aarch32/LDMDA/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 0
23:23 _ 0
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/LDMDA/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;

TAG:aarch32/LDMDA/A:index
Execute: aarch32/LDMDA/A:execute
Decode: aarch32/LDMDA/A1_A:decode@aarch32/LDMDA/A1_A:diagram
TAG:aarch32/VQSHL_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        shift = SInt(Elem[D[n+r],e,esize][7:0]);
        operand = Int(Elem[D[m+r],e,esize], unsigned);
        (result,sat) = SatQ(operand << shift, esize, unsigned);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQSHL_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQSHL_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQSHL_r/A:index
Execute: aarch32/VQSHL_r/A:execute
Decode: aarch32/VQSHL_r/T1A1_A:decode@aarch32/VQSHL_r/T1A1_A:diagram
Decode: aarch32/VQSHL_r/T1A1_A:decode@aarch32/VQSHL_r/T1A1_A:diagram
TAG:aarch32/SUB_SP_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(SP, NOT(shifted), '1');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SUB_SP_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 010
20:20 S x
19:16 _ 1101
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SUB_SP_r/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/SUB_SP_r/T1_A:diagram
T32
31:25 _ 1110101
24:21 _ 1101
20:20 S x
19:16 _ 1101
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/SUB_SP_r/T1_A:decode
if Rd == '1111' && S == '1' then SEE "CMP (register)";
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SUB_SP_r/A:index
Execute: aarch32/SUB_SP_r/A:execute
Decode: aarch32/SUB_SP_r/A1_A:decode@aarch32/SUB_SP_r/A1_A:diagram
Decode: aarch32/SUB_SP_r/T1_A:decode@aarch32/SUB_SP_r/T1_A:diagram
TAG:aarch32/VQRSHL/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        shift = SInt(Elem[D[n+r],e,esize][7:0]);
        round_const = 1 << (-1-shift); // 0 for left shift, 2^(n-1) for right shift
        operand = Int(Elem[D[m+r],e,esize], unsigned);
        (result, sat) = SatQ((operand + round_const) << shift, esize, unsigned);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQRSHL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRSHL/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRSHL/A:index
Execute: aarch32/VQRSHL/A:execute
Decode: aarch32/VQRSHL/T1A1_A:decode@aarch32/VQRSHL/T1A1_A:diagram
Decode: aarch32/VQRSHL/T1A1_A:decode@aarch32/VQRSHL/T1A1_A:diagram
TAG:aarch32/POP/A:execute
address = SP;
for i = 0 to 14
    if registers[i] == '1' then
        R[i] = if UnalignedAllowed then MemU[address,4] else MemA[address,4];
        address = address + 4;
if registers[15] == '1' then
    if UnalignedAllowed then
        if address[1:0] == '00' then
            LoadWritePC(MemU[address,4]);
        else
            UNPREDICTABLE;
    else
        LoadWritePC(MemA[address,4]);
if registers[13] == '0' then SP = SP + 4*BitCount(registers);
if registers[13] == '1' then SP = bits(32) UNKNOWN;
TAG:aarch32/POP/T1_A:diagram
T16
31:28 _ 1011
27:27 _ 1
26:25 _ 10
24:24 P x
23:16 register_list xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/POP/T1_A:decode
registers = P:'0000000':register_list;   UnalignedAllowed = FALSE;
if BitCount(registers) < 1 then UNPREDICTABLE;
if registers[15] == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/POP/A:index
Execute: aarch32/POP/A:execute
Decode: aarch32/POP/T1_A:decode@aarch32/POP/T1_A:diagram
TAG:aarch32/VDUP_r/A:execute
CheckAdvSIMDEnabled();
scalar = R[t][esize-1:0];
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = scalar;
TAG:aarch32/VDUP_r/T1A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 1
22:22 B x
21:21 Q x
20:20 _ 0
19:16 Vd xxxx
15:12 Rt xxxx
11:8 _ 1011
7:7 D x
6:6 _ 0
5:5 E x
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VDUP_r/T1A1_A:decode
if Q == '1' && Vd[0] == '1' then UNDEFINED;
d = UInt(D:Vd);  t = UInt(Rt);  regs = if Q == '0' then 1 else 2;
case B:E of
    when '00'  esize = 32;  elements = 2;
    when '01'  esize = 16;  elements = 4;
    when '10'  esize = 8;   elements = 8;
    when '11'  UNDEFINED;
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VDUP_r/A:index
Execute: aarch32/VDUP_r/A:execute
Decode: aarch32/VDUP_r/T1A1_A:decode@aarch32/VDUP_r/T1A1_A:diagram
Decode: aarch32/VDUP_r/T1A1_A:decode@aarch32/VDUP_r/T1A1_A:diagram
TAG:aarch32/MLA/A:execute
operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
result = operand1 * operand2 + addend;
R[d] = result[31:0];
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result[31:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/MLA/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 001
20:20 S x
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/MLA/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = (S == '1');
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

TAG:aarch32/MLA/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 000
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/MLA/T1_A:decode
if Ra == '1111' then SEE "MUL";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  setflags = FALSE;
if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MLA/A:index
Execute: aarch32/MLA/A:execute
Decode: aarch32/MLA/A1_A:decode@aarch32/MLA/A1_A:diagram
Decode: aarch32/MLA/T1_A:decode@aarch32/MLA/T1_A:diagram
TAG:aarch32/SSUB8/A:execute
diff1 = SInt(R[n][7:0]) - SInt(R[m][7:0]);
diff2 = SInt(R[n][15:8]) - SInt(R[m][15:8]);
diff3 = SInt(R[n][23:16]) - SInt(R[m][23:16]);
diff4 = SInt(R[n][31:24]) - SInt(R[m][31:24]);
R[d][7:0]   = diff1[7:0];
R[d][15:8]  = diff2[7:0];
R[d][23:16] = diff3[7:0];
R[d][31:24] = diff4[7:0];
PSTATE.GE[0]  = if diff1 >= 0 then '1' else '0';
PSTATE.GE[1]  = if diff2 >= 0 then '1' else '0';
PSTATE.GE[2]  = if diff3 >= 0 then '1' else '0';
PSTATE.GE[3]  = if diff4 >= 0 then '1' else '0';
TAG:aarch32/SSUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SSUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SSUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SSUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SSUB8/A:index
Execute: aarch32/SSUB8/A:execute
Decode: aarch32/SSUB8/A1_A:decode@aarch32/SSUB8/A1_A:diagram
Decode: aarch32/SSUB8/T1_A:decode@aarch32/SSUB8/T1_A:diagram
TAG:aarch32/MMLA/A:execute
CheckAdvSIMDEnabled();
bits(128) operand1 = Q[n>>1];
bits(128) operand2 = Q[m>>1];
bits(128) addend   = Q[d>>1];

Q[d>>1] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);
TAG:aarch32/MMLA/A1_A:diagram
A32
31:25 _ 1111110
24:24 _ 0
23:23 B 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 _ 1
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/MMLA/A1_A:decode
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
case B:U of
    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
    when '11' UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);

TAG:aarch32/MMLA/T1_A:diagram
T32
31:25 _ 1111110
24:24 _ 0
23:23 B 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 _ 1
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/MMLA/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
case B:U of
    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
    when '11' UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);

TAG:aarch32/MMLA/A:index
Execute: aarch32/MMLA/A:execute
Decode: aarch32/MMLA/A1_A:decode@aarch32/MMLA/A1_A:diagram
Decode: aarch32/MMLA/T1_A:decode@aarch32/MMLA/T1_A:diagram
TAG:aarch32/WFE/A:execute
if IsEventRegisterSet() then
    ClearEventRegister();
else
    if PSTATE.EL == EL0 then
        // Check for traps described by the OS which may be EL1 or EL2.
        AArch32.CheckForWFxTrap(EL1, TRUE);
    if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
        // Check for traps described by the Hypervisor.
        AArch32.CheckForWFxTrap(EL2, TRUE);
    if HaveEL(EL3) && PSTATE.M != M32_Monitor then
        // Check for traps described by the Secure Monitor.
        AArch32.CheckForWFxTrap(EL3, TRUE);
    WaitForEvent();
TAG:aarch32/WFE/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000010
TAG:aarch32/WFE/A1_A:decode
// No additional decoding required

TAG:aarch32/WFE/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0010
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/WFE/T1_A:decode
// No additional decoding required

TAG:aarch32/WFE/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0010
TAG:aarch32/WFE/T2_A:decode
// No additional decoding required

TAG:aarch32/WFE/A:index
Execute: aarch32/WFE/A:execute
Decode: aarch32/WFE/A1_A:decode@aarch32/WFE/A1_A:diagram
Decode: aarch32/WFE/T1_A:decode@aarch32/WFE/T1_A:diagram
Decode: aarch32/WFE/T2_A:decode@aarch32/WFE/T2_A:diagram
TAG:aarch32/VBIF/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    case operation of
        when VBitOps_VBIF  D[d+r] = (D[d+r] AND D[m+r]) OR (D[n+r] AND NOT(D[m+r]));
        when VBitOps_VBIT  D[d+r] = (D[n+r] AND D[m+r]) OR (D[d+r] AND NOT(D[m+r]));
        when VBitOps_VBSL  D[d+r] = (D[n+r] AND D[d+r]) OR (D[m+r] AND NOT(D[d+r]));
TAG:aarch32/VBIF/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 op 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VBIF/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if op == '00' then SEE "VEOR";
if op == '01' then operation = VBitOps_VBSL;
if op == '10' then operation = VBitOps_VBIT;
if op == '11' then operation = VBitOps_VBIF;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VBIF/A:index
Execute: aarch32/VBIF/A:execute
Decode: aarch32/VBIF/T1A1_A:decode@aarch32/VBIF/T1A1_A:diagram
Decode: aarch32/VBIF/T1A1_A:decode@aarch32/VBIF/T1A1_A:diagram
TAG:aarch32/ERET/AS:execute
if !Halted() then
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;                        // UNDEFINED or NOP
    else
        new_pc_value = if PSTATE.EL == EL2 then ELR_hyp else R[14];
        AArch32.ExceptionReturn(new_pc_value, SPSR[]);
else                                          // Perform DRPS operation in Debug state
    if PSTATE.M == M32_User then
        UNDEFINED;
    elsif PSTATE.M == M32_System then
        UNPREDICTABLE;                        // UNDEFINED or NOP
    else
        SynchronizeContext();
        SetPSTATEFromPSR(SPSR[]);
        // PSTATE.{N,Z,C,V,Q,GE,SS,A,I,F} are not observable and ignored in Debug state, so
        // behave as if UNKNOWN.
        PSTATE.[N,Z,C,V,Q,GE,SS,A,I,F] = bits(13) UNKNOWN;
        // In AArch32 Debug state, all instructions are T32 and unconditional.
        PSTATE.IT = '00000000';  PSTATE.T = '1';        // PSTATE.J is RES0
        DLR = bits(32) UNKNOWN;  DSPSR = bits(32) UNKNOWN;
        UpdateEDSCRFields();                  // Update EDSCR PE state flags
TAG:aarch32/ERET/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 00010110
19:19 _ (0)
18:18 _ (0)
17:17 _ (0)
16:16 _ (0)
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0110
3:3 _ (1)
2:2 _ (1)
1:1 _ (1)
0:0 _ (0)
TAG:aarch32/ERET/A1_A:decode
// No additional decoding required

TAG:aarch32/ERET/T1_A:diagram
T32
31:20 _ 111100111101
19:16 _ 1110
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:0 _ 00000000
TAG:aarch32/ERET/T1_A:decode
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/ERET/AS:index
Execute: aarch32/ERET/AS:execute
Decode: aarch32/ERET/A1_A:decode@aarch32/ERET/A1_A:diagram
Decode: aarch32/ERET/T1_A:decode@aarch32/ERET/T1_A:diagram
TAG:aarch32/VQDMLSL/A:execute
CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
for e = 0 to elements-1
    if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
    op1 = SInt(Elem[Din[n],e,esize]);
    // The following only saturates if both op1 and op2 equal -(2^(esize-1))
    (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
    if add then
        result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
    else
        result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
    (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
    if sat1 || sat2 then FPSCR.QC = '1';
TAG:aarch32/VQDMLSL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:9 op 1
8:8 _ 1
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMLSL/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
add = (op == '0');
scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
esize = 8 << UInt(size);  elements = 64 DIV esize;

TAG:aarch32/VQDMLSL/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 0
10:10 op 1
9:8 _ 11
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMLSL/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
add = (op == '0');
scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQDMLSL/A:index
Execute: aarch32/VQDMLSL/A:execute
Decode: aarch32/VQDMLSL/T1A1_A:decode@aarch32/VQDMLSL/T1A1_A:diagram
Decode: aarch32/VQDMLSL/T2A2_A:decode@aarch32/VQDMLSL/T2A2_A:diagram
Decode: aarch32/VQDMLSL/T1A1_A:decode@aarch32/VQDMLSL/T1A1_A:diagram
Decode: aarch32/VQDMLSL/T2A2_A:decode@aarch32/VQDMLSL/T2A2_A:diagram
TAG:aarch32/QSUB/A:execute
(R[d], sat) = SignedSatQ(SInt(R[m]) - SInt(R[n]), 32);
if sat then
    PSTATE.Q = '1';
TAG:aarch32/QSUB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0101
3:0 Rm xxxx
TAG:aarch32/QSUB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QSUB/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 10
3:0 Rm xxxx
TAG:aarch32/QSUB/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QSUB/A:index
Execute: aarch32/QSUB/A:execute
Decode: aarch32/QSUB/A1_A:decode@aarch32/QSUB/A1_A:diagram
Decode: aarch32/QSUB/T1_A:decode@aarch32/QSUB/T1_A:diagram
TAG:aarch32/SUB_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SUB_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 010
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SUB_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/SUB_rr/A:index
Execute: aarch32/SUB_rr/A:execute
Decode: aarch32/SUB_rr/A1_A:decode@aarch32/SUB_rr/A1_A:diagram
TAG:aarch32/SETEND/A:execute
AArch32.CheckSETENDEnabled();
PSTATE.E = if set_bigend then '1' else '0';
TAG:aarch32/SETEND/A1_A:diagram
A32
31:20 _ 111100010000
19:18 _ (0)(0)
17:17 _ (0)
16:16 _ 1
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:11 _ (0)
10:10 _ (0)
9:9 E x
8:8 _ (0)
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:0 _ 0(0)(0)(0)(0)
TAG:aarch32/SETEND/A1_A:decode
set_bigend = (E == '1');

TAG:aarch32/SETEND/T1_A:diagram
T16
31:22 _ 1011011001
21:21 _ 0
20:20 _ (1)
19:19 E x
18:16 _ (0)(0)(0)
15:0 _ 0000000000000000
TAG:aarch32/SETEND/T1_A:decode
set_bigend = (E == '1');
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/SETEND/A:index
Execute: aarch32/SETEND/A:execute
Decode: aarch32/SETEND/A1_A:decode@aarch32/SETEND/A1_A:diagram
Decode: aarch32/SETEND/T1_A:decode@aarch32/SETEND/T1_A:diagram
TAG:aarch32/SMLAD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 + product2 + SInt(R[a]);
R[d] = result[31:0];
if result != SInt(result[31:0]) then  // Signed overflow
    PSTATE.Q = '1';
TAG:aarch32/SMLAD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 000
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:6 _ 00
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMLAD/A1_A:decode
if Ra == '1111' then SEE "SMUAD";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMLAD/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 010
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLAD/T1_A:decode
if Ra == '1111' then SEE "SMUAD";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMLAD/A:index
Execute: aarch32/SMLAD/A:execute
Decode: aarch32/SMLAD/A1_A:decode@aarch32/SMLAD/A1_A:diagram
Decode: aarch32/SMLAD/T1_A:decode@aarch32/SMLAD/T1_A:diagram
TAG:aarch32/VCVT_ds/A:execute
CheckVFPEnabled(TRUE);
if double_to_single then
    S[d] = FPConvert(D[m], FPSCR);
else
    D[d] = FPConvert(S[m], FPSCR);
TAG:aarch32/VCVT_ds/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 111
15:12 Vd xxxx
11:10 _ 10
9:8 size 1x
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_ds/T1A1_A:decode
double_to_single = (size == '11');
d = if double_to_single then UInt(Vd:D) else UInt(D:Vd);
m = if double_to_single then UInt(M:Vm) else UInt(Vm:M);

TAG:aarch32/VCVT_ds/A:index
Execute: aarch32/VCVT_ds/A:execute
Decode: aarch32/VCVT_ds/T1A1_A:decode@aarch32/VCVT_ds/T1A1_A:diagram
Decode: aarch32/VCVT_ds/T1A1_A:decode@aarch32/VCVT_ds/T1A1_A:diagram
TAG:aarch32/VDOT_s/A:execute
bits(64) operand1;
bits(64) operand2 = D[m];
bits(64) result;
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    operand1 = D[n+r];
    result = D[d+r];
    integer element1, element2;
    for e = 0 to 1
        integer res = 0;
        for i = 0 to 3
            if signed then
                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
            else
                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
            res = res + element1 * element2;
        Elem[result, e, esize] = Elem[result, e, esize] + res;
    D[d+r] = result;
TAG:aarch32/VDOT_s/A1_A:diagram
A32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/VDOT_s/A1_A:decode
if !HaveDOTPExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
boolean signed = (U=='0');
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm[3:0]);
integer index = UInt(M);
integer esize = 32;
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_s/T1_A:diagram
T32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/VDOT_s/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveDOTPExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
boolean signed = (U=='0');
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm[3:0]);
integer index = UInt(M);
integer esize = 32;
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_s/A:index
Execute: aarch32/VDOT_s/A:execute
Decode: aarch32/VDOT_s/A1_A:decode@aarch32/VDOT_s/A1_A:diagram
Decode: aarch32/VDOT_s/T1_A:decode@aarch32/VDOT_s/T1_A:diagram
TAG:aarch32/STMDA/A:execute
address = R[n] - 4*BitCount(registers) + 4;
for i = 0 to 14
    if registers[i] == '1' then
        if i == n && wback && i != LowestSetBit(registers) then
            MemA[address,4] = bits(32) UNKNOWN;
        else
            MemA[address,4] = R[i];
        address = address + 4;
if registers[15] == '1' then
    MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] - 4*BitCount(registers);
TAG:aarch32/STMDA/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 0
23:23 _ 0
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/STMDA/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STMDA/A:index
Execute: aarch32/STMDA/A:execute
Decode: aarch32/STMDA/A1_A:decode@aarch32/STMDA/A1_A:diagram
TAG:aarch32/STRB_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
MemU[address,1] = R[t][7:0];
if wback then R[n] = offset_addr;
TAG:aarch32/STRB_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/STRB_r/A1_A:decode
if P == '0' && W == '1' then SEE "STRBT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STRB_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 0
26:26 _ 1
25:25 _ 0
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STRB_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/STRB_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/STRB_r/T2_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRB_r/A:index
Execute: aarch32/STRB_r/A:execute
Decode: aarch32/STRB_r/A1_A:decode@aarch32/STRB_r/A1_A:diagram
Decode: aarch32/STRB_r/T1_A:decode@aarch32/STRB_r/T1_A:diagram
Decode: aarch32/STRB_r/T2_A:decode@aarch32/STRB_r/T2_A:diagram
TAG:aarch32/SBFX/A:execute
msbit = lsbit + widthminus1;
if msbit <= 31 then
    R[d] = SignExtend(R[n][msbit:lsbit], 32);
else
    UNPREDICTABLE;
TAG:aarch32/SBFX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01111
22:22 _ 0
21:21 _ 1
20:16 widthm1 xxxxx
15:12 Rd xxxx
11:7 lsb xxxxx
6:4 _ 101
3:0 Rn xxxx
TAG:aarch32/SBFX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);
lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/SBFX/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 01
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 widthm1 xxxxx
TAG:aarch32/SBFX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);
lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SBFX/A:index
Execute: aarch32/SBFX/A:execute
Decode: aarch32/SBFX/A1_A:decode@aarch32/SBFX/A1_A:diagram
Decode: aarch32/SBFX/T1_A:decode@aarch32/SBFX/T1_A:diagram
TAG:aarch32/DSB/A:execute
case option of
    when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
    when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
    when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
    when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
    when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
    when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
    when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
    when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
    when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
    when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
    when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
    otherwise
        if       option == '0000' then SEE "SSBB";
        elsif    option == '0100' then SEE "PSSBB";
        else     domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;

if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then
    if HCR.BSU == '11' then
        domain = MBReqDomain_FullSystem;
    if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
        domain = MBReqDomain_OuterShareable;
    if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
        domain = MBReqDomain_InnerShareable;

DataSynchronizationBarrier(domain, types);
TAG:aarch32/DSB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0100
3:0 option xxxx
TAG:aarch32/DSB/A1_A:decode
// No additional decoding required

TAG:aarch32/DSB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0100
3:0 option xxxx
TAG:aarch32/DSB/T1_A:decode
// No additional decoding required

TAG:aarch32/DSB/A:index
Execute: aarch32/DSB/A:execute
Decode: aarch32/DSB/A1_A:decode@aarch32/DSB/A1_A:diagram
Decode: aarch32/DSB/T1_A:decode@aarch32/DSB/T1_A:diagram
TAG:aarch32/STR_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
if t == 15 then  // Only possible for encoding A1
    data = PCStoreValue();
else
    data = R[t];
MemU[address,4] = data;
if wback then R[n] = offset_addr;
TAG:aarch32/STR_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/STR_r/A1_A:decode
if P == '0' && W == '1' then SEE "STRT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STR_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 0
26:26 _ 0
25:25 _ 0
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STR_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/STR_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/STR_r/T2_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STR_r/A:index
Execute: aarch32/STR_r/A:execute
Decode: aarch32/STR_r/A1_A:decode@aarch32/STR_r/A1_A:diagram
Decode: aarch32/STR_r/T1_A:decode@aarch32/STR_r/T1_A:diagram
Decode: aarch32/STR_r/T2_A:decode@aarch32/STR_r/T2_A:diagram
TAG:aarch32/UHASX/A:execute
diff = UInt(R[n][15:0]) - UInt(R[m][31:16]);
sum  = UInt(R[n][31:16]) + UInt(R[m][15:0]);
R[d][15:0]  = diff[16:1];
R[d][31:16] = sum[16:1];
TAG:aarch32/UHASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHASX/A:index
Execute: aarch32/UHASX/A:execute
Decode: aarch32/UHASX/A1_A:decode@aarch32/UHASX/A1_A:diagram
Decode: aarch32/UHASX/T1_A:decode@aarch32/UHASX/T1_A:diagram
TAG:aarch32/SMMUL/A:execute
result = SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result[63:32];
TAG:aarch32/SMMUL/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 101
19:16 Rd xxxx
15:12 _ 1111
11:8 Rm xxxx
7:6 _ 00
5:5 R x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMMUL/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMMUL/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 R x
3:0 Rm xxxx
TAG:aarch32/SMMUL/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  round = (R == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMMUL/A:index
Execute: aarch32/SMMUL/A:execute
Decode: aarch32/SMMUL/A1_A:decode@aarch32/SMMUL/A1_A:diagram
Decode: aarch32/SMMUL/T1_A:decode@aarch32/SMMUL/T1_A:diagram
TAG:aarch32/UDIV/A:execute
if UInt(R[m]) == 0 then
    result = 0;
else
    result = RoundTowardsZero(Real(UInt(R[n])) / Real(UInt(R[m])));
R[d] = result[31:0];
TAG:aarch32/UDIV/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 011
19:16 Rd xxxx
15:12 Ra (1)(1)(1)(1)
11:8 Rm xxxx
7:5 _ 000
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/UDIV/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

TAG:aarch32/UDIV/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 011
19:16 Rn xxxx
15:12 Ra (1)(1)(1)(1)
11:8 Rd xxxx
7:4 _ 1111
3:0 Rm xxxx
TAG:aarch32/UDIV/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UDIV/A:index
Execute: aarch32/UDIV/A:execute
Decode: aarch32/UDIV/A1_A:decode@aarch32/UDIV/A1_A:diagram
Decode: aarch32/UDIV/T1_A:decode@aarch32/UDIV/T1_A:diagram
TAG:aarch32/LDMDB/A:execute
address = R[n] - 4*BitCount(registers);
for i = 0 to 14
    if registers[i] == '1' then
        R[i] = MemA[address,4];  address = address + 4;
if registers[15] == '1' then
    LoadWritePC(MemA[address,4]);
if wback && registers[n] == '0' then R[n] = R[n] - 4*BitCount(registers);
if wback && registers[n] == '1' then R[n] = bits(32) UNKNOWN;
TAG:aarch32/LDMDB/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 1
23:23 _ 0
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/LDMDB/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;

TAG:aarch32/LDMDB/T1_A:diagram
T32
31:25 _ 1110100
24:23 _ 10
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:15 P x
14:14 M x
13:0 register_list xxxxxxxxxxxxxx
TAG:aarch32/LDMDB/T1_A:decode
n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;
if registers[13] == '1' then UNPREDICTABLE;
if registers[15] == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/LDMDB/A:index
Execute: aarch32/LDMDB/A:execute
Decode: aarch32/LDMDB/A1_A:decode@aarch32/LDMDB/A1_A:diagram
Decode: aarch32/LDMDB/T1_A:decode@aarch32/LDMDB/T1_A:diagram
TAG:aarch32/VLDR/A:execute
CheckVFPEnabled(TRUE);
base = if n == 15 then Align(PC,4) else R[n];
address = if add then (base + imm32) else (base - imm32);
case esize of
    when 16
        S[d] = Zeros(16) : MemA[address,2];
    when 32
        S[d] = MemA[address,4];
    when 64
        word1 = MemA[address,4];  word2 = MemA[address+4,4];
        // Combine the word-aligned words in the correct order for current endianness.
        D[d] = if BigEndian() then word1:word2 else word2:word1;
TAG:aarch32/VLDR/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 _ 1
23:23 U x
22:22 D x
21:21 _ 0
20:20 _ 1
19:16 Rn 1111
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:0 imm8 xxxxxxxx
TAG:aarch32/VLDR/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
esize = 8 << UInt(size);  add = (U == '1');
imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
case size of
    when '01' d = UInt(Vd:D);
    when '10' d = UInt(Vd:D);
    when '11' d = UInt(D:Vd);
n = UInt(Rn);

TAG:aarch32/VLDR/T1_A:diagram
T32
31:25 _ 1110110
24:24 _ 1
23:23 U x
22:22 D x
21:21 _ 0
20:20 _ 1
19:16 Rn 1111
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:0 imm8 xxxxxxxx
TAG:aarch32/VLDR/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
esize = 8 << UInt(size);  add = (U == '1');
imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
case size of
    when '01' d = UInt(Vd:D);
    when '10' d = UInt(Vd:D);
    when '11' d = UInt(D:Vd);
n = UInt(Rn);

TAG:aarch32/VLDR/A:index
Execute: aarch32/VLDR/A:execute
Decode: aarch32/VLDR/A1_A:decode@aarch32/VLDR/A1_A:diagram
Decode: aarch32/VLDR/T1_A:decode@aarch32/VLDR/T1_A:diagram
TAG:aarch32/VMRS/AS:execute
if reg == '0001' then                 // FPSCR
    CheckVFPEnabled(TRUE);
    if t == 15 then
        PSTATE.[N,Z,C,V] = FPSR.[N,Z,C,V];
    else
        R[t] = FPSCR;
elsif PSTATE.EL == EL0 then
    UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
else
    CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
    AArch32.CheckAdvSIMDOrFPRegisterTraps(reg);
    case reg of
        when '0000'  R[t] = FPSID;
        when '0101'  R[t] = MVFR2;
        when '0110'  R[t] = MVFR1;
        when '0111'  R[t] = MVFR0;
        when '1000'  R[t] = FPEXC;
        otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode
TAG:aarch32/VMRS/T1A1_AS:diagram
A32
31:28 cond xxxx
27:21 _ 1110111
20:20 _ 1
19:16 reg xxxx
15:12 Rt xxxx
11:8 _ 1010
7:7 _ (0)
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMRS/T1A1_AS:decode
t = UInt(Rt);
if !(reg IN {'000x', '0101', '011x', '1000'}) then UNPREDICTABLE;
if t == 15 && reg != '0001' then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMRS/AS:index
Execute: aarch32/VMRS/AS:execute
Decode: aarch32/VMRS/T1A1_AS:decode@aarch32/VMRS/T1A1_AS:diagram
Decode: aarch32/VMRS/T1A1_AS:decode@aarch32/VMRS/T1A1_AS:diagram
TAG:aarch32/WFI/A:execute
if !InterruptPending() then
    if PSTATE.EL == EL0 then
        // Check for traps described by the OS which may be EL1 or EL2.
        AArch32.CheckForWFxTrap(EL1, FALSE);
    if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
        // Check for traps described by the Hypervisor.
        AArch32.CheckForWFxTrap(EL2, FALSE);
    if HaveEL(EL3) && PSTATE.M != M32_Monitor then
        // Check for traps described by the Secure Monitor.
        AArch32.CheckForWFxTrap(EL3, FALSE);
    WaitForInterrupt();
TAG:aarch32/WFI/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000011
TAG:aarch32/WFI/A1_A:decode
// No additional decoding required

TAG:aarch32/WFI/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0011
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/WFI/T1_A:decode
// No additional decoding required

TAG:aarch32/WFI/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0011
TAG:aarch32/WFI/T2_A:decode
// No additional decoding required

TAG:aarch32/WFI/A:index
Execute: aarch32/WFI/A:execute
Decode: aarch32/WFI/A1_A:decode@aarch32/WFI/A1_A:diagram
Decode: aarch32/WFI/T1_A:decode@aarch32/WFI/T1_A:diagram
Decode: aarch32/WFI/T2_A:decode@aarch32/WFI/T2_A:diagram
TAG:aarch32/VCVT_iv/A:execute
CheckVFPEnabled(TRUE);
if to_integer then
    case esize of
        when 16
            S[d] = FPToFixed(S[m][15:0], 0, unsigned, FPSCR, rounding);
        when 32
            S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
        when 64
            S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
else
    case esize of
        when 16
            bits(16) fp16 = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
            S[d] = Zeros(16):fp16;
        when 32
            S[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
        when 64
            D[d] = FixedToFP(S[m], 0, unsigned, FPSCR, rounding);
TAG:aarch32/VCVT_iv/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 1
18:16 opc2 10x
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_iv/A1_A:decode
if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
to_integer = (opc2[2] == '1');
if to_integer then
    unsigned = (opc2[0] == '0');
    rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
    d = UInt(Vd:D);
    case size of
        when '01' esize = 16; m = UInt(Vm:M);
        when '10' esize = 32; m = UInt(Vm:M);
        when '11' esize = 64; m = UInt(M:Vm);
else
    unsigned = (op == '0');
    rounding = FPRoundingMode(FPSCR);
    m = UInt(Vm:M);
    case size of
        when '01' esize = 16; d = UInt(Vd:D);
        when '10' esize = 32; d = UInt(Vd:D);
        when '11' esize = 64; d = UInt(D:Vd);

TAG:aarch32/VCVT_iv/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 1
18:16 opc2 10x
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_iv/T1_A:decode
if opc2 != '000' && opc2 != '10x' then SEE "Related encodings";
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
to_integer = (opc2[2] == '1');
if to_integer then
    unsigned = (opc2[0] == '0');
    rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
    d = UInt(Vd:D);
    case size of
        when '01' esize = 16; m = UInt(Vm:M);
        when '10' esize = 32; m = UInt(Vm:M);
        when '11' esize = 64; m = UInt(M:Vm);
else
    unsigned = (op == '0');
    rounding = FPRoundingMode(FPSCR);
    m = UInt(Vm:M);
    case size of
        when '01' esize = 16; d = UInt(Vd:D);
        when '10' esize = 32; d = UInt(Vd:D);
        when '11' esize = 64; d = UInt(D:Vd);

TAG:aarch32/VCVT_iv/A:index
Execute: aarch32/VCVT_iv/A:execute
Decode: aarch32/VCVT_iv/A1_A:decode@aarch32/VCVT_iv/A1_A:diagram
Decode: aarch32/VCVT_iv/T1_A:decode@aarch32/VCVT_iv/T1_A:diagram
TAG:aarch32/VRINTA_asimd/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[m+r],e,esize];
        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
        Elem[D[d+r],e,esize] = result;
TAG:aarch32/VRINTA_asimd/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:10 _ 1
9:7 op 010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTA_asimd/A1_A:decode
if op[2] != op[0] then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
// Rounding encoded differently from other VCVT and VRINT instructions
rounding = FPDecodeRM(op[2]:NOT(op[1]));  exact = FALSE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRINTA_asimd/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:10 _ 1
9:7 op 010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTA_asimd/T1_A:decode
if op[2] != op[0] then SEE "Related encodings";
if InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
// Rounding encoded differently from other VCVT and VRINT instructions
rounding = FPDecodeRM(op[2]:NOT(op[1]));  exact = FALSE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRINTA_asimd/A:index
Execute: aarch32/VRINTA_asimd/A:execute
Decode: aarch32/VRINTA_asimd/A1_A:decode@aarch32/VRINTA_asimd/A1_A:diagram
Decode: aarch32/VRINTA_asimd/T1_A:decode@aarch32/VRINTA_asimd/T1_A:diagram
TAG:aarch32/BKPT/A:execute
AArch32.SoftwareBreakpoint(imm16);
TAG:aarch32/BKPT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 0
19:8 imm12 xxxxxxxxxxxx
7:4 _ 0111
3:0 imm4 xxxx
TAG:aarch32/BKPT/A1_A:decode
imm16 = imm12:imm4;
if cond != '1110' then UNPREDICTABLE;  // BKPT must be encoded with AL condition

TAG:aarch32/BKPT/T1_A:diagram
T16
31:24 _ 10111110
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/BKPT/T1_A:decode
imm16 = ZeroExtend(imm8, 16);

TAG:aarch32/BKPT/A:index
Execute: aarch32/BKPT/A:execute
Decode: aarch32/BKPT/A1_A:decode@aarch32/BKPT/A1_A:diagram
Decode: aarch32/BKPT/T1_A:decode@aarch32/BKPT/T1_A:diagram
TAG:aarch32/VPMAX_f/A:execute
CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;

for e = 0 to h-1
    op1 = Elem[D[n],2*e,esize];  op2 = Elem[D[n],2*e+1,esize];
    Elem[dest,e,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());
    op1 = Elem[D[m],2*e,esize];  op2 = Elem[D[m],2*e+1,esize];
    Elem[dest,e+h,esize] = if maximum then FPMax(op1,op2,StandardFPSCRValue()) else FPMin(op1,op2,StandardFPSCRValue());

D[d] = dest;
TAG:aarch32/VPMAX_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPMAX_f/A1_A:decode
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
maximum = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPMAX_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPMAX_f/T1_A:decode
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
maximum = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPMAX_f/A:index
Execute: aarch32/VPMAX_f/A:execute
Decode: aarch32/VPMAX_f/A1_A:decode@aarch32/VPMAX_f/A1_A:diagram
Decode: aarch32/VPMAX_f/T1_A:decode@aarch32/VPMAX_f/T1_A:diagram
TAG:aarch32/PLD_l/A:execute
address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
Hint_PreloadData(address);
TAG:aarch32/PLD_l/A1_A:diagram
A32
31:25 _ 1111010
24:24 _ 1
23:23 U x
22:22 _ (1)
21:20 _ 01
19:16 _ 1111
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLD_l/A1_A:decode
imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

TAG:aarch32/PLD_l/T1_A:diagram
T32
31:24 _ 11111000
23:23 U x
22:22 _ 0
21:21 _ (0)
20:20 _ 1
19:16 _ 1111
15:12 _ 1111
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLD_l/T1_A:decode
imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

TAG:aarch32/PLD_l/A:index
Execute: aarch32/PLD_l/A:execute
Decode: aarch32/PLD_l/A1_A:decode@aarch32/PLD_l/A1_A:diagram
Decode: aarch32/PLD_l/T1_A:decode@aarch32/PLD_l/T1_A:diagram
TAG:aarch32/CBNZ/A:execute
if nonzero != IsZero(R[n]) then
    BranchWritePC(PC + imm32, BranchType_DIR);
TAG:aarch32/CBNZ/T1_A:diagram
T16
31:28 _ 1011
27:27 op x
26:26 _ 0
25:25 i x
24:24 _ 1
23:19 imm5 xxxxx
18:16 Rn xxx
15:0 _ 0000000000000000
TAG:aarch32/CBNZ/T1_A:decode
n = UInt(Rn);  imm32 = ZeroExtend(i:imm5:'0', 32);  nonzero = (op == '1');
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/CBNZ/A:index
Execute: aarch32/CBNZ/A:execute
Decode: aarch32/CBNZ/T1_A:decode@aarch32/CBNZ/T1_A:diagram
TAG:aarch32/ADR/A:execute
result = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
if d == 15 then          // Can only occur for A32 encodings
    ALUWritePC(result);
else
    R[d] = result;
TAG:aarch32/ADR/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 100
20:20 _ 0
19:16 _ 1111
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ADR/A1_A:decode
d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = TRUE;

TAG:aarch32/ADR/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 010
20:20 _ 0
19:16 _ 1111
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ADR/A2_A:decode
d = UInt(Rd);  imm32 = A32ExpandImm(imm12);  add = FALSE;

TAG:aarch32/ADR/T1_A:diagram
T16
31:28 _ 1010
27:27 _ 0
26:24 Rd xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/ADR/T1_A:decode
d = UInt(Rd);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

TAG:aarch32/ADR/T2_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 _ 1111
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADR/T2_A:decode
d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = FALSE;
if d == 15 then UNPREDICTABLE;     // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADR/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 0
22:22 _ 0
21:21 _ 0
20:20 _ 0
19:16 _ 1111
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADR/T3_A:decode
d = UInt(Rd);  imm32 = ZeroExtend(i:imm3:imm8, 32);  add = TRUE;
if d == 15 then UNPREDICTABLE;   // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADR/A:index
Execute: aarch32/ADR/A:execute
Decode: aarch32/ADR/A1_A:decode@aarch32/ADR/A1_A:diagram
Decode: aarch32/ADR/A2_A:decode@aarch32/ADR/A2_A:diagram
Decode: aarch32/ADR/T1_A:decode@aarch32/ADR/T1_A:diagram
Decode: aarch32/ADR/T2_A:decode@aarch32/ADR/T2_A:diagram
Decode: aarch32/ADR/T3_A:decode@aarch32/ADR/T3_A:diagram
TAG:aarch32/STC/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];

// System register read from DBGDTRRXint.
MemA[address,4] = DBGDTR_EL0[];

if wback then R[n] = offset_addr;
TAG:aarch32/STC/T1A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 _ 0101
11:9 _ 111
8:8 _ 0
7:0 imm8 xxxxxxxx
TAG:aarch32/STC/T1A1_A:decode
if P == '0' && U == '0' && W == '0' then UNDEFINED;
n = UInt(Rn);  cp = 14;
imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');
if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

TAG:aarch32/STC/A:index
Execute: aarch32/STC/A:execute
Decode: aarch32/STC/T1A1_A:decode@aarch32/STC/T1A1_A:diagram
Decode: aarch32/STC/T1A1_A:decode@aarch32/STC/T1A1_A:diagram
TAG:aarch32/VRINTA_vfp/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        S[d] = Zeros(16) : FPRoundInt(S[m][15:0], FPSCR, rounding, exact);
    when 32
        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
    when 64
        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);
TAG:aarch32/VRINTA_vfp/A1_A:diagram
A32
31:23 _ 111111101
22:22 D x
21:19 _ 111
18:18 _ 0
17:16 RM 10
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTA_vfp/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
rounding = FPDecodeRM(RM);  exact = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTA_vfp/T1_A:diagram
T32
31:23 _ 111111101
22:22 D x
21:19 _ 111
18:18 _ 0
17:16 RM 10
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTA_vfp/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
rounding = FPDecodeRM(RM);  exact = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTA_vfp/A:index
Execute: aarch32/VRINTA_vfp/A:execute
Decode: aarch32/VRINTA_vfp/A1_A:decode@aarch32/VRINTA_vfp/A1_A:diagram
Decode: aarch32/VRINTA_vfp/T1_A:decode@aarch32/VRINTA_vfp/T1_A:diagram
TAG:aarch32/CMP_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMP_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/CMP_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/CMP_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1010
21:19 Rm xxx
18:16 Rn xxx
15:0 _ 0000000000000000
TAG:aarch32/CMP_r/T1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/CMP_r/T2_A:diagram
T16
31:26 _ 010001
25:24 _ 01
23:23 N x
22:19 Rm xxxx
18:16 Rn xxx
15:0 _ 0000000000000000
TAG:aarch32/CMP_r/T2_A:decode
n = UInt(N:Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);
if n < 8 && m < 8 then UNPREDICTABLE;
if n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/CMP_r/T3_A:diagram
T32
31:25 _ 1110101
24:21 _ 1101
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 _ 1111
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/CMP_r/T3_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/CMP_r/A:index
Execute: aarch32/CMP_r/A:execute
Decode: aarch32/CMP_r/A1_A:decode@aarch32/CMP_r/A1_A:diagram
Decode: aarch32/CMP_r/T1_A:decode@aarch32/CMP_r/T1_A:diagram
Decode: aarch32/CMP_r/T2_A:decode@aarch32/CMP_r/T2_A:diagram
Decode: aarch32/CMP_r/T3_A:decode@aarch32/CMP_r/T3_A:diagram
TAG:aarch32/PLI_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
address = if add then (R[n] + offset) else (R[n] - offset);
Hint_PreloadInstr(address);
TAG:aarch32/PLI_r/A1_A:diagram
A32
31:25 _ 1111011
24:24 _ 0
23:23 U x
22:22 _ 1
21:20 _ 01
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/PLI_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if m == 15 then UNPREDICTABLE;

TAG:aarch32/PLI_r/T1_A:diagram
T32
31:23 _ 111110010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/PLI_r/T1_A:decode
if Rn == '1111' then SEE "PLI (immediate, literal)";
n = UInt(Rn);  m = UInt(Rm);  add = TRUE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/PLI_r/A:index
Execute: aarch32/PLI_r/A:execute
Decode: aarch32/PLI_r/A1_A:decode@aarch32/PLI_r/A1_A:diagram
Decode: aarch32/PLI_r/T1_A:decode@aarch32/PLI_r/T1_A:diagram
TAG:aarch32/VSHR/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
        Elem[D[d+r],e,esize] = result[esize-1:0];
TAG:aarch32/VSHR/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0000
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSHR/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSHR/A:index
Execute: aarch32/VSHR/A:execute
Decode: aarch32/VSHR/T1A1_A:decode@aarch32/VSHR/T1A1_A:diagram
Decode: aarch32/VSHR/T1A1_A:decode@aarch32/VSHR/T1A1_A:diagram
TAG:aarch32/BIC_i/A:execute
result = R[n] AND NOT(imm32);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/BIC_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00111
22:21 _ 10
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/BIC_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/BIC_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0001
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/BIC_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if d == 15 || n == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/BIC_i/A:index
Execute: aarch32/BIC_i/A:execute
Decode: aarch32/BIC_i/A1_A:decode@aarch32/BIC_i/A1_A:diagram
Decode: aarch32/BIC_i/T1_A:decode@aarch32/BIC_i/T1_A:diagram
TAG:aarch32/CLZ/A:execute
result = CountLeadingZeroBits(R[m]);
R[d] = result[31:0];
TAG:aarch32/CLZ/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 00010110
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0001
3:0 Rm xxxx
TAG:aarch32/CLZ/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/CLZ/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 011
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/CLZ/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/CLZ/A:index
Execute: aarch32/CLZ/A:execute
Decode: aarch32/CLZ/A1_A:decode@aarch32/CLZ/A1_A:diagram
Decode: aarch32/CLZ/T1_A:decode@aarch32/CLZ/T1_A:diagram
TAG:aarch32/LDAEXH/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address, 2);
R[t] = ZeroExtend(MemO[address, 2], 32);
TAG:aarch32/LDAEXH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXH/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 01
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXH/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXH/A:index
Execute: aarch32/LDAEXH/A:execute
Decode: aarch32/LDAEXH/A1_A:decode@aarch32/LDAEXH/A1_A:diagram
Decode: aarch32/LDAEXH/T1_A:decode@aarch32/LDAEXH/T1_A:diagram
TAG:aarch32/VDOT/A:execute
bits(64) operand1;
bits(64) operand2;
bits(64) result;
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    operand1 = D[n+r];
    operand2 = D[m+r];
    result = D[d+r];
    integer element1, element2;
    for e = 0 to 1
        integer res = 0;
        for i = 0 to 3
            if signed then
                element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
            else
                element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
                element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
            res = res + element1 * element2;
        Elem[result, e, esize] = Elem[result, e, esize] + res;
    D[d+r] = result;
TAG:aarch32/VDOT/A1_A:diagram
A32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/VDOT/A1_A:decode
if !HaveDOTPExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
boolean signed = U=='0';
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer esize = 32;
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT/T1_A:diagram
T32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/VDOT/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveDOTPExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
boolean signed = U=='0';
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer esize = 32;
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT/A:index
Execute: aarch32/VDOT/A:execute
Decode: aarch32/VDOT/A1_A:decode@aarch32/VDOT/A1_A:diagram
Decode: aarch32/VDOT/T1_A:decode@aarch32/VDOT/T1_A:diagram
TAG:aarch32/UMAAL/A:execute
result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]) + UInt(R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
TAG:aarch32/UMAAL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 010
20:20 _ 0
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/UMAAL/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMAAL/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 110
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:4 _ 0110
3:0 Rm xxxx
TAG:aarch32/UMAAL/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMAAL/A:index
Execute: aarch32/UMAAL/A:execute
Decode: aarch32/UMAAL/A1_A:decode@aarch32/UMAAL/A1_A:diagram
Decode: aarch32/UMAAL/T1_A:decode@aarch32/UMAAL/T1_A:diagram
TAG:aarch32/VMLA_f/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            product = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
            addend = if add then product else FPNeg(product);
            Elem[D[d+r],e,esize] = FPAdd(Elem[D[d+r],e,esize], addend, StandardFPSCRValue());
else             // VFP instruction
    case esize of
        when 16
            addend16 = if add then FPMul(S[n][15:0], S[m][15:0], FPSCR) else FPNeg(FPMul(S[n][15:0], S[m][15:0], FPSCR));
            S[d] = Zeros(16) : FPAdd(S[d][15:0], addend16, FPSCR);
        when 32
            addend32 = if add then FPMul(S[n], S[m], FPSCR) else FPNeg(FPMul(S[n], S[m], FPSCR));
            S[d] = FPAdd(S[d], addend32, FPSCR);
        when 64
            addend64 = if add then FPMul(D[n], D[m], FPSCR) else FPNeg(FPMul(D[n], D[m], FPSCR));
            D[d] = FPAdd(D[d], addend64, FPSCR);
TAG:aarch32/VMLA_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMLA_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE;  add = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMLA_f/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_f/A2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
advsimd = FALSE; add = (op == '0');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMLA_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMLA_f/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
advsimd = TRUE;  add = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMLA_f/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_f/T2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
advsimd = FALSE; add = (op == '0');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMLA_f/A:index
Execute: aarch32/VMLA_f/A:execute
Decode: aarch32/VMLA_f/A1_A:decode@aarch32/VMLA_f/A1_A:diagram
Decode: aarch32/VMLA_f/A2_A:decode@aarch32/VMLA_f/A2_A:diagram
Decode: aarch32/VMLA_f/T1_A:decode@aarch32/VMLA_f/T1_A:diagram
Decode: aarch32/VMLA_f/T2_A:decode@aarch32/VMLA_f/T2_A:diagram
TAG:aarch32/RSC_i/A:execute
(result, nzcv) = AddWithCarry(NOT(R[n]), imm32, PSTATE.C);
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSC_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 111
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/RSC_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/RSC_i/A:index
Execute: aarch32/RSC_i/A:execute
Decode: aarch32/RSC_i/A1_A:decode@aarch32/RSC_i/A1_A:diagram
TAG:aarch32/SXTAB/A:execute
rotated = ROR(R[m], rotation);
R[d] = R[n] + SignExtend(rotated[7:0], 32);
TAG:aarch32/SXTAB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 10
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTAB/A1_A:decode
if Rn == '1111' then SEE "SXTB";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTAB/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTAB/T1_A:decode
if Rn == '1111' then SEE "SXTB";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTAB/A:index
Execute: aarch32/SXTAB/A:execute
Decode: aarch32/SXTAB/A1_A:decode@aarch32/SXTAB/A1_A:diagram
Decode: aarch32/SXTAB/T1_A:decode@aarch32/SXTAB/T1_A:diagram
TAG:aarch32/VPMAX_i/A:execute
CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;

for e = 0 to h-1
    op1 = Int(Elem[D[n],2*e,esize], unsigned);
    op2 = Int(Elem[D[n],2*e+1,esize], unsigned);
    result = if maximum then Max(op1,op2) else Min(op1,op2);
    Elem[dest,e,esize] = result[esize-1:0];
    op1 = Int(Elem[D[m],2*e,esize], unsigned);
    op2 = Int(Elem[D[m],2*e+1,esize], unsigned);
    result = if maximum then Max(op1,op2) else Min(op1,op2);
    Elem[dest,e+h,esize] = result[esize-1:0];

D[d] = dest;
TAG:aarch32/VPMAX_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1010
7:7 N x
6:6 _ 0
5:5 M x
4:4 op 0
3:0 Vm xxxx
TAG:aarch32/VPMAX_i/T1A1_A:decode
if size == '11' then UNDEFINED;
maximum = (op == '0');  unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPMAX_i/A:index
Execute: aarch32/VPMAX_i/A:execute
Decode: aarch32/VPMAX_i/T1A1_A:decode@aarch32/VPMAX_i/T1A1_A:diagram
Decode: aarch32/VPMAX_i/T1A1_A:decode@aarch32/VPMAX_i/T1A1_A:diagram
TAG:aarch32/BIC_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND NOT(shifted);
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/BIC_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/BIC_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/BIC_rr/A:index
Execute: aarch32/BIC_rr/A:execute
Decode: aarch32/BIC_rr/A1_A:decode@aarch32/BIC_rr/A1_A:diagram
TAG:aarch32/LDRSH_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
R[t] = SignExtend(data, 32);
TAG:aarch32/LDRSH_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRSH_r/A1_A:decode
if P == '0' && W == '1' then SEE "LDRSHT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/LDRSH_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 1
26:26 _ 1
25:25 _ 1
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRSH_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/LDRSH_r/T2_A:diagram
T32
31:23 _ 111110010
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/LDRSH_r/T2_A:decode
if Rn == '1111' then SEE "LDRSH (literal)";
if Rt == '1111' then SEE "Related instructions";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSH_r/A:index
Execute: aarch32/LDRSH_r/A:execute
Decode: aarch32/LDRSH_r/A1_A:decode@aarch32/LDRSH_r/A1_A:diagram
Decode: aarch32/LDRSH_r/T1_A:decode@aarch32/LDRSH_r/T1_A:diagram
Decode: aarch32/LDRSH_r/T2_A:decode@aarch32/LDRSH_r/T2_A:diagram
TAG:aarch32/DCPS3/A:execute
if !Halted() || EDSCR.SDD == '1' then UNDEFINED;

if ELUsingAArch32(EL3) then
    from_secure = IsSecure();
    if PSTATE.M == M32_Monitor then SCR.NS = '0';
    AArch32.WriteMode(M32_Monitor);
    if HavePANExt() then
        if !from_secure then
            PSTATE.PAN = '0';
        elsif SCTLR.SPAN == '0' then
            PSTATE.PAN = '1';
    PSTATE.E = SCTLR.EE;

    LR_mon = bits(32) UNKNOWN;
    SPSR_mon = bits(32) UNKNOWN;

    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
else                                        // Targeting EL3 using AArch64
    AArch64.MaybeZeroRegisterUppers();
    MaybeZeroSVEUppers(EL3);
    PSTATE.nRW = '0';
    PSTATE.SP = '1';
    PSTATE.EL = EL3;
    if HaveUAOExt() then PSTATE.UAO = '0';

    ELR_EL3 = bits(64) UNKNOWN;
    ESR_EL3 = bits(32) UNKNOWN;
    SPSR_EL3 = bits(32) UNKNOWN;

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    sync_errors = HaveIESB() && SCTLR_EL3.IESB == '1';
    if HaveDoubleFaultExt() && SCR_EL3.EA == '1' && SCR_EL3.NMEA == '1' then
        sync_errors = TRUE;
    // SCTLR_EL3.IESB might be ignored in Debug state.
    if !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then
        sync_errors = FALSE;
    if sync_errors then SynchronizeErrors();

UpdateEDSCRFields();                        // Update EDSCR PE state flags
TAG:aarch32/DCPS3/T1_A:diagram
T32
31:20 _ 111101111000
19:16 _ 1111
15:12 _ 1000
11:2 _ 0000000000
1:0 _ 11
TAG:aarch32/DCPS3/T1_A:decode
if !HaveEL(EL3) then UNDEFINED;

TAG:aarch32/DCPS3/A:index
Execute: aarch32/DCPS3/A:execute
Decode: aarch32/DCPS3/T1_A:decode@aarch32/DCPS3/T1_A:diagram
TAG:aarch32/MSR_br/AS:execute
if PSTATE.EL == EL0 then
    UNPREDICTABLE;
else
    mode = PSTATE.M;
    if write_spsr then
        SPSRaccessValid(SYSm, mode);             // Check for UNPREDICTABLE cases
        case SYSm of
            when '01110'  SPSR_fiq = R[n];
            when '10000'  SPSR_irq = R[n];
            when '10010'  SPSR_svc = R[n];
            when '10100'  SPSR_abt = R[n];
            when '10110'  SPSR_und = R[n];
            when '11100'
                if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                SPSR_mon = R[n];
            when '11110'  SPSR_hyp = R[n];
    else
        BankedRegisterAccessValid(SYSm, mode);  // Check for UNPREDICTABLE cases
        case SYSm of
            when '00xxx'                       // Access the User mode registers
                m = UInt(SYSm[2:0]) + 8;
                Rmode[m,M32_User] = R[n];
            when '01xxx'                       // Access the FIQ mode registers
                m = UInt(SYSm[2:0]) + 8;
                Rmode[m,M32_FIQ] = R[n];
            when '1000x'                       // Access the IRQ mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                Rmode[m,M32_IRQ] = R[n];
            when '1001x'                       // Access the Supervisor mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                Rmode[m,M32_Svc] = R[n];
            when '1010x'                       // Access the Abort mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                Rmode[m,M32_Abort] = R[n];
            when '1011x'                       // Access the Undefined mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                Rmode[m,M32_Undef] = R[n];
            when '1110x'                       // Access Monitor registers
                if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                Rmode[m,M32_Monitor] = R[n];
            when '11110'                       // Access ELR_hyp register
                ELR_hyp = R[n];
            when '11111'                       // Access SP_hyp register
                Rmode[13,M32_Hyp] = R[n];
TAG:aarch32/MSR_br/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:22 R x
21:21 _ 1
20:20 _ 0
19:16 M1 xxxx
15:12 _ (1)(1)(1)(1)
11:11 _ (0)
10:10 _ (0)
9:9 _ 1
8:8 M x
7:4 _ 0000
3:0 Rn xxxx
TAG:aarch32/MSR_br/A1_AS:decode
n = UInt(Rn);  write_spsr = (R == '1');
if n == 15 then UNPREDICTABLE;
SYSm = M:M1;

TAG:aarch32/MSR_br/T1_AS:diagram
T32
31:21 _ 11110011100
20:20 R x
19:16 Rn xxxx
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:8 M1 xxxx
7:7 _ (0)
6:6 _ (0)
5:5 _ 1
4:4 M x
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/MSR_br/T1_AS:decode
n = UInt(Rn);  write_spsr = (R == '1');
if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
SYSm = M:M1;

TAG:aarch32/MSR_br/AS:index
Execute: aarch32/MSR_br/AS:execute
Decode: aarch32/MSR_br/A1_AS:decode@aarch32/MSR_br/A1_AS:diagram
Decode: aarch32/MSR_br/T1_AS:decode@aarch32/MSR_br/T1_AS:diagram
TAG:aarch32/BLX_r/A:execute
target = R[m];
if CurrentInstrSet() == InstrSet_A32 then
    next_instr_addr = PC - 4;
    LR = next_instr_addr;
else
    next_instr_addr = PC - 2;
    LR = next_instr_addr[31:1] : '1';
BXWritePC(target, BranchType_INDCALL);
TAG:aarch32/BLX_r/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 00010010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0011
3:0 Rm xxxx
TAG:aarch32/BLX_r/A1_A:decode
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;

TAG:aarch32/BLX_r/T1_A:diagram
T16
31:24 _ 01000111
23:23 _ 1
22:19 Rm xxxx
18:18 _ (0)
17:17 _ (0)
16:16 _ (0)
15:0 _ 0000000000000000
TAG:aarch32/BLX_r/T1_A:decode
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/BLX_r/A:index
Execute: aarch32/BLX_r/A:execute
Decode: aarch32/BLX_r/A1_A:decode@aarch32/BLX_r/A1_A:diagram
Decode: aarch32/BLX_r/T1_A:decode@aarch32/BLX_r/T1_A:diagram
TAG:aarch32/SXTAB16/A:execute
rotated = ROR(R[m], rotation);
R[d][15:0]  = R[n][15:0] + SignExtend(rotated[7:0], 16);
R[d][31:16] = R[n][31:16] + SignExtend(rotated[23:16], 16);
TAG:aarch32/SXTAB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 00
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTAB16/A1_A:decode
if Rn == '1111' then SEE "SXTB16";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTAB16/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTAB16/T1_A:decode
if Rn == '1111' then SEE "SXTB16";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTAB16/A:index
Execute: aarch32/SXTAB16/A:execute
Decode: aarch32/SXTAB16/A1_A:decode@aarch32/SXTAB16/A1_A:diagram
Decode: aarch32/SXTAB16/T1_A:decode@aarch32/SXTAB16/T1_A:diagram
TAG:aarch32/VRINTX_vfp/A:execute
CheckVFPEnabled(TRUE);
rounding = FPRoundingMode(FPSCR);
case esize of
    when 16
        S[d] = Zeros(16) : FPRoundInt(S[m][15:0], FPSCR, rounding, exact);
    when 32
        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
    when 64
        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);
TAG:aarch32/VRINTX_vfp/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 111
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTX_vfp/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
exact = TRUE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTX_vfp/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 111
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTX_vfp/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
exact = TRUE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTX_vfp/A:index
Execute: aarch32/VRINTX_vfp/A:execute
Decode: aarch32/VRINTX_vfp/A1_A:decode@aarch32/VRINTX_vfp/A1_A:diagram
Decode: aarch32/VRINTX_vfp/T1_A:decode@aarch32/VRINTX_vfp/T1_A:diagram
TAG:aarch32/VMLA_s/A:execute
CheckAdvSIMDEnabled();
op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
        if floating_point then
            fp_addend = if add then FPMul(op1,op2,StandardFPSCRValue()) else FPNeg(FPMul(op1,op2,StandardFPSCRValue()));
            Elem[D[d+r],e,esize] = FPAdd(Elem[Din[d+r],e,esize], fp_addend, StandardFPSCRValue());
        else
            addend = if add then op1val*op2val else -op1val*op2val;
            if long_destination then
                Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + addend;
            else
                Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + addend;
TAG:aarch32/VMLA_s/A1_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 0
10:10 op 1
9:9 _ 0
8:8 F x
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_s/A1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VMLA_s/T1_A:diagram
T32
31:29 _ 111
28:28 Q x
27:23 _ 11111
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 0
10:10 op 1
9:9 _ 0
8:8 F x
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_s/T1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
add = (op == '0');  floating_point = (F == '1');  long_destination = FALSE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VMLA_s/A:index
Execute: aarch32/VMLA_s/A:execute
Decode: aarch32/VMLA_s/A1_A:decode@aarch32/VMLA_s/A1_A:diagram
Decode: aarch32/VMLA_s/T1_A:decode@aarch32/VMLA_s/T1_A:diagram
TAG:aarch32/VCNT/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = BitCount(Elem[D[m+r],e,esize])[esize-1:0];
TAG:aarch32/VCNT/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCNT/T1A1_A:decode
if size != '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8;  elements = 8;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCNT/A:index
Execute: aarch32/VCNT/A:execute
Decode: aarch32/VCNT/T1A1_A:decode@aarch32/VCNT/T1A1_A:diagram
Decode: aarch32/VCNT/T1A1_A:decode@aarch32/VCNT/T1A1_A:diagram
TAG:aarch32/VNMLA/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        product16 = FPMul(S[n][15:0], S[m][15:0], FPSCR);
        case vtype of
            when VFPNegMul_VNMLA  S[d] = Zeros(16) : FPAdd(FPNeg(S[d][15:0]), FPNeg(product16), FPSCR);
            when VFPNegMul_VNMLS  S[d] = Zeros(16) : FPAdd(FPNeg(S[d][15:0]), product16, FPSCR);
            when VFPNegMul_VNMUL  S[d] = Zeros(16) : FPNeg(product16);
    when 32
        product32 = FPMul(S[n], S[m], FPSCR);
        case vtype of
            when VFPNegMul_VNMLA  S[d] = FPAdd(FPNeg(S[d]), FPNeg(product32), FPSCR);
            when VFPNegMul_VNMLS  S[d] = FPAdd(FPNeg(S[d]), product32, FPSCR);
            when VFPNegMul_VNMUL  S[d] = FPNeg(product32);
    when 64
        product64 = FPMul(D[n], D[m], FPSCR);
        case vtype of
            when VFPNegMul_VNMLA  D[d] = FPAdd(FPNeg(D[d]), FPNeg(product64), FPSCR);
            when VFPNegMul_VNMLS  D[d] = FPAdd(FPNeg(D[d]), product64, FPSCR);
            when VFPNegMul_VNMUL  D[d] = FPNeg(product64);
TAG:aarch32/VNMLA/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNMLA/A1_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
vtype = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VNMLA/T1_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNMLA/T1_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
vtype = if op == '1' then VFPNegMul_VNMLA else VFPNegMul_VNMLS;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VNMLA/A:index
Execute: aarch32/VNMLA/A:execute
Decode: aarch32/VNMLA/A1_A:decode@aarch32/VNMLA/A1_A:diagram
Decode: aarch32/VNMLA/T1_A:decode@aarch32/VNMLA/T1_A:diagram
TAG:aarch32/SMMLA/A:execute
result = (SInt(R[a]) << 32) + SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result[63:32];
TAG:aarch32/SMMLA/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 101
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:6 _ 00
5:5 R x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMMLA/A1_A:decode
if Ra == '1111' then SEE "SMMUL";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMMLA/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 101
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 R x
3:0 Rm xxxx
TAG:aarch32/SMMLA/T1_A:decode
if Ra == '1111' then SEE "SMMUL";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMMLA/A:index
Execute: aarch32/SMMLA/A:execute
Decode: aarch32/SMMLA/A1_A:decode@aarch32/SMMLA/A1_A:diagram
Decode: aarch32/SMMLA/T1_A:decode@aarch32/SMMLA/T1_A:diagram
TAG:aarch32/VFMAL_i/A:execute
CheckAdvSIMDEnabled();
bits(datasize) operand1 ;
bits(datasize) operand2 ;
bits(64) operand3;
bits(64) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;

if Q=='0' then
    operand1 = S[n][datasize-1:0];
    operand2 = S[m][datasize-1:0];
else
    operand1 = D[n][datasize-1:0];
    operand2 = D[m][datasize-1:0];
element2 = Elem[operand2, index, esize DIV 2];
for r = 0 to regs-1
    operand3 = D[d+r];
    for e = 0 to 1
        element1 = Elem[operand1, 2*r+e, esize DIV 2];
        if sub_op then element1 = FPNeg(element1);
        Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, StandardFPSCRValue());
    D[d+r] = result;
TAG:aarch32/VFMAL_i/A1_A:diagram
A32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 S 1
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMAL_i/A1_A:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
if Q == '1' && Vd[0] == '1' then UNDEFINED;

integer d = UInt(D:Vd);
integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
integer m = if Q == '1' then UInt(Vm[2:0]) else UInt(Vm[2:0]:M);

integer index = if Q == '1' then UInt(M:Vm[3]) else UInt(Vm[3]);
integer esize = 32;
integer regs = if Q=='1' then 2 else 1;
integer datasize = if Q=='1' then 64 else 32;
boolean sub_op = S=='1';

TAG:aarch32/VFMAL_i/T1_A:diagram
T32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 S 1
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMAL_i/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
if Q == '1' && Vd[0] == '1' then UNDEFINED;

integer d = UInt(D:Vd);
integer n = if Q == '1' then UInt(N:Vn) else UInt(Vn:N);
integer m = if Q == '1' then UInt(Vm[2:0]) else UInt(Vm[2:0]:M);

integer index = if Q == '1' then UInt(M:Vm[3]) else UInt(Vm[3]);
integer esize = 32;
integer regs = if Q=='1' then 2 else 1;
integer datasize = if Q=='1' then 64 else 32;
boolean sub_op = S=='1';

TAG:aarch32/VFMAL_i/A:index
Execute: aarch32/VFMAL_i/A:execute
Decode: aarch32/VFMAL_i/A1_A:decode@aarch32/VFMAL_i/A1_A:diagram
Decode: aarch32/VFMAL_i/T1_A:decode@aarch32/VFMAL_i/T1_A:diagram
TAG:aarch32/LDREXD/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address,8);
value = MemA[address,8];
// Extract words from 64-bit loaded value such that R[t] is
// loaded from address and R[t2] from address+4.
R[t]  = if BigEndian() then value[63:32] else value[31:0];
R[t2] = if BigEndian() then value[31:0] else value[63:32];
TAG:aarch32/LDREXD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXD/A1_A:decode
t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
if Rt[0] == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDREXD/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:6 _ 01
5:4 _ 11
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXD/T1_A:decode
t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDREXD/A:index
Execute: aarch32/LDREXD/A:execute
Decode: aarch32/LDREXD/A1_A:decode@aarch32/LDREXD/A1_A:diagram
Decode: aarch32/LDREXD/T1_A:decode@aarch32/LDREXD/T1_A:diagram
TAG:aarch32/MOV_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = shifted;
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/MOV_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/MOV_r/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/MOV_r/T1_A:diagram
T16
31:26 _ 010001
25:24 _ 10
23:23 D x
22:19 Rm xxxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/MOV_r/T1_A:decode
d = UInt(D:Rd);  m = UInt(Rm);  setflags = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/MOV_r/T2_A:diagram
T16
31:29 _ 000
28:27 op xx
26:22 imm5 xxxxx
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/MOV_r/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = DecodeImmShift(op, imm5);
if op == '00' && imm5 == '00000' && InITBlock() then UNPREDICTABLE;

TAG:aarch32/MOV_r/T3_A:diagram
T32
31:25 _ 1110101
24:21 _ 0010
20:20 S x
19:16 _ 1111
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/MOV_r/T3_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MOV_r/A:index
Execute: aarch32/MOV_r/A:execute
Decode: aarch32/MOV_r/A1_A:decode@aarch32/MOV_r/A1_A:diagram
Decode: aarch32/MOV_r/T1_A:decode@aarch32/MOV_r/T1_A:diagram
Decode: aarch32/MOV_r/T2_A:decode@aarch32/MOV_r/T2_A:diagram
Decode: aarch32/MOV_r/T3_A:decode@aarch32/MOV_r/T3_A:diagram
TAG:aarch32/AESE/A:execute
CheckCryptoEnabled32();
op1 = Q[d>>1]; op2 = Q[m>>1];
Q[d>>1] = AESSubBytes(AESShiftRows(op1 EOR op2));
TAG:aarch32/AESE/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0110
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESE/A1_A:decode
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESE/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0110
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESE/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESE/A:index
Execute: aarch32/AESE/A:execute
Decode: aarch32/AESE/A1_A:decode@aarch32/AESE/A1_A:diagram
Decode: aarch32/AESE/T1_A:decode@aarch32/AESE/T1_A:diagram
TAG:aarch32/VCMLA_idx/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    operand1 = D[n+r];
    operand2 = Din[m];
    operand3 = D[d+r];
    for e = 0 to (elements DIV 2)-1
        case rot of
            when '00'
                element1 = Elem[operand2,index*2,esize];
                element2 = Elem[operand1,e*2,esize];
                element3 = Elem[operand2,index*2+1,esize];
                element4 = Elem[operand1,e*2,esize];
            when '01'
                element1 = FPNeg(Elem[operand2,index*2+1,esize]);
                element2 = Elem[operand1,e*2+1,esize];
                element3 = Elem[operand2,index*2,esize];
                element4 = Elem[operand1,e*2+1,esize];
            when '10'
                element1 = FPNeg(Elem[operand2,index*2,esize]);
                element2 = Elem[operand1,e*2,esize];
                element3 = FPNeg(Elem[operand2,index*2+1,esize]);
                element4 = Elem[operand1,e*2,esize];
            when '11'
                element1 = Elem[operand2,index*2+1,esize];
                element2 = Elem[operand1,e*2+1,esize];
                element3 = FPNeg(Elem[operand2,index*2,esize]);
                element4 = Elem[operand1,e*2+1,esize];
        result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());
        result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3,StandardFPSCRValue());
        Elem[D[d+r],e*2,esize] = result1;
        Elem[D[d+r],e*2+1,esize] = result2;
TAG:aarch32/VCMLA_idx/A1_A:diagram
A32
31:24 _ 11111110
23:23 S x
22:22 D x
21:20 rot xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMLA_idx/A1_A:decode
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn);
m = if S=='1' then UInt(M:Vm) else UInt(Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;
index = if S=='1' then 0 else UInt(M);

TAG:aarch32/VCMLA_idx/T1_A:diagram
T32
31:24 _ 11111110
23:23 S x
22:22 D x
21:20 rot xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMLA_idx/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn);
m = if S=='1' then UInt(M:Vm) else UInt(Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;
index = if S=='1' then 0 else UInt(M);

TAG:aarch32/VCMLA_idx/A:index
Execute: aarch32/VCMLA_idx/A:execute
Decode: aarch32/VCMLA_idx/A1_A:decode@aarch32/VCMLA_idx/A1_A:diagram
Decode: aarch32/VCMLA_idx/T1_A:decode@aarch32/VCMLA_idx/T1_A:diagram
TAG:aarch32/VRINTZ_vfp/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        S[d] = Zeros(16) : FPRoundInt(S[m][15:0], FPSCR, rounding, exact);
    when 32
        S[d] = FPRoundInt(S[m], FPSCR, rounding, exact);
    when 64
        D[d] = FPRoundInt(D[m], FPSCR, rounding, exact);
TAG:aarch32/VRINTZ_vfp/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 110
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTZ_vfp/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
exact = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTZ_vfp/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 110
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTZ_vfp/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
rounding = if op == '1' then FPRounding_ZERO else FPRoundingMode(FPSCR);
exact = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VRINTZ_vfp/A:index
Execute: aarch32/VRINTZ_vfp/A:execute
Decode: aarch32/VRINTZ_vfp/A1_A:decode@aarch32/VRINTZ_vfp/A1_A:diagram
Decode: aarch32/VRINTZ_vfp/T1_A:decode@aarch32/VRINTZ_vfp/T1_A:diagram
TAG:aarch32/SXTB16/A:execute
rotated = ROR(R[m], rotation);
R[d][15:0]  = SignExtend(rotated[7:0], 16);
R[d][31:16] = SignExtend(rotated[23:16], 16);
TAG:aarch32/SXTB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 00
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTB16/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTB16/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 01
20:20 _ 0
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTB16/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTB16/A:index
Execute: aarch32/SXTB16/A:execute
Decode: aarch32/SXTB16/A1_A:decode@aarch32/SXTB16/A1_A:diagram
Decode: aarch32/SXTB16/T1_A:decode@aarch32/SXTB16/T1_A:diagram
TAG:aarch32/RFE/AS:execute
if PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNPREDICTABLE;                        // UNDEFINED or NOP
else
    address = if increment then R[n] else R[n]-8;
    if wordhigher then address = address+4;
    new_pc_value = MemA[address,4];
    spsr = MemA[address+4,4];
    if wback then R[n] = if increment then R[n]+8 else R[n]-8;
    AArch32.ExceptionReturn(new_pc_value, spsr);
TAG:aarch32/RFE/A1_AS:diagram
A32
31:25 _ 1111100
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:5 _ (0)(0)(0)(0)(1)(0)(1)(0)(0)(0)(0)
4:0 _ (0)(0)(0)(0)(0)
TAG:aarch32/RFE/A1_AS:decode
n = UInt(Rn);
wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/RFE/T1_AS:diagram
T32
31:25 _ 1110100
24:23 _ 00
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:0 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)
TAG:aarch32/RFE/T1_AS:decode
n = UInt(Rn);  wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;
if n == 15 then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/RFE/T2_AS:diagram
T32
31:25 _ 1110100
24:23 _ 11
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:0 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)
TAG:aarch32/RFE/T2_AS:decode
n = UInt(Rn);  wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;
if n == 15 then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/RFE/AS:index
Execute: aarch32/RFE/AS:execute
Decode: aarch32/RFE/A1_AS:decode@aarch32/RFE/A1_AS:diagram
Decode: aarch32/RFE/T1_AS:decode@aarch32/RFE/T1_AS:diagram
Decode: aarch32/RFE/T2_AS:decode@aarch32/RFE/T2_AS:diagram
TAG:aarch32/SSUB16/A:execute
diff1 = SInt(R[n][15:0]) - SInt(R[m][15:0]);
diff2 = SInt(R[n][31:16]) - SInt(R[m][31:16]);
R[d][15:0]  = diff1[15:0];
R[d][31:16] = diff2[15:0];
PSTATE.GE[1:0] = if diff1 >= 0 then '11' else '00';
PSTATE.GE[3:2] = if diff2 >= 0 then '11' else '00';
TAG:aarch32/SSUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SSUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SSUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SSUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SSUB16/A:index
Execute: aarch32/SSUB16/A:execute
Decode: aarch32/SSUB16/A1_A:decode@aarch32/SSUB16/A1_A:diagram
Decode: aarch32/SSUB16/T1_A:decode@aarch32/SSUB16/T1_A:diagram
TAG:aarch32/VCGE_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            bits(esize) zero = FPZero('0');
            test_passed = FPCompareGE(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
        else
            test_passed = (SInt(Elem[D[m+r],e,esize]) >= 0);
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCGE_i/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGE_i/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGE_i/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGE_i/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGE_i/A:index
Execute: aarch32/VCGE_i/A:execute
Decode: aarch32/VCGE_i/A1_A:decode@aarch32/VCGE_i/A1_A:diagram
Decode: aarch32/VCGE_i/T1_A:decode@aarch32/VCGE_i/T1_A:diagram
TAG:aarch32/STRBT/A:execute
offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
MemU_unpriv[address,1] = R[t][7:0];
if postindex then R[n] = offset_addr;
TAG:aarch32/STRBT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STRBT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/STRBT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/STRBT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(stype, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/STRBT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/STRBT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRBT/A:index
Execute: aarch32/STRBT/A:execute
Decode: aarch32/STRBT/A1_A:decode@aarch32/STRBT/A1_A:diagram
Decode: aarch32/STRBT/A2_A:decode@aarch32/STRBT/A2_A:diagram
Decode: aarch32/STRBT/T1_A:decode@aarch32/STRBT/T1_A:diagram
TAG:aarch32/STRHT/A:execute
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
MemU_unpriv[address,2] = R[t][15:0];
if postindex then R[n] = offset_addr;
TAG:aarch32/STRHT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/STRHT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/STRHT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/STRHT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/STRHT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/STRHT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRHT/A:index
Execute: aarch32/STRHT/A:execute
Decode: aarch32/STRHT/A1_A:decode@aarch32/STRHT/A1_A:diagram
Decode: aarch32/STRHT/A2_A:decode@aarch32/STRHT/A2_A:diagram
Decode: aarch32/STRHT/T1_A:decode@aarch32/STRHT/T1_A:diagram
TAG:aarch32/UHSUB16/A:execute
diff1 = UInt(R[n][15:0]) - UInt(R[m][15:0]);
diff2 = UInt(R[n][31:16]) - UInt(R[m][31:16]);
R[d][15:0]  = diff1[16:1];
R[d][31:16] = diff2[16:1];
TAG:aarch32/UHSUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHSUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHSUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHSUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHSUB16/A:index
Execute: aarch32/UHSUB16/A:execute
Decode: aarch32/UHSUB16/A1_A:decode@aarch32/UHSUB16/A1_A:diagram
Decode: aarch32/UHSUB16/T1_A:decode@aarch32/UHSUB16/T1_A:diagram
TAG:aarch32/RSB_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSB_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 011
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/RSB_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/RSB_r/T1_A:diagram
T32
31:25 _ 1110101
24:21 _ 1110
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/RSB_r/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/RSB_r/A:index
Execute: aarch32/RSB_r/A:execute
Decode: aarch32/RSB_r/A1_A:decode@aarch32/RSB_r/A1_A:diagram
Decode: aarch32/RSB_r/T1_A:decode@aarch32/RSB_r/T1_A:diagram
TAG:aarch32/DMB/A:execute
case option of
    when '0001'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Reads;
    when '0010'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_Writes;
    when '0011'  domain = MBReqDomain_OuterShareable;  types = MBReqTypes_All;
    when '0101'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Reads;
    when '0110'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_Writes;
    when '0111'  domain = MBReqDomain_Nonshareable;    types = MBReqTypes_All;
    when '1001'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Reads;
    when '1010'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_Writes;
    when '1011'  domain = MBReqDomain_InnerShareable;  types = MBReqTypes_All;
    when '1101'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Reads;
    when '1110'  domain = MBReqDomain_FullSystem;      types = MBReqTypes_Writes;
    otherwise    domain = MBReqDomain_FullSystem;      types = MBReqTypes_All;

if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then
    if HCR.BSU == '11' then
        domain = MBReqDomain_FullSystem;
    if HCR.BSU == '10' && domain != MBReqDomain_FullSystem then
        domain = MBReqDomain_OuterShareable;
    if HCR.BSU == '01' && domain == MBReqDomain_Nonshareable then
        domain = MBReqDomain_InnerShareable;

DataMemoryBarrier(domain, types);
TAG:aarch32/DMB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0101
3:0 option xxxx
TAG:aarch32/DMB/A1_A:decode
// No additional decoding required

TAG:aarch32/DMB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0101
3:0 option xxxx
TAG:aarch32/DMB/T1_A:decode
// No additional decoding required

TAG:aarch32/DMB/A:index
Execute: aarch32/DMB/A:execute
Decode: aarch32/DMB/A1_A:decode@aarch32/DMB/A1_A:diagram
Decode: aarch32/DMB/T1_A:decode@aarch32/DMB/T1_A:diagram
TAG:aarch32/STLEXH/A:execute
address = R[n];
if AArch32.ExclusiveMonitorsPass(address,2) then
    MemO[address, 2] = R[t][15:0];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STLEXH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLEXH/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEXH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 01
3:0 Rd xxxx
TAG:aarch32/STLEXH/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEXH/A:index
Execute: aarch32/STLEXH/A:execute
Decode: aarch32/STLEXH/A1_A:decode@aarch32/STLEXH/A1_A:diagram
Decode: aarch32/STLEXH/T1_A:decode@aarch32/STLEXH/T1_A:diagram
TAG:aarch32/B/A:execute
BranchWritePC(PC + imm32, BranchType_DIR);
TAG:aarch32/B/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 101
24:24 _ 0
23:0 imm24 xxxxxxxxxxxxxxxxxxxxxxxx
TAG:aarch32/B/A1_A:decode
imm32 = SignExtend(imm24:'00', 32);

TAG:aarch32/B/T1_A:diagram
T16
31:28 _ 1101
27:24 cond xxxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/B/T1_A:decode
if cond == '1110' then SEE "UDF";
if cond == '1111' then SEE "SVC";
imm32 = SignExtend(imm8:'0', 32);
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/B/T2_A:diagram
T16
31:27 _ 11100
26:16 imm11 xxxxxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/B/T2_A:decode
imm32 = SignExtend(imm11:'0', 32);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/B/T3_A:diagram
T32
31:27 _ 11110
26:26 S x
25:22 cond xxxx
21:16 imm6 xxxxxx
15:14 _ 10
13:13 J1 x
12:12 _ 0
11:11 J2 x
10:0 imm11 xxxxxxxxxxx
TAG:aarch32/B/T3_A:decode
if cond[3:1] == '111' then SEE "Related encodings";
imm32 = SignExtend(S:J2:J1:imm6:imm11:'0', 32);
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/B/T4_A:diagram
T32
31:27 _ 11110
26:26 S x
25:16 imm10 xxxxxxxxxx
15:14 _ 10
13:13 J1 x
12:12 _ 1
11:11 J2 x
10:0 imm11 xxxxxxxxxxx
TAG:aarch32/B/T4_A:decode
I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/B/A:index
Execute: aarch32/B/A:execute
Decode: aarch32/B/A1_A:decode@aarch32/B/A1_A:diagram
Decode: aarch32/B/T1_A:decode@aarch32/B/T1_A:diagram
Decode: aarch32/B/T2_A:decode@aarch32/B/T2_A:diagram
Decode: aarch32/B/T3_A:decode@aarch32/B/T3_A:diagram
Decode: aarch32/B/T4_A:decode@aarch32/B/T4_A:diagram
TAG:aarch32/UHSUB8/A:execute
diff1 = UInt(R[n][7:0]) - UInt(R[m][7:0]);
diff2 = UInt(R[n][15:8]) - UInt(R[m][15:8]);
diff3 = UInt(R[n][23:16]) - UInt(R[m][23:16]);
diff4 = UInt(R[n][31:24]) - UInt(R[m][31:24]);
R[d][7:0]   = diff1[8:1];
R[d][15:8]  = diff2[8:1];
R[d][23:16] = diff3[8:1];
R[d][31:24] = diff4[8:1];
TAG:aarch32/UHSUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHSUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHSUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHSUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHSUB8/A:index
Execute: aarch32/UHSUB8/A:execute
Decode: aarch32/UHSUB8/A1_A:decode@aarch32/UHSUB8/A1_A:diagram
Decode: aarch32/UHSUB8/T1_A:decode@aarch32/UHSUB8/T1_A:diagram
TAG:aarch32/SHSUB8/A:execute
diff1 = SInt(R[n][7:0]) - SInt(R[m][7:0]);
diff2 = SInt(R[n][15:8]) - SInt(R[m][15:8]);
diff3 = SInt(R[n][23:16]) - SInt(R[m][23:16]);
diff4 = SInt(R[n][31:24]) - SInt(R[m][31:24]);
R[d][7:0]   = diff1[8:1];
R[d][15:8]  = diff2[8:1];
R[d][23:16] = diff3[8:1];
R[d][31:24] = diff4[8:1];
TAG:aarch32/SHSUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHSUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHSUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHSUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHSUB8/A:index
Execute: aarch32/SHSUB8/A:execute
Decode: aarch32/SHSUB8/A1_A:decode@aarch32/SHSUB8/A1_A:diagram
Decode: aarch32/SHSUB8/T1_A:decode@aarch32/SHSUB8/T1_A:diagram
TAG:aarch32/VLD4_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
Elem[D[d], index] = MemU[address,ebytes];
Elem[D[d2],index] = MemU[address+ebytes,ebytes];
Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
Elem[D[d4],index] = MemU[address+3*ebytes,ebytes];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 4*ebytes;
TAG:aarch32/VLD4_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD4_1/T1A1_A:decode
if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
alignment = if index_align[0] == '0' then 1 else 4;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD4_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD4_1/T2A2_A:decode
if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 8;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD4_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD4_1/T3A3_A:decode
if size == '11' then SEE "VLD4 (single 4-element structure to all lanes)";
if index_align[1:0] == '11' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
alignment = if index_align[1:0] == '00' then 1 else 4 << UInt(index_align[1:0]);
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD4_1/A:index
Execute: aarch32/VLD4_1/A:execute
Decode: aarch32/VLD4_1/T1A1_A:decode@aarch32/VLD4_1/T1A1_A:diagram
Decode: aarch32/VLD4_1/T2A2_A:decode@aarch32/VLD4_1/T2A2_A:diagram
Decode: aarch32/VLD4_1/T3A3_A:decode@aarch32/VLD4_1/T3A3_A:diagram
Decode: aarch32/VLD4_1/T1A1_A:decode@aarch32/VLD4_1/T1A1_A:diagram
Decode: aarch32/VLD4_1/T2A2_A:decode@aarch32/VLD4_1/T2A2_A:diagram
Decode: aarch32/VLD4_1/T3A3_A:decode@aarch32/VLD4_1/T3A3_A:diagram
TAG:aarch32/MRC/A:execute
bits(32) value = AArch32.SysRegRead(cp, ThisInstr());
if t != 15 then
    R[t] = value;
elsif AArch32.SysRegReadCanWriteAPSR(cp, ThisInstr()) then
    PSTATE.[N,Z,C,V] = value[31:28];
    // value[27:0] are not used.
else
    PSTATE.[N,Z,C,V] = bits(4) UNKNOWN;
TAG:aarch32/MRC/T1A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:21 opc1 xxx
20:20 _ 1
19:16 CRn xxxx
15:12 Rt xxxx
11:8 coproc 111x
7:5 opc2 xxx
4:4 _ 1
3:0 CRm xxxx
TAG:aarch32/MRC/T1A1_A:decode
t = UInt(Rt);  cp = if coproc[0] == '0' then 14 else 15;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MRC/A:index
Execute: aarch32/MRC/A:execute
Decode: aarch32/MRC/T1A1_A:decode@aarch32/MRC/T1A1_A:diagram
Decode: aarch32/MRC/T1A1_A:decode@aarch32/MRC/T1A1_A:diagram
TAG:aarch32/VRSHL/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        shift = SInt(Elem[D[n+r],e,esize][7:0]);
        round_const = 1 << (-shift-1); // 0 for left shift, 2^(n-1) for right shift
        result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) << shift;
        Elem[D[d+r],e,esize] = result[esize-1:0];
TAG:aarch32/VRSHL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRSHL/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSHL/A:index
Execute: aarch32/VRSHL/A:execute
Decode: aarch32/VRSHL/T1A1_A:decode@aarch32/VRSHL/T1A1_A:diagram
Decode: aarch32/VRSHL/T1A1_A:decode@aarch32/VRSHL/T1A1_A:diagram
TAG:aarch32/VRINTX_asimd/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[m+r],e,esize];
        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
        Elem[D[d+r],e,esize] = result;
TAG:aarch32/VRINTX_asimd/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTX_asimd/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPRounding_TIEEVEN;  exact = TRUE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRINTX_asimd/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTX_asimd/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPRounding_TIEEVEN;  exact = TRUE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/VRINTX_asimd/A:index
Execute: aarch32/VRINTX_asimd/A:execute
Decode: aarch32/VRINTX_asimd/A1_A:decode@aarch32/VRINTX_asimd/A1_A:diagram
Decode: aarch32/VRINTX_asimd/T1_A:decode@aarch32/VRINTX_asimd/T1_A:diagram
TAG:aarch32/LDM_u/AS:execute
if PSTATE.EL == EL2 then UNDEFINED;
elsif PSTATE.M IN {M32_User,M32_System} then UNPREDICTABLE;
else
    length = 4*BitCount(registers);
    address = if increment then R[n] else R[n]-length;
    if wordhigher then address = address+4;
    for i = 0 to 14
        if registers[i] == '1' then  // Load User mode register
            Rmode[i, M32_User] = MemA[address,4];  address = address + 4;
TAG:aarch32/LDM_u/A1_AS:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 P x
23:23 U x
22:22 _ 1
21:21 _ (0)
20:20 _ 1
19:16 Rn xxxx
15:15 _ 0
14:0 register_list xxxxxxxxxxxxxxx
TAG:aarch32/LDM_u/A1_AS:decode
n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/LDM_u/AS:index
Execute: aarch32/LDM_u/AS:execute
Decode: aarch32/LDM_u/A1_AS:decode@aarch32/LDM_u/A1_AS:diagram
TAG:aarch32/ORN_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] OR NOT(shifted);
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/ORN_r/T1_A:diagram
T32
31:25 _ 1110101
24:21 _ 0011
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/ORN_r/T1_A:decode
if Rn == '1111' then SEE "MVN (register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ORN_r/A:index
Execute: aarch32/ORN_r/A:execute
Decode: aarch32/ORN_r/T1_A:decode@aarch32/ORN_r/T1_A:diagram
TAG:aarch32/LDAH/A:execute
address = R[n];
R[t] = ZeroExtend(MemO[address, 2], 32);
TAG:aarch32/LDAH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAH/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 01
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAH/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAH/A:index
Execute: aarch32/LDAH/A:execute
Decode: aarch32/LDAH/A1_A:decode@aarch32/LDAH/A1_A:diagram
Decode: aarch32/LDAH/T1_A:decode@aarch32/LDAH/T1_A:diagram
TAG:aarch32/VQNEG/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        result = -SInt(Elem[D[m+r],e,esize]);
        (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQNEG/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1111
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQNEG/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQNEG/A:index
Execute: aarch32/VQNEG/A:execute
Decode: aarch32/VQNEG/T1A1_A:decode@aarch32/VQNEG/T1A1_A:diagram
Decode: aarch32/VQNEG/T1A1_A:decode@aarch32/VQNEG/T1A1_A:diagram
TAG:aarch32/SHA1H/A:execute
CheckCryptoEnabled32();
Q[d>>1] = ZeroExtend(ROL(Q[m>>1][31:0], 30), 128);
TAG:aarch32/SHA1H/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0101
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1H/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA1H/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0101
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1H/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA1H/A:index
Execute: aarch32/SHA1H/A:execute
Decode: aarch32/SHA1H/A1_A:decode@aarch32/SHA1H/A1_A:diagram
Decode: aarch32/SHA1H/T1_A:decode@aarch32/SHA1H/T1_A:diagram
TAG:aarch32/LDAEX/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address, 4);
R[t] = MemO[address, 4];
TAG:aarch32/LDAEX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEX/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEX/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 10
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEX/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEX/A:index
Execute: aarch32/LDAEX/A:execute
Decode: aarch32/LDAEX/A1_A:decode@aarch32/LDAEX/A1_A:diagram
Decode: aarch32/LDAEX/T1_A:decode@aarch32/LDAEX/T1_A:diagram
TAG:aarch32/SSAT16/A:execute
(result1, sat1) = SignedSatQ(SInt(R[n][15:0]), saturate_to);
(result2, sat2) = SignedSatQ(SInt(R[n][31:16]), saturate_to);
R[d][15:0] = SignExtend(result1, 16);
R[d][31:16] = SignExtend(result2, 16);
if sat1 || sat2 then
    PSTATE.Q = '1';
TAG:aarch32/SSAT16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 10
19:16 sat_imm xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0011
3:0 Rn xxxx
TAG:aarch32/SSAT16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/SSAT16/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 00
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 _ 000
11:8 Rd xxxx
7:6 _ 00
5:5 _ (0)
4:4 _ (0)
3:0 sat_imm xxxx
TAG:aarch32/SSAT16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SSAT16/A:index
Execute: aarch32/SSAT16/A:execute
Decode: aarch32/SSAT16/A1_A:decode@aarch32/SSAT16/A1_A:diagram
Decode: aarch32/SSAT16/T1_A:decode@aarch32/SSAT16/T1_A:diagram
TAG:aarch32/SXTAH/A:execute
rotated = ROR(R[m], rotation);
R[d] = R[n] + SignExtend(rotated[15:0], 32);
TAG:aarch32/SXTAH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 11
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTAH/A1_A:decode
if Rn == '1111' then SEE "SXTH";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTAH/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTAH/T1_A:decode
if Rn == '1111' then SEE "SXTH";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTAH/A:index
Execute: aarch32/SXTAH/A:execute
Decode: aarch32/SXTAH/A1_A:decode@aarch32/SXTAH/A1_A:diagram
Decode: aarch32/SXTAH/T1_A:decode@aarch32/SXTAH/T1_A:diagram
TAG:aarch32/VRINTZ_asimd/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[m+r],e,esize];
        result = FPRoundInt(op1, StandardFPSCRValue(), rounding, exact);
        Elem[D[d+r],e,esize] = result;
TAG:aarch32/VRINTZ_asimd/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTZ_asimd/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPRounding_ZERO;  exact = FALSE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRINTZ_asimd/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRINTZ_asimd/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
rounding = FPRounding_ZERO;  exact = FALSE;
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/VRINTZ_asimd/A:index
Execute: aarch32/VRINTZ_asimd/A:execute
Decode: aarch32/VRINTZ_asimd/A1_A:decode@aarch32/VRINTZ_asimd/A1_A:diagram
Decode: aarch32/VRINTZ_asimd/T1_A:decode@aarch32/VRINTZ_asimd/T1_A:diagram
TAG:aarch32/VSUBHN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize];
    Elem[D[d],e,esize] = result[2*esize-1:esize];
TAG:aarch32/VSUBHN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0110
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUBHN/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VSUBHN/A:index
Execute: aarch32/VSUBHN/A:execute
Decode: aarch32/VSUBHN/T1A1_A:decode@aarch32/VSUBHN/T1A1_A:diagram
Decode: aarch32/VSUBHN/T1A1_A:decode@aarch32/VSUBHN/T1A1_A:diagram
TAG:aarch32/VST1_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for r = 0 to regs-1
    for e = 0 to elements-1
        if ebytes != 8 then
            MemU[address,ebytes] = Elem[D[d+r],e];
        else
            - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
            bits(64) data = Elem[D[d+r],e];
            MemU[address,4] = if BigEndian() then data[63:32] else data[31:0];
            MemU[address+4,4] = if BigEndian() then data[31:0] else data[63:32];
        address = address + ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 8*regs;
TAG:aarch32/VST1_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0111
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST1_m/T1A1_A:decode
regs = 1;  if align[1] == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST1_m/T2A2_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 1010
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST1_m/T2A2_A:decode
regs = 2;  if align == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST1_m/T3A3_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0110
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST1_m/T3A3_A:decode
regs = 3;  if align[1] == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST1_m/T4A4_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0010
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST1_m/T4A4_A:decode
regs = 4;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST1_m/A:index
Execute: aarch32/VST1_m/A:execute
Decode: aarch32/VST1_m/T1A1_A:decode@aarch32/VST1_m/T1A1_A:diagram
Decode: aarch32/VST1_m/T2A2_A:decode@aarch32/VST1_m/T2A2_A:diagram
Decode: aarch32/VST1_m/T3A3_A:decode@aarch32/VST1_m/T3A3_A:diagram
Decode: aarch32/VST1_m/T4A4_A:decode@aarch32/VST1_m/T4A4_A:diagram
Decode: aarch32/VST1_m/T1A1_A:decode@aarch32/VST1_m/T1A1_A:diagram
Decode: aarch32/VST1_m/T2A2_A:decode@aarch32/VST1_m/T2A2_A:diagram
Decode: aarch32/VST1_m/T3A3_A:decode@aarch32/VST1_m/T3A3_A:diagram
Decode: aarch32/VST1_m/T4A4_A:decode@aarch32/VST1_m/T4A4_A:diagram
TAG:aarch32/LDRSH_l/A:execute
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,2];
R[t] = SignExtend(data, 32);
TAG:aarch32/LDRSH_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSH_l/A1_A:decode
if P == '0' && W == '1' then SEE "LDRSHT";
t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || wback then UNPREDICTABLE;

TAG:aarch32/LDRSH_l/T1_A:diagram
T32
31:24 _ 11111001
23:23 U x
22:21 _ 01
20:16 _ 11111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRSH_l/T1_A:decode
if Rt == '1111' then SEE "Related instructions";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSH_l/A:index
Execute: aarch32/LDRSH_l/A:execute
Decode: aarch32/LDRSH_l/A1_A:decode@aarch32/LDRSH_l/A1_A:diagram
Decode: aarch32/LDRSH_l/T1_A:decode@aarch32/LDRSH_l/T1_A:diagram
TAG:aarch32/RSC_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSC_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 111
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/RSC_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/RSC_r/A:index
Execute: aarch32/RSC_r/A:execute
Decode: aarch32/RSC_r/A1_A:decode@aarch32/RSC_r/A1_A:diagram
TAG:aarch32/VDUP_s/A:execute
CheckAdvSIMDEnabled();
scalar = Elem[D[m],index,esize];
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = scalar;
TAG:aarch32/VDUP_s/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:16 imm4 xxxx
15:12 Vd xxxx
11:10 _ 11
9:7 _ 000
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDUP_s/T1A1_A:decode
if imm4 == 'x000' then UNDEFINED;
if Q == '1' && Vd[0] == '1' then UNDEFINED;
case imm4 of
    when 'xxx1'  esize = 8;  elements = 8;  index = UInt(imm4[3:1]);
    when 'xx10'  esize = 16;  elements = 4;  index = UInt(imm4[3:2]);
    when 'x100'  esize = 32;  elements = 2;  index = UInt(imm4[3]);
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VDUP_s/A:index
Execute: aarch32/VDUP_s/A:execute
Decode: aarch32/VDUP_s/T1A1_A:decode@aarch32/VDUP_s/T1A1_A:diagram
Decode: aarch32/VDUP_s/T1A1_A:decode@aarch32/VDUP_s/T1A1_A:diagram
TAG:aarch32/USUB16/A:execute
diff1 = UInt(R[n][15:0]) - UInt(R[m][15:0]);
diff2 = UInt(R[n][31:16]) - UInt(R[m][31:16]);
R[d][15:0]  = diff1[15:0];
R[d][31:16] = diff2[15:0];
PSTATE.GE[1:0] = if diff1 >= 0 then '11' else '00';
PSTATE.GE[3:2] = if diff2 >= 0 then '11' else '00';
TAG:aarch32/USUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/USUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/USUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/USUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USUB16/A:index
Execute: aarch32/USUB16/A:execute
Decode: aarch32/USUB16/A1_A:decode@aarch32/USUB16/A1_A:diagram
Decode: aarch32/USUB16/T1_A:decode@aarch32/USUB16/T1_A:diagram
TAG:aarch32/MVN_i/A:execute
result = NOT(imm32);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/MVN_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00111
22:21 _ 11
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/MVN_i/A1_A:decode
d = UInt(Rd);  setflags = (S == '1');
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/MVN_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0011
20:20 S x
19:16 _ 1111
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/MVN_i/T1_A:decode
d = UInt(Rd);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MVN_i/A:index
Execute: aarch32/MVN_i/A:execute
Decode: aarch32/MVN_i/A1_A:decode@aarch32/MVN_i/A1_A:diagram
Decode: aarch32/MVN_i/T1_A:decode@aarch32/MVN_i/T1_A:diagram
TAG:aarch32/LDRHT/A:execute
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,2];
if postindex then R[n] = offset_addr;
R[t] = ZeroExtend(data, 32);
TAG:aarch32/LDRHT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRHT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/LDRHT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRHT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/LDRHT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRHT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then SEE "LDRH (literal)";
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRHT/A:index
Execute: aarch32/LDRHT/A:execute
Decode: aarch32/LDRHT/A1_A:decode@aarch32/LDRHT/A1_A:diagram
Decode: aarch32/LDRHT/A2_A:decode@aarch32/LDRHT/A2_A:diagram
Decode: aarch32/LDRHT/T1_A:decode@aarch32/LDRHT/T1_A:diagram
TAG:aarch32/SHASX/A:execute
diff = SInt(R[n][15:0]) - SInt(R[m][31:16]);
sum  = SInt(R[n][31:16]) + SInt(R[m][15:0]);
R[d][15:0]  = diff[16:1];
R[d][31:16] = sum[16:1];
TAG:aarch32/SHASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHASX/A:index
Execute: aarch32/SHASX/A:execute
Decode: aarch32/SHASX/A1_A:decode@aarch32/SHASX/A1_A:diagram
Decode: aarch32/SHASX/T1_A:decode@aarch32/SHASX/T1_A:diagram
TAG:aarch32/VQDMLAL/A:execute
CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
for e = 0 to elements-1
    if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
    op1 = SInt(Elem[Din[n],e,esize]);
    // The following only saturates if both op1 and op2 equal -(2^(esize-1))
    (product, sat1) = SignedSatQ(2*op1*op2, 2*esize);
    if add then
        result = SInt(Elem[Qin[d>>1],e,2*esize]) + SInt(product);
    else
        result = SInt(Elem[Qin[d>>1],e,2*esize]) - SInt(product);
    (Elem[Q[d>>1],e,2*esize], sat2) = SignedSatQ(result, 2*esize);
    if sat1 || sat2 then FPSCR.QC = '1';
TAG:aarch32/VQDMLAL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:9 op 0
8:8 _ 1
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMLAL/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
add = (op == '0');
scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
esize = 8 << UInt(size);  elements = 64 DIV esize;

TAG:aarch32/VQDMLAL/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 0
10:10 op 0
9:8 _ 11
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMLAL/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
add = (op == '0');
scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQDMLAL/A:index
Execute: aarch32/VQDMLAL/A:execute
Decode: aarch32/VQDMLAL/T1A1_A:decode@aarch32/VQDMLAL/T1A1_A:diagram
Decode: aarch32/VQDMLAL/T2A2_A:decode@aarch32/VQDMLAL/T2A2_A:diagram
Decode: aarch32/VQDMLAL/T1A1_A:decode@aarch32/VQDMLAL/T1A1_A:diagram
Decode: aarch32/VQDMLAL/T2A2_A:decode@aarch32/VQDMLAL/T2A2_A:diagram
TAG:aarch32/VCADD/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    operand1 = D[n+r];
    operand2 = D[m+r];
    operand3 = D[d+r];
    for e = 0 to (elements DIV 2)-1
        case rot of
            when '0'
                element1 = FPNeg(Elem[operand2,e*2+1,esize]);
                element3 = Elem[operand2,e*2,esize];
            when '1'
                element1 = Elem[operand2,e*2+1,esize];
                element3 = FPNeg(Elem[operand2,e*2,esize]);
        result1 = FPAdd(Elem[operand1,e*2,esize],element1,StandardFPSCRValue());
        result2 = FPAdd(Elem[operand1,e*2+1,esize],element3,StandardFPSCRValue());
        Elem[D[d+r],e*2,esize] = result1;
        Elem[D[d+r],e*2+1,esize] = result2;
TAG:aarch32/VCADD/A1_A:diagram
A32
31:25 _ 1111110
24:24 rot x
23:23 _ 1
22:22 D x
21:21 _ 0
20:20 S x
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCADD/A1_A:decode
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCADD/T1_A:diagram
T32
31:25 _ 1111110
24:24 rot x
23:23 _ 1
22:22 D x
21:21 _ 0
20:20 S x
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCADD/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCADD/A:index
Execute: aarch32/VCADD/A:execute
Decode: aarch32/VCADD/A1_A:decode@aarch32/VCADD/A1_A:diagram
Decode: aarch32/VCADD/T1_A:decode@aarch32/VCADD/T1_A:diagram
TAG:aarch32/STMDB/A:execute
address = R[n] - 4*BitCount(registers);
for i = 0 to 14
    if registers[i] == '1' then
        if i == n && wback && i != LowestSetBit(registers) then
            MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encoding A1
        else
            MemA[address,4] = R[i];
        address = address + 4;
if registers[15] == '1' then  // Only possible for encoding A1
    MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] - 4*BitCount(registers);
TAG:aarch32/STMDB/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 1
23:23 _ 0
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/STMDB/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STMDB/T1_A:diagram
T32
31:25 _ 1110100
24:23 _ 10
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:15 P (0)
14:14 M x
13:0 register_list xxxxxxxxxxxxxx
TAG:aarch32/STMDB/T1_A:decode
n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;
if registers[13] == '1' then UNPREDICTABLE;
if registers[15] == '1' then UNPREDICTABLE;

TAG:aarch32/STMDB/A:index
Execute: aarch32/STMDB/A:execute
Decode: aarch32/STMDB/A1_A:decode@aarch32/STMDB/A1_A:diagram
Decode: aarch32/STMDB/T1_A:decode@aarch32/STMDB/T1_A:diagram
TAG:aarch32/VQRDMLAH/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = SInt(Elem[D[n+r],e,esize]);
        op3 = SInt(Elem[D[d+r],e,esize]) << esize;
        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
        (result, sat) = SignedSatQ((op3 + 2*(op1*op2) + round_const) >> esize, esize);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQRDMLAH/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRDMLAH/A1_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRDMLAH/A2_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMLAH/A2_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQRDMLAH/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRDMLAH/T1_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
add = TRUE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRDMLAH/T2_A:diagram
T32
31:29 _ 111
28:28 Q x
27:23 _ 11111
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMLAH/T2_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
add = TRUE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQRDMLAH/A:index
Execute: aarch32/VQRDMLAH/A:execute
Decode: aarch32/VQRDMLAH/A1_A:decode@aarch32/VQRDMLAH/A1_A:diagram
Decode: aarch32/VQRDMLAH/A2_A:decode@aarch32/VQRDMLAH/A2_A:diagram
Decode: aarch32/VQRDMLAH/T1_A:decode@aarch32/VQRDMLAH/T1_A:diagram
Decode: aarch32/VQRDMLAH/T2_A:decode@aarch32/VQRDMLAH/T2_A:diagram
TAG:aarch32/UXTB/A:execute
rotated = ROR(R[m], rotation);
R[d] = ZeroExtend(rotated[7:0], 32);
TAG:aarch32/UXTB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 10
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTB/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTB/T1_A:diagram
T16
31:24 _ 10110010
23:23 _ 1
22:22 _ 1
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/UXTB/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

TAG:aarch32/UXTB/T2_A:diagram
T32
31:23 _ 111110100
22:21 _ 10
20:20 _ 1
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTB/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTB/A:index
Execute: aarch32/UXTB/A:execute
Decode: aarch32/UXTB/A1_A:decode@aarch32/UXTB/A1_A:diagram
Decode: aarch32/UXTB/T1_A:decode@aarch32/UXTB/T1_A:diagram
Decode: aarch32/UXTB/T2_A:decode@aarch32/UXTB/T2_A:diagram
TAG:aarch32/VMAX_f/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
        if maximum then
            Elem[D[d+r],e,esize] = FPMax(op1, op2, StandardFPSCRValue());
        else
            Elem[D[d+r],e,esize] = FPMin(op1, op2, StandardFPSCRValue());
TAG:aarch32/VMAX_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMAX_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
maximum = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMAX_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMAX_f/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
maximum = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMAX_f/A:index
Execute: aarch32/VMAX_f/A:execute
Decode: aarch32/VMAX_f/A1_A:decode@aarch32/VMAX_f/A1_A:diagram
Decode: aarch32/VMAX_f/T1_A:decode@aarch32/VMAX_f/T1_A:diagram
TAG:aarch32/SUB_i/A:execute
(result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SUB_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 010
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/SUB_i/A1_A:decode
if Rn == '1111' && S == '0' then SEE "ADR";
if Rn == '1101' then SEE "SUB (SP minus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/SUB_i/T1_A:diagram
T16
31:26 _ 000111
25:25 _ 1
24:22 imm3 xxx
21:19 Rn xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/SUB_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

TAG:aarch32/SUB_i/T2_A:diagram
T16
31:29 _ 001
28:27 _ 11
26:24 Rdn xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/SUB_i/T2_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

TAG:aarch32/SUB_i/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1101
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/SUB_i/T3_A:decode
if Rd == '1111' && S == '1' then SEE "CMP (immediate)";
if Rn == '1101' then SEE "SUB (SP minus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SUB_i/T4_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/SUB_i/T4_A:decode
if Rn == '1111' then SEE "ADR";
if Rn == '1101' then SEE "SUB (SP minus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SUB_i/T5_AS:diagram
T32
31:20 _ 111100111101
19:16 Rn (1)(1)(1)(0)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:0 imm8 xxxxxxxx
TAG:aarch32/SUB_i/T5_AS:decode
if Rn == '1110' && IsZero(imm8) then SEE "ERET";
d = 15;  n = UInt(Rn);  setflags = TRUE;  imm32 = ZeroExtend(imm8, 32);
if n != 14 then UNPREDICTABLE;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/SUB_i/A:index
Execute: aarch32/SUB_i/A:execute
Decode: aarch32/SUB_i/A1_A:decode@aarch32/SUB_i/A1_A:diagram
Decode: aarch32/SUB_i/T1_A:decode@aarch32/SUB_i/T1_A:diagram
Decode: aarch32/SUB_i/T2_A:decode@aarch32/SUB_i/T2_A:diagram
Decode: aarch32/SUB_i/T3_A:decode@aarch32/SUB_i/T3_A:diagram
Decode: aarch32/SUB_i/T4_A:decode@aarch32/SUB_i/T4_A:diagram
Decode: aarch32/SUB_i/T5_AS:decode@aarch32/SUB_i/T5_AS:diagram
TAG:aarch32/USAD8/A:execute
absdiff1 = Abs(UInt(R[n][7:0])   - UInt(R[m][7:0]));
absdiff2 = Abs(UInt(R[n][15:8])  - UInt(R[m][15:8]));
absdiff3 = Abs(UInt(R[n][23:16]) - UInt(R[m][23:16]));
absdiff4 = Abs(UInt(R[n][31:24]) - UInt(R[m][31:24]));
result = absdiff1 + absdiff2 + absdiff3 + absdiff4;
R[d] = result[31:0];
TAG:aarch32/USAD8/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 01111000
19:16 Rd xxxx
15:12 _ 1111
11:8 Rm xxxx
7:4 _ 0001
3:0 Rn xxxx
TAG:aarch32/USAD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/USAD8/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 111
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/USAD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USAD8/A:index
Execute: aarch32/USAD8/A:execute
Decode: aarch32/USAD8/A1_A:decode@aarch32/USAD8/A1_A:diagram
Decode: aarch32/USAD8/T1_A:decode@aarch32/USAD8/T1_A:diagram
TAG:aarch32/VMLA_i/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:9 op 0
8:8 _ 0
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_i/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if Vd[0] == '1' then UNDEFINED;
add = (op == '0');  long_destination = TRUE;  unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

TAG:aarch32/VCVTB_bf16/A:execute
CheckVFPEnabled(TRUE);

S[d][15:0] = FPConvertBF(S[m], FPSCR);
TAG:aarch32/VCVTB_bf16/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 011
15:12 Vd xxxx
11:10 _ 10
9:8 _ 01
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTB_bf16/T1A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
integer d = UInt(Vd:D);
integer m = UInt(Vm:M);

TAG:aarch32/VCVTB_bf16/A:index
Execute: aarch32/VCVTB_bf16/A:execute
Decode: aarch32/VCVTB_bf16/T1A1_A:decode@aarch32/VCVTB_bf16/T1A1_A:diagram
Decode: aarch32/VCVTB_bf16/T1A1_A:decode@aarch32/VCVTB_bf16/T1A1_A:diagram
TAG:aarch32/EOR_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] EOR shifted;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/EOR_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 001
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/EOR_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/EOR_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 0001
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/EOR_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/EOR_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0100
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/EOR_r/T2_A:decode
if Rd == '1111' && S == '1' then SEE "TEQ (register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/EOR_r/A:index
Execute: aarch32/EOR_r/A:execute
Decode: aarch32/EOR_r/A1_A:decode@aarch32/EOR_r/A1_A:diagram
Decode: aarch32/EOR_r/T1_A:decode@aarch32/EOR_r/T1_A:diagram
Decode: aarch32/EOR_r/T2_A:decode@aarch32/EOR_r/T2_A:diagram
TAG:aarch32/UASX/A:execute
diff = UInt(R[n][15:0]) - UInt(R[m][31:16]);
sum  = UInt(R[n][31:16]) + UInt(R[m][15:0]);
R[d][15:0]  = diff[15:0];
R[d][31:16] = sum[15:0];
PSTATE.GE[1:0] = if diff >= 0 then '11' else '00';
PSTATE.GE[3:2] = if sum  >= 0x10000 then '11' else '00';
TAG:aarch32/UASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UASX/A:index
Execute: aarch32/UASX/A:execute
Decode: aarch32/UASX/A1_A:decode@aarch32/UASX/A1_A:diagram
Decode: aarch32/UASX/T1_A:decode@aarch32/UASX/T1_A:diagram
TAG:aarch32/SMC/AS:execute

AArch32.CheckForSMCUndefOrTrap();

if !ELUsingAArch32(EL3) then
    if SCR_EL3.SMD == '1' then
        // SMC disabled.
        UNDEFINED;
else
    if SCR.SCD == '1' then
        // SMC disabled
        if IsSecure() then
            // Executes either as a NOP or UNALLOCATED.
            c = ConstrainUnpredictable(Unpredictable_SMD);
            assert c IN {Constraint_NOP, Constraint_UNDEF};
            if c == Constraint_NOP then EndOfInstruction();
        UNDEFINED;

if !ELUsingAArch32(EL3) then
    AArch64.CallSecureMonitor(Zeros(16));
else
    AArch32.TakeSMCException();
TAG:aarch32/SMC/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 11
20:20 _ 0
19:8 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)
7:4 _ 0111
3:0 imm4 xxxx
TAG:aarch32/SMC/A1_AS:decode
// imm4 is for assembly/disassembly only and is ignored by hardware

TAG:aarch32/SMC/T1_AS:diagram
T32
31:21 _ 11110111111
20:20 _ 1
19:16 imm4 xxxx
15:14 _ 10
13:13 _ 0
12:12 _ 0
11:0 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)
TAG:aarch32/SMC/T1_AS:decode
// imm4 is for assembly/disassembly only and is ignored by hardware
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/SMC/AS:index
Execute: aarch32/SMC/AS:execute
Decode: aarch32/SMC/A1_AS:decode@aarch32/SMC/A1_AS:diagram
Decode: aarch32/SMC/T1_AS:decode@aarch32/SMC/T1_AS:diagram
TAG:aarch32/VNMLA/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNMLA/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '01' && !HaveFP16Ext() then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
vtype = VFPNegMul_VNMUL;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VNMLA/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNMLA/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '01' && !HaveFP16Ext() then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
vtype = VFPNegMul_VNMUL;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SMLALBB/A:execute
operand1 = if n_high then R[n][31:16] else R[n][15:0];
operand2 = if m_high then R[m][31:16] else R[m][15:0];
result = SInt(operand1) * SInt(operand2) + SInt(R[dHi]:R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
TAG:aarch32/SMLALBB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 10
20:20 _ 0
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:7 _ 1
6:6 M x
5:5 N x
4:4 _ 0
3:0 Rn xxxx
TAG:aarch32/SMLALBB/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
n_high = (N == '1');  m_high = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLALBB/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 100
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:6 _ 10
5:5 N x
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLALBB/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);
n_high = (N == '1');  m_high = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLALBB/A:index
Execute: aarch32/SMLALBB/A:execute
Decode: aarch32/SMLALBB/A1_A:decode@aarch32/SMLALBB/A1_A:diagram
Decode: aarch32/SMLALBB/T1_A:decode@aarch32/SMLALBB/T1_A:diagram
TAG:aarch32/VCVTA_vfp/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        S[d] = FPToFixed(S[m][15:0], 0, unsigned, FPSCR, rounding);
    when 32
        S[d] = FPToFixed(S[m], 0, unsigned, FPSCR, rounding);
    when 64
        S[d] = FPToFixed(D[m], 0, unsigned, FPSCR, rounding);
TAG:aarch32/VCVTA_vfp/A1_A:diagram
A32
31:23 _ 111111101
22:22 D x
21:19 _ 111
18:18 _ 1
17:16 RM 11
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTA_vfp/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
rounding = FPDecodeRM(RM);  unsigned = (op == '0');
d = UInt(Vd:D);
case size of
    when '01' esize = 16; m = UInt(Vm:M);
    when '10' esize = 32; m = UInt(Vm:M);
    when '11' esize = 64; m = UInt(M:Vm);

TAG:aarch32/VCVTA_vfp/T1_A:diagram
T32
31:23 _ 111111101
22:22 D x
21:19 _ 111
18:18 _ 1
17:16 RM 11
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 op x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTA_vfp/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
rounding = FPDecodeRM(RM);  unsigned = (op == '0');
d = UInt(Vd:D);
case size of
    when '01' esize = 16; m = UInt(Vm:M);
    when '10' esize = 32; m = UInt(Vm:M);
    when '11' esize = 64; m = UInt(M:Vm);

TAG:aarch32/VCVTA_vfp/A:index
Execute: aarch32/VCVTA_vfp/A:execute
Decode: aarch32/VCVTA_vfp/A1_A:decode@aarch32/VCVTA_vfp/A1_A:diagram
Decode: aarch32/VCVTA_vfp/T1_A:decode@aarch32/VCVTA_vfp/T1_A:diagram
TAG:aarch32/NOP/A:execute
// Do nothing
TAG:aarch32/NOP/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000000
TAG:aarch32/NOP/A1_A:decode
// No additional decoding required

TAG:aarch32/NOP/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0000
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/NOP/T1_A:decode
// No additional decoding required

TAG:aarch32/NOP/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0000
TAG:aarch32/NOP/T2_A:decode
// No additional decoding required

TAG:aarch32/NOP/A:index
Execute: aarch32/NOP/A:execute
Decode: aarch32/NOP/A1_A:decode@aarch32/NOP/A1_A:diagram
Decode: aarch32/NOP/T1_A:decode@aarch32/NOP/T1_A:diagram
Decode: aarch32/NOP/T2_A:decode@aarch32/NOP/T2_A:diagram
TAG:aarch32/CMN_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, '0');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMN_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/CMN_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/CMN_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1011
21:19 Rm xxx
18:16 Rn xxx
15:0 _ 0000000000000000
TAG:aarch32/CMN_r/T1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/CMN_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 1000
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 _ 1111
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/CMN_r/T2_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/CMN_r/A:index
Execute: aarch32/CMN_r/A:execute
Decode: aarch32/CMN_r/A1_A:decode@aarch32/CMN_r/A1_A:diagram
Decode: aarch32/CMN_r/T1_A:decode@aarch32/CMN_r/T1_A:diagram
Decode: aarch32/CMN_r/T2_A:decode@aarch32/CMN_r/T2_A:diagram
TAG:aarch32/VREV16/A:execute
CheckAdvSIMDEnabled();

bits(64) result;
integer element;
integer rev_element;
for r = 0 to regs-1
    element = 0;
    for c = 0 to containers-1
        rev_element = element + elements_per_container - 1;
        for e = 0 to elements_per_container-1
            Elem[result, rev_element, esize] = Elem[D[m+r], element, esize];
            element = element + 1;
            rev_element = rev_element - 1;
    D[d+r] = result;
TAG:aarch32/VREV16/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:9 _ 00
8:7 op 00
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VREV16/T1A1_A:decode
if UInt(op)+UInt(size) >= 3 then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;

esize = 8 << UInt(size);
integer container_size;
case op of
    when '10' container_size = 16;
    when '01' container_size = 32;
    when '00' container_size = 64;
integer containers = 64 DIV container_size;
integer elements_per_container = container_size DIV esize;

d = UInt(D:Vd); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

TAG:aarch32/VREV16/A:index
Execute: aarch32/VREV16/A:execute
Decode: aarch32/VREV16/T1A1_A:decode@aarch32/VREV16/T1A1_A:diagram
Decode: aarch32/VREV16/T1A1_A:decode@aarch32/VREV16/T1A1_A:diagram
TAG:aarch32/REV16/A:execute
bits(32) result;
result[31:24] = R[m][23:16];
result[23:16] = R[m][31:24];
result[15:8]  = R[m][7:0];
result[7:0]   = R[m][15:8];
R[d] = result;
TAG:aarch32/REV16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 11
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:4 _ 011
3:0 Rm xxxx
TAG:aarch32/REV16/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/REV16/T1_A:diagram
T16
31:24 _ 10111010
23:22 _ 01
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/REV16/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);

TAG:aarch32/REV16/T2_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 01
3:0 Rm xxxx
TAG:aarch32/REV16/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/REV16/A:index
Execute: aarch32/REV16/A:execute
Decode: aarch32/REV16/A1_A:decode@aarch32/REV16/A1_A:diagram
Decode: aarch32/REV16/T1_A:decode@aarch32/REV16/T1_A:diagram
Decode: aarch32/REV16/T2_A:decode@aarch32/REV16/T2_A:diagram
TAG:aarch32/VRSRA/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for r = 0 to regs-1
    for e = 0 to elements-1
        result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
        Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;
TAG:aarch32/VRSRA/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0011
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRSRA/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSRA/A:index
Execute: aarch32/VRSRA/A:execute
Decode: aarch32/VRSRA/T1A1_A:decode@aarch32/VRSRA/T1A1_A:diagram
Decode: aarch32/VRSRA/T1A1_A:decode@aarch32/VRSRA/T1A1_A:diagram
TAG:aarch32/SXTB/A:execute
rotated = ROR(R[m], rotation);
R[d] = SignExtend(rotated[7:0], 32);
TAG:aarch32/SXTB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 10
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTB/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTB/T1_A:diagram
T16
31:24 _ 10110010
23:23 _ 0
22:22 _ 1
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/SXTB/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

TAG:aarch32/SXTB/T2_A:diagram
T32
31:23 _ 111110100
22:21 _ 10
20:20 _ 0
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTB/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTB/A:index
Execute: aarch32/SXTB/A:execute
Decode: aarch32/SXTB/A1_A:decode@aarch32/SXTB/A1_A:diagram
Decode: aarch32/SXTB/T1_A:decode@aarch32/SXTB/T1_A:diagram
Decode: aarch32/SXTB/T2_A:decode@aarch32/SXTB/T2_A:diagram
TAG:aarch32/VST2_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
MemU[address,       ebytes] = Elem[D[d], index];
MemU[address+ebytes,ebytes] = Elem[D[d2],index];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 2*ebytes;
TAG:aarch32/VST2_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST2_1/T1A1_A:decode
if size == '11' then UNDEFINED;
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
alignment = if index_align[0] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VST2_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST2_1/T2A2_A:decode
if size == '11' then UNDEFINED;
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 4;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VST2_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST2_1/T3A3_A:decode
if size == '11' then UNDEFINED;
if index_align[1] != '0' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 8;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VST2_1/A:index
Execute: aarch32/VST2_1/A:execute
Decode: aarch32/VST2_1/T1A1_A:decode@aarch32/VST2_1/T1A1_A:diagram
Decode: aarch32/VST2_1/T2A2_A:decode@aarch32/VST2_1/T2A2_A:diagram
Decode: aarch32/VST2_1/T3A3_A:decode@aarch32/VST2_1/T3A3_A:diagram
Decode: aarch32/VST2_1/T1A1_A:decode@aarch32/VST2_1/T1A1_A:diagram
Decode: aarch32/VST2_1/T2A2_A:decode@aarch32/VST2_1/T2A2_A:diagram
Decode: aarch32/VST2_1/T3A3_A:decode@aarch32/VST2_1/T3A3_A:diagram
TAG:aarch32/VTBL/A:execute
CheckAdvSIMDEnabled();

// Create 256-bit = 32-byte table variable, with zeros in entries that will not be used.
table3 = if length == 4 then D[n+3] else Zeros(64);
table2 = if length >= 3 then D[n+2] else Zeros(64);
table1 = if length >= 2 then D[n+1] else Zeros(64);
table = table3 : table2 : table1 : D[n];

for i = 0 to 7
    index = UInt(Elem[D[m],i,8]);
    if index < 8*length then
        Elem[D[d],i,8] = Elem[table,index,8];
    else
        if is_vtbl then
            Elem[D[d],i,8] = Zeros(8);
        // else Elem[D[d],i,8] unchanged
TAG:aarch32/VTBL/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 len xx
7:7 N x
6:6 op x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VTBL/T1A1_A:decode
is_vtbl = (op == '0');  length = UInt(len)+1;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
if n+length > 32 then UNPREDICTABLE;

TAG:aarch32/VTBL/A:index
Execute: aarch32/VTBL/A:execute
Decode: aarch32/VTBL/T1A1_A:decode@aarch32/VTBL/T1A1_A:diagram
Decode: aarch32/VTBL/T1A1_A:decode@aarch32/VTBL/T1A1_A:diagram
TAG:aarch32/LDRT/A:execute
offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,4];
if postindex then R[n] = offset_addr;
R[t] = data;
TAG:aarch32/LDRT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/LDRT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/LDRT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(stype, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/LDRT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then SEE "LDR (literal)";
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRT/A:index
Execute: aarch32/LDRT/A:execute
Decode: aarch32/LDRT/A1_A:decode@aarch32/LDRT/A1_A:diagram
Decode: aarch32/LDRT/A2_A:decode@aarch32/LDRT/A2_A:diagram
Decode: aarch32/LDRT/T1_A:decode@aarch32/LDRT/T1_A:diagram
TAG:aarch32/SRS/AS:execute
if CurrentInstrSet() == InstrSet_A32 then
    if PSTATE.EL == EL2 then          // UNDEFINED at EL2
        UNDEFINED;
    
    // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
    // to be security holes
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;
    elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
        UNPREDICTABLE;
    elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
        if !HaveEL(EL3) || !IsSecure()  then
            UNPREDICTABLE;
        elsif !ELUsingAArch32(EL3) then
            AArch64.MonitorModeTrap();
    elsif BadMode(mode) then
        UNPREDICTABLE;
    
    base = Rmode[13,mode];
    address = if increment then base else base-8;
    if wordhigher then address = address+4;
    MemA[address,4]   = LR;
    MemA[address+4,4] = SPSR[];
    if wback then Rmode[13,mode] = if increment then base+8 else base-8;
else
    if PSTATE.EL == EL2 then          // UNDEFINED at EL2
        UNDEFINED;
    
    // Check for UNPREDICTABLE cases. The definition of UNPREDICTABLE does not permit these
    // to be security holes
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;
    elsif mode == M32_Hyp then        // Check for attempt to access Hyp mode SP
        UNPREDICTABLE;
    elsif mode == M32_Monitor then    // Check for attempt to access Monitor mode SP
        if !HaveEL(EL3) || !IsSecure()  then
            UNPREDICTABLE;
        elsif !ELUsingAArch32(EL3) then
            AArch64.MonitorModeTrap();
    elsif BadMode(mode) then
        UNPREDICTABLE;
    
    base = Rmode[13,mode];
    address = if increment then base else base-8;
    if wordhigher then address = address+4;
    MemA[address,4]   = LR;
    MemA[address+4,4] = SPSR[];
    if wback then Rmode[13,mode] = if increment then base+8 else base-8;
TAG:aarch32/SRS/A1_AS:diagram
A32
31:25 _ 1111100
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 _ (1)(1)(0)(1)
15:5 _ (0)(0)(0)(0)(0)(1)(0)(1)(0)(0)(0)
4:0 mode xxxxx
TAG:aarch32/SRS/A1_AS:decode
wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);

TAG:aarch32/SRS/T1_AS:diagram
T32
31:25 _ 1110100
24:23 _ 00
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 _ (1)(1)(0)(1)
15:15 _ (1)
14:14 _ (1)
13:5 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)
4:0 mode xxxxx
TAG:aarch32/SRS/T1_AS:decode
wback = (W == '1');  increment = FALSE;  wordhigher = FALSE;

TAG:aarch32/SRS/T2_AS:diagram
T32
31:25 _ 1110100
24:23 _ 11
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 _ (1)(1)(0)(1)
15:15 _ (1)
14:14 _ (1)
13:5 _ (0)(0)(0)(0)(0)(0)(0)(0)(0)
4:0 mode xxxxx
TAG:aarch32/SRS/T2_AS:decode
wback = (W == '1');  increment = TRUE;  wordhigher = FALSE;

TAG:aarch32/SRS/AS:index
Execute: aarch32/SRS/AS:execute
Decode: aarch32/SRS/A1_AS:decode@aarch32/SRS/A1_AS:diagram
Decode: aarch32/SRS/T1_AS:decode@aarch32/SRS/T1_AS:diagram
Decode: aarch32/SRS/T2_AS:decode@aarch32/SRS/T2_AS:diagram
TAG:aarch32/ADD_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    (result, nzcv) = AddWithCarry(R[n], imm32, '0');
    if d == 15 then          // Can only occur for A32 encoding
        if setflags then
            ALUExceptionReturn(result);
        else
            ALUWritePC(result);
    else
        R[d] = result;
        if setflags then
            PSTATE.[N,Z,C,V] = nzcv;
else
    (result, nzcv) = AddWithCarry(R[n], imm32, '0');
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADD_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 100
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ADD_i/A1_A:decode
if Rn == '1111' && S == '0' then SEE "ADR";
if Rn == '1101' then SEE "ADD (SP plus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/ADD_i/T1_A:diagram
T16
31:26 _ 000111
25:25 _ 0
24:22 imm3 xxx
21:19 Rn xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm3, 32);

TAG:aarch32/ADD_i/T2_A:diagram
T16
31:29 _ 001
28:27 _ 10
26:24 Rdn xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_i/T2_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);

TAG:aarch32/ADD_i/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1000
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADD_i/T3_A:decode
if Rd == '1111' && S == '1' then SEE "CMN (immediate)";
if Rn == '1101' then SEE "ADD (SP plus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADD_i/T4_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 0
22:22 _ 0
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADD_i/T4_A:decode
if Rn == '1111' then SEE "ADR";
if Rn == '1101' then SEE "ADD (SP plus immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE;   // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADD_i/A:index
Execute: aarch32/ADD_i/A:execute
Decode: aarch32/ADD_i/A1_A:decode@aarch32/ADD_i/A1_A:diagram
Decode: aarch32/ADD_i/T1_A:decode@aarch32/ADD_i/T1_A:diagram
Decode: aarch32/ADD_i/T2_A:decode@aarch32/ADD_i/T2_A:diagram
Decode: aarch32/ADD_i/T3_A:decode@aarch32/ADD_i/T3_A:diagram
Decode: aarch32/ADD_i/T4_A:decode@aarch32/ADD_i/T4_A:diagram
TAG:aarch32/VMAXNM/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then             // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            op1 = Elem[D[n+r], e, esize]; op2 = Elem[D[m+r], e, esize];
            if maximum then
                Elem[D[d+r], e, esize] = FPMaxNum(op1, op2, StandardFPSCRValue());
            else
                Elem[D[d+r], e, esize] = FPMinNum(op1, op2, StandardFPSCRValue());
else                        // VFP instruction
    case esize of
        when 16
            if maximum then
                S[d] = Zeros(16) : FPMaxNum(S[n][15:0], S[m][15:0], FPSCR);
            else
                S[d] = Zeros(16) : FPMinNum(S[n][15:0], S[m][15:0], FPSCR);
        when 32
            if maximum then
                S[d] = FPMaxNum(S[n], S[m], FPSCR);
            else
                S[d] = FPMinNum(S[n], S[m], FPSCR);
        when 64
            if maximum then
                D[d] = FPMaxNum(D[n], D[m], FPSCR);
            else
                D[d] = FPMinNum(D[n], D[m], FPSCR);
TAG:aarch32/VMAXNM/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMAXNM/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
maximum = (op == '0');
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMAXNM/A2_A:diagram
A32
31:23 _ 111111101
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMAXNM/A2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
advsimd = FALSE;
maximum = (op == '0');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMAXNM/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 op 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMAXNM/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
maximum = (op == '0');
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMAXNM/T2_A:diagram
T32
31:23 _ 111111101
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMAXNM/T2_A:decode
if InITBlock() then UNPREDICTABLE;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
advsimd = FALSE;
maximum = (op == '0');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMAXNM/A:index
Execute: aarch32/VMAXNM/A:execute
Decode: aarch32/VMAXNM/A1_A:decode@aarch32/VMAXNM/A1_A:diagram
Decode: aarch32/VMAXNM/A2_A:decode@aarch32/VMAXNM/A2_A:diagram
Decode: aarch32/VMAXNM/T1_A:decode@aarch32/VMAXNM/T1_A:diagram
Decode: aarch32/VMAXNM/T2_A:decode@aarch32/VMAXNM/T2_A:diagram
TAG:aarch32/MRS/AS:execute
if read_spsr then
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;
    else
        R[d] = SPSR[];
else
    // CPSR has same bit assignments as SPSR, but with the IT, J, SS, IL, and T bits masked out.
    bits(32) mask = '11111000 00001111 00000011 11011111';
    if HavePANExt() then
        mask[22] = '1';

    if HaveDITExt() then
        mask[21] = '1';
    psr_val = GetPSRFromPSTATE() AND mask;
    if PSTATE.EL == EL0 then
        // If accessed from User mode return UNKNOWN values for E, A, I, F bits, bits[9:6],
        // and for the M field, bits[4:0]
        psr_val[22] = bits(1) UNKNOWN;
        psr_val[9:6] = bits(4) UNKNOWN;
        psr_val[4:0] = bits(5) UNKNOWN;
    R[d] = psr_val;
TAG:aarch32/MRS/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:22 R x
21:21 _ 0
20:20 _ 0
19:16 _ (1)(1)(1)(1)
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ 0
8:8 _ (0)
7:4 _ 0000
3:0 _ (0)(0)(0)(0)
TAG:aarch32/MRS/A1_AS:decode
d = UInt(Rd);  read_spsr = (R == '1');
if d == 15 then UNPREDICTABLE;

TAG:aarch32/MRS/T1_AS:diagram
T32
31:21 _ 11110011111
20:20 R x
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:8 Rd xxxx
7:7 _ (0)
6:6 _ (0)
5:5 _ 0
4:4 _ (0)
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/MRS/T1_AS:decode
d = UInt(Rd);  read_spsr = (R == '1');
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MRS/AS:index
Execute: aarch32/MRS/AS:execute
Decode: aarch32/MRS/A1_AS:decode@aarch32/MRS/A1_AS:diagram
Decode: aarch32/MRS/T1_AS:decode@aarch32/MRS/T1_AS:diagram
TAG:aarch32/VMSR/AS:execute
if reg == '0001' then                 // FPSCR
    CheckVFPEnabled(TRUE);
    FPSCR = R[t];
elsif PSTATE.EL == EL0 then
    UNDEFINED;                        // Non-FPSCR registers accessible only at PL1 or above
else
    CheckVFPEnabled(FALSE);           // Non-FPSCR registers are not affected by FPEXC.EN
    case reg of
        when '0000'                   // VMSR access to FPSID is ignored
        when '1000'  FPEXC = R[t];
        otherwise    Unreachable();   // Dealt with above or in encoding-specific pseudocode
TAG:aarch32/VMSR/T1A1_AS:diagram
A32
31:28 cond xxxx
27:21 _ 1110111
20:20 _ 0
19:16 reg xxxx
15:12 Rt xxxx
11:8 _ 1010
7:7 _ (0)
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMSR/T1A1_AS:decode
t = UInt(Rt);
if reg != '000x' && reg != '1000' then UNPREDICTABLE;
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMSR/AS:index
Execute: aarch32/VMSR/AS:execute
Decode: aarch32/VMSR/T1A1_AS:decode@aarch32/VMSR/T1A1_AS:diagram
Decode: aarch32/VMSR/T1A1_AS:decode@aarch32/VMSR/T1A1_AS:diagram
TAG:aarch32/DCPS2/A:execute
if !Halted() || IsSecure() then UNDEFINED;

if ELUsingAArch32(EL2) then
    AArch32.WriteMode(M32_Hyp);
    PSTATE.E = HSCTLR.EE;

    ELR_hyp = bits(32) UNKNOWN;
    HSR = bits(32) UNKNOWN;
    SPSR_hyp = bits(32) UNKNOWN;

    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
else                                        // Targeting EL2 using AArch64
    AArch64.MaybeZeroRegisterUppers();
    MaybeZeroSVEUppers(EL2);
    PSTATE.nRW = '0';
    PSTATE.SP = '1';
    PSTATE.EL = EL2;
    if HavePANExt() && SCTLR_EL2.SPAN == '0' && HCR_EL2.E2H == '1' && HCR_EL2.TGE == '1' then
        PSTATE.PAN = '1';
    if HaveUAOExt() then PSTATE.UAO = '0';

    ELR_EL2 = bits(64) UNKNOWN;
    ESR_EL2 = bits(32) UNKNOWN;
    SPSR_EL2 = bits(32) UNKNOWN;

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    // SCTLR_EL2.IESB might be ignored in Debug state.
    if HaveIESB() && SCTLR_EL2.IESB == '1' && !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then
        SynchronizeErrors();

UpdateEDSCRFields();                        // Update EDSCR PE state flags
TAG:aarch32/DCPS2/T1_A:diagram
T32
31:20 _ 111101111000
19:16 _ 1111
15:12 _ 1000
11:2 _ 0000000000
1:0 _ 10
TAG:aarch32/DCPS2/T1_A:decode
if !HaveEL(EL2) then UNDEFINED;

TAG:aarch32/DCPS2/A:index
Execute: aarch32/DCPS2/A:execute
Decode: aarch32/DCPS2/T1_A:decode@aarch32/DCPS2/T1_A:diagram
TAG:aarch32/VST3_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];
MemU[address,         ebytes] = Elem[D[d], index];
MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 3*ebytes;
TAG:aarch32/VST3_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST3_1/T1A1_A:decode
if size == '11' then UNDEFINED;
if index_align[0] != '0' then UNDEFINED;
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VST3_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST3_1/T2A2_A:decode
if size == '11' then UNDEFINED;
if index_align[0] != '0' then UNDEFINED;
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VST3_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST3_1/T3A3_A:decode
if size == '11' then UNDEFINED;
if index_align[1:0] != '00' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VST3_1/A:index
Execute: aarch32/VST3_1/A:execute
Decode: aarch32/VST3_1/T1A1_A:decode@aarch32/VST3_1/T1A1_A:diagram
Decode: aarch32/VST3_1/T2A2_A:decode@aarch32/VST3_1/T2A2_A:diagram
Decode: aarch32/VST3_1/T3A3_A:decode@aarch32/VST3_1/T3A3_A:diagram
Decode: aarch32/VST3_1/T1A1_A:decode@aarch32/VST3_1/T1A1_A:diagram
Decode: aarch32/VST3_1/T2A2_A:decode@aarch32/VST3_1/T2A2_A:diagram
Decode: aarch32/VST3_1/T3A3_A:decode@aarch32/VST3_1/T3A3_A:diagram
TAG:aarch32/BXJ/A:execute
BXWritePC(R[m], BranchType_INDIR);
TAG:aarch32/BXJ/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 00010010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0010
3:0 Rm xxxx
TAG:aarch32/BXJ/A1_A:decode
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;

TAG:aarch32/BXJ/T1_A:diagram
T32
31:20 _ 111100111100
19:16 Rm xxxx
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ (0)
6:6 _ (0)
5:5 _ (0)
4:4 _ (0)
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/BXJ/T1_A:decode
m = UInt(Rm);
if m == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/BXJ/A:index
Execute: aarch32/BXJ/A:execute
Decode: aarch32/BXJ/A1_A:decode@aarch32/BXJ/A1_A:diagram
Decode: aarch32/BXJ/T1_A:decode@aarch32/BXJ/T1_A:diagram
TAG:aarch32/VSTR/A:execute
CheckVFPEnabled(TRUE);
address = if add then (R[n] + imm32) else (R[n] - imm32);
case esize of
    when 16
        MemA[address,2] = S[d][15:0];
    when 32
        MemA[address,4] = S[d];
    when 64
        // Store as two word-aligned words in the correct order for current endianness.
        MemA[address,4]   = if BigEndian() then D[d][63:32] else D[d][31:0];
        MemA[address+4,4] = if BigEndian() then D[d][31:0]  else D[d][63:32];
TAG:aarch32/VSTR/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 _ 1
23:23 U x
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:0 imm8 xxxxxxxx
TAG:aarch32/VSTR/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
esize = 8 << UInt(size);  add = (U == '1');
imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
case size of
    when '01' d = UInt(Vd:D);
    when '10' d = UInt(Vd:D);
    when '11' d = UInt(D:Vd);
n = UInt(Rn);
if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

TAG:aarch32/VSTR/T1_A:diagram
T32
31:25 _ 1110110
24:24 _ 1
23:23 U x
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:0 imm8 xxxxxxxx
TAG:aarch32/VSTR/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
esize = 8 << UInt(size);  add = (U == '1');
imm32 = if esize == 16 then ZeroExtend(imm8:'0', 32) else ZeroExtend(imm8:'00', 32);
case size of
    when '01' d = UInt(Vd:D);
    when '10' d = UInt(Vd:D);
    when '11' d = UInt(D:Vd);
n = UInt(Rn);
if n == 15 && CurrentInstrSet() != InstrSet_A32 then UNPREDICTABLE;

TAG:aarch32/VSTR/A:index
Execute: aarch32/VSTR/A:execute
Decode: aarch32/VSTR/A1_A:decode@aarch32/VSTR/A1_A:diagram
Decode: aarch32/VSTR/T1_A:decode@aarch32/VSTR/T1_A:diagram
TAG:aarch32/VCGT_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
        case vtype of
            when VCGTtype_signed    test_passed = (SInt(op1) > SInt(op2));
            when VCGTtype_unsigned  test_passed = (UInt(op1) > UInt(op2));
            when VCGTtype_fp        test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCGT_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGT_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
vtype = if U == '1' then VCGTtype_unsigned else VCGTtype_signed;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGT_r/A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGT_r/A2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
vtype = VCGTtype_fp;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGT_r/T2_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGT_r/T2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
vtype = VCGTtype_fp;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGT_r/A:index
Execute: aarch32/VCGT_r/A:execute
Decode: aarch32/VCGT_r/T1A1_A:decode@aarch32/VCGT_r/T1A1_A:diagram
Decode: aarch32/VCGT_r/A2_A:decode@aarch32/VCGT_r/A2_A:diagram
Decode: aarch32/VCGT_r/T1A1_A:decode@aarch32/VCGT_r/T1A1_A:diagram
Decode: aarch32/VCGT_r/T2_A:decode@aarch32/VCGT_r/T2_A:diagram
TAG:aarch32/VQSHRN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
    (result, sat) = SatQ(operand >> shift_amount, esize, dest_unsigned);
    Elem[D[d],e,esize] = result;
    if sat then FPSCR.QC = '1';
TAG:aarch32/VQSHRN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:9 _ 100
8:8 op x
7:7 _ 0
6:6 _ 0
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQSHRN/T1A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if U == '0' && op == '0' then SEE "VSHRN";
if Vm[0] == '1' then UNDEFINED;
case imm6 of
    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VQSHRN/A:index
Execute: aarch32/VQSHRN/A:execute
Decode: aarch32/VQSHRN/T1A1_A:decode@aarch32/VQSHRN/T1A1_A:diagram
Decode: aarch32/VQSHRN/T1A1_A:decode@aarch32/VQSHRN/T1A1_A:diagram
TAG:aarch32/VMAX_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Int(Elem[D[n+r],e,esize], unsigned);
        op2 = Int(Elem[D[m+r],e,esize], unsigned);
        result = if maximum then Max(op1,op2) else Min(op1,op2);
        Elem[D[d+r],e,esize] = result[esize-1:0];
TAG:aarch32/VMAX_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0110
7:7 N x
6:6 Q x
5:5 M x
4:4 op 1
3:0 Vm xxxx
TAG:aarch32/VMAX_i/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
maximum = (op == '0');  unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMAX_i/A:index
Execute: aarch32/VMAX_i/A:execute
Decode: aarch32/VMAX_i/T1A1_A:decode@aarch32/VMAX_i/T1A1_A:diagram
Decode: aarch32/VMAX_i/T1A1_A:decode@aarch32/VMAX_i/T1A1_A:diagram
TAG:aarch32/UQSAX/A:execute
sum  = UInt(R[n][15:0]) + UInt(R[m][31:16]);
diff = UInt(R[n][31:16]) - UInt(R[m][15:0]);
R[d][15:0]  = UnsignedSat(sum, 16);
R[d][31:16] = UnsignedSat(diff, 16);
TAG:aarch32/UQSAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQSAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQSAX/A:index
Execute: aarch32/UQSAX/A:execute
Decode: aarch32/UQSAX/A1_A:decode@aarch32/UQSAX/A1_A:diagram
Decode: aarch32/UQSAX/T1_A:decode@aarch32/UQSAX/T1_A:diagram
TAG:aarch32/VQMOVN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
    (Elem[D[d],e,esize], sat) = SatQ(operand, esize, dest_unsigned);
    if sat then FPSCR.QC = '1';
TAG:aarch32/VQMOVN/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:8 _ 010
7:6 op xx
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQMOVN/T1A1_A:decode
if op == '00' then SEE "VMOVN";
if size == '11' || Vm[0] == '1' then UNDEFINED;
src_unsigned = (op == '11');  dest_unsigned = (op[0] == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VQMOVN/A:index
Execute: aarch32/VQMOVN/A:execute
Decode: aarch32/VQMOVN/T1A1_A:decode@aarch32/VQMOVN/T1A1_A:diagram
Decode: aarch32/VQMOVN/T1A1_A:decode@aarch32/VQMOVN/T1A1_A:diagram
TAG:aarch32/UHADD8/A:execute
sum1 = UInt(R[n][7:0]) + UInt(R[m][7:0]);
sum2 = UInt(R[n][15:8]) + UInt(R[m][15:8]);
sum3 = UInt(R[n][23:16]) + UInt(R[m][23:16]);
sum4 = UInt(R[n][31:24]) + UInt(R[m][31:24]);
R[d][7:0]   = sum1[8:1];
R[d][15:8]  = sum2[8:1];
R[d][23:16] = sum3[8:1];
R[d][31:24] = sum4[8:1];
TAG:aarch32/UHADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHADD8/A:index
Execute: aarch32/UHADD8/A:execute
Decode: aarch32/UHADD8/A1_A:decode@aarch32/UHADD8/A1_A:diagram
Decode: aarch32/UHADD8/T1_A:decode@aarch32/UHADD8/T1_A:diagram
TAG:aarch32/MOVT/A:execute
R[d][31:16] = imm16;
// R[d][15:0] unchanged
TAG:aarch32/MOVT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 1
21:20 _ 00
19:16 imm4 xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/MOVT/A1_A:decode
d = UInt(Rd);  imm16 = imm4:imm12;
if d == 15 then UNPREDICTABLE;

TAG:aarch32/MOVT/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 1
22:20 _ 100
19:16 imm4 xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/MOVT/T1_A:decode
d = UInt(Rd);  imm16 = imm4:i:imm3:imm8;
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MOVT/A:index
Execute: aarch32/MOVT/A:execute
Decode: aarch32/MOVT/A1_A:decode@aarch32/MOVT/A1_A:diagram
Decode: aarch32/MOVT/T1_A:decode@aarch32/MOVT/T1_A:diagram
TAG:aarch32/SEVL/A:execute
SendEventLocal();
TAG:aarch32/SEVL/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000101
TAG:aarch32/SEVL/A1_A:decode
// No additional decoding required

TAG:aarch32/SEVL/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0101
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/SEVL/T1_A:decode
// No additional decoding required

TAG:aarch32/SEVL/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0101
TAG:aarch32/SEVL/T2_A:decode
// No additional decoding required

TAG:aarch32/SEVL/A:index
Execute: aarch32/SEVL/A:execute
Decode: aarch32/SEVL/A1_A:decode@aarch32/SEVL/A1_A:diagram
Decode: aarch32/SEVL/T1_A:decode@aarch32/SEVL/T1_A:diagram
Decode: aarch32/SEVL/T2_A:decode@aarch32/SEVL/T2_A:diagram
TAG:aarch32/VZIP/A:execute
CheckAdvSIMDEnabled();
if quadword_operation then
    if d == m then
        Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
    else
        bits(256) zipped_q;
        for e = 0 to (128 DIV esize) - 1
            Elem[zipped_q,2*e,esize] = Elem[Q[d>>1],e,esize];
            Elem[zipped_q,2*e+1,esize] = Elem[Q[m>>1],e,esize];
        Q[d>>1] = zipped_q[127:0];  Q[m>>1] = zipped_q[255:128];
else
    if d == m then
        D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
    else
        bits(128) zipped_d;
        for e = 0 to (64 DIV esize) - 1
            Elem[zipped_d,2*e,esize] = Elem[D[d],e,esize];
            Elem[zipped_d,2*e+1,esize] = Elem[D[m],e,esize];
        D[d] = zipped_d[63:0];  D[m] = zipped_d[127:64];
TAG:aarch32/VZIP/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VZIP/T1A1_A:decode
if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
quadword_operation = (Q == '1');  esize = 8 << UInt(size);
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VZIP/A:index
Execute: aarch32/VZIP/A:execute
Decode: aarch32/VZIP/T1A1_A:decode@aarch32/VZIP/T1A1_A:diagram
Decode: aarch32/VZIP/T1A1_A:decode@aarch32/VZIP/T1A1_A:diagram
TAG:aarch32/VABA/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[Din[n+r],e,esize];
        op2 = Elem[Din[m+r],e,esize];
        absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
        if long_destination then
            Elem[Q[d>>1],e,2*esize] = Elem[Qin[d>>1],e,2*esize] + absdiff;
        else
            Elem[D[d+r],e,esize] = Elem[Din[d+r],e,esize] + absdiff;
TAG:aarch32/VABA/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0101
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABA/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if Vd[0] == '1' then UNDEFINED;
unsigned = (U == '1');  long_destination = TRUE;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

TAG:aarch32/VABA/A:index
Execute: aarch32/VABA/A:execute
Decode: aarch32/VABA/T2A2_A:decode@aarch32/VABA/T2A2_A:diagram
Decode: aarch32/VABA/T2A2_A:decode@aarch32/VABA/T2A2_A:diagram
TAG:aarch32/UADD8/A:execute
sum1 = UInt(R[n][7:0]) + UInt(R[m][7:0]);
sum2 = UInt(R[n][15:8]) + UInt(R[m][15:8]);
sum3 = UInt(R[n][23:16]) + UInt(R[m][23:16]);
sum4 = UInt(R[n][31:24]) + UInt(R[m][31:24]);
R[d][7:0]   = sum1[7:0];
R[d][15:8]  = sum2[7:0];
R[d][23:16] = sum3[7:0];
R[d][31:24] = sum4[7:0];
PSTATE.GE[0]  = if sum1 >= 0x100 then '1' else '0';
PSTATE.GE[1]  = if sum2 >= 0x100 then '1' else '0';
PSTATE.GE[2]  = if sum3 >= 0x100 then '1' else '0';
PSTATE.GE[3]  = if sum4 >= 0x100 then '1' else '0';
TAG:aarch32/UADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m  == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UADD8/A:index
Execute: aarch32/UADD8/A:execute
Decode: aarch32/UADD8/A1_A:decode@aarch32/UADD8/A1_A:diagram
Decode: aarch32/UADD8/T1_A:decode@aarch32/UADD8/T1_A:diagram
TAG:aarch32/SHA256SU1/A:execute
CheckCryptoEnabled32();
bits(128) result;
X = Q[d>>1]; Y = Q[n>>1]; Z = Q[m>>1];
T0 = Z[31:0] : Y[127:32];

T1 = Z[127:64];
for e = 0 to 1
    elt = Elem[T1, e, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

T1 = result[63:0];
for e = 2 to 3
    elt = Elem[T1, e - 2, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[X, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

Q[d>>1] = result;
TAG:aarch32/SHA256SU1/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256SU1/A1_A:decode
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256SU1/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256SU1/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256SU1/A:index
Execute: aarch32/SHA256SU1/A:execute
Decode: aarch32/SHA256SU1/A1_A:decode@aarch32/SHA256SU1/A1_A:diagram
Decode: aarch32/SHA256SU1/T1_A:decode@aarch32/SHA256SU1/T1_A:diagram
TAG:aarch32/MOV_rr/A:execute
shift_n = UInt(R[s][7:0]);
(result, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/MOV_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/MOV_rr/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/MOV_rr/T1_A:diagram
T16
31:26 _ 010000
25:22 op 0xxx
21:19 Rs xxx
18:16 Rdm xxx
15:0 _ 0000000000000000
TAG:aarch32/MOV_rr/T1_A:decode
if !(op IN {'0010', '0011', '0100', '0111'}) then SEE "Related encodings";
d = UInt(Rdm);  m = UInt(Rdm);  s = UInt(Rs);
setflags = !InITBlock();  shift_t = DecodeRegShift(op[2]:op[0]);

TAG:aarch32/MOV_rr/T2_A:diagram
T32
31:23 _ 111110100
22:21 stype xx
20:20 S x
19:16 Rm xxxx
15:12 _ 1111
11:8 Rd xxxx
7:4 _ 0000
3:0 Rs xxxx
TAG:aarch32/MOV_rr/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || m == 15 || s == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MOV_rr/A:index
Execute: aarch32/MOV_rr/A:execute
Decode: aarch32/MOV_rr/A1_A:decode@aarch32/MOV_rr/A1_A:diagram
Decode: aarch32/MOV_rr/T1_A:decode@aarch32/MOV_rr/T1_A:diagram
Decode: aarch32/MOV_rr/T2_A:decode@aarch32/MOV_rr/T2_A:diagram
TAG:aarch32/MRRC/A:execute
value = AArch32.SysRegRead64(cp, ThisInstr());
R[t] = value[31:0];
R[t2] = value[63:32];
TAG:aarch32/MRRC/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11000
22:22 _ 1
21:21 _ 0
20:20 _ 1
19:16 Rt2 xxxx
15:12 Rt xxxx
11:8 coproc 111x
7:4 opc1 xxxx
3:0 CRm xxxx
TAG:aarch32/MRRC/T1A1_A:decode
t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc[0] == '0' then 14 else 15;
if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MRRC/A:index
Execute: aarch32/MRRC/A:execute
Decode: aarch32/MRRC/T1A1_A:decode@aarch32/MRRC/T1A1_A:diagram
Decode: aarch32/MRRC/T1A1_A:decode@aarch32/MRRC/T1A1_A:diagram
TAG:aarch32/VRHADD/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Int(Elem[D[n+r],e,esize], unsigned);
        op2 = Int(Elem[D[m+r],e,esize], unsigned);
        result = op1 + op2 + 1;
        Elem[D[d+r],e,esize] = result[esize:1];
TAG:aarch32/VRHADD/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRHADD/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRHADD/A:index
Execute: aarch32/VRHADD/A:execute
Decode: aarch32/VRHADD/T1A1_A:decode@aarch32/VRHADD/T1A1_A:diagram
Decode: aarch32/VRHADD/T1A1_A:decode@aarch32/VRHADD/T1A1_A:diagram
TAG:aarch32/BFI/A:execute
if msbit >= lsbit then
    R[d][msbit:lsbit] = R[n][(msbit-lsbit):0];
    // Other bits of R[d] are unchanged
else
    UNPREDICTABLE;
TAG:aarch32/BFI/A1_A:diagram
A32
31:28 cond xxxx
27:21 _ 0111110
20:16 msb xxxxx
15:12 Rd xxxx
11:7 lsb xxxxx
6:4 _ 001
3:0 Rn xxxx
TAG:aarch32/BFI/A1_A:decode
if Rn == '1111' then SEE "BFC";
d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(lsb);
if d == 15 then UNPREDICTABLE;

TAG:aarch32/BFI/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 01
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 msb xxxxx
TAG:aarch32/BFI/T1_A:decode
if Rn == '1111' then SEE "BFC";
d = UInt(Rd);  n = UInt(Rn);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/BFI/A:index
Execute: aarch32/BFI/A:execute
Decode: aarch32/BFI/A1_A:decode@aarch32/BFI/A1_A:diagram
Decode: aarch32/BFI/T1_A:decode@aarch32/BFI/T1_A:diagram
TAG:aarch32/VMUL_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
        op2 = Elem[Din[m+r],e,esize];  op2val = Int(op2, unsigned);
        if polynomial then
            product = PolynomialMult(op1,op2);
        else
            product = (op1val*op2val)[2*esize-1:0];
        if long_destination then
            Elem[Q[d>>1],e,2*esize] = product;
        else
            Elem[D[d+r],e,esize] = product[esize-1:0];
TAG:aarch32/VMUL_i/A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 11
9:9 op x
8:8 _ 0
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_i/A2_A:decode
if size == '11' then SEE "Related encodings";
unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
esize = 8 << UInt(size); elements = 64 DIV esize;
if polynomial then
    if U == '1' || size == '01' then UNDEFINED;
    if size == '10' then    // .p64
        if !HaveBit128PMULLExt() then UNDEFINED;
        esize = 64; elements = 1;
if Vd[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

TAG:aarch32/VMUL_i/T2_A:diagram
T32
31:29 _ 111
28:28 U x
27:23 _ 11111
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 11
9:9 op x
8:8 _ 0
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_i/T2_A:decode
if size == '11' then SEE "Related encodings";
unsigned = (U == '1'); polynomial = (op == '1'); long_destination = TRUE;
esize = 8 << UInt(size); elements = 64 DIV esize;
if polynomial then
    if U == '1' || size == '01' then UNDEFINED;
    if size == '10' then    // .p64
        if InITBlock() then UNPREDICTABLE;
        if !HaveBit128PMULLExt() then UNDEFINED;
        esize = 64; elements = 1;
if Vd[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm); regs = 1;

TAG:aarch32/VMUL_i/A:index
Execute: aarch32/VMUL_i/A:execute
Decode: aarch32/VMUL_i/A2_A:decode@aarch32/VMUL_i/A2_A:diagram
Decode: aarch32/VMUL_i/T2_A:decode@aarch32/VMUL_i/T2_A:diagram
TAG:aarch32/SBC_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SBC_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 110
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SBC_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/SBC_rr/A:index
Execute: aarch32/SBC_rr/A:execute
Decode: aarch32/SBC_rr/A1_A:decode@aarch32/SBC_rr/A1_A:diagram
TAG:aarch32/USADA8/A:execute
absdiff1 = Abs(UInt(R[n][7:0])   - UInt(R[m][7:0]));
absdiff2 = Abs(UInt(R[n][15:8])  - UInt(R[m][15:8]));
absdiff3 = Abs(UInt(R[n][23:16]) - UInt(R[m][23:16]));
absdiff4 = Abs(UInt(R[n][31:24]) - UInt(R[m][31:24]));
result = UInt(R[a]) + absdiff1 + absdiff2 + absdiff3 + absdiff4;
R[d] = result[31:0];
TAG:aarch32/USADA8/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 01111000
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:4 _ 0001
3:0 Rn xxxx
TAG:aarch32/USADA8/A1_A:decode
if Ra == '1111' then SEE "USAD8";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/USADA8/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 111
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/USADA8/T1_A:decode
if Ra == '1111' then SEE "USAD8";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USADA8/A:index
Execute: aarch32/USADA8/A:execute
Decode: aarch32/USADA8/A1_A:decode@aarch32/USADA8/A1_A:diagram
Decode: aarch32/USADA8/T1_A:decode@aarch32/USADA8/T1_A:diagram
TAG:aarch32/VQRDMULH/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = SInt(Elem[D[n+r],e,esize]);
        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
        (result, sat) = SignedSatQ((2*op1*op2 + round_const) >> esize, esize);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQRDMULH/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMULH/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRDMULH/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMULH/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQRDMULH/A:index
Execute: aarch32/VQRDMULH/A:execute
Decode: aarch32/VQRDMULH/T1A1_A:decode@aarch32/VQRDMULH/T1A1_A:diagram
Decode: aarch32/VQRDMULH/T2A2_A:decode@aarch32/VQRDMULH/T2A2_A:diagram
Decode: aarch32/VQRDMULH/T1A1_A:decode@aarch32/VQRDMULH/T1A1_A:diagram
Decode: aarch32/VQRDMULH/T2A2_A:decode@aarch32/VQRDMULH/T2A2_A:diagram
TAG:aarch32/VABD_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[Din[n+r],e,esize];
        op2 = Elem[Din[m+r],e,esize];
        absdiff = Abs(Int(op1,unsigned) - Int(op2,unsigned));
        if long_destination then
            Elem[Q[d>>1],e,2*esize] = absdiff[2*esize-1:0];
        else
            Elem[D[d+r],e,esize] = absdiff[esize-1:0];
TAG:aarch32/VABD_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABD_i/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (U == '1');  long_destination = FALSE;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VABD_i/A:index
Execute: aarch32/VABD_i/A:execute
Decode: aarch32/VABD_i/T1A1_A:decode@aarch32/VABD_i/T1A1_A:diagram
Decode: aarch32/VABD_i/T1A1_A:decode@aarch32/VABD_i/T1A1_A:diagram
TAG:aarch32/LDRB_l/A:execute
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
R[t] = ZeroExtend(MemU[address,1], 32);
TAG:aarch32/LDRB_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRB_l/A1_A:decode
if P == '0' && W == '1' then SEE "LDRBT";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || wback then UNPREDICTABLE;

TAG:aarch32/LDRB_l/T1_A:diagram
T32
31:24 _ 11111000
23:23 U x
22:21 _ 00
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRB_l/T1_A:decode
if Rt == '1111' then SEE "PLD";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRB_l/A:index
Execute: aarch32/LDRB_l/A:execute
Decode: aarch32/LDRB_l/A1_A:decode@aarch32/LDRB_l/A1_A:diagram
Decode: aarch32/LDRB_l/T1_A:decode@aarch32/LDRB_l/T1_A:diagram
TAG:aarch32/USAT16/A:execute
(result1, sat1) = UnsignedSatQ(SInt(R[n][15:0]), saturate_to);
(result2, sat2) = UnsignedSatQ(SInt(R[n][31:16]), saturate_to);
R[d][15:0] = ZeroExtend(result1, 16);
R[d][31:16] = ZeroExtend(result2, 16);
if sat1 || sat2 then
    PSTATE.Q = '1';
TAG:aarch32/USAT16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 10
19:16 sat_imm xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0011
3:0 Rn xxxx
TAG:aarch32/USAT16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/USAT16/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 10
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 _ 000
11:8 Rd xxxx
7:6 _ 00
5:5 _ (0)
4:4 _ (0)
3:0 sat_imm xxxx
TAG:aarch32/USAT16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USAT16/A:index
Execute: aarch32/USAT16/A:execute
Decode: aarch32/USAT16/A1_A:decode@aarch32/USAT16/A1_A:diagram
Decode: aarch32/USAT16/T1_A:decode@aarch32/USAT16/T1_A:diagram
TAG:aarch32/VDOT_bf16/A:execute
bits(64) operand1;
bits(64) operand2;
bits(64) result;

CheckAdvSIMDEnabled();

for r = 0 to regs-1
    operand1 = Din[n+r];
    operand2 = Din[m+r];
    result = Din[d+r];
    for e = 0 to 1
        bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
        bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
        bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];
        bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];
        bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
        Elem[result, e, 32] = BFAdd(Elem[result, e, 32], sum);
    D[d+r] = result;
TAG:aarch32/VDOT_bf16/A1_A:diagram
A32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDOT_bf16/A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_bf16/T1_A:diagram
T32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDOT_bf16/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32BF16Ext() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_bf16/A:index
Execute: aarch32/VDOT_bf16/A:execute
Decode: aarch32/VDOT_bf16/A1_A:decode@aarch32/VDOT_bf16/A1_A:diagram
Decode: aarch32/VDOT_bf16/T1_A:decode@aarch32/VDOT_bf16/T1_A:diagram
TAG:aarch32/VCLS/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = CountLeadingSignBits(Elem[D[m+r],e,esize])[esize-1:0];
TAG:aarch32/VCLS/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1000
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLS/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLS/A:index
Execute: aarch32/VCLS/A:execute
Decode: aarch32/VCLS/T1A1_A:decode@aarch32/VCLS/T1A1_A:diagram
Decode: aarch32/VCLS/T1A1_A:decode@aarch32/VCLS/T1A1_A:diagram
TAG:aarch32/VBIC_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[d+r] AND NOT(imm64);
TAG:aarch32/VBIC_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 0xx1
7:7 _ 0
6:6 Q x
5:5 _ 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VBIC_i/T1A1_A:decode
if cmode[0] == '0' || cmode[3:2] == '11' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VBIC_i/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 10x1
7:7 _ 0
6:6 Q x
5:5 _ 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VBIC_i/T2A2_A:decode
if cmode[0] == '0' || cmode[3:2] == '11' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VBIC_i/A:index
Execute: aarch32/VBIC_i/A:execute
Decode: aarch32/VBIC_i/T1A1_A:decode@aarch32/VBIC_i/T1A1_A:diagram
Decode: aarch32/VBIC_i/T2A2_A:decode@aarch32/VBIC_i/T2A2_A:diagram
Decode: aarch32/VBIC_i/T1A1_A:decode@aarch32/VBIC_i/T1A1_A:diagram
Decode: aarch32/VBIC_i/T2A2_A:decode@aarch32/VBIC_i/T2A2_A:diagram
TAG:aarch32/VLD3_a/A:execute
CheckAdvSIMDEnabled();
address = R[n];
D[d] = Replicate(MemU[address,ebytes]);
D[d2] = Replicate(MemU[address+ebytes,ebytes]);
D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 3*ebytes;
TAG:aarch32/VLD3_a/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 11
9:8 _ 10
7:6 size xx
5:5 T x
4:4 a 0
3:0 Rm xxxx
TAG:aarch32/VLD3_a/T1A1_A:decode
if size == '11' || a == '1' then UNDEFINED;
ebytes = 1 << UInt(size);
inc = if T == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD3_a/A:index
Execute: aarch32/VLD3_a/A:execute
Decode: aarch32/VLD3_a/T1A1_A:decode@aarch32/VLD3_a/T1A1_A:diagram
Decode: aarch32/VLD3_a/T1A1_A:decode@aarch32/VLD3_a/T1A1_A:diagram
TAG:aarch32/QDADD/A:execute
(doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
(R[d], sat2)  = SignedSatQ(SInt(R[m]) + SInt(doubled), 32);
if sat1 || sat2 then
    PSTATE.Q = '1';
TAG:aarch32/QDADD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0101
3:0 Rm xxxx
TAG:aarch32/QDADD/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QDADD/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 01
3:0 Rm xxxx
TAG:aarch32/QDADD/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QDADD/A:index
Execute: aarch32/QDADD/A:execute
Decode: aarch32/QDADD/A1_A:decode@aarch32/QDADD/A1_A:diagram
Decode: aarch32/QDADD/T1_A:decode@aarch32/QDADD/T1_A:diagram
TAG:aarch32/UXTAH/A:execute
rotated = ROR(R[m], rotation);
R[d] = R[n] + ZeroExtend(rotated[15:0], 32);
TAG:aarch32/UXTAH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 11
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTAH/A1_A:decode
if Rn == '1111' then SEE "UXTH";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTAH/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTAH/T1_A:decode
if Rn == '1111' then SEE "UXTH";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTAH/A:index
Execute: aarch32/UXTAH/A:execute
Decode: aarch32/UXTAH/A1_A:decode@aarch32/UXTAH/A1_A:diagram
Decode: aarch32/UXTAH/T1_A:decode@aarch32/UXTAH/T1_A:diagram
TAG:aarch32/SMLSD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 - product2 + SInt(R[a]);
R[d] = result[31:0];
if result != SInt(result[31:0]) then  // Signed overflow
    PSTATE.Q = '1';
TAG:aarch32/SMLSD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 000
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:6 _ 01
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMLSD/A1_A:decode
if Ra == '1111' then SEE "SMUSD";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMLSD/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 100
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLSD/T1_A:decode
if Ra == '1111' then SEE "SMUSD";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMLSD/A:index
Execute: aarch32/SMLSD/A:execute
Decode: aarch32/SMLSD/A1_A:decode@aarch32/SMLSD/A1_A:diagram
Decode: aarch32/SMLSD/T1_A:decode@aarch32/SMLSD/T1_A:diagram
TAG:aarch32/DOT/A:execute
CheckAdvSIMDEnabled();
bits(64) operand1;
bits(64) operand2;
bits(64) result;

operand2 = Din[m];
for r = 0 to regs-1
    operand1 = Din[n+r];
    result = Din[d+r];
    for e = 0 to 1
        bits(32) res = Elem[result, e, 32];
        for b = 0 to 3
            element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);
            element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);
            res = res + element1 * element2;
        Elem[result, e, 32] = res;
    D[d+r] = result;
TAG:aarch32/DOT/A1_A:diagram
A32
31:24 _ 11111110
23:23 _ 1
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/DOT/A1_A:decode
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
boolean op1_unsigned = (U == '0');
boolean op2_unsigned = (U == '1');
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm);
integer i = UInt(M);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/DOT/T1_A:diagram
T32
31:24 _ 11111110
23:23 _ 1
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 U 1
3:0 Vm xxxx
TAG:aarch32/DOT/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
boolean op1_unsigned = (U == '0');
boolean op2_unsigned = (U == '1');
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm);
integer i = UInt(M);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/DOT/A:index
Execute: aarch32/DOT/A:execute
Decode: aarch32/DOT/A1_A:decode@aarch32/DOT/A1_A:diagram
Decode: aarch32/DOT/T1_A:decode@aarch32/DOT/T1_A:diagram
TAG:aarch32/CRC32/A:execute

acc = R[n];             // accumulator
val = R[m][size-1:0];   // input value
poly = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)[31:0];
tempacc = BitReverse(acc):Zeros(size);
tempval = BitReverse(val):Zeros(32);
// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
R[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));
TAG:aarch32/CRC32/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 sz xx
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 C 1
8:8 _ (0)
7:4 _ 0100
3:0 Rm xxxx
TAG:aarch32/CRC32/A1_A:decode
if ! HaveCRCExt() then UNDEFINED;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
size = 8 << UInt(sz);
crc32c = (C == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if size == 64 then UNPREDICTABLE;
if cond != '1110' then UNPREDICTABLE;

TAG:aarch32/CRC32/T1_A:diagram
T32
31:23 _ 111110101
22:21 _ 10
20:20 C 1
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 sz xx
3:0 Rm xxxx
TAG:aarch32/CRC32/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if ! HaveCRCExt() then UNDEFINED;
d = UInt(Rd); n = UInt(Rn); m = UInt(Rm);
size = 8 << UInt(sz);
crc32c = (C == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if size == 64 then UNPREDICTABLE;

TAG:aarch32/CRC32/A:index
Execute: aarch32/CRC32/A:execute
Decode: aarch32/CRC32/A1_A:decode@aarch32/CRC32/A1_A:diagram
Decode: aarch32/CRC32/T1_A:decode@aarch32/CRC32/T1_A:diagram
TAG:aarch32/STREXD/A:execute
address = R[n];
// Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
if AArch32.ExclusiveMonitorsPass(address,8) then
    MemA[address,8] = value;  R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STREXD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STREXD/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
if d == 15 || Rt[0] == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t || d == t2 then UNPREDICTABLE;

TAG:aarch32/STREXD/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:6 _ 01
5:4 _ 11
3:0 Rd xxxx
TAG:aarch32/STREXD/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if d == n || d == t || d == t2 then UNPREDICTABLE;

TAG:aarch32/STREXD/A:index
Execute: aarch32/STREXD/A:execute
Decode: aarch32/STREXD/A1_A:decode@aarch32/STREXD/A1_A:diagram
Decode: aarch32/STREXD/T1_A:decode@aarch32/STREXD/T1_A:diagram
TAG:aarch32/TST_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND shifted;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TST_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/TST_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/TST_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1000
21:19 Rm xxx
18:16 Rn xxx
15:0 _ 0000000000000000
TAG:aarch32/TST_r/T1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/TST_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0000
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 _ 1111
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/TST_r/T2_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/TST_r/A:index
Execute: aarch32/TST_r/A:execute
Decode: aarch32/TST_r/A1_A:decode@aarch32/TST_r/A1_A:diagram
Decode: aarch32/TST_r/T1_A:decode@aarch32/TST_r/T1_A:diagram
Decode: aarch32/TST_r/T2_A:decode@aarch32/TST_r/T2_A:diagram
TAG:aarch32/VQDMULH/A:execute
CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
    for e = 0 to elements-1
        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
        op1 = SInt(Elem[D[n+r],e,esize]);
        // The following only saturates if both op1 and op2 equal -(2^(esize-1))
        (result, sat) = SignedSatQ((2*op1*op2) >> esize, esize);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQDMULH/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMULH/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQDMULH/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMULH/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQDMULH/A:index
Execute: aarch32/VQDMULH/A:execute
Decode: aarch32/VQDMULH/T1A1_A:decode@aarch32/VQDMULH/T1A1_A:diagram
Decode: aarch32/VQDMULH/T2A2_A:decode@aarch32/VQDMULH/T2A2_A:diagram
Decode: aarch32/VQDMULH/T1A1_A:decode@aarch32/VQDMULH/T1A1_A:diagram
Decode: aarch32/VQDMULH/T2A2_A:decode@aarch32/VQDMULH/T2A2_A:diagram
TAG:aarch32/VDOT_bf16_i/A:execute
bits(64) operand1;
bits(64) operand2;
bits(64) result;

CheckAdvSIMDEnabled();

operand2 = Din[m];
for r = 0 to regs-1
    operand1 = Din[n+r];
    result = Din[d+r];
    for e = 0 to 1
        bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
        bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
        bits(16) elt2_a = Elem[operand2, 2 * i + 0, 16];
        bits(16) elt2_b = Elem[operand2, 2 * i + 1, 16];
        bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
        Elem[result, e, 32] = BFAdd(Elem[result, e, 32], sum);
    D[d+r] = result;
TAG:aarch32/VDOT_bf16_i/A1_A:diagram
A32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDOT_bf16_i/A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm);
integer i = UInt(M);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_bf16_i/T1_A:diagram
T32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDOT_bf16_i/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32BF16Ext() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm);
integer i = UInt(M);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VDOT_bf16_i/A:index
Execute: aarch32/VDOT_bf16_i/A:execute
Decode: aarch32/VDOT_bf16_i/A1_A:decode@aarch32/VDOT_bf16_i/A1_A:diagram
Decode: aarch32/VDOT_bf16_i/T1_A:decode@aarch32/VDOT_bf16_i/T1_A:diagram
TAG:aarch32/VSRA/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        result = Int(Elem[D[m+r],e,esize], unsigned) >> shift_amount;
        Elem[D[d+r],e,esize] = Elem[D[d+r],e,esize] + result;
TAG:aarch32/VSRA/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSRA/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSRA/A:index
Execute: aarch32/VSRA/A:execute
Decode: aarch32/VSRA/T1A1_A:decode@aarch32/VSRA/T1A1_A:diagram
Decode: aarch32/VSRA/T1A1_A:decode@aarch32/VSRA/T1A1_A:diagram
TAG:aarch32/VCEQ_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            bits(esize) zero = FPZero('0');
            test_passed = FPCompareEQ(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
        else
            test_passed = (Elem[D[m+r],e,esize] == Zeros(esize));
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCEQ_i/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCEQ_i/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCEQ_i/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCEQ_i/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCEQ_i/A:index
Execute: aarch32/VCEQ_i/A:execute
Decode: aarch32/VCEQ_i/A1_A:decode@aarch32/VCEQ_i/A1_A:diagram
Decode: aarch32/VCEQ_i/T1_A:decode@aarch32/VCEQ_i/T1_A:diagram
TAG:aarch32/ADD_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, '0');
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADD_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 100
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/ADD_r/A1_A:decode
if Rn == '1101' then SEE "ADD (SP plus register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/ADD_r/T1_A:diagram
T16
31:26 _ 000110
25:25 _ 0
24:22 Rm xxx
21:19 Rn xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_r/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/ADD_r/T2_A:diagram
T16
31:26 _ 010001
25:24 _ 00
23:23 DN x
22:19 Rm xxxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_r/T2_A:decode
if (DN:Rdn) == '1101' || Rm == '1101' then SEE "ADD (SP plus register)";
d = UInt(DN:Rdn);  n = d;  m = UInt(Rm);  setflags = FALSE;  (shift_t, shift_n) = (SRType_LSL, 0);
if n == 15 && m == 15 then UNPREDICTABLE;
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/ADD_r/T3_A:diagram
T32
31:25 _ 1110101
24:21 _ 1000
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/ADD_r/T3_A:decode
if Rd == '1111' && S == '1' then SEE "CMN (register)";
if Rn == '1101' then SEE "ADD (SP plus register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADD_r/A:index
Execute: aarch32/ADD_r/A:execute
Decode: aarch32/ADD_r/A1_A:decode@aarch32/ADD_r/A1_A:diagram
Decode: aarch32/ADD_r/T1_A:decode@aarch32/ADD_r/T1_A:diagram
Decode: aarch32/ADD_r/T2_A:decode@aarch32/ADD_r/T2_A:diagram
Decode: aarch32/ADD_r/T3_A:decode@aarch32/ADD_r/T3_A:diagram
TAG:aarch32/SADD16/A:execute
sum1 = SInt(R[n][15:0]) + SInt(R[m][15:0]);
sum2 = SInt(R[n][31:16]) + SInt(R[m][31:16]);
R[d][15:0]  = sum1[15:0];
R[d][31:16] = sum2[15:0];
PSTATE.GE[1:0] = if sum1 >= 0 then '11' else '00';
PSTATE.GE[3:2] = if sum2 >= 0 then '11' else '00';
TAG:aarch32/SADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SADD16/A:index
Execute: aarch32/SADD16/A:execute
Decode: aarch32/SADD16/A1_A:decode@aarch32/SADD16/A1_A:diagram
Decode: aarch32/SADD16/T1_A:decode@aarch32/SADD16/T1_A:diagram
TAG:aarch32/SMUAD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 + product2;
R[d] = result[31:0];
if result != SInt(result[31:0]) then  // Signed overflow
    PSTATE.Q = '1';
TAG:aarch32/SMUAD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 000
19:16 Rd xxxx
15:12 _ 1111
11:8 Rm xxxx
7:6 _ 00
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMUAD/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMUAD/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMUAD/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMUAD/A:index
Execute: aarch32/SMUAD/A:execute
Decode: aarch32/SMUAD/A1_A:decode@aarch32/SMUAD/A1_A:diagram
Decode: aarch32/SMUAD/T1_A:decode@aarch32/SMUAD/T1_A:diagram
TAG:aarch32/ORR_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] OR shifted;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/ORR_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/ORR_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/ORR_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1100
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/ORR_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/ORR_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0010
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/ORR_r/T2_A:decode
if Rn == '1111' then SEE "Related encodings";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ORR_r/A:index
Execute: aarch32/ORR_r/A:execute
Decode: aarch32/ORR_r/A1_A:decode@aarch32/ORR_r/A1_A:diagram
Decode: aarch32/ORR_r/T1_A:decode@aarch32/ORR_r/T1_A:diagram
Decode: aarch32/ORR_r/T2_A:decode@aarch32/ORR_r/T2_A:diagram
TAG:aarch32/VCVTB/A:execute
CheckVFPEnabled(TRUE);
bits(16) hp;
if convert_from_half then
    hp = S[m][lowbit+15:lowbit];
    if uses_double then
        D[d] = FPConvert(hp, FPSCR);
    else
        S[d] = FPConvert(hp, FPSCR);
else
    if uses_double then
        hp = FPConvert(D[m], FPSCR);
    else
        hp = FPConvert(S[m], FPSCR);
    S[d][lowbit+15:lowbit] = hp;
TAG:aarch32/VCVTB/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:17 _ 01
16:16 op x
15:12 Vd xxxx
11:10 _ 10
9:9 _ 1
8:8 sz x
7:7 T 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTB/T1A1_A:decode
uses_double = (sz == '1'); convert_from_half = (op == '0');
lowbit = (if T == '1' then 16 else 0);
if uses_double then
    if convert_from_half then
        d = UInt(D:Vd); m = UInt(Vm:M);
    else
        d = UInt(Vd:D); m = UInt(M:Vm);
else
    d = UInt(Vd:D); m = UInt(Vm:M);

TAG:aarch32/VCVTB/A:index
Execute: aarch32/VCVTB/A:execute
Decode: aarch32/VCVTB/T1A1_A:decode@aarch32/VCVTB/T1A1_A:diagram
Decode: aarch32/VCVTB/T1A1_A:decode@aarch32/VCVTB/T1A1_A:diagram
TAG:aarch32/LDRSBT/A:execute
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
R[t] = SignExtend(MemU_unpriv[address,1], 32);
if postindex then R[n] = offset_addr;
TAG:aarch32/LDRSBT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSBT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/LDRSBT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRSBT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/LDRSBT/T1_A:diagram
T32
31:23 _ 111110010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRSBT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then SEE "LDRSB (literal)";
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSBT/A:index
Execute: aarch32/LDRSBT/A:execute
Decode: aarch32/LDRSBT/A1_A:decode@aarch32/LDRSBT/A1_A:diagram
Decode: aarch32/LDRSBT/A2_A:decode@aarch32/LDRSBT/A2_A:diagram
Decode: aarch32/LDRSBT/T1_A:decode@aarch32/LDRSBT/T1_A:diagram
TAG:aarch32/SEV/A:execute
SendEvent();
TAG:aarch32/SEV/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000100
TAG:aarch32/SEV/A1_A:decode
// No additional decoding required

TAG:aarch32/SEV/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0100
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/SEV/T1_A:decode
// No additional decoding required

TAG:aarch32/SEV/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0100
TAG:aarch32/SEV/T2_A:decode
// No additional decoding required

TAG:aarch32/SEV/A:index
Execute: aarch32/SEV/A:execute
Decode: aarch32/SEV/A1_A:decode@aarch32/SEV/A1_A:diagram
Decode: aarch32/SEV/T1_A:decode@aarch32/SEV/T1_A:diagram
Decode: aarch32/SEV/T2_A:decode@aarch32/SEV/T2_A:diagram
TAG:aarch32/MOV_i/A:execute
result = imm32;
if d == 15 then          // Can only occur for encoding A1
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/MOV_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00111
22:21 _ 01
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/MOV_i/A1_A:decode
d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/MOV_i/A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 00
19:16 imm4 xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/MOV_i/A2_A:decode
d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:imm12, 32);
if d == 15 then UNPREDICTABLE;

TAG:aarch32/MOV_i/T1_A:diagram
T16
31:29 _ 001
28:27 _ 00
26:24 Rd xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/MOV_i/T1_A:decode
d = UInt(Rd);  setflags = !InITBlock();  imm32 = ZeroExtend(imm8, 32);  carry = PSTATE.C;

TAG:aarch32/MOV_i/T2_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0010
20:20 S x
19:16 _ 1111
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/MOV_i/T2_A:decode
d = UInt(Rd);  setflags = (S == '1');  (imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MOV_i/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 0
22:20 _ 100
19:16 imm4 xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/MOV_i/T3_A:decode
d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm4:i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MOV_i/A:index
Execute: aarch32/MOV_i/A:execute
Decode: aarch32/MOV_i/A1_A:decode@aarch32/MOV_i/A1_A:diagram
Decode: aarch32/MOV_i/A2_A:decode@aarch32/MOV_i/A2_A:diagram
Decode: aarch32/MOV_i/T1_A:decode@aarch32/MOV_i/T1_A:diagram
Decode: aarch32/MOV_i/T2_A:decode@aarch32/MOV_i/T2_A:diagram
Decode: aarch32/MOV_i/T3_A:decode@aarch32/MOV_i/T3_A:diagram
TAG:aarch32/MLS/A:execute
operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
addend   = SInt(R[a]);  // addend   = UInt(R[a]) produces the same final results
result = addend - operand1 * operand2;
R[d] = result[31:0];
TAG:aarch32/MLS/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 011
20:20 _ 0
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/MLS/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

TAG:aarch32/MLS/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 000
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:4 _ 01
3:0 Rm xxxx
TAG:aarch32/MLS/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MLS/A:index
Execute: aarch32/MLS/A:execute
Decode: aarch32/MLS/A1_A:decode@aarch32/MLS/A1_A:diagram
Decode: aarch32/MLS/T1_A:decode@aarch32/MLS/T1_A:diagram
TAG:aarch32/CSDB/A:execute

ConsumptionOfSpeculativeDataBarrier();
TAG:aarch32/CSDB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:16 _ 0000
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00010100
TAG:aarch32/CSDB/A1_A:decode
if cond != '1110' then UNPREDICTABLE;      // CSDB must be encoded with AL condition

TAG:aarch32/CSDB/T1_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0001
3:0 _ 0100
TAG:aarch32/CSDB/T1_A:decode
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/CSDB/A:index
Execute: aarch32/CSDB/A:execute
Decode: aarch32/CSDB/A1_A:decode@aarch32/CSDB/A1_A:diagram
Decode: aarch32/CSDB/T1_A:decode@aarch32/CSDB/T1_A:diagram
TAG:aarch32/SMLALD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 + product2 + SInt(R[dHi]:R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
TAG:aarch32/SMLALD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 100
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:6 _ 00
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMLALD/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLALD/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 100
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:5 _ 110
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLALD/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLALD/A:index
Execute: aarch32/SMLALD/A:execute
Decode: aarch32/SMLALD/A1_A:decode@aarch32/SMLALD/A1_A:diagram
Decode: aarch32/SMLALD/T1_A:decode@aarch32/SMLALD/T1_A:diagram
TAG:aarch32/UQASX/A:execute
diff = UInt(R[n][15:0]) - UInt(R[m][31:16]);
sum  = UInt(R[n][31:16]) + UInt(R[m][15:0]);
R[d][15:0]  = UnsignedSat(diff, 16);
R[d][31:16] = UnsignedSat(sum, 16);
TAG:aarch32/UQASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQASX/A:index
Execute: aarch32/UQASX/A:execute
Decode: aarch32/UQASX/A1_A:decode@aarch32/UQASX/A1_A:diagram
Decode: aarch32/UQASX/T1_A:decode@aarch32/UQASX/T1_A:diagram
TAG:aarch32/ADD_SP_i/A:execute
(result, nzcv) = AddWithCarry(SP, imm32, '0');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADD_SP_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 100
20:20 S x
19:16 _ 1101
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ADD_SP_i/A1_A:decode
d = UInt(Rd);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/ADD_SP_i/T1_A:diagram
T16
31:28 _ 1010
27:27 _ 1
26:24 Rd xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_SP_i/T1_A:decode
d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(imm8:'00', 32);

TAG:aarch32/ADD_SP_i/T2_A:diagram
T16
31:24 _ 10110000
23:23 _ 0
22:16 imm7 xxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_SP_i/T2_A:decode
d = 13;  setflags = FALSE;  imm32 = ZeroExtend(imm7:'00', 32);

TAG:aarch32/ADD_SP_i/T3_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1000
20:20 S x
19:16 _ 1101
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADD_SP_i/T3_A:decode
if Rd == '1111' && S == '1' then SEE "CMN (immediate)";
d = UInt(Rd);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if d == 15 && !setflags then UNPREDICTABLE;

TAG:aarch32/ADD_SP_i/T4_A:diagram
T32
31:27 _ 11110
26:26 i x
25:24 _ 10
23:23 _ 0
22:22 _ 0
21:21 _ 0
20:20 _ 0
19:16 _ 1101
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADD_SP_i/T4_A:decode
d = UInt(Rd);  setflags = FALSE;  imm32 = ZeroExtend(i:imm3:imm8, 32);
if d == 15 then UNPREDICTABLE;

TAG:aarch32/ADD_SP_i/A:index
Execute: aarch32/ADD_SP_i/A:execute
Decode: aarch32/ADD_SP_i/A1_A:decode@aarch32/ADD_SP_i/A1_A:diagram
Decode: aarch32/ADD_SP_i/T1_A:decode@aarch32/ADD_SP_i/T1_A:diagram
Decode: aarch32/ADD_SP_i/T2_A:decode@aarch32/ADD_SP_i/T2_A:diagram
Decode: aarch32/ADD_SP_i/T3_A:decode@aarch32/ADD_SP_i/T3_A:diagram
Decode: aarch32/ADD_SP_i/T4_A:decode@aarch32/ADD_SP_i/T4_A:diagram
TAG:aarch32/VSTM/A:execute
CheckVFPEnabled(TRUE);
address = if add then R[n] else R[n]-imm32;
for r = 0 to regs-1
    if single_regs then
        MemA[address,4] = S[d+r];  address = address+4;
    else
        // Store as two word-aligned words in the correct order for current endianness.
        MemA[address,4] = if BigEndian() then D[d+r][63:32] else D[d+r][31:0];
        MemA[address+4,4] = if BigEndian() then D[d+r][31:0] else D[d+r][63:32];
        address = address+8;
if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;
TAG:aarch32/VSTM/T1A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 D x
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 _ 11
7:0 imm8 xxxxxxx0
TAG:aarch32/VSTM/T1A1_A:decode
if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
if P == '1' && W == '0' then SEE "VSTR";
if P == U && W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FSTMX".
if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if imm8[0] == '1' && (d+regs) > 16 then UNPREDICTABLE;

TAG:aarch32/VSTM/T2A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 D x
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:0 imm8 xxxxxxxx
TAG:aarch32/VSTM/T2A2_A:decode
if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
if P == '1' && W == '0' then SEE "VSTR";
if P == U && W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

TAG:aarch32/VSTM/A:index
Execute: aarch32/VSTM/A:execute
Decode: aarch32/VSTM/T1A1_A:decode@aarch32/VSTM/T1A1_A:diagram
Decode: aarch32/VSTM/T2A2_A:decode@aarch32/VSTM/T2A2_A:diagram
Decode: aarch32/VSTM/T1A1_A:decode@aarch32/VSTM/T1A1_A:diagram
Decode: aarch32/VSTM/T2A2_A:decode@aarch32/VSTM/T2A2_A:diagram
TAG:aarch32/VFMA/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            bits(esize) op1 = Elem[D[n+r],e,esize];
            if op1_neg then op1 = FPNeg(op1);
            Elem[D[d+r],e,esize] = FPMulAdd(Elem[D[d+r],e,esize],
                                   op1, Elem[D[m+r],e,esize], StandardFPSCRValue());

else // VFP instruction
    case esize of
        when 16
            op16 = if op1_neg then FPNeg(S[n][15:0]) else S[n][15:0];
            S[d] = Zeros(16) : FPMulAdd(S[d][15:0], op16, S[m][15:0], FPSCR);
        when 32
            op32 = if op1_neg then FPNeg(S[n]) else S[n];
            S[d] = FPMulAdd(S[d], op32, S[m], FPSCR);
        when 64
            op64 = if op1_neg then FPNeg(D[n]) else D[n];
            D[d] = FPMulAdd(D[d], op64, D[m], FPSCR);
TAG:aarch32/VFMA/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 op 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE; op1_neg = (op == '1');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VFMA/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 1
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VFMA/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
advsimd = FALSE; op1_neg = (op == '1');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VFMA/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 op 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
advsimd = TRUE; op1_neg = (op == '1');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VFMA/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 1
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VFMA/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
advsimd = FALSE; op1_neg = (op == '1');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VFMA/A:index
Execute: aarch32/VFMA/A:execute
Decode: aarch32/VFMA/A1_A:decode@aarch32/VFMA/A1_A:diagram
Decode: aarch32/VFMA/A2_A:decode@aarch32/VFMA/A2_A:diagram
Decode: aarch32/VFMA/T1_A:decode@aarch32/VFMA/T1_A:diagram
Decode: aarch32/VFMA/T2_A:decode@aarch32/VFMA/T2_A:diagram
TAG:aarch32/VJCVT/A:execute
CheckVFPEnabled(TRUE);
bits(64) fltval = D[m];
bits(32) intval;
bit      Z;
(intval, Z) = FPToFixedJS(fltval, FPSCR, FALSE);
FPSCR[31:28] = '0':Z:'00';
S[d] = intval;
TAG:aarch32/VJCVT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 1
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 _ 11
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VJCVT/A1_A:decode
if !HaveFJCVTZSExt() then UNDEFINED;
if cond != '1110' then UNPREDICTABLE;
d = UInt(Vd:D);  m = UInt(M:Vm);

TAG:aarch32/VJCVT/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 1
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 _ 11
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VJCVT/T1_A:decode
if !HaveFJCVTZSExt() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
d = UInt(Vd:D);  m = UInt(M:Vm);

TAG:aarch32/VJCVT/A:index
Execute: aarch32/VJCVT/A:execute
Decode: aarch32/VJCVT/A1_A:decode@aarch32/VJCVT/A1_A:diagram
Decode: aarch32/VJCVT/T1_A:decode@aarch32/VJCVT/T1_A:diagram
TAG:aarch32/ESB/A:execute

SynchronizeErrors();
AArch32.ESBOperation();
if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch32.vESBOperation();
TakeUnmaskedSErrorInterrupts();
TAG:aarch32/ESB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:16 _ 0000
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00010000
TAG:aarch32/ESB/A1_A:decode
if !HaveRASExt() then EndOfInstruction();  // Instruction executes as NOP
if cond != '1110' then UNPREDICTABLE;      // ESB must be encoded with AL condition

TAG:aarch32/ESB/T1_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0001
3:0 _ 0000
TAG:aarch32/ESB/T1_A:decode
if !HaveRASExt() then EndOfInstruction();  // Instruction executes as NOP
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/ESB/A:index
Execute: aarch32/ESB/A:execute
Decode: aarch32/ESB/A1_A:decode@aarch32/ESB/A1_A:diagram
Decode: aarch32/ESB/T1_A:decode@aarch32/ESB/T1_A:diagram
TAG:aarch32/VSHL_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = LSL(Elem[D[m+r],e,esize], shift_amount);
TAG:aarch32/VSHL_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0101
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSHL_i/T1A1_A:decode
if L:imm6 == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSHL_i/A:index
Execute: aarch32/VSHL_i/A:execute
Decode: aarch32/VSHL_i/T1A1_A:decode@aarch32/VSHL_i/T1A1_A:diagram
Decode: aarch32/VSHL_i/T1A1_A:decode@aarch32/VSHL_i/T1A1_A:diagram
TAG:aarch32/SMLABB/A:execute
operand1 = if n_high then R[n][31:16] else R[n][15:0];
operand2 = if m_high then R[m][31:16] else R[m][15:0];
result = SInt(operand1) * SInt(operand2) + SInt(R[a]);
R[d] = result[31:0];
if result != SInt(result[31:0]) then  // Signed overflow
    PSTATE.Q = '1';
TAG:aarch32/SMLABB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 00
20:20 _ 0
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:7 _ 1
6:6 M x
5:5 N x
4:4 _ 0
3:0 Rn xxxx
TAG:aarch32/SMLABB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
n_high = (N == '1');  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

TAG:aarch32/SMLABB/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 001
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 N x
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLABB/T1_A:decode
if Ra == '1111' then SEE "SMULBB, SMULBT, SMULTB, SMULTT";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
n_high = (N == '1');  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMLABB/A:index
Execute: aarch32/SMLABB/A:execute
Decode: aarch32/SMLABB/A1_A:decode@aarch32/SMLABB/A1_A:diagram
Decode: aarch32/SMLABB/T1_A:decode@aarch32/SMLABB/T1_A:diagram
TAG:aarch32/STRD_r/A:execute
offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
address = if index then offset_addr else R[n];
if address == Align(address, 8) then
    bits(64) data;
    if BigEndian() then
        data[63:32] = R[t];
        data[31:0] = R[t2];
    else
        data[31:0] = R[t];
        data[63:32] = R[t2];
    MemA[address,8] = data;
else
    MemA[address,4] = R[t];
    MemA[address+4,4] = R[t2];
if wback then R[n] = offset_addr;
TAG:aarch32/STRD_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/STRD_r/A1_A:decode
if Rt[0] == '1' then UNPREDICTABLE;
t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if P == '0' && W == '1' then UNPREDICTABLE;
if t2 == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

TAG:aarch32/STRD_r/A:index
Execute: aarch32/STRD_r/A:execute
Decode: aarch32/STRD_r/A1_A:decode@aarch32/STRD_r/A1_A:diagram
TAG:aarch32/UHSAX/A:execute
sum  = UInt(R[n][15:0]) + UInt(R[m][31:16]);
diff = UInt(R[n][31:16]) - UInt(R[m][15:0]);
R[d][15:0]  = sum[16:1];
R[d][31:16] = diff[16:1];
TAG:aarch32/UHSAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHSAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHSAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHSAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHSAX/A:index
Execute: aarch32/UHSAX/A:execute
Decode: aarch32/UHSAX/A1_A:decode@aarch32/UHSAX/A1_A:diagram
Decode: aarch32/UHSAX/T1_A:decode@aarch32/UHSAX/T1_A:diagram
TAG:aarch32/SHA256H2/A:execute
CheckCryptoEnabled32();
X = Q[n>>1]; Y = Q[d>>1]; W = Q[m>>1]; part1 = FALSE;
Q[d>>1] = SHA256hash(X, Y, W, part1);
TAG:aarch32/SHA256H2/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256H2/A1_A:decode
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256H2/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256H2/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256H2/A:index
Execute: aarch32/SHA256H2/A:execute
Decode: aarch32/SHA256H2/A1_A:decode@aarch32/SHA256H2/A1_A:diagram
Decode: aarch32/SHA256H2/T1_A:decode@aarch32/SHA256H2/T1_A:diagram
TAG:aarch32/SMULL/A:execute
result = SInt(R[n]) * SInt(R[m]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
if setflags then
    PSTATE.N = result[63];
    PSTATE.Z = IsZeroBit(result[63:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/SMULL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 110
20:20 S x
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/SMULL/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMULL/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 000
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:4 _ 0000
3:0 Rm xxxx
TAG:aarch32/SMULL/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMULL/A:index
Execute: aarch32/SMULL/A:execute
Decode: aarch32/SMULL/A1_A:decode@aarch32/SMULL/A1_A:diagram
Decode: aarch32/SMULL/T1_A:decode@aarch32/SMULL/T1_A:diagram
TAG:aarch32/MUL/A:execute
operand1 = SInt(R[n]);  // operand1 = UInt(R[n]) produces the same final results
operand2 = SInt(R[m]);  // operand2 = UInt(R[m]) produces the same final results
result = operand1 * operand2;
R[d] = result[31:0];
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result[31:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/MUL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 000
20:20 S x
19:16 Rd xxxx
15:12 _ (0)(0)(0)(0)
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/MUL/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/MUL/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1101
21:19 Rn xxx
18:16 Rdm xxx
15:0 _ 0000000000000000
TAG:aarch32/MUL/T1_A:decode
d = UInt(Rdm);  n = UInt(Rn);  m = UInt(Rdm);  setflags = !InITBlock();

TAG:aarch32/MUL/T2_A:diagram
T32
31:23 _ 111110110
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/MUL/T2_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MUL/A:index
Execute: aarch32/MUL/A:execute
Decode: aarch32/MUL/A1_A:decode@aarch32/MUL/A1_A:diagram
Decode: aarch32/MUL/T1_A:decode@aarch32/MUL/T1_A:diagram
Decode: aarch32/MUL/T2_A:decode@aarch32/MUL/T2_A:diagram
TAG:aarch32/VLD4_a/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
D[d] = Replicate(MemU[address,ebytes]);
D[d2] = Replicate(MemU[address+ebytes,ebytes]);
D[d3] = Replicate(MemU[address+2*ebytes,ebytes]);
D[d4] = Replicate(MemU[address+3*ebytes,ebytes]);
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 4*ebytes;
TAG:aarch32/VLD4_a/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 11
9:8 _ 11
7:6 size xx
5:5 T x
4:4 a x
3:0 Rm xxxx
TAG:aarch32/VLD4_a/T1A1_A:decode
if size == '11' && a == '0' then UNDEFINED;
if size == '11' then
    ebytes = 4;  alignment = 16;
else
    ebytes = 1 << UInt(size);
    if size == '10' then
        alignment = if a == '0' then 1 else 8;
    else
        alignment = if a == '0' then 1 else 4*ebytes;
inc = if T == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD4_a/A:index
Execute: aarch32/VLD4_a/A:execute
Decode: aarch32/VLD4_a/T1A1_A:decode@aarch32/VLD4_a/T1A1_A:diagram
Decode: aarch32/VLD4_a/T1A1_A:decode@aarch32/VLD4_a/T1A1_A:diagram
TAG:aarch32/LDR_l/A:execute
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,4];
if t == 15 then
    if address[1:0] == '00' then
        LoadWritePC(data);
    else
        UNPREDICTABLE;
else
    R[t] = data;
TAG:aarch32/LDR_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDR_l/A1_A:decode
if P == '0' && W == '1' then SEE "LDRT";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);
add = (U == '1');  wback = (P == '0') || (W == '1');
if wback then UNPREDICTABLE;

TAG:aarch32/LDR_l/T1_A:diagram
T16
31:27 _ 01001
26:24 Rt xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/LDR_l/T1_A:decode
t = UInt(Rt);  imm32 = ZeroExtend(imm8:'00', 32);  add = TRUE;

TAG:aarch32/LDR_l/T2_A:diagram
T32
31:24 _ 11111000
23:23 U x
22:21 _ 10
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDR_l/T2_A:decode
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/LDR_l/A:index
Execute: aarch32/LDR_l/A:execute
Decode: aarch32/LDR_l/A1_A:decode@aarch32/LDR_l/A1_A:diagram
Decode: aarch32/LDR_l/T1_A:decode@aarch32/LDR_l/T1_A:diagram
Decode: aarch32/LDR_l/T2_A:decode@aarch32/LDR_l/T2_A:diagram
TAG:aarch32/LDMIB/A:execute
address = R[n] + 4;
for i = 0 to 14
    if registers[i] == '1' then
        R[i] = MemA[address,4];  address = address + 4;
if registers[15] == '1' then
    LoadWritePC(MemA[address,4]);
if wback && registers[n] == '0' then R[n] = R[n] + 4*BitCount(registers);
if wback && registers[n] == '1' then R[n] = bits(32) UNKNOWN;
TAG:aarch32/LDMIB/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 1
23:23 _ 1
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/LDMIB/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;

TAG:aarch32/LDMIB/A:index
Execute: aarch32/LDMIB/A:execute
Decode: aarch32/LDMIB/A1_A:decode@aarch32/LDMIB/A1_A:diagram
TAG:aarch32/VRADDHN/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
for e = 0 to elements-1
    result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize] + round_const;
    Elem[D[d],e,esize] = result[2*esize-1:esize];
TAG:aarch32/VRADDHN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0100
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRADDHN/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VRADDHN/A:index
Execute: aarch32/VRADDHN/A:execute
Decode: aarch32/VRADDHN/T1A1_A:decode@aarch32/VRADDHN/T1A1_A:diagram
Decode: aarch32/VRADDHN/T1A1_A:decode@aarch32/VRADDHN/T1A1_A:diagram
TAG:aarch32/SHA1M/A:execute
CheckCryptoEnabled32();
X = Q[d>>1];
Y = Q[n>>1][31:0]; // Note: 32 bits wide
W = Q[m>>1];
for e = 0 to 3
    t = SHAmajority(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y:X, 32);
Q[d>>1] = X;
TAG:aarch32/SHA1M/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1M/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1M/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1M/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1M/A:index
Execute: aarch32/SHA1M/A:execute
Decode: aarch32/SHA1M/A1_A:decode@aarch32/SHA1M/A1_A:diagram
Decode: aarch32/SHA1M/T1_A:decode@aarch32/SHA1M/T1_A:diagram
TAG:aarch32/VMOV_rs/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
Elem[D[d],index,esize] = R[t][esize-1:0];
TAG:aarch32/VMOV_rs/T1A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:21 opc1 xx
20:20 _ 0
19:16 Vd xxxx
15:12 Rt xxxx
11:8 _ 1011
7:7 D x
6:5 opc2 xx
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_rs/T1A1_A:decode
case opc1:opc2 of
    when '1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1[0]:opc2);
    when '0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1[0]:opc2[1]);
    when '0x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1[0]);
    when '0x10'  UNDEFINED;
d = UInt(D:Vd);  t = UInt(Rt);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_rs/A:index
Execute: aarch32/VMOV_rs/A:execute
Decode: aarch32/VMOV_rs/T1A1_A:decode@aarch32/VMOV_rs/T1A1_A:diagram
Decode: aarch32/VMOV_rs/T1A1_A:decode@aarch32/VMOV_rs/T1A1_A:diagram
TAG:aarch32/LDRH_l/A:execute
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
data = MemU[address,2];
R[t] = ZeroExtend(data, 32);
TAG:aarch32/LDRH_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRH_l/A1_A:decode
if P == '0' && W == '1' then SEE "LDRHT";
t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || wback then UNPREDICTABLE;

TAG:aarch32/LDRH_l/T1_A:diagram
T32
31:24 _ 11111000
23:23 U x
22:21 _ 01
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRH_l/T1_A:decode
if Rt == '1111' then SEE "PLD (literal)";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRH_l/A:index
Execute: aarch32/LDRH_l/A:execute
Decode: aarch32/LDRH_l/A1_A:decode@aarch32/LDRH_l/A1_A:diagram
Decode: aarch32/LDRH_l/T1_A:decode@aarch32/LDRH_l/T1_A:diagram
TAG:aarch32/MCRR/A:execute
value = R[t2]:R[t];
AArch32.SysRegWrite64(cp, ThisInstr(), value);
TAG:aarch32/MCRR/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11000
22:22 _ 1
21:21 _ 0
20:20 _ 0
19:16 Rt2 xxxx
15:12 Rt xxxx
11:8 coproc 111x
7:4 opc1 xxxx
3:0 CRm xxxx
TAG:aarch32/MCRR/T1A1_A:decode
t = UInt(Rt);  t2 = UInt(Rt2);  cp = if coproc[0] == '0' then 14 else 15;
if t == 15 || t2 == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MCRR/A:index
Execute: aarch32/MCRR/A:execute
Decode: aarch32/MCRR/T1A1_A:decode@aarch32/MCRR/T1A1_A:diagram
Decode: aarch32/MCRR/T1A1_A:decode@aarch32/MCRR/T1A1_A:diagram
TAG:aarch32/VHADD/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Int(Elem[D[n+r],e,esize], unsigned);
        op2 = Int(Elem[D[m+r],e,esize], unsigned);
        result = if add then op1+op2 else op1-op2;
        Elem[D[d+r],e,esize] = result[esize:1];
TAG:aarch32/VHADD/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 00
9:9 op 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VHADD/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
add = (op == '0');  unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VHADD/A:index
Execute: aarch32/VHADD/A:execute
Decode: aarch32/VHADD/T1A1_A:decode@aarch32/VHADD/T1A1_A:diagram
Decode: aarch32/VHADD/T1A1_A:decode@aarch32/VHADD/T1A1_A:diagram
TAG:aarch32/VSUBL/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    if is_vsubw then
        op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
    else
        op1 = Int(Elem[Din[n],e,esize], unsigned);
    result = op1 - Int(Elem[Din[m],e,esize], unsigned);
    Elem[Q[d>>1],e,2*esize] = result[2*esize-1:0];
TAG:aarch32/VSUBL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:9 _ 001
8:8 op 1
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUBL/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vd[0] == '1' || (op == '1' && Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vsubw = (op == '1');
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VSUBL/A:index
Execute: aarch32/VSUBL/A:execute
Decode: aarch32/VSUBL/T1A1_A:decode@aarch32/VSUBL/T1A1_A:diagram
Decode: aarch32/VSUBL/T1A1_A:decode@aarch32/VSUBL/T1A1_A:diagram
TAG:aarch32/QASX/A:execute
diff = SInt(R[n][15:0]) - SInt(R[m][31:16]);
sum  = SInt(R[n][31:16]) + SInt(R[m][15:0]);
R[d][15:0]  = SignedSat(diff, 16);
R[d][31:16] = SignedSat(sum, 16);
TAG:aarch32/QASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QASX/A:index
Execute: aarch32/QASX/A:execute
Decode: aarch32/QASX/A1_A:decode@aarch32/QASX/A1_A:diagram
Decode: aarch32/QASX/T1_A:decode@aarch32/QASX/T1_A:diagram
TAG:aarch32/SXTH/A:execute
rotated = ROR(R[m], rotation);
R[d] = SignExtend(rotated[15:0], 32);
TAG:aarch32/SXTH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 11
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/SXTH/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SXTH/T1_A:diagram
T16
31:24 _ 10110010
23:23 _ 0
22:22 _ 0
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/SXTH/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

TAG:aarch32/SXTH/T2_A:diagram
T32
31:23 _ 111110100
22:21 _ 00
20:20 _ 0
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/SXTH/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SXTH/A:index
Execute: aarch32/SXTH/A:execute
Decode: aarch32/SXTH/A1_A:decode@aarch32/SXTH/A1_A:diagram
Decode: aarch32/SXTH/T1_A:decode@aarch32/SXTH/T1_A:diagram
Decode: aarch32/SXTH/T2_A:decode@aarch32/SXTH/T2_A:diagram
TAG:aarch32/UXTAB16/A:execute
rotated = ROR(R[m], rotation);
R[d][15:0]  = R[n][15:0] + ZeroExtend(rotated[7:0], 16);
R[d][31:16] = R[n][31:16] + ZeroExtend(rotated[23:16], 16);
TAG:aarch32/UXTAB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 00
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTAB16/A1_A:decode
if Rn == '1111' then SEE "UXTB16";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTAB16/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTAB16/T1_A:decode
if Rn == '1111' then SEE "UXTB16";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTAB16/A:index
Execute: aarch32/UXTAB16/A:execute
Decode: aarch32/UXTAB16/A1_A:decode@aarch32/UXTAB16/A1_A:diagram
Decode: aarch32/UXTAB16/T1_A:decode@aarch32/UXTAB16/T1_A:diagram
TAG:aarch32/UDF/A:execute
UNDEFINED;
TAG:aarch32/UDF/A1_A:diagram
A32
31:28 cond 1110
27:20 _ 01111111
19:8 imm12 xxxxxxxxxxxx
7:4 _ 1111
3:0 imm4 xxxx
TAG:aarch32/UDF/A1_A:decode
imm32 = ZeroExtend(imm12:imm4, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.

TAG:aarch32/UDF/T1_A:diagram
T16
31:25 _ 1101111
24:24 _ 0
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/UDF/T1_A:decode
imm32 = ZeroExtend(imm8, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.

TAG:aarch32/UDF/T2_A:diagram
T32
31:21 _ 11110111111
20:20 _ 1
19:16 imm4 xxxx
15:14 _ 10
13:13 _ 1
12:12 _ 0
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/UDF/T2_A:decode
imm32 = ZeroExtend(imm4:imm12, 32);
// imm32 is for assembly and disassembly only, and is ignored by hardware.

TAG:aarch32/UDF/A:index
Execute: aarch32/UDF/A:execute
Decode: aarch32/UDF/A1_A:decode@aarch32/UDF/A1_A:diagram
Decode: aarch32/UDF/T1_A:decode@aarch32/UDF/T1_A:diagram
Decode: aarch32/UDF/T2_A:decode@aarch32/UDF/T2_A:diagram
TAG:aarch32/BX/A:execute
BXWritePC(R[m], BranchType_INDIR);
TAG:aarch32/BX/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 00010010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0001
3:0 Rm xxxx
TAG:aarch32/BX/A1_A:decode
m = UInt(Rm);

TAG:aarch32/BX/T1_A:diagram
T16
31:24 _ 01000111
23:23 _ 0
22:19 Rm xxxx
18:18 _ (0)
17:17 _ (0)
16:16 _ (0)
15:0 _ 0000000000000000
TAG:aarch32/BX/T1_A:decode
m = UInt(Rm);
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/BX/A:index
Execute: aarch32/BX/A:execute
Decode: aarch32/BX/A1_A:decode@aarch32/BX/A1_A:diagram
Decode: aarch32/BX/T1_A:decode@aarch32/BX/T1_A:diagram
TAG:aarch32/LDAEXB/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address, 1);
R[t] = ZeroExtend(MemO[address, 1], 32);
TAG:aarch32/LDAEXB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXB/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 00
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXB/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXB/A:index
Execute: aarch32/LDAEXB/A:execute
Decode: aarch32/LDAEXB/A1_A:decode@aarch32/LDAEXB/A1_A:diagram
Decode: aarch32/LDAEXB/T1_A:decode@aarch32/LDAEXB/T1_A:diagram
TAG:aarch32/VORR_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[d+r] OR imm64;
TAG:aarch32/VORR_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 0xx1
7:7 _ 0
6:6 Q x
5:5 _ 0
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VORR_i/T1A1_A:decode
if cmode[0] == '0' || cmode[3:2] == '11' then SEE "VMOV (immediate)";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VORR_i/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 10x1
7:7 _ 0
6:6 Q x
5:5 _ 0
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VORR_i/T2A2_A:decode
if cmode[0] == '0' || cmode[3:2] == '11' then SEE "VMOV (immediate)";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('0', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VORR_i/A:index
Execute: aarch32/VORR_i/A:execute
Decode: aarch32/VORR_i/T1A1_A:decode@aarch32/VORR_i/T1A1_A:diagram
Decode: aarch32/VORR_i/T2A2_A:decode@aarch32/VORR_i/T2A2_A:diagram
Decode: aarch32/VORR_i/T1A1_A:decode@aarch32/VORR_i/T1A1_A:diagram
Decode: aarch32/VORR_i/T2A2_A:decode@aarch32/VORR_i/T2A2_A:diagram
TAG:aarch32/LDRSB_l/A:execute
base = Align(PC,4);
address = if add then (base + imm32) else (base - imm32);
R[t] = SignExtend(MemU[address,1], 32);
TAG:aarch32/LDRSB_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSB_l/A1_A:decode
if P == '0' && W == '1' then SEE "LDRSBT";
t = UInt(Rt);  imm32 = ZeroExtend(imm4H:imm4L, 32);
add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || wback then UNPREDICTABLE;

TAG:aarch32/LDRSB_l/T1_A:diagram
T32
31:24 _ 11111001
23:23 U x
22:21 _ 00
20:16 _ 11111
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRSB_l/T1_A:decode
if Rt == '1111' then SEE "PLI";
t = UInt(Rt);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSB_l/A:index
Execute: aarch32/LDRSB_l/A:execute
Decode: aarch32/LDRSB_l/A1_A:decode@aarch32/LDRSB_l/A1_A:diagram
Decode: aarch32/LDRSB_l/T1_A:decode@aarch32/LDRSB_l/T1_A:diagram
TAG:aarch32/SHSAX/A:execute
sum  = SInt(R[n][15:0]) + SInt(R[m][31:16]);
diff = SInt(R[n][31:16]) - SInt(R[m][15:0]);
R[d][15:0]  = sum[16:1];
R[d][31:16] = diff[16:1];
TAG:aarch32/SHSAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHSAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHSAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHSAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHSAX/A:index
Execute: aarch32/SHSAX/A:execute
Decode: aarch32/SHSAX/A1_A:decode@aarch32/SHSAX/A1_A:diagram
Decode: aarch32/SHSAX/T1_A:decode@aarch32/SHSAX/T1_A:diagram
TAG:aarch32/LDRSHT/A:execute
offset = if register_form then R[m] else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
data = MemU_unpriv[address,2];
if postindex then R[n] = offset_addr;
R[t] = SignExtend(data, 32);
TAG:aarch32/LDRSHT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSHT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm4H:imm4L, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/LDRSHT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRSHT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/LDRSHT/T1_A:diagram
T32
31:23 _ 111110010
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRSHT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then SEE "LDRSH (literal)";
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSHT/A:index
Execute: aarch32/LDRSHT/A:execute
Decode: aarch32/LDRSHT/A1_A:decode@aarch32/LDRSHT/A1_A:diagram
Decode: aarch32/LDRSHT/A2_A:decode@aarch32/LDRSHT/A2_A:diagram
Decode: aarch32/LDRSHT/T1_A:decode@aarch32/LDRSHT/T1_A:diagram
TAG:aarch32/VACGE/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = FPAbs(Elem[D[n+r],e,esize]);  op2 = FPAbs(Elem[D[m+r],e,esize]);
        if or_equal then
            test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
        else
            test_passed = FPCompareGT(op1, op2, StandardFPSCRValue());
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VACGE/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 op 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VACGE/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
or_equal = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VACGE/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 op 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VACGE/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
or_equal = (op == '0');
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VACGE/A:index
Execute: aarch32/VACGE/A:execute
Decode: aarch32/VACGE/A1_A:decode@aarch32/VACGE/A1_A:diagram
Decode: aarch32/VACGE/T1_A:decode@aarch32/VACGE/T1_A:diagram
TAG:aarch32/VRECPE/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            Elem[D[d+r],e,esize] = FPRecipEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
        else
            Elem[D[d+r],e,esize] = UnsignedRecipEstimate(Elem[D[m+r],e,esize]);
TAG:aarch32/VRECPE/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 10
8:8 F x
7:7 _ 0
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRECPE/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
floating_point = (F == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRECPE/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 10
8:8 F x
7:7 _ 0
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRECPE/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
floating_point = (F == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRECPE/A:index
Execute: aarch32/VRECPE/A:execute
Decode: aarch32/VRECPE/A1_A:decode@aarch32/VRECPE/A1_A:diagram
Decode: aarch32/VRECPE/T1_A:decode@aarch32/VRECPE/T1_A:diagram
TAG:aarch32/UQSUB8/A:execute
diff1 = UInt(R[n][7:0]) - UInt(R[m][7:0]);
diff2 = UInt(R[n][15:8]) - UInt(R[m][15:8]);
diff3 = UInt(R[n][23:16]) - UInt(R[m][23:16]);
diff4 = UInt(R[n][31:24]) - UInt(R[m][31:24]);
R[d][7:0]   = UnsignedSat(diff1, 8);
R[d][15:8]  = UnsignedSat(diff2, 8);
R[d][23:16] = UnsignedSat(diff3, 8);
R[d][31:24] = UnsignedSat(diff4, 8);
TAG:aarch32/UQSUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQSUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQSUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQSUB8/A:index
Execute: aarch32/UQSUB8/A:execute
Decode: aarch32/UQSUB8/A1_A:decode@aarch32/UQSUB8/A1_A:diagram
Decode: aarch32/UQSUB8/T1_A:decode@aarch32/UQSUB8/T1_A:diagram
TAG:aarch32/VRSUBHN/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
for e = 0 to elements-1
    result = Elem[Qin[n>>1],e,2*esize] - Elem[Qin[m>>1],e,2*esize] + round_const;
    Elem[D[d],e,esize] = result[2*esize-1:esize];
TAG:aarch32/VRSUBHN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0110
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRSUBHN/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VRSUBHN/A:index
Execute: aarch32/VRSUBHN/A:execute
Decode: aarch32/VRSUBHN/T1A1_A:decode@aarch32/VRSUBHN/T1A1_A:diagram
Decode: aarch32/VRSUBHN/T1A1_A:decode@aarch32/VRSUBHN/T1A1_A:diagram
TAG:aarch32/VINS/A:execute
CheckVFPEnabled(TRUE);
S[d] = S[m][15:0] : S[d][15:0];
TAG:aarch32/VINS/A1_A:diagram
A32
31:23 _ 111111101
22:22 D x
21:16 _ 110000
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VINS/A1_A:decode
if !HaveFP16Ext() then UNDEFINED;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
d = UInt(Vd:D); m = UInt(Vm:M);

TAG:aarch32/VINS/T1_A:diagram
T32
31:23 _ 111111101
22:22 D x
21:16 _ 110000
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VINS/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFP16Ext() then UNDEFINED;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
d = UInt(Vd:D); m = UInt(Vm:M);

TAG:aarch32/VINS/A:index
Execute: aarch32/VINS/A:execute
Decode: aarch32/VINS/A1_A:decode@aarch32/VINS/A1_A:diagram
Decode: aarch32/VINS/T1_A:decode@aarch32/VINS/T1_A:diagram
TAG:aarch32/VMOVN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    Elem[D[d],e,esize] = Elem[Qin[m>>1],e,2*esize][esize-1:0];
TAG:aarch32/VMOVN/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0100
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMOVN/T1A1_A:decode
if size == '11' then UNDEFINED;
if Vm[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VMOVN/A:index
Execute: aarch32/VMOVN/A:execute
Decode: aarch32/VMOVN/T1A1_A:decode@aarch32/VMOVN/T1A1_A:diagram
Decode: aarch32/VMOVN/T1A1_A:decode@aarch32/VMOVN/T1A1_A:diagram
TAG:aarch32/VMUL_s/A:execute
CheckAdvSIMDEnabled();
op2 = Elem[Din[m],index,esize];  op2val = Int(op2, unsigned);
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[Din[n+r],e,esize];  op1val = Int(op1, unsigned);
        if floating_point then
            Elem[D[d+r],e,esize] = FPMul(op1, op2, StandardFPSCRValue());
        else
            if long_destination then
                Elem[Q[d>>1],e,2*esize] = (op1val*op2val)[2*esize-1:0];
            else
                Elem[D[d+r],e,esize] = (op1val*op2val)[esize-1:0];
TAG:aarch32/VMUL_s/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1010
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_s/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
unsigned = (U == '1');  long_destination = TRUE;  floating_point = FALSE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VMUL_s/A:index
Execute: aarch32/VMUL_s/A:execute
Decode: aarch32/VMUL_s/T2A2_A:decode@aarch32/VMUL_s/T2A2_A:diagram
Decode: aarch32/VMUL_s/T2A2_A:decode@aarch32/VMUL_s/T2A2_A:diagram
TAG:aarch32/VRECPS/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = FPRecipStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);
TAG:aarch32/VRECPS/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRECPS/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRECPS/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRECPS/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRECPS/A:index
Execute: aarch32/VRECPS/A:execute
Decode: aarch32/VRECPS/A1_A:decode@aarch32/VRECPS/A1_A:diagram
Decode: aarch32/VRECPS/T1_A:decode@aarch32/VRECPS/T1_A:diagram
TAG:aarch32/ADD_SP_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(SP, shifted, '0');
if d == 15 then
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADD_SP_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 100
20:20 S x
19:16 _ 1101
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/ADD_SP_r/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/ADD_SP_r/T1_A:diagram
T16
31:26 _ 010001
25:24 _ 00
23:23 DM x
22:19 _ 1101
18:16 Rdm xxx
15:0 _ 0000000000000000
TAG:aarch32/ADD_SP_r/T1_A:decode
d = UInt(DM:Rdm);  m = UInt(DM:Rdm);  setflags = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);
if d == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/ADD_SP_r/T2_A:diagram
T16
31:26 _ 010001
25:24 _ 00
23:23 _ 1
22:19 Rm xxxx
18:16 _ 101
15:0 _ 0000000000000000
TAG:aarch32/ADD_SP_r/T2_A:decode
if Rm == '1101' then SEE "encoding T1";
d = 13;  m = UInt(Rm);  setflags = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/ADD_SP_r/T3_A:diagram
T32
31:25 _ 1110101
24:21 _ 1000
20:20 S x
19:16 _ 1101
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/ADD_SP_r/T3_A:decode
if Rd == '1111' && S == '1' then SEE "CMN (register)";
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADD_SP_r/A:index
Execute: aarch32/ADD_SP_r/A:execute
Decode: aarch32/ADD_SP_r/A1_A:decode@aarch32/ADD_SP_r/A1_A:diagram
Decode: aarch32/ADD_SP_r/T1_A:decode@aarch32/ADD_SP_r/T1_A:diagram
Decode: aarch32/ADD_SP_r/T2_A:decode@aarch32/ADD_SP_r/T2_A:diagram
Decode: aarch32/ADD_SP_r/T3_A:decode@aarch32/ADD_SP_r/T3_A:diagram
TAG:aarch32/VQDMULL/A:execute
CheckAdvSIMDEnabled();
if scalar_form then op2 = SInt(Elem[Din[m],index,esize]);
for e = 0 to elements-1
    if !scalar_form then op2 = SInt(Elem[Din[m],e,esize]);
    op1 = SInt(Elem[Din[n],e,esize]);
    // The following only saturates if both op1 and op2 equal -(2^(esize-1))
    (product, sat) = SignedSatQ(2*op1*op2, 2*esize);
    Elem[Q[d>>1],e,2*esize] = product;
    if sat then FPSCR.QC = '1';
TAG:aarch32/VQDMULL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMULL/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
scalar_form = FALSE;  d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);
esize = 8 << UInt(size);  elements = 64 DIV esize;

TAG:aarch32/VQDMULL/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQDMULL/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQDMULL/A:index
Execute: aarch32/VQDMULL/A:execute
Decode: aarch32/VQDMULL/T1A1_A:decode@aarch32/VQDMULL/T1A1_A:diagram
Decode: aarch32/VQDMULL/T2A2_A:decode@aarch32/VQDMULL/T2A2_A:diagram
Decode: aarch32/VQDMULL/T1A1_A:decode@aarch32/VQDMULL/T1A1_A:diagram
Decode: aarch32/VQDMULL/T2A2_A:decode@aarch32/VQDMULL/T2A2_A:diagram
TAG:aarch32/VQABS/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        result = Abs(SInt(Elem[D[m+r],e,esize]));
        (Elem[D[d+r],e,esize], sat) = SignedSatQ(result, esize);
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQABS/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1110
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQABS/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQABS/A:index
Execute: aarch32/VQABS/A:execute
Decode: aarch32/VQABS/T1A1_A:decode@aarch32/VQABS/T1A1_A:diagram
Decode: aarch32/VQABS/T1A1_A:decode@aarch32/VQABS/T1A1_A:diagram
TAG:aarch32/ORN_i/A:execute
result = R[n] OR NOT(imm32);
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/ORN_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0011
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ORN_i/T1_A:decode
if Rn == '1111' then SEE "MVN (immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ORN_i/A:index
Execute: aarch32/ORN_i/A:execute
Decode: aarch32/ORN_i/T1_A:decode@aarch32/ORN_i/T1_A:diagram
TAG:aarch32/RSB_i/A:execute
(result, nzcv) = AddWithCarry(NOT(R[n]), imm32, '1');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSB_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 011
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/RSB_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/RSB_i/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1001
21:19 Rn xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/RSB_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = !InITBlock();  imm32 = Zeros(32); // immediate = #0

TAG:aarch32/RSB_i/T2_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1110
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/RSB_i/T2_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/RSB_i/A:index
Execute: aarch32/RSB_i/A:execute
Decode: aarch32/RSB_i/A1_A:decode@aarch32/RSB_i/A1_A:diagram
Decode: aarch32/RSB_i/T1_A:decode@aarch32/RSB_i/T1_A:diagram
Decode: aarch32/RSB_i/T2_A:decode@aarch32/RSB_i/T2_A:diagram
TAG:aarch32/SSAT/A:execute
operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
(result, sat) = SignedSatQ(SInt(operand), saturate_to);
R[d] = SignExtend(result, 32);
if sat then
    PSTATE.Q = '1';
TAG:aarch32/SSAT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:21 _ 1
20:16 sat_imm xxxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:6 sh x
5:4 _ 01
3:0 Rn xxxx
TAG:aarch32/SSAT/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/SSAT/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 00
21:21 sh x
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 sat_imm xxxxx
TAG:aarch32/SSAT/T1_A:decode
if sh == '1' && (imm3:imm2) == '00000' then SEE "SSAT16";
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm)+1;
(shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SSAT/A:index
Execute: aarch32/SSAT/A:execute
Decode: aarch32/SSAT/A1_A:decode@aarch32/SSAT/A1_A:diagram
Decode: aarch32/SSAT/T1_A:decode@aarch32/SSAT/T1_A:diagram
TAG:aarch32/VABD_f/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
        Elem[D[d+r],e,esize] = FPAbs(FPSub(op1,op2,StandardFPSCRValue()));
TAG:aarch32/VABD_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABD_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VABD_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABD_f/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VABD_f/A:index
Execute: aarch32/VABD_f/A:execute
Decode: aarch32/VABD_f/A1_A:decode@aarch32/VABD_f/A1_A:diagram
Decode: aarch32/VABD_f/T1_A:decode@aarch32/VABD_f/T1_A:diagram
TAG:aarch32/UQADD16/A:execute
sum1 = UInt(R[n][15:0]) + UInt(R[m][15:0]);
sum2 = UInt(R[n][31:16]) + UInt(R[m][31:16]);
R[d][15:0]  = UnsignedSat(sum1, 16);
R[d][31:16] = UnsignedSat(sum2, 16);
TAG:aarch32/UQADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQADD16/A:index
Execute: aarch32/UQADD16/A:execute
Decode: aarch32/UQADD16/A1_A:decode@aarch32/UQADD16/A1_A:diagram
Decode: aarch32/UQADD16/T1_A:decode@aarch32/UQADD16/T1_A:diagram
TAG:aarch32/QDSUB/A:execute
(doubled, sat1) = SignedSatQ(2 * SInt(R[n]), 32);
(R[d], sat2)  = SignedSatQ(SInt(R[m]) - SInt(doubled), 32);
if sat1 || sat2 then
    PSTATE.Q = '1';
TAG:aarch32/QDSUB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 11
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0101
3:0 Rm xxxx
TAG:aarch32/QDSUB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QDSUB/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 11
3:0 Rm xxxx
TAG:aarch32/QDSUB/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QDSUB/A:index
Execute: aarch32/QDSUB/A:execute
Decode: aarch32/QDSUB/A1_A:decode@aarch32/QDSUB/A1_A:diagram
Decode: aarch32/QDSUB/T1_A:decode@aarch32/QDSUB/T1_A:diagram
TAG:aarch32/REV/A:execute
bits(32) result;
result[31:24] = R[m][7:0];
result[23:16] = R[m][15:8];
result[15:8]  = R[m][23:16];
result[7:0]   = R[m][31:24];
R[d] = result;
TAG:aarch32/REV/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 0
21:20 _ 11
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:4 _ 011
3:0 Rm xxxx
TAG:aarch32/REV/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/REV/T1_A:diagram
T16
31:24 _ 10111010
23:22 _ 00
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/REV/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);

TAG:aarch32/REV/T2_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/REV/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/REV/A:index
Execute: aarch32/REV/A:execute
Decode: aarch32/REV/A1_A:decode@aarch32/REV/A1_A:diagram
Decode: aarch32/REV/T1_A:decode@aarch32/REV/T1_A:diagram
Decode: aarch32/REV/T2_A:decode@aarch32/REV/T2_A:diagram
TAG:aarch32/STREXB/A:execute
address = R[n];
if AArch32.ExclusiveMonitorsPass(address,1) then
    MemA[address,1] = R[t][7:0];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STREXB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STREXB/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREXB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:6 _ 01
5:4 _ 00
3:0 Rd xxxx
TAG:aarch32/STREXB/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREXB/A:index
Execute: aarch32/STREXB/A:execute
Decode: aarch32/STREXB/A1_A:decode@aarch32/STREXB/A1_A:diagram
Decode: aarch32/STREXB/T1_A:decode@aarch32/STREXB/T1_A:diagram
TAG:aarch32/DCPS1/A:execute
if !Halted() then UNDEFINED;

if EL2Enabled() && PSTATE.EL == EL0 then
    tge = if ELUsingAArch32(EL2) then HCR.TGE else HCR_EL2.TGE;
    if tge == '1' then UNDEFINED;

if PSTATE.EL != EL0 || ELUsingAArch32(EL1) then
    if PSTATE.M == M32_Monitor then SCR.NS = '0';
    if PSTATE.EL != EL2 then
        AArch32.WriteMode(M32_Svc);
        PSTATE.E = SCTLR.EE;
        if HavePANExt() && SCTLR.SPAN == '0' then PSTATE.PAN = '1';
        LR_svc = bits(32) UNKNOWN;
        SPSR_svc = bits(32) UNKNOWN;
    else
        PSTATE.E = HSCTLR.EE;
        ELR_hyp = bits(32) UNKNOWN;
        HSR = bits(32) UNKNOWN;
        SPSR_hyp = bits(32) UNKNOWN;

    DLR = bits(32) UNKNOWN;
    DSPSR = bits(32) UNKNOWN;
else                                        // Targeting EL1 using AArch64
    AArch64.MaybeZeroRegisterUppers();
    MaybeZeroSVEUppers(EL1);
    PSTATE.nRW = '0';
    PSTATE.SP = '1';
    PSTATE.EL = EL1;
    if HavePANExt() && SCTLR_EL1.SPAN == '0' then PSTATE.PAN = '1';
    if HaveUAOExt() then PSTATE.UAO = '0';

    ELR_EL1 = bits(64) UNKNOWN;
    ESR_EL1 = bits(32) UNKNOWN;
    SPSR_EL1 = bits(32) UNKNOWN;

    DLR_EL0 = bits(64) UNKNOWN;
    DSPSR_EL0 = bits(32) UNKNOWN;

    // SCTLR_EL1.IESB might be ignored in Debug state.
    if HaveIESB() && SCTLR_EL1.IESB == '1' &&  !ConstrainUnpredictableBool(Unpredictable_IESBinDebug) then
        SynchronizeErrors();

UpdateEDSCRFields();                        // Update EDSCR PE state flags
TAG:aarch32/DCPS1/T1_A:diagram
T32
31:20 _ 111101111000
19:16 _ 1111
15:12 _ 1000
11:2 _ 0000000000
1:0 _ 01
TAG:aarch32/DCPS1/T1_A:decode
// No additional decoding required.

TAG:aarch32/DCPS1/A:index
Execute: aarch32/DCPS1/A:execute
Decode: aarch32/DCPS1/T1_A:decode@aarch32/DCPS1/T1_A:diagram
TAG:aarch32/STM_u/AS:execute
if PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.M IN {M32_User,M32_System} then
    UNPREDICTABLE;
else
    length = 4*BitCount(registers);
    address = if increment then R[n] else R[n]-length;
    if wordhigher then address = address+4;
    for i = 0 to 14
        if registers[i] == '1' then  // Store User mode register
            MemA[address,4] = Rmode[i, M32_User];
            address = address + 4;
    if registers[15] == '1' then
        MemA[address,4] = PCStoreValue();
TAG:aarch32/STM_u/A1_AS:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 P x
23:23 U x
22:22 _ 1
21:21 _ (0)
20:20 _ 0
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/STM_u/A1_AS:decode
n = UInt(Rn);  registers = register_list;  increment = (U == '1');  wordhigher = (P == U);
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STM_u/AS:index
Execute: aarch32/STM_u/AS:execute
Decode: aarch32/STM_u/A1_AS:decode@aarch32/STM_u/A1_AS:diagram
TAG:aarch32/VST1_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
MemU[address,ebytes] = Elem[D[d],index];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + ebytes;
TAG:aarch32/VST1_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST1_1/T1A1_A:decode
if size == '11' then UNDEFINED;
if index_align[0] != '0' then UNDEFINED;
ebytes = 1;  index = UInt(index_align[3:1]);  alignment = 1;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VST1_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST1_1/T2A2_A:decode
if size == '11' then UNDEFINED;
if index_align[1] != '0' then UNDEFINED;
ebytes = 2;  index = UInt(index_align[3:2]);
alignment = if index_align[0] == '0' then 1 else 2;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VST1_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST1_1/T3A3_A:decode
if size == '11' then UNDEFINED;
if index_align[2] != '0' then UNDEFINED;
if index_align[1:0] != '00' && index_align[1:0] != '11' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
alignment = if index_align[1:0] == '00' then 1 else 4;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VST1_1/A:index
Execute: aarch32/VST1_1/A:execute
Decode: aarch32/VST1_1/T1A1_A:decode@aarch32/VST1_1/T1A1_A:diagram
Decode: aarch32/VST1_1/T2A2_A:decode@aarch32/VST1_1/T2A2_A:diagram
Decode: aarch32/VST1_1/T3A3_A:decode@aarch32/VST1_1/T3A3_A:diagram
Decode: aarch32/VST1_1/T1A1_A:decode@aarch32/VST1_1/T1A1_A:diagram
Decode: aarch32/VST1_1/T2A2_A:decode@aarch32/VST1_1/T2A2_A:diagram
Decode: aarch32/VST1_1/T3A3_A:decode@aarch32/VST1_1/T3A3_A:diagram
TAG:aarch32/VCVT/A:execute
bits(128) operand;
bits(64) result;

if ConditionPassed() then
    EncodingSpecificOperations();
    CheckAdvSIMDEnabled();

    operand = Q[m>>1];
    for e = 0 to 3
        bits(32) op = Elem[operand, e, 32];
        Elem[result, e, 16] = FPConvertBF(op, StandardFPSCRValue());
    D[d] = result;
TAG:aarch32/VCVT/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 _ 01
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1100
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT/T1A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer m = UInt(M:Vm);

TAG:aarch32/VCVT/A:index
Execute: aarch32/VCVT/A:execute
Decode: aarch32/VCVT/T1A1_A:decode@aarch32/VCVT/T1A1_A:diagram
Decode: aarch32/VCVT/T1A1_A:decode@aarch32/VCVT/T1A1_A:diagram
TAG:aarch32/LDAB/A:execute
address = R[n];
R[t] = ZeroExtend(MemO[address, 1], 32);
TAG:aarch32/LDAB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAB/A1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 00
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAB/T1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAB/A:index
Execute: aarch32/LDAB/A:execute
Decode: aarch32/LDAB/A1_A:decode@aarch32/LDAB/A1_A:diagram
Decode: aarch32/LDAB/T1_A:decode@aarch32/LDAB/T1_A:diagram
TAG:aarch32/VSQRT/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16 S[d] = Zeros(16) : FPSqrt(S[m][15:0], FPSCR);
    when 32 S[d] = FPSqrt(S[m], FPSCR);
    when 64 D[d] = FPSqrt(D[m], FPSCR);
TAG:aarch32/VSQRT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSQRT/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VSQRT/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSQRT/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VSQRT/A:index
Execute: aarch32/VSQRT/A:execute
Decode: aarch32/VSQRT/A1_A:decode@aarch32/VSQRT/A1_A:diagram
Decode: aarch32/VSQRT/T1_A:decode@aarch32/VSQRT/T1_A:diagram
TAG:aarch32/VMLA_s/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 0
10:10 op 1
9:8 _ 10
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMLA_s/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || Vd[0] == '1' then UNDEFINED;
unsigned = (U == '1');  add = (op == '0');  floating_point = FALSE;  long_destination = TRUE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = 1;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/SHSUB16/A:execute
diff1 = SInt(R[n][15:0]) - SInt(R[m][15:0]);
diff2 = SInt(R[n][31:16]) - SInt(R[m][31:16]);
R[d][15:0]  = diff1[16:1];
R[d][31:16] = diff2[16:1];
TAG:aarch32/SHSUB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHSUB16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHSUB16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 101
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHSUB16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHSUB16/A:index
Execute: aarch32/SHSUB16/A:execute
Decode: aarch32/SHSUB16/A1_A:decode@aarch32/SHSUB16/A1_A:diagram
Decode: aarch32/SHSUB16/T1_A:decode@aarch32/SHSUB16/T1_A:diagram
TAG:aarch32/VQRSHRN/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for e = 0 to elements-1
    operand = Int(Elem[Qin[m>>1],e,2*esize], src_unsigned);
    (result, sat) = SatQ((operand + round_const) >> shift_amount, esize, dest_unsigned);
    Elem[D[d],e,esize] = result;
    if sat then FPSCR.QC = '1';
TAG:aarch32/VQRSHRN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:9 _ 100
8:8 op x
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRSHRN/T1A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if U == '0' && op == '0' then SEE "VRSHRN";
if Vm[0] == '1' then UNDEFINED;
case imm6 of
    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VQRSHRN/A:index
Execute: aarch32/VQRSHRN/A:execute
Decode: aarch32/VQRSHRN/T1A1_A:decode@aarch32/VQRSHRN/T1A1_A:diagram
Decode: aarch32/VQRSHRN/T1A1_A:decode@aarch32/VQRSHRN/T1A1_A:diagram
TAG:aarch32/STRH_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
MemU[address,2] = R[t][15:0];
if wback then R[n] = offset_addr;
TAG:aarch32/STRH_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/STRH_r/A1_A:decode
if P == '0' && W == '1' then SEE "STRHT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STRH_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 0
26:26 _ 0
25:25 _ 1
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STRH_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/STRH_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/STRH_r/T2_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if t == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRH_r/A:index
Execute: aarch32/STRH_r/A:execute
Decode: aarch32/STRH_r/A1_A:decode@aarch32/STRH_r/A1_A:diagram
Decode: aarch32/STRH_r/T1_A:decode@aarch32/STRH_r/T1_A:diagram
Decode: aarch32/STRH_r/T2_A:decode@aarch32/STRH_r/T2_A:diagram
TAG:aarch32/LDRH_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    data = MemU[address,2];
    if wback then R[n] = offset_addr;
    R[t] = ZeroExtend(data, 32);
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    data = MemU[address,2];
    if wback then R[n] = offset_addr;
    R[t] = ZeroExtend(data, 32);
TAG:aarch32/LDRH_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRH_i/A1_A:decode
if Rn == '1111' then SEE "LDRH (literal)";
if P == '0' && W == '1' then SEE "LDRHT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE;

TAG:aarch32/LDRH_i/T1_A:diagram
T16
31:28 _ 1000
27:27 _ 1
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRH_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/LDRH_i/T2_A:diagram
T32
31:23 _ 111110001
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRH_i/T2_A:decode
if Rt == '1111' then SEE "PLD (immediate)";
if Rn == '1111' then SEE "LDRH (literal)";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRH_i/T3_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRH_i/T3_A:decode
if Rn == '1111' then SEE "LDRH (literal)";
if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLDW (immediate)";
if P == '1' && U == '1' && W == '0' then SEE "LDRHT";
if P == '0' && W == '0' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRH_i/A:index
Execute: aarch32/LDRH_i/A:execute
Decode: aarch32/LDRH_i/A1_A:decode@aarch32/LDRH_i/A1_A:diagram
Decode: aarch32/LDRH_i/T1_A:decode@aarch32/LDRH_i/T1_A:diagram
Decode: aarch32/LDRH_i/T2_A:decode@aarch32/LDRH_i/T2_A:diagram
Decode: aarch32/LDRH_i/T3_A:decode@aarch32/LDRH_i/T3_A:diagram
TAG:aarch32/VST3_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for e = 0 to elements-1
    MemU[address,         ebytes] = Elem[D[d], e];
    MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
    MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
    address = address + 3*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 24;
TAG:aarch32/VST3_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 010x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST3_m/T1A1_A:decode
if size == '11' || align[1] == '1' then UNDEFINED;
case itype of
    when '0100'
        inc = 1;
    when '0101'
        inc = 2;
    otherwise
        SEE "Related encodings";
alignment = if align[0] == '0' then 1 else 8;
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VST3_m/A:index
Execute: aarch32/VST3_m/A:execute
Decode: aarch32/VST3_m/T1A1_A:decode@aarch32/VST3_m/T1A1_A:diagram
Decode: aarch32/VST3_m/T1A1_A:decode@aarch32/VST3_m/T1A1_A:diagram
TAG:aarch32/VADDL/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    if is_vaddw then
        op1 = Int(Elem[Qin[n>>1],e,2*esize], unsigned);
    else
        op1 = Int(Elem[Din[n],e,esize], unsigned);
    result = op1 + Int(Elem[Din[m],e,esize],unsigned);
    Elem[Q[d>>1],e,2*esize] = result[2*esize-1:0];
TAG:aarch32/VADDL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:9 _ 000
8:8 op 0
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADDL/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vd[0] == '1' || (op == '1' && Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;  is_vaddw = (op == '1');
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VADDL/A:index
Execute: aarch32/VADDL/A:execute
Decode: aarch32/VADDL/T1A1_A:decode@aarch32/VADDL/T1A1_A:diagram
Decode: aarch32/VADDL/T1A1_A:decode@aarch32/VADDL/T1A1_A:diagram
TAG:aarch32/SHADD16/A:execute
sum1 = SInt(R[n][15:0]) + SInt(R[m][15:0]);
sum2 = SInt(R[n][31:16]) + SInt(R[m][31:16]);
R[d][15:0]  = sum1[16:1];
R[d][31:16] = sum2[16:1];
TAG:aarch32/SHADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHADD16/A:index
Execute: aarch32/SHADD16/A:execute
Decode: aarch32/SHADD16/A1_A:decode@aarch32/SHADD16/A1_A:diagram
Decode: aarch32/SHADD16/T1_A:decode@aarch32/SHADD16/T1_A:diagram
TAG:aarch32/PLD_i/A:execute
address = if add then (R[n] + imm32) else (R[n] - imm32);
if is_pldw then
    Hint_PreloadDataForWrite(address);
else
    Hint_PreloadData(address);
TAG:aarch32/PLD_i/A1_A:diagram
A32
31:25 _ 1111010
24:24 _ 1
23:23 U x
22:22 R x
21:20 _ 01
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLD_i/A1_A:decode
if Rn == '1111' then SEE "PLD (literal)";
n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');  is_pldw = (R == '0');

TAG:aarch32/PLD_i/T1_A:diagram
T32
31:23 _ 111110001
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLD_i/T1_A:decode
if Rn == '1111' then SEE "PLD (literal)";
n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;  is_pldw = (W == '1');

TAG:aarch32/PLD_i/T2_A:diagram
T32
31:23 _ 111110000
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:8 _ 1100
7:0 imm8 xxxxxxxx
TAG:aarch32/PLD_i/T2_A:decode
if Rn == '1111' then SEE "PLD (literal)";
n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;  is_pldw = (W == '1');

TAG:aarch32/PLD_i/A:index
Execute: aarch32/PLD_i/A:execute
Decode: aarch32/PLD_i/A1_A:decode@aarch32/PLD_i/A1_A:diagram
Decode: aarch32/PLD_i/T1_A:decode@aarch32/PLD_i/T1_A:diagram
Decode: aarch32/PLD_i/T2_A:decode@aarch32/PLD_i/T2_A:diagram
TAG:aarch32/STR_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,4] = if t == 15 then PCStoreValue() else R[t];
    if wback then R[n] = offset_addr;
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,4] = R[t];
    if wback then R[n] = offset_addr;
TAG:aarch32/STR_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STR_i/A1_A:decode
if P == '0' && W == '1' then SEE "STRT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STR_i/T1_A:diagram
T16
31:29 _ 011
28:28 _ 0
27:27 _ 0
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STR_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'00', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/STR_i/T2_A:diagram
T16
31:28 _ 1001
27:27 _ 0
26:24 Rt xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/STR_i/T2_A:decode
t = UInt(Rt);  n = 13;  imm32 = ZeroExtend(imm8:'00', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/STR_i/T3_A:diagram
T32
31:23 _ 111110001
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STR_i/T3_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
if t == 15 then UNPREDICTABLE;

TAG:aarch32/STR_i/T4_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/STR_i/T4_A:decode
if P == '1' && U == '1' && W == '0' then SEE "STRT";
if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE;

TAG:aarch32/STR_i/A:index
Execute: aarch32/STR_i/A:execute
Decode: aarch32/STR_i/A1_A:decode@aarch32/STR_i/A1_A:diagram
Decode: aarch32/STR_i/T1_A:decode@aarch32/STR_i/T1_A:diagram
Decode: aarch32/STR_i/T2_A:decode@aarch32/STR_i/T2_A:diagram
Decode: aarch32/STR_i/T3_A:decode@aarch32/STR_i/T3_A:diagram
Decode: aarch32/STR_i/T4_A:decode@aarch32/STR_i/T4_A:diagram
TAG:aarch32/SADD8/A:execute
sum1 = SInt(R[n][7:0]) + SInt(R[m][7:0]);
sum2 = SInt(R[n][15:8]) + SInt(R[m][15:8]);
sum3 = SInt(R[n][23:16]) + SInt(R[m][23:16]);
sum4 = SInt(R[n][31:24]) + SInt(R[m][31:24]);
R[d][7:0]   = sum1[7:0];
R[d][15:8]  = sum2[7:0];
R[d][23:16] = sum3[7:0];
R[d][31:24] = sum4[7:0];
PSTATE.GE[0]  = if sum1 >= 0 then '1' else '0';
PSTATE.GE[1]  = if sum2 >= 0 then '1' else '0';
PSTATE.GE[2]  = if sum3 >= 0 then '1' else '0';
PSTATE.GE[3]  = if sum4 >= 0 then '1' else '0';
TAG:aarch32/SADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SADD8/A:index
Execute: aarch32/SADD8/A:execute
Decode: aarch32/SADD8/A1_A:decode@aarch32/SADD8/A1_A:diagram
Decode: aarch32/SADD8/T1_A:decode@aarch32/SADD8/T1_A:diagram
TAG:aarch32/SB/A:execute
SpeculationBarrier();
TAG:aarch32/SB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 _ (0)(0)(0)(0)
TAG:aarch32/SB/A1_A:decode
// No additional decoding required

TAG:aarch32/SB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0111
3:0 _ (0)(0)(0)(0)
TAG:aarch32/SB/T1_A:decode
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/SB/A:index
Execute: aarch32/SB/A:execute
Decode: aarch32/SB/A1_A:decode@aarch32/SB/A1_A:diagram
Decode: aarch32/SB/T1_A:decode@aarch32/SB/T1_A:diagram
TAG:aarch32/ADC_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADC_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 101
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/ADC_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/ADC_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 0101
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/ADC_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/ADC_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 1010
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/ADC_r/T2_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADC_r/A:index
Execute: aarch32/ADC_r/A:execute
Decode: aarch32/ADC_r/A1_A:decode@aarch32/ADC_r/A1_A:diagram
Decode: aarch32/ADC_r/T1_A:decode@aarch32/ADC_r/T1_A:diagram
Decode: aarch32/ADC_r/T2_A:decode@aarch32/ADC_r/T2_A:diagram
TAG:aarch32/UQADD8/A:execute
sum1 = UInt(R[n][7:0]) + UInt(R[m][7:0]);
sum2 = UInt(R[n][15:8]) + UInt(R[m][15:8]);
sum3 = UInt(R[n][23:16]) + UInt(R[m][23:16]);
sum4 = UInt(R[n][31:24]) + UInt(R[m][31:24]);
R[d][7:0]   = UnsignedSat(sum1, 8);
R[d][15:8]  = UnsignedSat(sum2, 8);
R[d][23:16] = UnsignedSat(sum3, 8);
R[d][31:24] = UnsignedSat(sum4, 8);
TAG:aarch32/UQADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 110
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UQADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UQADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UQADD8/A:index
Execute: aarch32/UQADD8/A:execute
Decode: aarch32/UQADD8/A1_A:decode@aarch32/UQADD8/A1_A:diagram
Decode: aarch32/UQADD8/T1_A:decode@aarch32/UQADD8/T1_A:diagram
TAG:aarch32/VQRDMLSH/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (esize-1);
if scalar_form then op2 = SInt(Elem[D[m],index,esize]);
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = SInt(Elem[D[n+r],e,esize]);
        op3 = SInt(Elem[D[d+r],e,esize]) << esize;
        if !scalar_form then op2 = SInt(Elem[D[m+r],e,esize]);
        (result, sat) = SignedSatQ((op3 - 2*(op1*op2) + round_const) >> esize, esize);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQRDMLSH/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRDMLSH/A1_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRDMLSH/A2_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMLSH/A2_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQRDMLSH/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQRDMLSH/T1_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '00' || size == '11' then UNDEFINED;
add = FALSE;  scalar_form = FALSE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQRDMLSH/T2_A:diagram
T32
31:29 _ 111
28:28 Q x
27:23 _ 11111
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VQRDMLSH/T2_A:decode
if !HaveQRDMLAHExt() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
if size == '11' then SEE "Related encodings";
if size == '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
add = FALSE;  scalar_form = TRUE;  d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VQRDMLSH/A:index
Execute: aarch32/VQRDMLSH/A:execute
Decode: aarch32/VQRDMLSH/A1_A:decode@aarch32/VQRDMLSH/A1_A:diagram
Decode: aarch32/VQRDMLSH/A2_A:decode@aarch32/VQRDMLSH/A2_A:diagram
Decode: aarch32/VQRDMLSH/T1_A:decode@aarch32/VQRDMLSH/T1_A:diagram
Decode: aarch32/VQRDMLSH/T2_A:decode@aarch32/VQRDMLSH/T2_A:diagram
TAG:aarch32/HVC/AS:execute
if !HaveEL(EL2) || PSTATE.EL == EL0 || (IsSecure() && !IsSecureEL2Enabled()) then
    UNDEFINED;

if HaveEL(EL3) then
    if ELUsingAArch32(EL3) && SCR.HCE == '0' && PSTATE.EL == EL2 then
        UNPREDICTABLE;
    else
        hvc_enable = SCR_GEN[].HCE;
else
    hvc_enable = if ELUsingAArch32(EL2) then NOT(HCR.HCD) else NOT(HCR_EL2.HCD);

if hvc_enable == '0' then
    UNDEFINED;
else
    AArch32.CallHypervisor(imm16);
TAG:aarch32/HVC/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 10
20:20 _ 0
19:8 imm12 xxxxxxxxxxxx
7:4 _ 0111
3:0 imm4 xxxx
TAG:aarch32/HVC/A1_A:decode
if cond != '1110' then UNPREDICTABLE;
imm16 = imm12:imm4;

TAG:aarch32/HVC/T1_A:diagram
T32
31:21 _ 11110111111
20:20 _ 0
19:16 imm4 xxxx
15:14 _ 10
13:13 _ 0
12:12 _ 0
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/HVC/T1_A:decode
imm16 = imm4:imm12;
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/HVC/AS:index
Execute: aarch32/HVC/AS:execute
Decode: aarch32/HVC/A1_A:decode@aarch32/HVC/A1_A:diagram
Decode: aarch32/HVC/T1_A:decode@aarch32/HVC/T1_A:diagram
TAG:aarch32/VLDM/A:execute
CheckVFPEnabled(TRUE);
address = if add then R[n] else R[n]-imm32;
for r = 0 to regs-1
    if single_regs then
        S[d+r] = MemA[address,4];  address = address+4;
    else
        word1 = MemA[address,4];  word2 = MemA[address+4,4];  address = address+8;
        // Combine the word-aligned words in the correct order for current endianness.
        D[d+r] = if BigEndian() then word1:word2 else word2:word1;
if wback then R[n] = if add then R[n]+imm32 else R[n]-imm32;
TAG:aarch32/VLDM/T1A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 D x
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 _ 11
7:0 imm8 xxxxxxx1
TAG:aarch32/VLDM/T1A1_A:decode
if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
if P == '1' && W == '0' then SEE "VLDR";
if P == U && W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = FALSE;  add = (U == '1');  wback = (W == '1');
d = UInt(D:Vd);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
regs = UInt(imm8) DIV 2;  // If UInt(imm8) is odd, see "FLDM*X".
if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
if regs == 0 || regs > 16 || (d+regs) > 32 then UNPREDICTABLE;
if imm8[0] == '1' && (d+regs) > 16 then UNPREDICTABLE;

TAG:aarch32/VLDM/A:index
Execute: aarch32/VLDM/A:execute
Decode: aarch32/VLDM/T1A1_A:decode@aarch32/VLDM/T1A1_A:diagram
Decode: aarch32/VLDM/T1A1_A:decode@aarch32/VLDM/T1A1_A:diagram
TAG:aarch32/TST_i/A:execute
result = R[n] AND imm32;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TST_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/TST_i/A1_A:decode
n = UInt(Rn);
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/TST_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0000
20:20 _ 1
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 _ 1111
7:0 imm8 xxxxxxxx
TAG:aarch32/TST_i/T1_A:decode
n = UInt(Rn);
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/TST_i/A:index
Execute: aarch32/TST_i/A:execute
Decode: aarch32/TST_i/A1_A:decode@aarch32/TST_i/A1_A:diagram
Decode: aarch32/TST_i/T1_A:decode@aarch32/TST_i/T1_A:diagram
TAG:aarch32/VLD1_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for r = 0 to regs-1
    for e = 0 to elements-1
        bits(ebytes*8) data;
        if ebytes != 8 then
            data = MemU[address,ebytes];
        else
            - = AArch32.CheckAlignment(address, ebytes, AccType_NORMAL, iswrite);
            data[31:0] = if BigEndian() then MemU[address+4,4] else MemU[address,4];
            data[63:32] = if BigEndian() then MemU[address,4] else MemU[address+4,4];
        Elem[D[d+r],e] = data;
        address = address + ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 8*regs;
TAG:aarch32/VLD1_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0111
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD1_m/T1A1_A:decode
regs = 1;  if align[1] == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD1_m/T2A2_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 1010
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD1_m/T2A2_A:decode
regs = 2;  if align == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD1_m/T3A3_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0110
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD1_m/T3A3_A:decode
regs = 3;  if align[1] == '1' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD1_m/T4A4_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0010
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD1_m/T4A4_A:decode
regs = 4;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD1_m/A:index
Execute: aarch32/VLD1_m/A:execute
Decode: aarch32/VLD1_m/T1A1_A:decode@aarch32/VLD1_m/T1A1_A:diagram
Decode: aarch32/VLD1_m/T2A2_A:decode@aarch32/VLD1_m/T2A2_A:diagram
Decode: aarch32/VLD1_m/T3A3_A:decode@aarch32/VLD1_m/T3A3_A:diagram
Decode: aarch32/VLD1_m/T4A4_A:decode@aarch32/VLD1_m/T4A4_A:diagram
Decode: aarch32/VLD1_m/T1A1_A:decode@aarch32/VLD1_m/T1A1_A:diagram
Decode: aarch32/VLD1_m/T2A2_A:decode@aarch32/VLD1_m/T2A2_A:diagram
Decode: aarch32/VLD1_m/T3A3_A:decode@aarch32/VLD1_m/T3A3_A:diagram
Decode: aarch32/VLD1_m/T4A4_A:decode@aarch32/VLD1_m/T4A4_A:diagram
TAG:aarch32/VLDM/T2A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 D x
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:0 imm8 xxxxxxxx
TAG:aarch32/VLDM/T2A2_A:decode
if P == '0' && U == '0' && W == '0' then SEE "Related encodings";
if P == '1' && W == '0' then SEE "VLDR";
if P == U && W == '1' then UNDEFINED;
// Remaining combinations are PUW = 010 (IA without !), 011 (IA with !), 101 (DB with !)
single_regs = TRUE;  add = (U == '1');  wback = (W == '1');  d = UInt(Vd:D);  n = UInt(Rn);
imm32 = ZeroExtend(imm8:'00', 32);  regs = UInt(imm8);
if n == 15 && (wback || CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;
if regs == 0 || (d+regs) > 32 then UNPREDICTABLE;

TAG:aarch32/VLD4_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for e = 0 to elements-1
    Elem[D[d], e] = MemU[address,ebytes];
    Elem[D[d2],e] = MemU[address+ebytes,ebytes];
    Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
    Elem[D[d4],e] = MemU[address+3*ebytes,ebytes];
    address = address + 4*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 32;
TAG:aarch32/VLD4_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 000x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD4_m/T1A1_A:decode
case itype of
    when '0000'
        inc = 1;
    when '0001'
        inc = 2;
    otherwise
        SEE "Related encodings";
if size == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD4_m/A:index
Execute: aarch32/VLD4_m/A:execute
Decode: aarch32/VLD4_m/T1A1_A:decode@aarch32/VLD4_m/T1A1_A:diagram
Decode: aarch32/VLD4_m/T1A1_A:decode@aarch32/VLD4_m/T1A1_A:diagram
TAG:aarch32/VCVT_xv/A:execute
CheckVFPEnabled(TRUE);
if to_fixed then
    bits(size) result;
    case fp_size of
        when 16
            result = FPToFixed(S[d][15:0], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
            S[d] = Extend(result, 32, unsigned);
        when 32
            result = FPToFixed(S[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
            S[d] = Extend(result, 32, unsigned);
        when 64
            result = FPToFixed(D[d], frac_bits, unsigned, FPSCR, FPRounding_ZERO);
            D[d] = Extend(result, 64, unsigned);
else
    case fp_size of
        when 16
            bits(16) fp16 = FixedToFP(S[d][size-1:0], frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
            S[d] = Zeros(16):fp16;
        when 32
            S[d] = FixedToFP(S[d][size-1:0], frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
        when 64
            D[d] = FixedToFP(D[d][size-1:0], frac_bits, unsigned, FPSCR, FPRounding_TIEEVEN);
TAG:aarch32/VCVT_xv/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 1
18:18 op x
17:17 _ 1
16:16 U x
15:12 Vd xxxx
11:10 _ 10
9:8 sf xx
7:7 sx x
6:6 _ 1
5:5 i x
4:4 _ 0
3:0 imm4 xxxx
TAG:aarch32/VCVT_xv/A1_A:decode
if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
if sf == '01' && cond != '1110' then UNPREDICTABLE;
to_fixed = (op == '1');  unsigned = (U == '1');
size = if sx == '0' then 16 else 32;
frac_bits = size - UInt(imm4:i);
case sf of
    when '01' fp_size = 16; d = UInt(Vd:D);
    when '10' fp_size = 32; d = UInt(Vd:D);
    when '11' fp_size = 64; d = UInt(D:Vd);

if frac_bits < 0 then UNPREDICTABLE;

TAG:aarch32/VCVT_xv/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 1
18:18 op x
17:17 _ 1
16:16 U x
15:12 Vd xxxx
11:10 _ 10
9:8 sf xx
7:7 sx x
6:6 _ 1
5:5 i x
4:4 _ 0
3:0 imm4 xxxx
TAG:aarch32/VCVT_xv/T1_A:decode
if sf == '00' || (sf == '01' && !HaveFP16Ext()) then UNDEFINED;
if sf == '01' && InITBlock() then UNPREDICTABLE;
to_fixed = (op == '1');  unsigned = (U == '1');
size = if sx == '0' then 16 else 32;
frac_bits = size - UInt(imm4:i);
case sf of
    when '01' fp_size = 16; d = UInt(Vd:D);
    when '10' fp_size = 32; d = UInt(Vd:D);
    when '11' fp_size = 64; d = UInt(D:Vd);

if frac_bits < 0 then UNPREDICTABLE;

TAG:aarch32/VCVT_xv/A:index
Execute: aarch32/VCVT_xv/A:execute
Decode: aarch32/VCVT_xv/A1_A:decode@aarch32/VCVT_xv/A1_A:diagram
Decode: aarch32/VCVT_xv/T1_A:decode@aarch32/VCVT_xv/T1_A:diagram
TAG:aarch32/BIC_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND NOT(shifted);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/BIC_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/BIC_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/BIC_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1110
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/BIC_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/BIC_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0001
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/BIC_r/T2_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/BIC_r/A:index
Execute: aarch32/BIC_r/A:execute
Decode: aarch32/BIC_r/A1_A:decode@aarch32/BIC_r/A1_A:diagram
Decode: aarch32/BIC_r/T1_A:decode@aarch32/BIC_r/T1_A:diagram
Decode: aarch32/BIC_r/T2_A:decode@aarch32/BIC_r/T2_A:diagram
TAG:aarch32/SDIV/A:execute
if SInt(R[m]) == 0 then
    result = 0;
else
    result = RoundTowardsZero(Real(SInt(R[n])) / Real(SInt(R[m])));
R[d] = result[31:0];
TAG:aarch32/SDIV/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 001
19:16 Rd xxxx
15:12 Ra (1)(1)(1)(1)
11:8 Rm xxxx
7:5 _ 000
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SDIV/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE;

TAG:aarch32/SDIV/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 001
19:16 Rn xxxx
15:12 Ra (1)(1)(1)(1)
11:8 Rd xxxx
7:4 _ 1111
3:0 Rm xxxx
TAG:aarch32/SDIV/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);
if d == 15 || n == 15 || m == 15 || a != 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SDIV/A:index
Execute: aarch32/SDIV/A:execute
Decode: aarch32/SDIV/A1_A:decode@aarch32/SDIV/A1_A:diagram
Decode: aarch32/SDIV/T1_A:decode@aarch32/SDIV/T1_A:diagram
TAG:aarch32/VCMP/A:execute
CheckVFPEnabled(TRUE);
bits(4) nzcv;
case esize of
    when 16
        bits(16) op16 = if with_zero then FPZero('0') else S[m][15:0];
        nzcv = FPCompare(S[d][15:0], op16, quiet_nan_exc, FPSCR);
    when 32
        bits(32) op32 = if with_zero then FPZero('0') else S[m];
        nzcv = FPCompare(S[d], op32, quiet_nan_exc, FPSCR);
    when 64
        bits(64) op64 = if with_zero then FPZero('0') else D[m];
        nzcv = FPCompare(D[d], op64, quiet_nan_exc, FPSCR);

FPSCR.[N,Z,C,V] = nzcv;
TAG:aarch32/VCMP/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 100
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 E 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMP/A1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
quiet_nan_exc = (E == '1');  with_zero = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VCMP/A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 101
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 E 0
6:6 _ 1
5:5 _ (0)
4:4 _ 0
3:0 _ (0)(0)(0)(0)
TAG:aarch32/VCMP/A2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
quiet_nan_exc = (E == '1');  with_zero = TRUE;
case size of
    when '01' esize = 16; d = UInt(Vd:D);
    when '10' esize = 32; d = UInt(Vd:D);
    when '11' esize = 64; d = UInt(D:Vd);

TAG:aarch32/VCMP/T1_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 100
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 E 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMP/T1_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
quiet_nan_exc = (E == '1');  with_zero = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VCMP/T2_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 101
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 E 0
6:6 _ 1
5:5 _ (0)
4:4 _ 0
3:0 _ (0)(0)(0)(0)
TAG:aarch32/VCMP/T2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
quiet_nan_exc = (E == '1');  with_zero = TRUE;
case size of
    when '01' esize = 16; d = UInt(Vd:D);
    when '10' esize = 32; d = UInt(Vd:D);
    when '11' esize = 64; d = UInt(D:Vd);

TAG:aarch32/VCMP/A:index
Execute: aarch32/VCMP/A:execute
Decode: aarch32/VCMP/A1_A:decode@aarch32/VCMP/A1_A:diagram
Decode: aarch32/VCMP/A2_A:decode@aarch32/VCMP/A2_A:diagram
Decode: aarch32/VCMP/T1_A:decode@aarch32/VCMP/T1_A:diagram
Decode: aarch32/VCMP/T2_A:decode@aarch32/VCMP/T2_A:diagram
TAG:aarch32/SHA256H/A:execute
CheckCryptoEnabled32();
X = Q[d>>1]; Y = Q[n>>1]; W = Q[m>>1]; part1 = TRUE;
Q[d>>1] = SHA256hash(X, Y, W, part1);
TAG:aarch32/SHA256H/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256H/A1_A:decode
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256H/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256H/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA256Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA256H/A:index
Execute: aarch32/SHA256H/A:execute
Decode: aarch32/SHA256H/A1_A:decode@aarch32/SHA256H/A1_A:diagram
Decode: aarch32/SHA256H/T1_A:decode@aarch32/SHA256H/T1_A:diagram
TAG:aarch32/MCR/A:execute
AArch32.SysRegWrite(cp, ThisInstr(), R[t]);
TAG:aarch32/MCR/T1A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:21 opc1 xxx
20:20 _ 0
19:16 CRn xxxx
15:12 Rt xxxx
11:8 coproc 111x
7:5 opc2 xxx
4:4 _ 1
3:0 CRm xxxx
TAG:aarch32/MCR/T1A1_A:decode
t = UInt(Rt);  cp = if coproc[0] == '0' then 14 else 15;
if t == 15  then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MCR/A:index
Execute: aarch32/MCR/A:execute
Decode: aarch32/MCR/T1A1_A:decode@aarch32/MCR/T1A1_A:diagram
Decode: aarch32/MCR/T1A1_A:decode@aarch32/MCR/T1A1_A:diagram
TAG:aarch32/PSSBB/A:execute
SpeculativeStoreBypassBarrierToPA();
TAG:aarch32/PSSBB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0100
3:0 _ 0100
TAG:aarch32/PSSBB/A1_A:decode
// No additional decoding required

TAG:aarch32/PSSBB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0100
3:0 _ 0100
TAG:aarch32/PSSBB/T1_A:decode
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/PSSBB/A:index
Execute: aarch32/PSSBB/A:execute
Decode: aarch32/PSSBB/A1_A:decode@aarch32/PSSBB/A1_A:diagram
Decode: aarch32/PSSBB/T1_A:decode@aarch32/PSSBB/T1_A:diagram
TAG:aarch32/UMLAL/A:execute
result = UInt(R[n]) * UInt(R[m]) + UInt(R[dHi]:R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
if setflags then
    PSTATE.N = result[63];
    PSTATE.Z = IsZeroBit(result[63:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/UMLAL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 101
20:20 S x
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/UMLAL/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMLAL/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 110
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:4 _ 0000
3:0 Rm xxxx
TAG:aarch32/UMLAL/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMLAL/A:index
Execute: aarch32/UMLAL/A:execute
Decode: aarch32/UMLAL/A1_A:decode@aarch32/UMLAL/A1_A:diagram
Decode: aarch32/UMLAL/T1_A:decode@aarch32/UMLAL/T1_A:diagram
TAG:aarch32/VMOVL/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    result = Int(Elem[Din[m],e,esize], unsigned);
    Elem[Q[d>>1],e,2*esize] = result[2*esize-1:0];
TAG:aarch32/VMOVL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:19 imm3H xxx
18:16 _ 000
15:12 Vd xxxx
11:8 _ 1010
7:7 _ 0
6:6 _ 0
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMOVL/T1A1_A:decode
if imm3H == '000' then SEE "Related encodings";
if imm3H != '001' && imm3H != '010' && imm3H != '100' then SEE "VSHLL";
if Vd[0] == '1' then UNDEFINED;
esize = 8 * UInt(imm3H);
unsigned = (U == '1');  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VMOVL/A:index
Execute: aarch32/VMOVL/A:execute
Decode: aarch32/VMOVL/T1A1_A:decode@aarch32/VMOVL/T1A1_A:diagram
Decode: aarch32/VMOVL/T1A1_A:decode@aarch32/VMOVL/T1A1_A:diagram
TAG:aarch32/VABA/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VABA/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (U == '1');  long_destination = FALSE;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/SHA1SU1/A:execute
CheckCryptoEnabled32();
X = Q[d>>1]; Y = Q[m>>1];
T = X EOR LSR(Y, 32);
W0 = ROL(T[31:0], 1);
W1 = ROL(T[63:32], 1);
W2 = ROL(T[95:64], 1);
W3 = ROL(T[127:96], 1) EOR ROL(T[31:0], 2);
Q[d>>1] = W3:W2:W1:W0;
TAG:aarch32/SHA1SU1/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1SU1/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA1SU1/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1SU1/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA1SU1/A:index
Execute: aarch32/SHA1SU1/A:execute
Decode: aarch32/SHA1SU1/A1_A:decode@aarch32/SHA1SU1/A1_A:diagram
Decode: aarch32/SHA1SU1/T1_A:decode@aarch32/SHA1SU1/T1_A:diagram
TAG:aarch32/YIELD/A:execute
Hint_Yield();
TAG:aarch32/YIELD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00000001
TAG:aarch32/YIELD/A1_A:decode
// No additional decoding required

TAG:aarch32/YIELD/T1_A:diagram
T16
31:24 _ 10111111
23:20 _ 0001
19:16 _ 0000
15:0 _ 0000000000000000
TAG:aarch32/YIELD/T1_A:decode
// No additional decoding required

TAG:aarch32/YIELD/T2_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0000
3:0 _ 0001
TAG:aarch32/YIELD/T2_A:decode
// No additional decoding required

TAG:aarch32/YIELD/A:index
Execute: aarch32/YIELD/A:execute
Decode: aarch32/YIELD/A1_A:decode@aarch32/YIELD/A1_A:diagram
Decode: aarch32/YIELD/T1_A:decode@aarch32/YIELD/T1_A:diagram
Decode: aarch32/YIELD/T2_A:decode@aarch32/YIELD/T2_A:diagram
TAG:aarch32/VRSHR/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount - 1);
for r = 0 to regs-1
    for e = 0 to elements-1
        result = (Int(Elem[D[m+r],e,esize], unsigned) + round_const) >> shift_amount;
        Elem[D[d+r],e,esize] = result[esize-1:0];
TAG:aarch32/VRSHR/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0010
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRSHR/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSHR/A:index
Execute: aarch32/VRSHR/A:execute
Decode: aarch32/VRSHR/T1A1_A:decode@aarch32/VRSHR/T1A1_A:diagram
Decode: aarch32/VRSHR/T1A1_A:decode@aarch32/VRSHR/T1A1_A:diagram
TAG:aarch32/SSBB/A:execute
SpeculativeStoreBypassBarrierToVA();
TAG:aarch32/SSBB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0100
3:0 _ 0000
TAG:aarch32/SSBB/A1_A:decode
// No additional decoding required

TAG:aarch32/SSBB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0100
3:0 _ 0000
TAG:aarch32/SSBB/T1_A:decode
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/SSBB/A:index
Execute: aarch32/SSBB/A:execute
Decode: aarch32/SSBB/A1_A:decode@aarch32/SSBB/A1_A:diagram
Decode: aarch32/SSBB/T1_A:decode@aarch32/SSBB/T1_A:diagram
TAG:aarch32/STREXH/A:execute
address = R[n];
if AArch32.ExclusiveMonitorsPass(address,2) then
    MemA[address,2] = R[t][15:0];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STREXH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STREXH/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREXH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:6 _ 01
5:4 _ 01
3:0 Rd xxxx
TAG:aarch32/STREXH/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREXH/A:index
Execute: aarch32/STREXH/A:execute
Decode: aarch32/STREXH/A1_A:decode@aarch32/STREXH/A1_A:diagram
Decode: aarch32/STREXH/T1_A:decode@aarch32/STREXH/T1_A:diagram
TAG:aarch32/VTRN/A:execute
CheckAdvSIMDEnabled();
h = elements DIV 2;

for r = 0 to regs-1
    if d == m then
        D[d+r] = bits(64) UNKNOWN;
    else
        for e = 0 to h-1
            Elem[D[d+r],2*e+1,esize] = Elem[Din[m+r],2*e,esize];
            Elem[D[m+r],2*e,esize] = Elem[Din[d+r],2*e+1,esize];
TAG:aarch32/VTRN/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VTRN/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VTRN/A:index
Execute: aarch32/VTRN/A:execute
Decode: aarch32/VTRN/T1A1_A:decode@aarch32/VTRN/T1A1_A:diagram
Decode: aarch32/VTRN/T1A1_A:decode@aarch32/VTRN/T1A1_A:diagram
TAG:aarch32/SVC/A:execute
AArch32.CheckForSVCTrap(imm32[15:0]);
AArch32.CallSupervisor(imm32[15:0]);
TAG:aarch32/SVC/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1111
23:0 imm24 xxxxxxxxxxxxxxxxxxxxxxxx
TAG:aarch32/SVC/A1_A:decode
imm32 = ZeroExtend(imm24, 32);

TAG:aarch32/SVC/T1_A:diagram
T16
31:25 _ 1101111
24:24 _ 1
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/SVC/T1_A:decode
imm32 = ZeroExtend(imm8, 32);

TAG:aarch32/SVC/A:index
Execute: aarch32/SVC/A:execute
Decode: aarch32/SVC/A1_A:decode@aarch32/SVC/A1_A:diagram
Decode: aarch32/SVC/T1_A:decode@aarch32/SVC/T1_A:diagram
TAG:aarch32/STM/A:execute
address = R[n];
for i = 0 to 14
    if registers[i] == '1' then
        if i == n && wback && i != LowestSetBit(registers) then
            MemA[address,4] = bits(32) UNKNOWN;  // Only possible for encodings T1 and A1
        else
            MemA[address,4] = R[i];
        address = address + 4;
if registers[15] == '1' then  // Only possible for encoding A1
    MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] + 4*BitCount(registers);
TAG:aarch32/STM/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 0
23:23 _ 1
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/STM/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STM/T1_A:diagram
T16
31:28 _ 1100
27:27 _ 0
26:24 Rn xxx
23:16 register_list xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/STM/T1_A:decode
n = UInt(Rn);  registers = '00000000':register_list;  wback = TRUE;
if BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STM/T2_A:diagram
T32
31:25 _ 1110100
24:23 _ 01
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:15 P (0)
14:14 M x
13:0 register_list xxxxxxxxxxxxxx
TAG:aarch32/STM/T2_A:decode
n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 2 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;
if registers[13] == '1' then UNPREDICTABLE;
if registers[15] == '1' then UNPREDICTABLE;

TAG:aarch32/STM/A:index
Execute: aarch32/STM/A:execute
Decode: aarch32/STM/A1_A:decode@aarch32/STM/A1_A:diagram
Decode: aarch32/STM/T1_A:decode@aarch32/STM/T1_A:diagram
Decode: aarch32/STM/T2_A:decode@aarch32/STM/T2_A:diagram
TAG:aarch32/SHADD8/A:execute
sum1 = SInt(R[n][7:0]) + SInt(R[m][7:0]);
sum2 = SInt(R[n][15:8]) + SInt(R[m][15:8]);
sum3 = SInt(R[n][23:16]) + SInt(R[m][23:16]);
sum4 = SInt(R[n][31:24]) + SInt(R[m][31:24]);
R[d][7:0]   = sum1[8:1];
R[d][15:8]  = sum2[8:1];
R[d][23:16] = sum3[8:1];
R[d][31:24] = sum4[8:1];
TAG:aarch32/SHADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 011
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SHADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SHADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SHADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SHADD8/A:index
Execute: aarch32/SHADD8/A:execute
Decode: aarch32/SHADD8/A1_A:decode@aarch32/SHADD8/A1_A:diagram
Decode: aarch32/SHADD8/T1_A:decode@aarch32/SHADD8/T1_A:diagram
TAG:aarch32/CLREX/A:execute
ClearExclusiveLocal(ProcessorID());
TAG:aarch32/CLREX/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/CLREX/A1_A:decode
// No additional decoding required

TAG:aarch32/CLREX/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0010
3:0 _ (1)(1)(1)(1)
TAG:aarch32/CLREX/T1_A:decode
// No additional decoding required

TAG:aarch32/CLREX/A:index
Execute: aarch32/CLREX/A:execute
Decode: aarch32/CLREX/A1_A:decode@aarch32/CLREX/A1_A:diagram
Decode: aarch32/CLREX/T1_A:decode@aarch32/CLREX/T1_A:diagram
TAG:aarch32/VMOV_sr/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if unsigned then
    R[t] = ZeroExtend(Elem[D[n],index,esize], 32);
else
    R[t] = SignExtend(Elem[D[n],index,esize], 32);
TAG:aarch32/VMOV_sr/T1A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 U x
22:21 opc1 xx
20:20 _ 1
19:16 Vn xxxx
15:12 Rt xxxx
11:8 _ 1011
7:7 N x
6:5 opc2 xx
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_sr/T1A1_A:decode
case U:opc1:opc2 of
    when 'x1xxx'  advsimd = TRUE;  esize = 8;  index = UInt(opc1[0]:opc2);
    when 'x0xx1'  advsimd = TRUE;  esize = 16;  index = UInt(opc1[0]:opc2[1]);
    when '00x00'  advsimd = FALSE;  esize = 32;  index = UInt(opc1[0]);
    when '10x00'  UNDEFINED;
    when 'x0x10'  UNDEFINED;
t = UInt(Rt);  n = UInt(N:Vn);  unsigned = (U == '1');
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_sr/A:index
Execute: aarch32/VMOV_sr/A:execute
Decode: aarch32/VMOV_sr/T1A1_A:decode@aarch32/VMOV_sr/T1A1_A:diagram
Decode: aarch32/VMOV_sr/T1A1_A:decode@aarch32/VMOV_sr/T1A1_A:diagram
TAG:aarch32/VADD_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] + Elem[D[m+r],e,esize];
TAG:aarch32/VADD_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADD_i/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VADD_i/A:index
Execute: aarch32/VADD_i/A:execute
Decode: aarch32/VADD_i/T1A1_A:decode@aarch32/VADD_i/T1A1_A:diagram
Decode: aarch32/VADD_i/T1A1_A:decode@aarch32/VADD_i/T1A1_A:diagram
TAG:aarch32/VFMA_bfs/A:execute
CheckAdvSIMDEnabled();
bits(128) operand1 = Q[n>>1];
bits(64) operand2 = D[m];
bits(128) operand3 = Q[d>>1];
bits(128) result;

bits(32) element2 = Elem[operand2, i, 16] : Zeros(16);

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);
    bits(32) addend = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(addend, element1, element2,
                                   StandardFPSCRValue());

Q[d>>1] = result;
TAG:aarch32/VFMA_bfs/A1_A:diagram
A32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA_bfs/A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm[2:0]);
integer i = UInt(M:Vm[3]);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch32/VFMA_bfs/T1_A:diagram
T32
31:24 _ 11111110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA_bfs/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(Vm[2:0]);
integer i = UInt(M:Vm[3]);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch32/VFMA_bfs/A:index
Execute: aarch32/VFMA_bfs/A:execute
Decode: aarch32/VFMA_bfs/A1_A:decode@aarch32/VFMA_bfs/A1_A:diagram
Decode: aarch32/VFMA_bfs/T1_A:decode@aarch32/VFMA_bfs/T1_A:diagram
TAG:aarch32/ISB/A:execute
InstructionSynchronizationBarrier();
TAG:aarch32/ISB/A1_A:diagram
A32
31:20 _ 111101010111
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0110
3:0 option xxxx
TAG:aarch32/ISB/A1_A:decode
// No additional decoding required

TAG:aarch32/ISB/T1_A:diagram
T32
31:20 _ 111100111011
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 0110
3:0 option xxxx
TAG:aarch32/ISB/T1_A:decode
// No additional decoding required

TAG:aarch32/ISB/A:index
Execute: aarch32/ISB/A:execute
Decode: aarch32/ISB/A1_A:decode@aarch32/ISB/A1_A:diagram
Decode: aarch32/ISB/T1_A:decode@aarch32/ISB/T1_A:diagram
TAG:aarch32/SBC_i/A:execute
(result, nzcv) = AddWithCarry(R[n], NOT(imm32), PSTATE.C);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SBC_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 110
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/SBC_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/SBC_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1011
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/SBC_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SBC_i/A:index
Execute: aarch32/SBC_i/A:execute
Decode: aarch32/SBC_i/A1_A:decode@aarch32/SBC_i/A1_A:diagram
Decode: aarch32/SBC_i/T1_A:decode@aarch32/SBC_i/T1_A:diagram
TAG:aarch32/ADC_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, PSTATE.C);
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADC_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 101
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/ADC_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/ADC_rr/A:index
Execute: aarch32/ADC_rr/A:execute
Decode: aarch32/ADC_rr/A1_A:decode@aarch32/ADC_rr/A1_A:diagram
TAG:aarch32/VMUL_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 op x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMUL_i/T1A1_A:decode
if size == '11' || (op == '1' && size != '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
polynomial = (op == '1');  long_destination = FALSE;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/TEQ_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] EOR shifted;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TEQ_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/TEQ_rr/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
shift_t = DecodeRegShift(stype);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/TEQ_rr/A:index
Execute: aarch32/TEQ_rr/A:execute
Decode: aarch32/TEQ_rr/A1_A:decode@aarch32/TEQ_rr/A1_A:diagram
TAG:aarch32/TEQ_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] EOR shifted;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TEQ_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/TEQ_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/TEQ_r/T1_A:diagram
T32
31:25 _ 1110101
24:21 _ 0100
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 _ 1111
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/TEQ_r/T1_A:decode
n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/TEQ_r/A:index
Execute: aarch32/TEQ_r/A:execute
Decode: aarch32/TEQ_r/A1_A:decode@aarch32/TEQ_r/A1_A:diagram
Decode: aarch32/TEQ_r/T1_A:decode@aarch32/TEQ_r/T1_A:diagram
TAG:aarch32/VCGT_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            bits(esize) zero = FPZero('0');
            test_passed = FPCompareGT(Elem[D[m+r],e,esize], zero, StandardFPSCRValue());
        else
            test_passed = (SInt(Elem[D[m+r],e,esize]) > 0);
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCGT_i/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 000
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGT_i/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGT_i/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 000
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGT_i/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGT_i/A:index
Execute: aarch32/VCGT_i/A:execute
Decode: aarch32/VCGT_i/A1_A:decode@aarch32/VCGT_i/A1_A:diagram
Decode: aarch32/VCGT_i/T1_A:decode@aarch32/VCGT_i/T1_A:diagram
TAG:aarch32/STRH_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,2] = R[t][15:0];
    if wback then R[n] = offset_addr;
else
    offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
    address = if index then offset_addr else R[n];
    MemU[address,2] = R[t][15:0];
    if wback then R[n] = offset_addr;
TAG:aarch32/STRH_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/STRH_i/A1_A:decode
if P == '0' && W == '1' then SEE "STRHT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/STRH_i/T1_A:diagram
T16
31:28 _ 1000
27:27 _ 0
26:22 imm5 xxxxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/STRH_i/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm5:'0', 32);
index = TRUE;  add = TRUE;  wback = FALSE;

TAG:aarch32/STRH_i/T2_A:diagram
T32
31:23 _ 111110001
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STRH_i/T2_A:decode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRH_i/T3_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/STRH_i/T3_A:decode
if P == '1' && U == '1' && W == '0' then SEE "STRHT";
if Rn == '1111' || (P == '0' && W == '0') then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRH_i/A:index
Execute: aarch32/STRH_i/A:execute
Decode: aarch32/STRH_i/A1_A:decode@aarch32/STRH_i/A1_A:diagram
Decode: aarch32/STRH_i/T1_A:decode@aarch32/STRH_i/T1_A:diagram
Decode: aarch32/STRH_i/T2_A:decode@aarch32/STRH_i/T2_A:diagram
Decode: aarch32/STRH_i/T3_A:decode@aarch32/STRH_i/T3_A:diagram
TAG:aarch32/QADD8/A:execute
sum1 = SInt(R[n][7:0]) + SInt(R[m][7:0]);
sum2 = SInt(R[n][15:8]) + SInt(R[m][15:8]);
sum3 = SInt(R[n][23:16]) + SInt(R[m][23:16]);
sum4 = SInt(R[n][31:24]) + SInt(R[m][31:24]);
R[d][7:0]   = SignedSat(sum1, 8);
R[d][15:8]  = SignedSat(sum2, 8);
R[d][23:16] = SignedSat(sum3, 8);
R[d][31:24] = SignedSat(sum4, 8);
TAG:aarch32/QADD8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QADD8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QADD8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QADD8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QADD8/A:index
Execute: aarch32/QADD8/A:execute
Decode: aarch32/QADD8/A1_A:decode@aarch32/QADD8/A1_A:diagram
Decode: aarch32/QADD8/T1_A:decode@aarch32/QADD8/T1_A:diagram
TAG:aarch32/VMOV_s/A:execute
CheckVFPEnabled(TRUE);
if to_arm_register then
    R[t] = S[n];
else
    S[n] = R[t];
TAG:aarch32/VMOV_s/A1_A:diagram
A32
31:28 cond xxxx
27:21 _ 1110000
20:20 op x
19:16 Vn xxxx
15:12 Rt xxxx
11:8 _ 1010
7:7 N x
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_s/A1_A:decode
to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_s/T1_A:diagram
T32
31:21 _ 11101110000
20:20 op x
19:16 Vn xxxx
15:12 Rt xxxx
11:8 _ 1010
7:7 N x
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_s/T1_A:decode
to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_s/A:index
Execute: aarch32/VMOV_s/A:execute
Decode: aarch32/VMOV_s/A1_A:decode@aarch32/VMOV_s/A1_A:diagram
Decode: aarch32/VMOV_s/T1_A:decode@aarch32/VMOV_s/T1_A:diagram
TAG:aarch32/VSUB_f/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            Elem[D[d+r],e,esize] = FPSub(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
else             // VFP instruction
    case esize of
        when 16
            S[d] = Zeros(16) : FPSub(S[n][15:0], S[m][15:0], FPSCR);
        when 32
            S[d] = FPSub(S[n], S[m], FPSCR);
        when 64
            D[d] = FPSub(D[n], D[m], FPSCR);
TAG:aarch32/VSUB_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUB_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSUB_f/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUB_f/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VSUB_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUB_f/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSUB_f/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUB_f/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VSUB_f/A:index
Execute: aarch32/VSUB_f/A:execute
Decode: aarch32/VSUB_f/A1_A:decode@aarch32/VSUB_f/A1_A:diagram
Decode: aarch32/VSUB_f/A2_A:decode@aarch32/VSUB_f/A2_A:diagram
Decode: aarch32/VSUB_f/T1_A:decode@aarch32/VSUB_f/T1_A:diagram
Decode: aarch32/VSUB_f/T2_A:decode@aarch32/VSUB_f/T2_A:diagram
TAG:aarch32/SHA256SU0/A:execute
CheckCryptoEnabled32();
bits(128) result;
X = Q[d>>1]; Y = Q[m>>1];
T = Y[31:0] : X[127:32];
for e = 0 to 3
    elt = Elem[T, e, 32];
    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
    Elem[result, e, 32] = elt + Elem[X, e, 32];
Q[d>>1] = result;
TAG:aarch32/SHA256SU0/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256SU0/A1_A:decode
if !HaveSHA256Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA256SU0/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA256SU0/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA256Ext() then UNDEFINED;
if size != '10' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/SHA256SU0/A:index
Execute: aarch32/SHA256SU0/A:execute
Decode: aarch32/SHA256SU0/A1_A:decode@aarch32/SHA256SU0/A1_A:diagram
Decode: aarch32/SHA256SU0/T1_A:decode@aarch32/SHA256SU0/T1_A:diagram
TAG:aarch32/MRS_br/AS:execute
if PSTATE.EL == EL0 then
   UNPREDICTABLE;
else
    mode = PSTATE.M;
    if read_spsr then
        SPSRaccessValid(SYSm, mode);           // Check for UNPREDICTABLE cases
        case SYSm of
            when '01110'  R[d] = SPSR_fiq;
            when '10000'  R[d] = SPSR_irq;
            when '10010'  R[d] = SPSR_svc;
            when '10100'  R[d] = SPSR_abt;
            when '10110'  R[d] = SPSR_und;
            when '11100'
                if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                R[d] = SPSR_mon;
            when '11110'  R[d] = SPSR_hyp;
    else
        BankedRegisterAccessValid(SYSm, mode); // Check for UNPREDICTABLE cases
        case SYSm of
            when '00xxx'                       // Access the User mode registers
                m = UInt(SYSm[2:0]) + 8;
                R[d] = Rmode[m,M32_User];
            when '01xxx'                       // Access the FIQ mode registers
                m = UInt(SYSm[2:0]) + 8;
                R[d] = Rmode[m,M32_FIQ];
            when '1000x'                       // Access the IRQ mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                R[d] = Rmode[m,M32_IRQ];
            when '1001x'                       // Access the Supervisor mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                R[d] = Rmode[m,M32_Svc];
            when '1010x'                       // Access the Abort mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                R[d] = Rmode[m,M32_Abort];
            when '1011x'                       // Access the Undefined mode registers
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                R[d] = Rmode[m,M32_Undef];
            when '1110x'                       // Access Monitor registers
                if !ELUsingAArch32(EL3) then AArch64.MonitorModeTrap();
                m = 14 - UInt(SYSm[0]);        // LR when SYSm[0] == 0, otherwise SP
                R[d] = Rmode[m,M32_Monitor];
            when '11110'                       // Access ELR_hyp register
                R[d] = ELR_hyp;
            when '11111'                       // Access SP_hyp register
                R[d] = Rmode[13,M32_Hyp];
TAG:aarch32/MRS_br/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:22 R x
21:21 _ 0
20:20 _ 0
19:16 M1 xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ 1
8:8 M x
7:4 _ 0000
3:0 _ (0)(0)(0)(0)
TAG:aarch32/MRS_br/A1_AS:decode
d = UInt(Rd);  read_spsr = (R == '1');
if d == 15 then UNPREDICTABLE;
SYSm = M:M1;

TAG:aarch32/MRS_br/T1_AS:diagram
T32
31:21 _ 11110011111
20:20 R x
19:16 M1 xxxx
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:8 Rd xxxx
7:7 _ (0)
6:6 _ (0)
5:5 _ 1
4:4 M x
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/MRS_br/T1_AS:decode
d = UInt(Rd);  read_spsr = (R == '1');
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
SYSm = M:M1;

TAG:aarch32/MRS_br/AS:index
Execute: aarch32/MRS_br/AS:execute
Decode: aarch32/MRS_br/A1_AS:decode@aarch32/MRS_br/A1_AS:diagram
Decode: aarch32/MRS_br/T1_AS:decode@aarch32/MRS_br/T1_AS:diagram
TAG:aarch32/RSB_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(NOT(R[n]), shifted, '1');
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSB_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 011
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/RSB_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/RSB_rr/A:index
Execute: aarch32/RSB_rr/A:execute
Decode: aarch32/RSB_rr/A1_A:decode@aarch32/RSB_rr/A1_A:diagram
TAG:aarch32/MVN_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = NOT(shifted);
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/MVN_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/MVN_rr/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/MVN_rr/A:index
Execute: aarch32/MVN_rr/A:execute
Decode: aarch32/MVN_rr/A1_A:decode@aarch32/MVN_rr/A1_A:diagram
TAG:aarch32/VLD2_a/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
D[d] = Replicate(MemU[address,ebytes]);
D[d2] = Replicate(MemU[address+ebytes,ebytes]);
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 2*ebytes;
TAG:aarch32/VLD2_a/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 11
9:8 _ 01
7:6 size xx
5:5 T x
4:4 a x
3:0 Rm xxxx
TAG:aarch32/VLD2_a/T1A1_A:decode
if size == '11' then UNDEFINED;
ebytes = 1 << UInt(size);
alignment = if a == '0' then 1 else 2*ebytes;
inc = if T == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD2_a/A:index
Execute: aarch32/VLD2_a/A:execute
Decode: aarch32/VLD2_a/T1A1_A:decode@aarch32/VLD2_a/T1A1_A:diagram
Decode: aarch32/VLD2_a/T1A1_A:decode@aarch32/VLD2_a/T1A1_A:diagram
TAG:aarch32/VFMA_bf/A:execute
CheckAdvSIMDEnabled();
bits(128) operand1 = Q[n>>1];
bits(128) operand2 = Q[m>>1];
bits(128) operand3 = Q[d>>1];
bits(128) result;

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);
    bits(32) addend = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(addend, element1, element2,
                                   StandardFPSCRValue());

Q[d>>1] = result;
TAG:aarch32/VFMA_bf/A1_A:diagram
A32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA_bf/A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch32/VFMA_bf/T1_A:diagram
T32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VFMA_bf/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch32/VFMA_bf/A:index
Execute: aarch32/VFMA_bf/A:execute
Decode: aarch32/VFMA_bf/A1_A:decode@aarch32/VFMA_bf/A1_A:diagram
Decode: aarch32/VFMA_bf/T1_A:decode@aarch32/VFMA_bf/T1_A:diagram
TAG:aarch32/TBB/A:execute
if is_tbh then
    halfwords = UInt(MemU[R[n]+LSL(R[m],1), 2]);
else
    halfwords = UInt(MemU[R[n]+R[m], 1]);
BranchWritePC(PC + 2*halfwords, BranchType_INDIR);
TAG:aarch32/TBB/T1_A:diagram
T32
31:20 _ 111010001101
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:5 _ 000
4:4 H x
3:0 Rm xxxx
TAG:aarch32/TBB/T1_A:decode
n = UInt(Rn);  m = UInt(Rm);  is_tbh = (H == '1');
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/TBB/A:index
Execute: aarch32/TBB/A:execute
Decode: aarch32/TBB/T1_A:decode@aarch32/TBB/T1_A:diagram
TAG:aarch32/ADD_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, '0');
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADD_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 100
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/ADD_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/ADD_rr/A:index
Execute: aarch32/ADD_rr/A:execute
Decode: aarch32/ADD_rr/A1_A:decode@aarch32/ADD_rr/A1_A:diagram
TAG:aarch32/SEL/A:execute
R[d][7:0]   = if PSTATE.GE[0] == '1' then R[n][7:0]   else R[m][7:0];
R[d][15:8]  = if PSTATE.GE[1] == '1' then R[n][15:8]  else R[m][15:8];
R[d][23:16] = if PSTATE.GE[2] == '1' then R[n][23:16] else R[m][23:16];
R[d][31:24] = if PSTATE.GE[3] == '1' then R[n][31:24] else R[m][31:24];
TAG:aarch32/SEL/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 01101000
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:4 _ 1011
3:0 Rm xxxx
TAG:aarch32/SEL/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SEL/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/SEL/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SEL/A:index
Execute: aarch32/SEL/A:execute
Decode: aarch32/SEL/A1_A:decode@aarch32/SEL/A1_A:diagram
Decode: aarch32/SEL/T1_A:decode@aarch32/SEL/T1_A:diagram
TAG:aarch32/VRSHRN/A:execute
CheckAdvSIMDEnabled();
round_const = 1 << (shift_amount-1);
for e = 0 to elements-1
    result = LSR(Elem[Qin[m>>1],e,2*esize] + round_const, shift_amount);
    Elem[D[d],e,esize] = result[esize-1:0];
TAG:aarch32/VRSHRN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRSHRN/T1A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if Vm[0] == '1' then UNDEFINED;
case imm6 of
    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VRSHRN/A:index
Execute: aarch32/VRSHRN/A:execute
Decode: aarch32/VRSHRN/T1A1_A:decode@aarch32/VRSHRN/T1A1_A:diagram
Decode: aarch32/VRSHRN/T1A1_A:decode@aarch32/VRSHRN/T1A1_A:diagram
TAG:aarch32/VSHRN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    result = LSR(Elem[Qin[m>>1],e,2*esize], shift_amount);
    Elem[D[d],e,esize] = result[esize-1:0];
TAG:aarch32/VSHRN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 _ 0
6:6 _ 0
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSHRN/T1A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if Vm[0] == '1' then UNDEFINED;
case imm6 of
    when '001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VSHRN/A:index
Execute: aarch32/VSHRN/A:execute
Decode: aarch32/VSHRN/T1A1_A:decode@aarch32/VSHRN/T1A1_A:diagram
Decode: aarch32/VSHRN/T1A1_A:decode@aarch32/VSHRN/T1A1_A:diagram
TAG:aarch32/VCVT_hs/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    if half_to_single then
        Elem[Q[d>>1],e,32] = FPConvert(Elem[Din[m],e,16], StandardFPSCRValue());
    else
        Elem[D[d],e,16] = FPConvert(Elem[Qin[m>>1],e,32], StandardFPSCRValue());
TAG:aarch32/VCVT_hs/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:9 _ 11
8:8 op x
7:7 _ 0
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_hs/T1A1_A:decode
if size != '01' then UNDEFINED;
half_to_single = (op == '1');
if half_to_single && Vd[0] == '1' then UNDEFINED;
if !half_to_single && Vm[0] == '1' then UNDEFINED;
esize = 16;  elements = 4;
m = UInt(M:Vm);  d = UInt(D:Vd);

TAG:aarch32/VCVT_hs/A:index
Execute: aarch32/VCVT_hs/A:execute
Decode: aarch32/VCVT_hs/T1A1_A:decode@aarch32/VCVT_hs/T1A1_A:diagram
Decode: aarch32/VCVT_hs/T1A1_A:decode@aarch32/VCVT_hs/T1A1_A:diagram
TAG:aarch32/ADC_i/A:execute
(result, nzcv) = AddWithCarry(R[n], imm32, PSTATE.C);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/ADC_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 101
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ADC_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = A32ExpandImm(imm12);

TAG:aarch32/ADC_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1010
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ADC_i/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');  imm32 = T32ExpandImm(i:imm3:imm8);
if d == 15 || n == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ADC_i/A:index
Execute: aarch32/ADC_i/A:execute
Decode: aarch32/ADC_i/A1_A:decode@aarch32/ADC_i/A1_A:diagram
Decode: aarch32/ADC_i/T1_A:decode@aarch32/ADC_i/T1_A:diagram
TAG:aarch32/VSLI/A:execute
CheckAdvSIMDEnabled();
mask = LSL(Ones(esize), shift_amount);
for r = 0 to regs-1
    for e = 0 to elements-1
        shifted_op = LSL(Elem[D[m+r],e,esize], shift_amount);
        Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;
TAG:aarch32/VSLI/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0101
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSLI/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSLI/A:index
Execute: aarch32/VSLI/A:execute
Decode: aarch32/VSLI/T1A1_A:decode@aarch32/VSLI/T1A1_A:diagram
Decode: aarch32/VSLI/T1A1_A:decode@aarch32/VSLI/T1A1_A:diagram
TAG:aarch32/SMULWB/A:execute
operand2 = if m_high then R[m][31:16] else R[m][15:0];
product = SInt(R[n]) * SInt(operand2);
R[d] = product[47:16];
// Signed overflow cannot occur
TAG:aarch32/SMULWB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 0
19:16 Rd xxxx
15:12 _ (0)(0)(0)(0)
11:8 Rm xxxx
7:7 _ 1
6:6 M x
5:5 _ 1
4:4 _ 0
3:0 Rn xxxx
TAG:aarch32/SMULWB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMULWB/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 011
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMULWB/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMULWB/A:index
Execute: aarch32/SMULWB/A:execute
Decode: aarch32/SMULWB/A1_A:decode@aarch32/SMULWB/A1_A:diagram
Decode: aarch32/SMULWB/T1_A:decode@aarch32/SMULWB/T1_A:diagram
TAG:aarch32/VST4_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
MemU[address,         ebytes] = Elem[D[d], index];
MemU[address+ebytes,  ebytes] = Elem[D[d2],index];
MemU[address+2*ebytes,ebytes] = Elem[D[d3],index];
MemU[address+3*ebytes,ebytes] = Elem[D[d4],index];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 4*ebytes;
TAG:aarch32/VST4_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST4_1/T1A1_A:decode
if size == '11' then UNDEFINED;
if size != '00' then SEE "Related encodings";
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
alignment = if index_align[0] == '0' then 1 else 4;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VST4_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST4_1/T2A2_A:decode
if size == '11' then UNDEFINED;
if size != '01' then SEE "Related encodings";
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 8;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VST4_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 11
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VST4_1/T3A3_A:decode
if size == '11' then UNDEFINED;
if size != '10' then SEE "Related encodings";
if index_align[1:0] == '11' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
alignment = if index_align[1:0] == '00' then 1 else 4 << UInt(index_align[1:0]);
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VST4_1/A:index
Execute: aarch32/VST4_1/A:execute
Decode: aarch32/VST4_1/T1A1_A:decode@aarch32/VST4_1/T1A1_A:diagram
Decode: aarch32/VST4_1/T2A2_A:decode@aarch32/VST4_1/T2A2_A:diagram
Decode: aarch32/VST4_1/T3A3_A:decode@aarch32/VST4_1/T3A3_A:diagram
Decode: aarch32/VST4_1/T1A1_A:decode@aarch32/VST4_1/T1A1_A:diagram
Decode: aarch32/VST4_1/T2A2_A:decode@aarch32/VST4_1/T2A2_A:diagram
Decode: aarch32/VST4_1/T3A3_A:decode@aarch32/VST4_1/T3A3_A:diagram
TAG:aarch32/STLH/A:execute
address = R[n];
MemO[address, 2] = R[t][15:0];
TAG:aarch32/STLH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 0
19:16 Rn xxxx
15:12 _ (1)(1)(1)(1)
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLH/A1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STLH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 01
3:0 _ (1)(1)(1)(1)
TAG:aarch32/STLH/T1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STLH/A:index
Execute: aarch32/STLH/A:execute
Decode: aarch32/STLH/A1_A:decode@aarch32/STLH/A1_A:diagram
Decode: aarch32/STLH/T1_A:decode@aarch32/STLH/T1_A:diagram
TAG:aarch32/VCMLA/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    operand1 = D[n+r];
    operand2 = D[m+r];
    operand3 = D[d+r];
    for e = 0 to (elements DIV 2)-1
        case rot of
            when '00'
               element1 = Elem[operand2,e*2,esize];
               element2 = Elem[operand1,e*2,esize];
               element3 = Elem[operand2,e*2+1,esize];
               element4 = Elem[operand1,e*2,esize];
            when '01'
               element1 = FPNeg(Elem[operand2,e*2+1,esize]);
               element2 = Elem[operand1,e*2+1,esize];
               element3 = Elem[operand2,e*2,esize];
               element4 = Elem[operand1,e*2+1,esize];
            when '10'
               element1 = FPNeg(Elem[operand2,e*2,esize]);
               element2 = Elem[operand1,e*2,esize];
               element3 = FPNeg(Elem[operand2,e*2+1,esize]);
               element4 = Elem[operand1,e*2,esize];
            when '11'
               element1 = Elem[operand2,e*2+1,esize];
               element2 = Elem[operand1,e*2+1,esize];
               element3 = FPNeg(Elem[operand2,e*2,esize]);
               element4 = Elem[operand1,e*2+1,esize];
        result1 = FPMulAdd(Elem[operand3,e*2,esize],element2,element1, StandardFPSCRValue());
        result2 = FPMulAdd(Elem[operand3,e*2+1,esize],element4,element3, StandardFPSCRValue());
        Elem[D[d+r],e*2,esize] = result1;
        Elem[D[d+r],e*2+1,esize] = result2;
TAG:aarch32/VCMLA/A1_A:diagram
A32
31:25 _ 1111110
24:23 rot xx
22:22 D x
21:21 _ 1
20:20 S x
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMLA/A1_A:decode
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCMLA/T1_A:diagram
T32
31:25 _ 1111110
24:23 rot xx
22:22 D x
21:21 _ 1
20:20 S x
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCMLA/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFCADDExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);
esize = 16 << UInt(S);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
elements = 64 DIV esize;
regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCMLA/A:index
Execute: aarch32/VCMLA/A:execute
Decode: aarch32/VCMLA/A1_A:decode@aarch32/VCMLA/A1_A:diagram
Decode: aarch32/VCMLA/T1_A:decode@aarch32/VCMLA/T1_A:diagram
TAG:aarch32/SSAX/A:execute
sum  = SInt(R[n][15:0]) + SInt(R[m][31:16]);
diff = SInt(R[n][31:16]) - SInt(R[m][15:0]);
R[d][15:0]  = sum[15:0];
R[d][31:16] = diff[15:0];
PSTATE.GE[1:0] = if sum  >= 0 then '11' else '00';
PSTATE.GE[3:2] = if diff >= 0 then '11' else '00';
TAG:aarch32/SSAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SSAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SSAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SSAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SSAX/A:index
Execute: aarch32/SSAX/A:execute
Decode: aarch32/SSAX/A1_A:decode@aarch32/SSAX/A1_A:diagram
Decode: aarch32/SSAX/T1_A:decode@aarch32/SSAX/T1_A:diagram
TAG:aarch32/QSAX/A:execute
sum  = SInt(R[n][15:0]) + SInt(R[m][31:16]);
diff = SInt(R[n][31:16]) - SInt(R[m][15:0]);
R[d][15:0]  = SignedSat(sum, 16);
R[d][31:16] = SignedSat(diff, 16);
TAG:aarch32/QSAX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSAX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QSAX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 110
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSAX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QSAX/A:index
Execute: aarch32/QSAX/A:execute
Decode: aarch32/QSAX/A1_A:decode@aarch32/QSAX/A1_A:diagram
Decode: aarch32/QSAX/T1_A:decode@aarch32/QSAX/T1_A:diagram
TAG:aarch32/UXTH/A:execute
rotated = ROR(R[m], rotation);
R[d] = ZeroExtend(rotated[15:0], 32);
TAG:aarch32/UXTH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 11
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTH/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTH/T1_A:diagram
T16
31:24 _ 10110010
23:23 _ 1
22:22 _ 0
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/UXTH/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = 0;

TAG:aarch32/UXTH/T2_A:diagram
T32
31:23 _ 111110100
22:21 _ 00
20:20 _ 1
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTH/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTH/A:index
Execute: aarch32/UXTH/A:execute
Decode: aarch32/UXTH/A1_A:decode@aarch32/UXTH/A1_A:diagram
Decode: aarch32/UXTH/T1_A:decode@aarch32/UXTH/T1_A:diagram
Decode: aarch32/UXTH/T2_A:decode@aarch32/UXTH/T2_A:diagram
TAG:aarch32/VCLT_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            bits(esize) zero = FPZero('0');
            test_passed = FPCompareGT(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
        else
            test_passed = (SInt(Elem[D[m+r],e,esize]) < 0);
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCLT_i/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 100
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLT_i/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLT_i/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 100
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLT_i/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLT_i/A:index
Execute: aarch32/VCLT_i/A:execute
Decode: aarch32/VCLT_i/A1_A:decode@aarch32/VCLT_i/A1_A:diagram
Decode: aarch32/VCLT_i/T1_A:decode@aarch32/VCLT_i/T1_A:diagram
TAG:aarch32/RBIT/A:execute
bits(32) result;
for i = 0 to 31
    result[31-i] = R[m][i];
R[d] = result;
TAG:aarch32/RBIT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 11
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:4 _ 011
3:0 Rm xxxx
TAG:aarch32/RBIT/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/RBIT/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 10
3:0 Rm xxxx
TAG:aarch32/RBIT/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/RBIT/A:index
Execute: aarch32/RBIT/A:execute
Decode: aarch32/RBIT/A1_A:decode@aarch32/RBIT/A1_A:diagram
Decode: aarch32/RBIT/T1_A:decode@aarch32/RBIT/T1_A:diagram
TAG:aarch32/STLEX/A:execute
address = R[n];
if AArch32.ExclusiveMonitorsPass(address,4) then
    MemO[address, 4] = R[t];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STLEX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLEX/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEX/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 10
3:0 Rd xxxx
TAG:aarch32/STLEX/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEX/A:index
Execute: aarch32/STLEX/A:execute
Decode: aarch32/STLEX/A1_A:decode@aarch32/STLEX/A1_A:diagram
Decode: aarch32/STLEX/T1_A:decode@aarch32/STLEX/T1_A:diagram
TAG:aarch32/AND_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND shifted;
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/AND_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 000
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/AND_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/AND_rr/A:index
Execute: aarch32/AND_rr/A:execute
Decode: aarch32/AND_rr/A1_A:decode@aarch32/AND_rr/A1_A:diagram
TAG:aarch32/LDRSH_i/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
R[t] = SignExtend(data, 32);
TAG:aarch32/LDRSH_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSH_i/A1_A:decode
if Rn == '1111' then SEE "LDRSH (literal)";
if P == '0' && W == '1' then SEE "LDRSHT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE;

TAG:aarch32/LDRSH_i/T1_A:diagram
T32
31:23 _ 111110011
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRSH_i/T1_A:decode
if Rn == '1111' then SEE "LDRSH (literal)";
if Rt == '1111' then SEE "Related instructions";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSH_i/T2_A:diagram
T32
31:23 _ 111110010
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRSH_i/T2_A:decode
if Rn == '1111' then SEE "LDRSH (literal)";
if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "Related instructions";
if P == '1' && U == '1' && W == '0' then SEE "LDRSHT";
if P == '0' && W == '0' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSH_i/A:index
Execute: aarch32/LDRSH_i/A:execute
Decode: aarch32/LDRSH_i/A1_A:decode@aarch32/LDRSH_i/A1_A:diagram
Decode: aarch32/LDRSH_i/T1_A:decode@aarch32/LDRSH_i/T1_A:diagram
Decode: aarch32/LDRSH_i/T2_A:decode@aarch32/LDRSH_i/T2_A:diagram
TAG:aarch32/SBC_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), PSTATE.C);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SBC_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 110
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SBC_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/SBC_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 0110
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/SBC_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/SBC_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 1011
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/SBC_r/T2_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SBC_r/A:index
Execute: aarch32/SBC_r/A:execute
Decode: aarch32/SBC_r/A1_A:decode@aarch32/SBC_r/A1_A:diagram
Decode: aarch32/SBC_r/T1_A:decode@aarch32/SBC_r/T1_A:diagram
Decode: aarch32/SBC_r/T2_A:decode@aarch32/SBC_r/T2_A:diagram
TAG:aarch32/LDM_e/AS:execute
if PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.M IN {M32_User,M32_System} then
    UNPREDICTABLE;                        // UNDEFINED or NOP
else
    length = 4*BitCount(registers) + 4;
    address = if increment then R[n] else R[n]-length;
    if wordhigher then address = address+4;

    for i = 0 to 14
        if registers[i] == '1' then
            R[i] = MemA[address,4];  address = address + 4;
    new_pc_value = MemA[address,4];

    if wback && registers[n] == '0' then R[n] = if increment then R[n]+length else R[n]-length;
    if wback && registers[n] == '1' then R[n] = bits(32) UNKNOWN;

    AArch32.ExceptionReturn(new_pc_value, SPSR[]);
TAG:aarch32/LDM_e/A1_AS:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:15 _ 1
14:0 register_list xxxxxxxxxxxxxxx
TAG:aarch32/LDM_e/A1_AS:decode
n = UInt(Rn);  registers = register_list;
wback = (W == '1');  increment = (U == '1');  wordhigher = (P == U);
if n == 15 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;

TAG:aarch32/LDM_e/AS:index
Execute: aarch32/LDM_e/AS:execute
Decode: aarch32/LDM_e/A1_AS:decode@aarch32/LDM_e/A1_AS:diagram
TAG:aarch32/VSUB_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = Elem[D[n+r],e,esize] - Elem[D[m+r],e,esize];
TAG:aarch32/VSUB_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSUB_i/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSUB_i/A:index
Execute: aarch32/VSUB_i/A:execute
Decode: aarch32/VSUB_i/T1A1_A:decode@aarch32/VSUB_i/T1A1_A:diagram
Decode: aarch32/VSUB_i/T1A1_A:decode@aarch32/VSUB_i/T1A1_A:diagram
TAG:aarch32/VMUL_f/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            Elem[D[d+r],e,esize] = FPMul(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize], StandardFPSCRValue());
else             // VFP instruction
    case esize of
        when 16
            S[d] = Zeros(16) : FPMul(S[n][15:0], S[m][15:0], FPSCR);
        when 32
            S[d] = FPMul(S[n], S[m], FPSCR);
        when 64
            D[d] = FPMul(D[n], D[m], FPSCR);
TAG:aarch32/VMUL_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMUL_f/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMUL_f/A2_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_f/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
advsimd = FALSE;

case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMUL_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMUL_f/T1_A:decode
if sz == '1' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
advsimd = TRUE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMUL_f/T2_A:diagram
T32
31:24 _ 11101110
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_f/T2_A:decode
if size == '01' && InITBlock()  then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
advsimd = FALSE;

case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VMUL_f/A:index
Execute: aarch32/VMUL_f/A:execute
Decode: aarch32/VMUL_f/A1_A:decode@aarch32/VMUL_f/A1_A:diagram
Decode: aarch32/VMUL_f/A2_A:decode@aarch32/VMUL_f/A2_A:diagram
Decode: aarch32/VMUL_f/T1_A:decode@aarch32/VMUL_f/T1_A:diagram
Decode: aarch32/VMUL_f/T2_A:decode@aarch32/VMUL_f/T2_A:diagram
TAG:aarch32/VQSHL_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        operand = Int(Elem[D[m+r],e,esize], src_unsigned);
        (result, sat) = SatQ(operand << shift_amount, esize, dest_unsigned);
        Elem[D[d+r],e,esize] = result;
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQSHL_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:9 _ 011
8:8 op x
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQSHL_i/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if U == '0' && op == '0' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = UInt(imm6);
src_unsigned = (U == '1' && op == '1');  dest_unsigned = (U == '1');
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQSHL_i/A:index
Execute: aarch32/VQSHL_i/A:execute
Decode: aarch32/VQSHL_i/T1A1_A:decode@aarch32/VQSHL_i/T1A1_A:diagram
Decode: aarch32/VQSHL_i/T1A1_A:decode@aarch32/VQSHL_i/T1A1_A:diagram
TAG:aarch32/VMOV_r/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if single_register then
    S[d] = S[m];
else
    for r = 0 to regs-1
        D[d+r] = D[m+r];
TAG:aarch32/VMOV_r/T2A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 000
15:12 Vd xxxx
11:10 _ 10
9:8 size 1x
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMOV_r/T2A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
single_register = (size == '10');  advsimd = FALSE;
if single_register then
    d = UInt(Vd:D);  m = UInt(Vm:M);
else
    d = UInt(D:Vd);  m = UInt(M:Vm);  regs = 1;

TAG:aarch32/VMOV_r/A:index
Execute: aarch32/VMOV_r/A:execute
Decode: aarch32/VMOV_r/T2A2_A:decode@aarch32/VMOV_r/T2A2_A:diagram
Decode: aarch32/VMOV_r/T2A2_A:decode@aarch32/VMOV_r/T2A2_A:diagram
TAG:aarch32/SASX/A:execute
diff = SInt(R[n][15:0]) - SInt(R[m][31:16]);
sum  = SInt(R[n][31:16]) + SInt(R[m][15:0]);
R[d][15:0]  = diff[15:0];
R[d][31:16] = sum[15:0];
PSTATE.GE[1:0] = if diff >= 0 then '11' else '00';
PSTATE.GE[3:2] = if sum  >= 0 then '11' else '00';
TAG:aarch32/SASX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 001
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/SASX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SASX/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 010
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SASX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SASX/A:index
Execute: aarch32/SASX/A:execute
Decode: aarch32/SASX/A1_A:decode@aarch32/SASX/A1_A:diagram
Decode: aarch32/SASX/T1_A:decode@aarch32/SASX/T1_A:diagram
TAG:aarch32/SUB_r/A:execute
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/SUB_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 010
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/SUB_r/A1_A:decode
if Rn == '1101' then SEE "SUB (SP minus register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/SUB_r/T1_A:diagram
T16
31:26 _ 000110
25:25 _ 1
24:22 Rm xxx
21:19 Rn xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/SUB_r/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/SUB_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 1101
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/SUB_r/T2_A:decode
if Rd == '1111' && S == '1' then SEE "CMP (register)";
if Rn == '1101' then SEE "SUB (SP minus register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SUB_r/A:index
Execute: aarch32/SUB_r/A:execute
Decode: aarch32/SUB_r/A1_A:decode@aarch32/SUB_r/A1_A:diagram
Decode: aarch32/SUB_r/T1_A:decode@aarch32/SUB_r/T1_A:diagram
Decode: aarch32/SUB_r/T2_A:decode@aarch32/SUB_r/T2_A:diagram
TAG:aarch32/LDA/A:execute
address = R[n];
R[t] = MemO[address, 4];
TAG:aarch32/LDA/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDA/A1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDA/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 10
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDA/T1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDA/A:index
Execute: aarch32/LDA/A:execute
Decode: aarch32/LDA/A1_A:decode@aarch32/LDA/A1_A:diagram
Decode: aarch32/LDA/T1_A:decode@aarch32/LDA/T1_A:diagram
TAG:aarch32/VUZP/A:execute
CheckAdvSIMDEnabled();
if quadword_operation then
    if d == m then
        Q[d>>1] = bits(128) UNKNOWN;  Q[m>>1] = bits(128) UNKNOWN;
    else
        zipped_q = Q[m>>1]:Q[d>>1];
        for e = 0 to (128 DIV esize) - 1
            Elem[Q[d>>1],e,esize] = Elem[zipped_q,2*e,esize];
            Elem[Q[m>>1],e,esize] = Elem[zipped_q,2*e+1,esize];
else
    if d == m then
        D[d] = bits(64) UNKNOWN;  D[m] = bits(64) UNKNOWN;
    else
        zipped_d = D[m]:D[d];
        for e = 0 to (64 DIV esize) - 1
            Elem[D[d],e,esize] = Elem[zipped_d,2*e,esize];
            Elem[D[m],e,esize] = Elem[zipped_d,2*e+1,esize];
TAG:aarch32/VUZP/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0010
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VUZP/T1A1_A:decode
if size == '11' || (Q == '0' && size == '10') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
quadword_operation = (Q == '1');  esize = 8 << UInt(size);
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VUZP/A:index
Execute: aarch32/VUZP/A:execute
Decode: aarch32/VUZP/T1A1_A:decode@aarch32/VUZP/T1A1_A:diagram
Decode: aarch32/VUZP/T1A1_A:decode@aarch32/VUZP/T1A1_A:diagram
TAG:aarch32/LDRBT/A:execute
offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
R[t] = ZeroExtend(MemU_unpriv[address,1],32);
if postindex then R[n] = offset_addr;
TAG:aarch32/LDRBT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRBT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
if t == 15 || n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/LDRBT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 _ 0
23:23 U x
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/LDRBT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(stype, imm5);
if t == 15 || n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/LDRBT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRBT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then SEE "LDRB (literal)";
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRBT/A:index
Execute: aarch32/LDRBT/A:execute
Decode: aarch32/LDRBT/A1_A:decode@aarch32/LDRBT/A1_A:diagram
Decode: aarch32/LDRBT/A2_A:decode@aarch32/LDRBT/A2_A:diagram
Decode: aarch32/LDRBT/T1_A:decode@aarch32/LDRBT/T1_A:diagram
TAG:aarch32/AND_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND shifted;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/AND_r/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 000
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/AND_r/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/AND_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 0000
21:19 Rm xxx
18:16 Rdn xxx
15:0 _ 0000000000000000
TAG:aarch32/AND_r/T1_A:decode
d = UInt(Rdn);  n = UInt(Rdn);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/AND_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0000
20:20 S x
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/AND_r/T2_A:decode
if Rd == '1111' && S == '1' then SEE "TST (register)";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if (d == 15 && !setflags) || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/AND_r/A:index
Execute: aarch32/AND_r/A:execute
Decode: aarch32/AND_r/A1_A:decode@aarch32/AND_r/A1_A:diagram
Decode: aarch32/AND_r/T1_A:decode@aarch32/AND_r/T1_A:diagram
Decode: aarch32/AND_r/T2_A:decode@aarch32/AND_r/T2_A:diagram
TAG:aarch32/UADD16/A:execute
sum1 = UInt(R[n][15:0]) + UInt(R[m][15:0]);
sum2 = UInt(R[n][31:16]) + UInt(R[m][31:16]);
R[d][15:0]  = sum1[15:0];
R[d][31:16] = sum2[15:0];
PSTATE.GE[1:0] = if sum1 >= 0x10000 then '11' else '00';
PSTATE.GE[3:2] = if sum2 >= 0x10000 then '11' else '00';
TAG:aarch32/UADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 101
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 0
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UADD16/A:index
Execute: aarch32/UADD16/A:execute
Decode: aarch32/UADD16/A1_A:decode@aarch32/UADD16/A1_A:diagram
Decode: aarch32/UADD16/T1_A:decode@aarch32/UADD16/T1_A:diagram
TAG:aarch32/VPADAL/A:execute
CheckAdvSIMDEnabled();
h = elements DIV 2;

for r = 0 to regs-1
    for e = 0 to h-1
        op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
        result = Int(op1, unsigned) + Int(op2, unsigned);
        Elem[D[d+r],e,2*esize] = Elem[D[d+r],e,2*esize] + result;
TAG:aarch32/VPADAL/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:8 _ 110
7:7 op x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPADAL/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (op == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VPADAL/A:index
Execute: aarch32/VPADAL/A:execute
Decode: aarch32/VPADAL/T1A1_A:decode@aarch32/VPADAL/T1A1_A:diagram
Decode: aarch32/VPADAL/T1A1_A:decode@aarch32/VPADAL/T1A1_A:diagram
TAG:aarch32/CPS/AS:execute
if CurrentInstrSet() == InstrSet_A32 then
    if PSTATE.EL != EL0 then
        if enable then
            if affectA then PSTATE.A = '0';
            if affectI then PSTATE.I = '0';
            if affectF then PSTATE.F = '0';
        if disable then
            if affectA then PSTATE.A = '1';
            if affectI then PSTATE.I = '1';
            if affectF then PSTATE.F = '1';
        if changemode then
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            AArch32.WriteModeByInstr(mode);
else
    if PSTATE.EL != EL0 then
        if enable then
            if affectA then PSTATE.A = '0';
            if affectI then PSTATE.I = '0';
            if affectF then PSTATE.F = '0';
        if disable then
            if affectA then PSTATE.A = '1';
            if affectI then PSTATE.I = '1';
            if affectF then PSTATE.F = '1';
        if changemode then
            // AArch32.WriteModeByInstr() sets PSTATE.IL to 1 if this is an illegal mode change.
            AArch32.WriteModeByInstr(mode);
TAG:aarch32/CPS/A1_AS:diagram
A32
31:20 _ 111100010000
19:18 imod xx
17:17 M x
16:16 _ 0
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 A x
7:7 I x
6:6 F x
5:5 _ 0
4:0 mode xxxxx
TAG:aarch32/CPS/A1_AS:decode
if mode != '00000' && M == '0' then UNPREDICTABLE;
if (imod[1] == '1' && A:I:F == '000') || (imod[1] == '0' && A:I:F != '000') then UNPREDICTABLE;
enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
if (imod == '00' && M == '0') || imod == '01' then UNPREDICTABLE;

TAG:aarch32/CPS/T1_AS:diagram
T16
31:22 _ 1011011001
21:21 _ 1
20:20 im x
19:19 _ (0)
18:18 A x
17:17 I x
16:16 F x
15:0 _ 0000000000000000
TAG:aarch32/CPS/T1_AS:decode
if A:I:F == '000' then UNPREDICTABLE;
enable = (im == '0');  disable = (im == '1');  changemode = FALSE;
affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/CPS/T2_AS:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:9 imod xx
8:8 M x
7:7 A x
6:6 I x
5:5 F x
4:0 mode xxxxx
TAG:aarch32/CPS/T2_AS:decode
if imod == '00' && M == '0' then SEE "Hint instructions";
if mode != '00000' && M == '0' then UNPREDICTABLE;
if (imod[1] == '1' && A:I:F == '000') || (imod[1] == '0' && A:I:F != '000') then UNPREDICTABLE;
enable = (imod == '10');  disable = (imod == '11');  changemode = (M == '1');
affectA = (A == '1');  affectI = (I == '1');  affectF = (F == '1');
if imod == '01' || InITBlock() then UNPREDICTABLE;

TAG:aarch32/CPS/AS:index
Execute: aarch32/CPS/AS:execute
Decode: aarch32/CPS/A1_AS:decode@aarch32/CPS/A1_AS:diagram
Decode: aarch32/CPS/T1_AS:decode@aarch32/CPS/T1_AS:diagram
Decode: aarch32/CPS/T2_AS:decode@aarch32/CPS/T2_AS:diagram
TAG:aarch32/LDM/A:execute
address = R[n];
for i = 0 to 14
    if registers[i] == '1' then
        R[i] = MemA[address,4];  address = address + 4;
if registers[15] == '1' then
    LoadWritePC(MemA[address,4]);
if wback && registers[n] == '0' then R[n] = R[n] + 4*BitCount(registers);
if wback && registers[n] == '1' then R[n] = bits(32) UNKNOWN;
TAG:aarch32/LDM/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 0
23:23 _ 1
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/LDM/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;

TAG:aarch32/LDM/T1_A:diagram
T16
31:28 _ 1100
27:27 _ 1
26:24 Rn xxx
23:16 register_list xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/LDM/T1_A:decode
n = UInt(Rn);  registers = '00000000':register_list;  wback = (registers[n] == '0');
if BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/LDM/T2_A:diagram
T32
31:25 _ 1110100
24:23 _ 01
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:15 P x
14:14 M x
13:0 register_list xxxxxxxxxxxxxx
TAG:aarch32/LDM/T2_A:decode
n = UInt(Rn);  registers = P:M:register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 2 || (P == '1' && M == '1') then UNPREDICTABLE;
if wback && registers[n] == '1' then UNPREDICTABLE;
if registers[13] == '1' then UNPREDICTABLE;
if registers[15] == '1' && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/LDM/A:index
Execute: aarch32/LDM/A:execute
Decode: aarch32/LDM/A1_A:decode@aarch32/LDM/A1_A:diagram
Decode: aarch32/LDM/T1_A:decode@aarch32/LDM/T1_A:diagram
Decode: aarch32/LDM/T2_A:decode@aarch32/LDM/T2_A:diagram
TAG:aarch32/LDC_i/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];

// System register write to DBGDTRTXint.
DBGDTR_EL0[] = MemA[address,4];

if wback then R[n] = offset_addr;
TAG:aarch32/LDC_i/T1A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 _ 0101
11:9 _ 111
8:8 _ 0
7:0 imm8 xxxxxxxx
TAG:aarch32/LDC_i/T1A1_A:decode
if Rn == '1111' then SEE "LDC (literal)";
if P == '0' && U == '0' && W == '0' then UNDEFINED;
n = UInt(Rn);  cp = 14;
imm32 = ZeroExtend(imm8:'00', 32);  index = (P == '1');  add = (U == '1');  wback = (W == '1');

TAG:aarch32/LDC_i/A:index
Execute: aarch32/LDC_i/A:execute
Decode: aarch32/LDC_i/T1A1_A:decode@aarch32/LDC_i/T1A1_A:diagram
Decode: aarch32/LDC_i/T1A1_A:decode@aarch32/LDC_i/T1A1_A:diagram
TAG:aarch32/UXTAB/A:execute
rotated = ROR(R[m], rotation);
R[d] = R[n] + ZeroExtend(rotated[7:0], 32);
TAG:aarch32/UXTAB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 10
19:16 Rn xxxx
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTAB/A1_A:decode
if Rn == '1111' then SEE "UXTB";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTAB/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTAB/T1_A:decode
if Rn == '1111' then SEE "UXTB";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTAB/A:index
Execute: aarch32/UXTAB/A:execute
Decode: aarch32/UXTAB/A1_A:decode@aarch32/UXTAB/A1_A:diagram
Decode: aarch32/UXTAB/T1_A:decode@aarch32/UXTAB/T1_A:diagram
TAG:aarch32/VFNMA/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        op16 = if op1_neg then FPNeg(S[n][15:0]) else S[n][15:0];
        S[d] = Zeros(16) : FPMulAdd(FPNeg(S[d][15:0]), op16, S[m][15:0], FPSCR);
    when 32
        op32 = if op1_neg then FPNeg(S[n]) else S[n];
        S[d] = FPMulAdd(FPNeg(S[d]), op32, S[m], FPSCR);
    when 64
        op64 = if op1_neg then FPNeg(D[n]) else D[n];
        D[d] = FPMulAdd(FPNeg(D[d]), op64, D[m], FPSCR);
TAG:aarch32/VFNMA/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 1
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VFNMA/A1_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
op1_neg = (op == '1');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VFNMA/T1_A:diagram
T32
31:24 _ 11101110
23:23 _ 1
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 op 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VFNMA/T1_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
op1_neg = (op == '1');
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VFNMA/A:index
Execute: aarch32/VFNMA/A:execute
Decode: aarch32/VFNMA/A1_A:decode@aarch32/VFNMA/A1_A:diagram
Decode: aarch32/VFNMA/T1_A:decode@aarch32/VFNMA/T1_A:diagram
TAG:aarch32/VBIC_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[n+r] AND NOT(D[m+r]);
TAG:aarch32/VBIC_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VBIC_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VBIC_r/A:index
Execute: aarch32/VBIC_r/A:execute
Decode: aarch32/VBIC_r/T1A1_A:decode@aarch32/VBIC_r/T1A1_A:diagram
Decode: aarch32/VBIC_r/T1A1_A:decode@aarch32/VBIC_r/T1A1_A:diagram
TAG:aarch32/STRT/A:execute
offset = if register_form then Shift(R[m], shift_t, shift_n, PSTATE.C) else imm32;
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if postindex then R[n] else offset_addr;
if t == 15 then  // Only possible for encodings A1 and A2
    data = PCStoreValue();
else
    data = R[t];
MemU_unpriv[address,4] = data;
if postindex then R[n] = offset_addr;
TAG:aarch32/STRT/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 010
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/STRT/A1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  postindex = TRUE;  add = (U == '1');
register_form = FALSE;  imm32 = ZeroExtend(imm12, 32);
if n == 15 || n == t then UNPREDICTABLE;

TAG:aarch32/STRT/A2_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 _ 0
23:23 U x
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/STRT/A2_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);  postindex = TRUE;  add = (U == '1');
register_form = TRUE;  (shift_t, shift_n) = DecodeImmShift(stype, imm5);
if n == 15 || n == t || m == 15 then UNPREDICTABLE;

TAG:aarch32/STRT/T1_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ 1110
7:0 imm8 xxxxxxxx
TAG:aarch32/STRT/T1_A:decode
if PSTATE.EL == EL2 then UNPREDICTABLE;               // Hyp mode
if Rn == '1111' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  postindex = FALSE;  add = TRUE;
register_form = FALSE;  imm32 = ZeroExtend(imm8, 32);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRT/A:index
Execute: aarch32/STRT/A:execute
Decode: aarch32/STRT/A1_A:decode@aarch32/STRT/A1_A:diagram
Decode: aarch32/STRT/A2_A:decode@aarch32/STRT/A2_A:diagram
Decode: aarch32/STRT/T1_A:decode@aarch32/STRT/T1_A:diagram
TAG:aarch32/SHA1C/A:execute
CheckCryptoEnabled32();
X = Q[d>>1];
Y = Q[n>>1][31:0]; // Note: 32 bits wide
W = Q[m>>1];
for e = 0 to 3
    t = SHAchoose(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y:X, 32);
Q[d>>1] = X;
TAG:aarch32/SHA1C/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1C/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1C/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1C/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1C/A:index
Execute: aarch32/SHA1C/A:execute
Decode: aarch32/SHA1C/A1_A:decode@aarch32/SHA1C/A1_A:diagram
Decode: aarch32/SHA1C/T1_A:decode@aarch32/SHA1C/T1_A:diagram
TAG:aarch32/STRD_i/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if address == Align(address, 8) then
    bits(64) data;
    if BigEndian() then
        data[63:32] = R[t];
        data[31:0] = R[t2];
    else
        data[31:0] = R[t];
        data[63:32] = R[t2];
    MemA[address,8] = data;
else
    MemA[address,4] = R[t];
    MemA[address+4,4] = R[t2];
if wback then R[n] = offset_addr;
TAG:aarch32/STRD_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/STRD_i/A1_A:decode
if Rt[0] == '1' then UNPREDICTABLE;
t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if P == '0' && W == '1' then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;
if t2 == 15 then UNPREDICTABLE;

TAG:aarch32/STRD_i/T1_A:diagram
T32
31:25 _ 1110100
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/STRD_i/T1_A:decode
if P == '0' && W == '0' then SEE "Related encodings";
t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if wback && (n == t || n == t2) then UNPREDICTABLE;
if n == 15 || t == 15 || t2 == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/STRD_i/A:index
Execute: aarch32/STRD_i/A:execute
Decode: aarch32/STRD_i/A1_A:decode@aarch32/STRD_i/A1_A:diagram
Decode: aarch32/STRD_i/T1_A:decode@aarch32/STRD_i/T1_A:diagram
TAG:aarch32/VCEQ_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
        if int_operation then
            test_passed = (op1 == op2);
        else
            test_passed = FPCompareEQ(op1, op2, StandardFPSCRValue());
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCEQ_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VCEQ_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
int_operation = TRUE;  esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCEQ_r/A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCEQ_r/A2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
int_operation = FALSE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCEQ_r/T2_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCEQ_r/T2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
int_operation = FALSE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCEQ_r/A:index
Execute: aarch32/VCEQ_r/A:execute
Decode: aarch32/VCEQ_r/T1A1_A:decode@aarch32/VCEQ_r/T1A1_A:diagram
Decode: aarch32/VCEQ_r/A2_A:decode@aarch32/VCEQ_r/A2_A:diagram
Decode: aarch32/VCEQ_r/T1A1_A:decode@aarch32/VCEQ_r/T1A1_A:diagram
Decode: aarch32/VCEQ_r/T2_A:decode@aarch32/VCEQ_r/T2_A:diagram
TAG:aarch32/VMOV_h/A:execute
CheckVFPEnabled(TRUE);
if to_arm_register then
    R[t] = Zeros(16) : S[n][15:0];
else
    S[n] = Zeros(16) : R[t][15:0];
TAG:aarch32/VMOV_h/A1_A:diagram
A32
31:28 cond xxxx
27:21 _ 1110000
20:20 op x
19:16 Vn xxxx
15:12 Rt xxxx
11:8 _ 1001
7:7 N x
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_h/A1_A:decode
if !HaveFP16Ext() then UNDEFINED;
if cond != '1110' then UNPREDICTABLE;
to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_h/T1_A:diagram
T32
31:21 _ 11101110000
20:20 op x
19:16 Vn xxxx
15:12 Rt xxxx
11:8 _ 1001
7:7 N x
6:6 _ (0)
5:5 _ (0)
4:4 _ 1
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/VMOV_h/T1_A:decode
if !HaveFP16Ext() then UNDEFINED;
if InITBlock() then UNPREDICTABLE;
to_arm_register = (op == '1');  t = UInt(Rt);  n = UInt(Vn:N);
if t == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/VMOV_h/A:index
Execute: aarch32/VMOV_h/A:execute
Decode: aarch32/VMOV_h/A1_A:decode@aarch32/VMOV_h/A1_A:diagram
Decode: aarch32/VMOV_h/T1_A:decode@aarch32/VMOV_h/T1_A:diagram
TAG:aarch32/PKH/A:execute
operand2 = Shift(R[m], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
R[d][15:0]  = if tbform then operand2[15:0] else R[n][15:0];
R[d][31:16] = if tbform then R[n][31:16]    else operand2[31:16];
TAG:aarch32/PKH/A1_A:diagram
A32
31:28 cond xxxx
27:20 _ 01101000
19:16 Rn xxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:6 tb x
5:4 _ 01
3:0 Rm xxxx
TAG:aarch32/PKH/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
(shift_t, shift_n) = DecodeImmShift(tb:'0', imm5);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/PKH/T1_A:diagram
T32
31:25 _ 1110101
24:21 _ 0110
20:20 S 0
19:16 Rn xxxx
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 tb x
4:4 T 0
3:0 Rm xxxx
TAG:aarch32/PKH/T1_A:decode
if S == '1' || T == '1' then UNDEFINED;
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  tbform = (tb == '1');
(shift_t, shift_n) = DecodeImmShift(tb:'0', imm3:imm2);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/PKH/A:index
Execute: aarch32/PKH/A:execute
Decode: aarch32/PKH/A1_A:decode@aarch32/PKH/A1_A:diagram
Decode: aarch32/PKH/T1_A:decode@aarch32/PKH/T1_A:diagram
TAG:aarch32/VSWP/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    if d == m then
        D[d+r] = bits(64) UNKNOWN;
    else
        D[d+r] = Din[m+r];
        D[m+r] = Din[d+r];
TAG:aarch32/VSWP/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size 00
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0000
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSWP/T1A1_A:decode
if size != '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSWP/A:index
Execute: aarch32/VSWP/A:execute
Decode: aarch32/VSWP/T1A1_A:decode@aarch32/VSWP/T1A1_A:diagram
Decode: aarch32/VSWP/T1A1_A:decode@aarch32/VSWP/T1A1_A:diagram
TAG:aarch32/LDRD_i/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
if address == Align(address, 8) then
    data = MemA[address,8];
    if BigEndian()  then
        R[t] = data[63:32];
        R[t2] = data[31:0];
    else
        R[t] = data[31:0];
        R[t2] = data[63:32];
else
    R[t] = MemA[address,4];
    R[t2] = MemA[address+4,4];
if wback then R[n] = offset_addr;
TAG:aarch32/LDRD_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRD_i/A1_A:decode
if Rn == '1111' then SEE "LDRD (literal)";
if Rt[0] == '1' then UNPREDICTABLE;
t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if P == '0' && W == '1' then UNPREDICTABLE;
if wback && (n == t || n == t2) then UNPREDICTABLE;
if t2 == 15 then UNPREDICTABLE;

TAG:aarch32/LDRD_i/T1_A:diagram
T32
31:25 _ 1110100
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRD_i/T1_A:decode
if P == '0' && W == '0' then SEE "Related encodings";
if Rn == '1111' then SEE "LDRD (literal)";
t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if wback && (n == t || n == t2) then UNPREDICTABLE;
if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRD_i/A:index
Execute: aarch32/LDRD_i/A:execute
Decode: aarch32/LDRD_i/A1_A:decode@aarch32/LDRD_i/A1_A:diagram
Decode: aarch32/LDRD_i/T1_A:decode@aarch32/LDRD_i/T1_A:diagram
TAG:aarch32/VMOV_ss/A:execute
CheckVFPEnabled(TRUE);
if to_arm_registers then
    R[t] = S[m];
    R[t2] = S[m+1];
else
    S[m] = R[t];
    S[m+1] = R[t2];
TAG:aarch32/VMOV_ss/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11000
22:22 _ 1
21:21 _ 0
20:20 op x
19:16 Rt2 xxxx
15:12 Rt xxxx
11:10 _ 10
9:8 _ 10
7:6 _ 00
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VMOV_ss/T1A1_A:decode
to_arm_registers = (op == '1');  t = UInt(Rt);  t2 = UInt(Rt2);  m = UInt(Vm:M);
if t == 15 || t2 == 15 || m == 31 then UNPREDICTABLE;
if to_arm_registers && t == t2 then UNPREDICTABLE;

TAG:aarch32/VMOV_ss/A:index
Execute: aarch32/VMOV_ss/A:execute
Decode: aarch32/VMOV_ss/T1A1_A:decode@aarch32/VMOV_ss/T1A1_A:diagram
Decode: aarch32/VMOV_ss/T1A1_A:decode@aarch32/VMOV_ss/T1A1_A:diagram
TAG:aarch32/UXTB16/A:execute
rotated = ROR(R[m], rotation);
R[d][15:0]  = ZeroExtend(rotated[7:0], 16);
R[d][31:16] = ZeroExtend(rotated[23:16], 16);
TAG:aarch32/UXTB16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 00
19:16 _ 1111
15:12 Rd xxxx
11:10 rotate xx
9:9 _ (0)
8:8 _ (0)
7:4 _ 0111
3:0 Rm xxxx
TAG:aarch32/UXTB16/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UXTB16/T1_A:diagram
T32
31:23 _ 111110100
22:21 _ 01
20:20 _ 1
19:16 _ 1111
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 1
6:6 _ (0)
5:4 rotate xx
3:0 Rm xxxx
TAG:aarch32/UXTB16/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  rotation = UInt(rotate:'000');
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UXTB16/A:index
Execute: aarch32/UXTB16/A:execute
Decode: aarch32/UXTB16/A1_A:decode@aarch32/UXTB16/A1_A:diagram
Decode: aarch32/UXTB16/T1_A:decode@aarch32/UXTB16/T1_A:diagram
TAG:aarch32/LDR_r/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
    offset_addr = if add then (R[n] + offset) else (R[n] - offset);
    address = if index then offset_addr else R[n];
    data = MemU[address,4];
    if wback then R[n] = offset_addr;
    if t == 15 then
        if address[1:0] == '00' then
            LoadWritePC(data);
        else
            UNPREDICTABLE;
    else
        R[t] = data;
else
    offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
    offset_addr = (R[n] + offset);
    address = offset_addr;
    data = MemU[address,4];
    if t == 15 then
        if address[1:0] == '00' then
            LoadWritePC(data);
        else
            UNPREDICTABLE;
    else
        R[t] = data;
TAG:aarch32/LDR_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/LDR_r/A1_A:decode
if P == '0' && W == '1' then SEE "LDRT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/LDR_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 1
26:26 _ 0
25:25 _ 0
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDR_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/LDR_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/LDR_r/T2_A:decode
if Rn == '1111' then SEE "LDR (literal)";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if t == 15 && InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/LDR_r/A:index
Execute: aarch32/LDR_r/A:execute
Decode: aarch32/LDR_r/A1_A:decode@aarch32/LDR_r/A1_A:diagram
Decode: aarch32/LDR_r/T1_A:decode@aarch32/LDR_r/T1_A:diagram
Decode: aarch32/LDR_r/T2_A:decode@aarch32/LDR_r/T2_A:diagram
TAG:aarch32/TEQ_i/A:execute
result = R[n] EOR imm32;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TEQ_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/TEQ_i/A1_A:decode
n = UInt(Rn);
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/TEQ_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0100
20:20 _ 1
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 _ 1111
7:0 imm8 xxxxxxxx
TAG:aarch32/TEQ_i/T1_A:decode
n = UInt(Rn);
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/TEQ_i/A:index
Execute: aarch32/TEQ_i/A:execute
Decode: aarch32/TEQ_i/A1_A:decode@aarch32/TEQ_i/A1_A:diagram
Decode: aarch32/TEQ_i/T1_A:decode@aarch32/TEQ_i/T1_A:diagram
TAG:aarch32/ORR_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] OR shifted;
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/ORR_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/ORR_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/ORR_rr/A:index
Execute: aarch32/ORR_rr/A:execute
Decode: aarch32/ORR_rr/A1_A:decode@aarch32/ORR_rr/A1_A:diagram
TAG:aarch32/SMLAWB/A:execute
operand2 = if m_high then R[m][31:16] else R[m][15:0];
result = SInt(R[n]) * SInt(operand2) + (SInt(R[a]) << 16);
R[d] = result[47:16];
if (result >> 16) != SInt(R[d]) then  // Signed overflow
    PSTATE.Q = '1';
TAG:aarch32/SMLAWB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 01
20:20 _ 0
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:7 _ 1
6:6 M x
5:5 _ 0
4:4 _ 0
3:0 Rn xxxx
TAG:aarch32/SMLAWB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

TAG:aarch32/SMLAWB/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 011
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLAWB/T1_A:decode
if Ra == '1111' then SEE "SMULWB, SMULWT";
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMLAWB/A:index
Execute: aarch32/SMLAWB/A:execute
Decode: aarch32/SMLAWB/A1_A:decode@aarch32/SMLAWB/A1_A:diagram
Decode: aarch32/SMLAWB/T1_A:decode@aarch32/SMLAWB/T1_A:diagram
TAG:aarch32/PLI_i/A:execute
base = if n == 15 then Align(PC,4) else R[n];
address = if add then (base + imm32) else (base - imm32);
Hint_PreloadInstr(address);
TAG:aarch32/PLI_i/A1_A:diagram
A32
31:25 _ 1111010
24:24 _ 0
23:23 U x
22:22 _ 1
21:20 _ 01
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLI_i/A1_A:decode
n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

TAG:aarch32/PLI_i/T1_A:diagram
T32
31:23 _ 111110011
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLI_i/T1_A:decode
if Rn == '1111' then SEE "encoding T3";
n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);  add = TRUE;

TAG:aarch32/PLI_i/T2_A:diagram
T32
31:23 _ 111110010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:8 _ 1100
7:0 imm8 xxxxxxxx
TAG:aarch32/PLI_i/T2_A:decode
if Rn == '1111' then SEE "encoding T3";
n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);  add = FALSE;

TAG:aarch32/PLI_i/T3_A:diagram
T32
31:24 _ 11111001
23:23 U x
22:21 _ 00
20:16 _ 11111
15:12 _ 1111
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/PLI_i/T3_A:decode
n = 15;  imm32 = ZeroExtend(imm12, 32);  add = (U == '1');

TAG:aarch32/PLI_i/A:index
Execute: aarch32/PLI_i/A:execute
Decode: aarch32/PLI_i/A1_A:decode@aarch32/PLI_i/A1_A:diagram
Decode: aarch32/PLI_i/T1_A:decode@aarch32/PLI_i/T1_A:diagram
Decode: aarch32/PLI_i/T2_A:decode@aarch32/PLI_i/T2_A:diagram
Decode: aarch32/PLI_i/T3_A:decode@aarch32/PLI_i/T3_A:diagram
TAG:aarch32/VPADD_f/A:execute
CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;

for e = 0 to h-1
    Elem[dest,e,esize]   = FPAdd(Elem[D[n],2*e,esize], Elem[D[n],2*e+1,esize], StandardFPSCRValue());
    Elem[dest,e+h,esize] = FPAdd(Elem[D[m],2*e,esize], Elem[D[m],2*e+1,esize], StandardFPSCRValue());

D[d] = dest;
TAG:aarch32/VPADD_f/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPADD_f/A1_A:decode
if Q == '1' then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPADD_f/T1_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1101
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPADD_f/T1_A:decode
if Q == '1' then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPADD_f/A:index
Execute: aarch32/VPADD_f/A:execute
Decode: aarch32/VPADD_f/A1_A:decode@aarch32/VPADD_f/A1_A:diagram
Decode: aarch32/VPADD_f/T1_A:decode@aarch32/VPADD_f/T1_A:diagram
TAG:aarch32/LDREXB/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address,1);
R[t] = ZeroExtend(MemA[address,1], 32);
TAG:aarch32/LDREXB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXB/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDREXB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:6 _ 01
5:4 _ 00
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXB/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDREXB/A:index
Execute: aarch32/LDREXB/A:execute
Decode: aarch32/LDREXB/A1_A:decode@aarch32/LDREXB/A1_A:diagram
Decode: aarch32/LDREXB/T1_A:decode@aarch32/LDREXB/T1_A:diagram
TAG:aarch32/STLB/A:execute
address = R[n];
MemO[address, 1] = R[t][7:0];
TAG:aarch32/STLB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 _ (1)(1)(1)(1)
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLB/A1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STLB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 00
3:0 _ (1)(1)(1)(1)
TAG:aarch32/STLB/T1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STLB/A:index
Execute: aarch32/STLB/A:execute
Decode: aarch32/STLB/A1_A:decode@aarch32/STLB/A1_A:diagram
Decode: aarch32/STLB/T1_A:decode@aarch32/STLB/T1_A:diagram
TAG:aarch32/VCVT_is/A:execute
CheckAdvSIMDEnabled();
bits(esize) result;
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[m+r],e,esize];
        if to_integer then
            result = FPToFixed(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_ZERO);
        else
            result = FixedToFP(op1, 0, unsigned, StandardFPSCRValue(), FPRounding_TIEEVEN);
        Elem[D[d+r],e,esize] = result;
TAG:aarch32/VCVT_is/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 11
8:7 op xx
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_is/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
to_integer = (op[1] == '1');  unsigned = (op[0] == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVT_is/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 11
8:7 op xx
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVT_is/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
to_integer = (op[1] == '1');  unsigned = (op[0] == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVT_is/A:index
Execute: aarch32/VCVT_is/A:execute
Decode: aarch32/VCVT_is/A1_A:decode@aarch32/VCVT_is/A1_A:diagram
Decode: aarch32/VCVT_is/T1_A:decode@aarch32/VCVT_is/T1_A:diagram
TAG:aarch32/CMP_i/A:execute
(result, nzcv) = AddWithCarry(R[n], NOT(imm32), '1');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMP_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/CMP_i/A1_A:decode
n = UInt(Rn);  imm32 = A32ExpandImm(imm12);

TAG:aarch32/CMP_i/T1_A:diagram
T16
31:29 _ 001
28:27 _ 01
26:24 Rn xxx
23:16 imm8 xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/CMP_i/T1_A:decode
n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);

TAG:aarch32/CMP_i/T2_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 1101
20:20 _ 1
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 _ 1111
7:0 imm8 xxxxxxxx
TAG:aarch32/CMP_i/T2_A:decode
n = UInt(Rn);  imm32 = T32ExpandImm(i:imm3:imm8);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/CMP_i/A:index
Execute: aarch32/CMP_i/A:execute
Decode: aarch32/CMP_i/A1_A:decode@aarch32/CMP_i/A1_A:diagram
Decode: aarch32/CMP_i/T1_A:decode@aarch32/CMP_i/T1_A:diagram
Decode: aarch32/CMP_i/T2_A:decode@aarch32/CMP_i/T2_A:diagram
TAG:aarch32/VLD3_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for e = 0 to elements-1
    Elem[D[d], e] = MemU[address,ebytes];
    Elem[D[d2],e] = MemU[address+ebytes,ebytes];
    Elem[D[d3],e] = MemU[address+2*ebytes,ebytes];
    address = address + 3*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 24;
TAG:aarch32/VLD3_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 010x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD3_m/T1A1_A:decode
case itype of
    when '0100'
        inc = 1;
    when '0101'
        inc = 2;
    otherwise
        SEE "Related encodings";
if size == '11' || align[1] == '1' then UNDEFINED;
alignment = if align[0] == '0' then 1 else 8;
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD3_m/A:index
Execute: aarch32/VLD3_m/A:execute
Decode: aarch32/VLD3_m/T1A1_A:decode@aarch32/VLD3_m/T1A1_A:diagram
Decode: aarch32/VLD3_m/T1A1_A:decode@aarch32/VLD3_m/T1A1_A:diagram
TAG:aarch32/VST2_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for r = 0 to regs-1
    for e = 0 to elements-1
        MemU[address,       ebytes] = Elem[D[d+r], e];
        MemU[address+ebytes,ebytes] = Elem[D[d2+r],e];
        address = address + 2*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 16*regs;
TAG:aarch32/VST2_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 100x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST2_m/T1A1_A:decode
regs = 1;  if align == '11' then UNDEFINED;
if size == '11' then UNDEFINED;
inc = if itype == '1001' then 2 else 1;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST2_m/T2A2_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0011
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST2_m/T2A2_A:decode
regs = 2;  inc = 2;
if size == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VST2_m/A:index
Execute: aarch32/VST2_m/A:execute
Decode: aarch32/VST2_m/T1A1_A:decode@aarch32/VST2_m/T1A1_A:diagram
Decode: aarch32/VST2_m/T2A2_A:decode@aarch32/VST2_m/T2A2_A:diagram
Decode: aarch32/VST2_m/T1A1_A:decode@aarch32/VST2_m/T1A1_A:diagram
Decode: aarch32/VST2_m/T2A2_A:decode@aarch32/VST2_m/T2A2_A:diagram
TAG:aarch32/VORR_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[n+r] OR D[m+r];
TAG:aarch32/VORR_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VORR_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VORR_r/A:index
Execute: aarch32/VORR_r/A:execute
Decode: aarch32/VORR_r/T1A1_A:decode@aarch32/VORR_r/T1A1_A:diagram
Decode: aarch32/VORR_r/T1A1_A:decode@aarch32/VORR_r/T1A1_A:diagram
TAG:aarch32/EOR_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] EOR shifted;
R[d] = result;
if setflags then
    PSTATE.N = result[31];
    PSTATE.Z = IsZeroBit(result);
    PSTATE.C = carry;
    // PSTATE.V unchanged
TAG:aarch32/EOR_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 001
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/EOR_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/EOR_rr/A:index
Execute: aarch32/EOR_rr/A:execute
Decode: aarch32/EOR_rr/A1_A:decode@aarch32/EOR_rr/A1_A:diagram
TAG:aarch32/SMMLS/A:execute
result = (SInt(R[a]) << 32) - SInt(R[n]) * SInt(R[m]);
if round then result = result + 0x80000000;
R[d] = result[63:32];
TAG:aarch32/SMMLS/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 101
19:16 Rd xxxx
15:12 Ra xxxx
11:8 Rm xxxx
7:6 _ 11
5:5 R x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMMLS/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;

TAG:aarch32/SMMLS/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 110
19:16 Rn xxxx
15:12 Ra xxxx
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 R x
3:0 Rm xxxx
TAG:aarch32/SMMLS/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  a = UInt(Ra);  round = (R == '1');
if d == 15 || n == 15 || m == 15 || a == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMMLS/A:index
Execute: aarch32/SMMLS/A:execute
Decode: aarch32/SMMLS/A1_A:decode@aarch32/SMMLS/A1_A:diagram
Decode: aarch32/SMMLS/T1_A:decode@aarch32/SMMLS/T1_A:diagram
TAG:aarch32/LDREXH/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address,2);
R[t] = ZeroExtend(MemA[address,2], 32);
TAG:aarch32/LDREXH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXH/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDREXH/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:6 _ 01
5:4 _ 01
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREXH/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDREXH/A:index
Execute: aarch32/LDREXH/A:execute
Decode: aarch32/LDREXH/A1_A:decode@aarch32/LDREXH/A1_A:diagram
Decode: aarch32/LDREXH/T1_A:decode@aarch32/LDREXH/T1_A:diagram
TAG:aarch32/LDAEXD/A:execute
address = R[n];
AArch32.SetExclusiveMonitors(address, 8);
value = MemO[address, 8];
// Extract words from 64-bit loaded value such that R[t] is
// loaded from address and R[t2] from address+4.
R[t]  = if BigEndian() then value[63:32] else value[31:0];
R[t2] = if BigEndian() then value[31:0]  else value[63:32];
TAG:aarch32/LDAEXD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXD/A1_A:decode
t = UInt(Rt);  t2 = t + 1;  n = UInt(Rn);
if Rt[0] == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXD/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:7 _ 1
6:6 _ 1
5:4 _ 11
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDAEXD/T1_A:decode
t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
if t == 15 || t2 == 15 || t == t2 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDAEXD/A:index
Execute: aarch32/LDAEXD/A:execute
Decode: aarch32/LDAEXD/A1_A:decode@aarch32/LDAEXD/A1_A:diagram
Decode: aarch32/LDAEXD/T1_A:decode@aarch32/LDAEXD/T1_A:diagram
TAG:aarch32/PLD_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
address = if add then (R[n] + offset) else (R[n] - offset);
if is_pldw then
    Hint_PreloadDataForWrite(address);
else
    Hint_PreloadData(address);
TAG:aarch32/PLD_r/A1_A:diagram
A32
31:25 _ 1111011
24:24 _ 1
23:23 U x
22:22 R x
21:20 _ 01
19:16 Rn xxxx
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/PLD_r/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  add = (U == '1');  is_pldw = (R == '0');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if m == 15 || (n == 15 && is_pldw) then UNPREDICTABLE;

TAG:aarch32/PLD_r/T1_A:diagram
T32
31:23 _ 111110000
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 _ 1111
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/PLD_r/T1_A:decode
if Rn == '1111' then SEE "PLD (literal)";
n = UInt(Rn);  m = UInt(Rm);  add = TRUE;  is_pldw = (W == '1');
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/PLD_r/A:index
Execute: aarch32/PLD_r/A:execute
Decode: aarch32/PLD_r/A1_A:decode@aarch32/PLD_r/A1_A:diagram
Decode: aarch32/PLD_r/T1_A:decode@aarch32/PLD_r/T1_A:diagram
TAG:aarch32/VLD1_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
Elem[D[d],index] = MemU[address,ebytes];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + ebytes;
TAG:aarch32/VLD1_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD1_1/T1A1_A:decode
if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align[0] != '0' then UNDEFINED;
ebytes = 1;  index = UInt(index_align[3:1]);  alignment = 1;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VLD1_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD1_1/T2A2_A:decode
if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align[1] != '0' then UNDEFINED;
ebytes = 2;  index = UInt(index_align[3:2]);
alignment = if index_align[0] == '0' then 1 else 2;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VLD1_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 00
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD1_1/T3A3_A:decode
if size == '11' then SEE "VLD1 (single element to all lanes)";
if index_align[2] != '0' then UNDEFINED;
if index_align[1:0] != '00' && index_align[1:0] != '11' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
alignment = if index_align[1:0] == '00' then 1 else 4;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 then UNPREDICTABLE;

TAG:aarch32/VLD1_1/A:index
Execute: aarch32/VLD1_1/A:execute
Decode: aarch32/VLD1_1/T1A1_A:decode@aarch32/VLD1_1/T1A1_A:diagram
Decode: aarch32/VLD1_1/T2A2_A:decode@aarch32/VLD1_1/T2A2_A:diagram
Decode: aarch32/VLD1_1/T3A3_A:decode@aarch32/VLD1_1/T3A3_A:diagram
Decode: aarch32/VLD1_1/T1A1_A:decode@aarch32/VLD1_1/T1A1_A:diagram
Decode: aarch32/VLD1_1/T2A2_A:decode@aarch32/VLD1_1/T2A2_A:diagram
Decode: aarch32/VLD1_1/T3A3_A:decode@aarch32/VLD1_1/T3A3_A:diagram
TAG:aarch32/VAND_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[n+r] AND D[m+r];
TAG:aarch32/VAND_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VAND_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VAND_r/A:index
Execute: aarch32/VAND_r/A:execute
Decode: aarch32/VAND_r/T1A1_A:decode@aarch32/VAND_r/T1A1_A:diagram
Decode: aarch32/VAND_r/T1A1_A:decode@aarch32/VAND_r/T1A1_A:diagram
TAG:aarch32/VORN_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[n+r] OR NOT(D[m+r]);
TAG:aarch32/VORN_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 11
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VORN_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VORN_r/A:index
Execute: aarch32/VORN_r/A:execute
Decode: aarch32/VORN_r/T1A1_A:decode@aarch32/VORN_r/T1A1_A:diagram
Decode: aarch32/VORN_r/T1A1_A:decode@aarch32/VORN_r/T1A1_A:diagram
TAG:aarch32/REVSH/A:execute
bits(32) result;
result[31:8]  = SignExtend(R[m][7:0], 24);
result[7:0]   = R[m][15:8];
R[d] = result;
TAG:aarch32/REVSH/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:20 _ 11
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:4 _ 011
3:0 Rm xxxx
TAG:aarch32/REVSH/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);
if d == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/REVSH/T1_A:diagram
T16
31:24 _ 10111010
23:22 _ 11
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/REVSH/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);

TAG:aarch32/REVSH/T2_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 11
3:0 Rm xxxx
TAG:aarch32/REVSH/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  n = UInt(Rn);
if m != n || d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/REVSH/A:index
Execute: aarch32/REVSH/A:execute
Decode: aarch32/REVSH/A1_A:decode@aarch32/REVSH/A1_A:diagram
Decode: aarch32/REVSH/T1_A:decode@aarch32/REVSH/T1_A:diagram
Decode: aarch32/REVSH/T2_A:decode@aarch32/REVSH/T2_A:diagram
TAG:aarch32/UMULL/A:execute
result = UInt(R[n]) * UInt(R[m]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
if setflags then
    PSTATE.N = result[63];
    PSTATE.Z = IsZeroBit(result[63:0]);
    // PSTATE.C, PSTATE.V unchanged
TAG:aarch32/UMULL/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 100
20:20 S x
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:4 _ 1001
3:0 Rn xxxx
TAG:aarch32/UMULL/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = (S == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMULL/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 010
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:4 _ 0000
3:0 Rm xxxx
TAG:aarch32/UMULL/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  setflags = FALSE;
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/UMULL/A:index
Execute: aarch32/UMULL/A:execute
Decode: aarch32/UMULL/A1_A:decode@aarch32/UMULL/A1_A:diagram
Decode: aarch32/UMULL/T1_A:decode@aarch32/UMULL/T1_A:diagram
TAG:aarch32/LDRD_l/A:execute
address = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
if address == Align(address, 8) then
    data = MemA[address,8];
    if BigEndian() then
        R[t] = data[63:32];
        R[t2] = data[31:0];
    else
        R[t] = data[31:0];
        R[t2] = data[63:32];
else
    R[t] = MemA[address,4];
    R[t2] = MemA[address+4,4];
TAG:aarch32/LDRD_l/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 _ (1)
23:23 U x
22:22 _ 1
21:21 _ (0)
20:20 _ 0
19:16 _ 1111
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRD_l/A1_A:decode
if Rt[0] == '1' then UNPREDICTABLE;
t = UInt(Rt);  t2 = t+1;  imm32 = ZeroExtend(imm4H:imm4L, 32);  add = (U == '1');
if t2 == 15 then UNPREDICTABLE;

TAG:aarch32/LDRD_l/T1_A:diagram
T32
31:25 _ 1110100
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 Rt xxxx
11:8 Rt2 xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRD_l/T1_A:decode
if P == '0' && W == '0' then SEE "Related encodings";
t = UInt(Rt);  t2 = UInt(Rt2);
imm32 = ZeroExtend(imm8:'00', 32);  add = (U == '1');
if t == 15 || t2 == 15 || t == t2 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if W == '1' then UNPREDICTABLE;

TAG:aarch32/LDRD_l/A:index
Execute: aarch32/LDRD_l/A:execute
Decode: aarch32/LDRD_l/A1_A:decode@aarch32/LDRD_l/A1_A:diagram
Decode: aarch32/LDRD_l/T1_A:decode@aarch32/LDRD_l/T1_A:diagram
TAG:aarch32/SETPAN/A:execute
if PSTATE.EL != EL0 then
    PSTATE.PAN = value;
TAG:aarch32/SETPAN/A1_A:diagram
A32
31:20 _ 111100010001
19:19 _ (0)
18:18 _ (0)
17:17 _ (0)
16:16 _ (0)
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:11 _ (0)
10:10 _ (0)
9:9 imm1 x
8:8 _ (0)
7:4 _ 0000
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/SETPAN/A1_A:decode
if !HavePANExt() then UNDEFINED;
value = imm1;

TAG:aarch32/SETPAN/T1_A:diagram
T16
31:21 _ 10110110000
20:20 _ (1)
19:19 imm1 x
18:18 _ (0)
17:17 _ (0)
16:16 _ (0)
15:0 _ 0000000000000000
TAG:aarch32/SETPAN/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HavePANExt() then UNDEFINED;
value = imm1;

TAG:aarch32/SETPAN/A:index
Execute: aarch32/SETPAN/A:execute
Decode: aarch32/SETPAN/A1_A:decode@aarch32/SETPAN/A1_A:diagram
Decode: aarch32/SETPAN/T1_A:decode@aarch32/SETPAN/T1_A:diagram
TAG:aarch32/STMIB/A:execute
address = R[n] + 4;
for i = 0 to 14
    if registers[i] == '1' then
        if i == n && wback && i != LowestSetBit(registers) then
            MemA[address,4] = bits(32) UNKNOWN;
        else
            MemA[address,4] = R[i];
        address = address + 4;
if registers[15] == '1' then
    MemA[address,4] = PCStoreValue();
if wback then R[n] = R[n] + 4*BitCount(registers);
TAG:aarch32/STMIB/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 100
24:24 _ 1
23:23 _ 1
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:0 register_list xxxxxxxxxxxxxxxx
TAG:aarch32/STMIB/A1_A:decode
n = UInt(Rn);  registers = register_list;  wback = (W == '1');
if n == 15 || BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/STMIB/A:index
Execute: aarch32/STMIB/A:execute
Decode: aarch32/STMIB/A1_A:decode@aarch32/STMIB/A1_A:diagram
TAG:aarch32/QADD/A:execute
(R[d], sat) = SignedSatQ(SInt(R[m]) + SInt(R[n]), 32);
if sat then
    PSTATE.Q = '1';
TAG:aarch32/QADD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:4 _ 0101
3:0 Rm xxxx
TAG:aarch32/QADD/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QADD/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 000
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 10
5:4 _ 00
3:0 Rm xxxx
TAG:aarch32/QADD/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QADD/A:index
Execute: aarch32/QADD/A:execute
Decode: aarch32/QADD/A1_A:decode@aarch32/QADD/A1_A:diagram
Decode: aarch32/QADD/T1_A:decode@aarch32/QADD/T1_A:diagram
TAG:aarch32/VLD2_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
Elem[D[d], index] = MemU[address,ebytes];
Elem[D[d2],index] = MemU[address+ebytes,ebytes];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 2*ebytes;
TAG:aarch32/VLD2_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD2_1/T1A1_A:decode
if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
alignment = if index_align[0] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD2_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD2_1/T2A2_A:decode
if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 4;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD2_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 01
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD2_1/T3A3_A:decode
if size == '11' then SEE "VLD2 (single 2-element structure to all lanes)";
if index_align[1] != '0' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
alignment = if index_align[0] == '0' then 1 else 8;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD2_1/A:index
Execute: aarch32/VLD2_1/A:execute
Decode: aarch32/VLD2_1/T1A1_A:decode@aarch32/VLD2_1/T1A1_A:diagram
Decode: aarch32/VLD2_1/T2A2_A:decode@aarch32/VLD2_1/T2A2_A:diagram
Decode: aarch32/VLD2_1/T3A3_A:decode@aarch32/VLD2_1/T3A3_A:diagram
Decode: aarch32/VLD2_1/T1A1_A:decode@aarch32/VLD2_1/T1A1_A:diagram
Decode: aarch32/VLD2_1/T2A2_A:decode@aarch32/VLD2_1/T2A2_A:diagram
Decode: aarch32/VLD2_1/T3A3_A:decode@aarch32/VLD2_1/T3A3_A:diagram
TAG:aarch32/QSUB8/A:execute
diff1 = SInt(R[n][7:0]) - SInt(R[m][7:0]);
diff2 = SInt(R[n][15:8]) - SInt(R[m][15:8]);
diff3 = SInt(R[n][23:16]) - SInt(R[m][23:16]);
diff4 = SInt(R[n][31:24]) - SInt(R[m][31:24]);
R[d][7:0]   = SignedSat(diff1, 8);
R[d][15:8]  = SignedSat(diff2, 8);
R[d][23:16] = SignedSat(diff3, 8);
R[d][31:24] = SignedSat(diff4, 8);
TAG:aarch32/QSUB8/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 1
6:5 _ 11
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSUB8/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QSUB8/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QSUB8/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QSUB8/A:index
Execute: aarch32/QSUB8/A:execute
Decode: aarch32/QSUB8/A1_A:decode@aarch32/QSUB8/A1_A:diagram
Decode: aarch32/QSUB8/T1_A:decode@aarch32/QSUB8/T1_A:diagram
TAG:aarch32/HLT/A:execute
Halt(DebugHalt_HaltInstruction);
TAG:aarch32/HLT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 00
20:20 _ 0
19:8 imm12 xxxxxxxxxxxx
7:4 _ 0111
3:0 imm4 xxxx
TAG:aarch32/HLT/A1_A:decode
if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
if cond != '1110' then UNPREDICTABLE; // HLT must be encoded with AL condition

TAG:aarch32/HLT/T1_A:diagram
T16
31:22 _ 1011101010
21:16 imm6 xxxxxx
15:0 _ 0000000000000000
TAG:aarch32/HLT/T1_A:decode
if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;

TAG:aarch32/HLT/A:index
Execute: aarch32/HLT/A:execute
Decode: aarch32/HLT/A1_A:decode@aarch32/HLT/A1_A:diagram
Decode: aarch32/HLT/T1_A:decode@aarch32/HLT/T1_A:diagram
TAG:aarch32/QADD16/A:execute
sum1 = SInt(R[n][15:0]) + SInt(R[m][15:0]);
sum2 = SInt(R[n][31:16]) + SInt(R[m][31:16]);
R[d][15:0]  = SignedSat(sum1, 16);
R[d][31:16] = SignedSat(sum2, 16);
TAG:aarch32/QADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 010
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/QADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 0
5:5 _ 0
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/QADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/QADD16/A:index
Execute: aarch32/QADD16/A:execute
Decode: aarch32/QADD16/A1_A:decode@aarch32/QADD16/A1_A:diagram
Decode: aarch32/QADD16/T1_A:decode@aarch32/QADD16/T1_A:diagram
TAG:aarch32/VPADDL/A:execute
CheckAdvSIMDEnabled();
h = elements DIV 2;

for r = 0 to regs-1
    for e = 0 to h-1
        op1 = Elem[D[m+r],2*e,esize];  op2 = Elem[D[m+r],2*e+1,esize];
        result = Int(op1, unsigned) + Int(op2, unsigned);
        Elem[D[d+r],e,2*esize] = result[2*esize-1:0];
TAG:aarch32/VPADDL/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:8 _ 010
7:7 op x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VPADDL/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (op == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VPADDL/A:index
Execute: aarch32/VPADDL/A:execute
Decode: aarch32/VPADDL/T1A1_A:decode@aarch32/VPADDL/T1A1_A:diagram
Decode: aarch32/VPADDL/T1A1_A:decode@aarch32/VPADDL/T1A1_A:diagram
TAG:aarch32/VSHLL/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    result = Int(Elem[Din[m],e,esize], unsigned) << shift_amount;
    Elem[Q[d>>1],e,2*esize] = result[2*esize-1:0];
TAG:aarch32/VSHLL/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 1010
7:7 _ 0
6:6 _ 0
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSHLL/T1A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if Vd[0] == '1' then UNDEFINED;
case imm6 of
    when '001xxx'  esize = 8;  elements = 8;  shift_amount = UInt(imm6) - 8;
    when '01xxxx'  esize = 16;  elements = 4;  shift_amount = UInt(imm6) - 16;
    when '1xxxxx'  esize = 32;  elements = 2;  shift_amount = UInt(imm6) - 32;
if shift_amount == 0 then SEE "VMOVL";
unsigned = (U == '1');  d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VSHLL/T2A2_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 10
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0110
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSHLL/T2A2_A:decode
if size == '11' || Vd[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;  shift_amount = esize;
unsigned = FALSE;  // Or TRUE without change of functionality
d = UInt(D:Vd);  m = UInt(M:Vm);

TAG:aarch32/VSHLL/A:index
Execute: aarch32/VSHLL/A:execute
Decode: aarch32/VSHLL/T1A1_A:decode@aarch32/VSHLL/T1A1_A:diagram
Decode: aarch32/VSHLL/T2A2_A:decode@aarch32/VSHLL/T2A2_A:diagram
Decode: aarch32/VSHLL/T1A1_A:decode@aarch32/VSHLL/T1A1_A:diagram
Decode: aarch32/VSHLL/T2A2_A:decode@aarch32/VSHLL/T2A2_A:diagram
TAG:aarch32/VMOVX/A:execute
CheckVFPEnabled(TRUE);
S[d] = Zeros(16) : S[m][31:16];
TAG:aarch32/VMOVX/A1_A:diagram
A32
31:23 _ 111111101
22:22 D x
21:16 _ 110000
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMOVX/A1_A:decode
if !HaveFP16Ext() then UNDEFINED;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
d = UInt(Vd:D); m = UInt(Vm:M);

TAG:aarch32/VMOVX/T1_A:diagram
T32
31:23 _ 111111101
22:22 D x
21:16 _ 110000
15:12 Vd xxxx
11:10 _ 10
9:8 _ 10
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMOVX/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveFP16Ext() then UNDEFINED;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
d = UInt(Vd:D); m = UInt(Vm:M);

TAG:aarch32/VMOVX/A:index
Execute: aarch32/VMOVX/A:execute
Decode: aarch32/VMOVX/A1_A:decode@aarch32/VMOVX/A1_A:diagram
Decode: aarch32/VMOVX/T1_A:decode@aarch32/VMOVX/T1_A:diagram
TAG:aarch32/VMVN_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = NOT(imm64);
TAG:aarch32/VMVN_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 0xx0
7:7 _ 0
6:6 Q x
5:5 _ 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMVN_i/T1A1_A:decode
if (cmode[0] == '1' && cmode[3:2] != '11') || cmode[3:1] == '111' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMVN_i/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 10x0
7:7 _ 0
6:6 Q x
5:5 _ 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMVN_i/T2A2_A:decode
if (cmode[0] == '1' && cmode[3:2] != '11') || cmode[3:1] == '111' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMVN_i/T3A3_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 110x
7:7 _ 0
6:6 Q x
5:5 _ 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMVN_i/T3A3_A:decode
if (cmode[0] == '1' && cmode[3:2] != '11') || cmode[3:1] == '111' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
imm64 = AdvSIMDExpandImm('1', cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMVN_i/A:index
Execute: aarch32/VMVN_i/A:execute
Decode: aarch32/VMVN_i/T1A1_A:decode@aarch32/VMVN_i/T1A1_A:diagram
Decode: aarch32/VMVN_i/T2A2_A:decode@aarch32/VMVN_i/T2A2_A:diagram
Decode: aarch32/VMVN_i/T3A3_A:decode@aarch32/VMVN_i/T3A3_A:diagram
Decode: aarch32/VMVN_i/T1A1_A:decode@aarch32/VMVN_i/T1A1_A:diagram
Decode: aarch32/VMVN_i/T2A2_A:decode@aarch32/VMVN_i/T2A2_A:diagram
Decode: aarch32/VMVN_i/T3A3_A:decode@aarch32/VMVN_i/T3A3_A:diagram
TAG:aarch32/IT/A:execute
AArch32.CheckITEnabled(mask);
PSTATE.IT[7:0] = firstcond:mask;
ShouldAdvanceIT = FALSE;
TAG:aarch32/IT/T1_A:diagram
T16
31:24 _ 10111111
23:20 firstcond xxxx
19:16 mask xxxx
15:0 _ 0000000000000000
TAG:aarch32/IT/T1_A:decode
if mask == '0000' then SEE "Related encodings";
if firstcond == '1111' || (firstcond == '1110' && BitCount(mask) != 1) then UNPREDICTABLE;
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/IT/A:index
Execute: aarch32/IT/A:execute
Decode: aarch32/IT/T1_A:decode@aarch32/IT/T1_A:diagram
TAG:aarch32/BL_i/A:execute
if CurrentInstrSet() == InstrSet_A32 then
    LR = PC - 4;
else
    LR = PC[31:1] : '1';
if targetInstrSet == InstrSet_A32 then
    targetAddress = Align(PC,4) + imm32;
else
    targetAddress = PC + imm32;
SelectInstrSet(targetInstrSet);
BranchWritePC(targetAddress, BranchType_DIRCALL);
TAG:aarch32/BL_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 101
24:24 _ 1
23:0 imm24 xxxxxxxxxxxxxxxxxxxxxxxx
TAG:aarch32/BL_i/A1_A:decode
imm32 = SignExtend(imm24:'00', 32);  targetInstrSet = InstrSet_A32;

TAG:aarch32/BL_i/A2_A:diagram
A32
31:28 cond 1111
27:25 _ 101
24:24 H x
23:0 imm24 xxxxxxxxxxxxxxxxxxxxxxxx
TAG:aarch32/BL_i/A2_A:decode
imm32 = SignExtend(imm24:H:'0', 32);  targetInstrSet = InstrSet_T32;

TAG:aarch32/BL_i/T1_A:diagram
T32
31:27 _ 11110
26:26 S x
25:16 imm10 xxxxxxxxxx
15:14 _ 11
13:13 J1 x
12:12 _ 1
11:11 J2 x
10:0 imm11 xxxxxxxxxxx
TAG:aarch32/BL_i/T1_A:decode
I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10:imm11:'0', 32);
targetInstrSet = InstrSet_T32;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/BL_i/T2_A:diagram
T32
31:27 _ 11110
26:26 S x
25:16 imm10H xxxxxxxxxx
15:14 _ 11
13:13 J1 x
12:12 _ 0
11:11 J2 x
10:1 imm10L xxxxxxxxxx
0:0 H x
TAG:aarch32/BL_i/T2_A:decode
if H == '1' then UNDEFINED;
I1 = NOT(J1 EOR S);  I2 = NOT(J2 EOR S);  imm32 = SignExtend(S:I1:I2:imm10H:imm10L:'00', 32);
targetInstrSet = InstrSet_A32;
if InITBlock() && !LastInITBlock() then UNPREDICTABLE;

TAG:aarch32/BL_i/A:index
Execute: aarch32/BL_i/A:execute
Decode: aarch32/BL_i/A1_A:decode@aarch32/BL_i/A1_A:diagram
Decode: aarch32/BL_i/A2_A:decode@aarch32/BL_i/A2_A:diagram
Decode: aarch32/BL_i/T1_A:decode@aarch32/BL_i/T1_A:diagram
Decode: aarch32/BL_i/T2_A:decode@aarch32/BL_i/T2_A:diagram
TAG:aarch32/AESD/A:execute
CheckCryptoEnabled32();
op1 = Q[d>>1]; op2 = Q[m>>1];
Q[d>>1] = AESInvSubBytes(AESInvShiftRows(op1 EOR op2));
TAG:aarch32/AESD/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0110
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESD/A1_A:decode
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESD/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0110
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESD/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESD/A:index
Execute: aarch32/AESD/A:execute
Decode: aarch32/AESD/A1_A:decode@aarch32/AESD/A1_A:diagram
Decode: aarch32/AESD/T1_A:decode@aarch32/AESD/T1_A:diagram
TAG:aarch32/VLD3_1/A:execute
CheckAdvSIMDEnabled();
address = R[n];
Elem[D[d], index] = MemU[address,ebytes];
Elem[D[d2],index] = MemU[address+ebytes,ebytes];
Elem[D[d3],index] = MemU[address+2*ebytes,ebytes];
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 3*ebytes;
TAG:aarch32/VLD3_1/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 00
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD3_1/T1A1_A:decode
if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
if index_align[0] != '0' then UNDEFINED;
ebytes = 1;  index = UInt(index_align[3:1]);  inc = 1;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD3_1/T2A2_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 01
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD3_1/T2A2_A:decode
if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
if index_align[0] != '0' then UNDEFINED;
ebytes = 2;  index = UInt(index_align[3:2]);
inc = if index_align[1] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD3_1/T3A3_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 size 10
9:8 _ 10
7:4 index_align xxxx
3:0 Rm xxxx
TAG:aarch32/VLD3_1/T3A3_A:decode
if size == '11' then SEE "VLD3 (single 3-element structure to all lanes)";
if index_align[1:0] != '00' then UNDEFINED;
ebytes = 4;  index = UInt(index_align[3]);
inc = if index_align[2] == '0' then 1 else 2;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d3 > 31 then UNPREDICTABLE;

TAG:aarch32/VLD3_1/A:index
Execute: aarch32/VLD3_1/A:execute
Decode: aarch32/VLD3_1/T1A1_A:decode@aarch32/VLD3_1/T1A1_A:diagram
Decode: aarch32/VLD3_1/T2A2_A:decode@aarch32/VLD3_1/T2A2_A:diagram
Decode: aarch32/VLD3_1/T3A3_A:decode@aarch32/VLD3_1/T3A3_A:diagram
Decode: aarch32/VLD3_1/T1A1_A:decode@aarch32/VLD3_1/T1A1_A:diagram
Decode: aarch32/VLD3_1/T2A2_A:decode@aarch32/VLD3_1/T2A2_A:diagram
Decode: aarch32/VLD3_1/T3A3_A:decode@aarch32/VLD3_1/T3A3_A:diagram
TAG:aarch32/VST4_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = TRUE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for e = 0 to elements-1
    MemU[address,         ebytes] = Elem[D[d], e];
    MemU[address+ebytes,  ebytes] = Elem[D[d2],e];
    MemU[address+2*ebytes,ebytes] = Elem[D[d3],e];
    MemU[address+3*ebytes,ebytes] = Elem[D[d4],e];
    address = address + 4*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 32;
TAG:aarch32/VST4_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 000x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VST4_m/T1A1_A:decode
if size == '11' then UNDEFINED;
case itype of
    when '0000'
        inc = 1;
    when '0001'
        inc = 2;
    otherwise
        SEE "Related encodings";
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  d3 = d2 + inc;  d4 = d3 + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d4 > 31 then UNPREDICTABLE;

TAG:aarch32/VST4_m/A:index
Execute: aarch32/VST4_m/A:execute
Decode: aarch32/VST4_m/T1A1_A:decode@aarch32/VST4_m/T1A1_A:diagram
Decode: aarch32/VST4_m/T1A1_A:decode@aarch32/VST4_m/T1A1_A:diagram
TAG:aarch32/LDRD_r/A:execute
offset_addr = if add then (R[n] + R[m]) else (R[n] - R[m]);
address = if index then offset_addr else R[n];
if address == Align(address, 8) then
    data = MemA[address,8];
    if BigEndian() then
        R[t] = data[63:32];
        R[t2] = data[31:0];
    else
        R[t] = data[31:0];
        R[t2] = data[63:32];
else
    R[t] = MemA[address,4];
    R[t2] = MemA[address+4,4];

if wback then R[n] = offset_addr;
TAG:aarch32/LDRD_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRD_r/A1_A:decode
if Rt[0] == '1' then UNPREDICTABLE;
t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if P == '0' && W == '1' then UNPREDICTABLE;
if t2 == 15 || m == 15 || m == t || m == t2 then UNPREDICTABLE;
if wback && (n == 15 || n == t || n == t2) then UNPREDICTABLE;

TAG:aarch32/LDRD_r/A:index
Execute: aarch32/LDRD_r/A:execute
Decode: aarch32/LDRD_r/A1_A:decode@aarch32/LDRD_r/A1_A:diagram
TAG:aarch32/STL/A:execute
address = R[n];
MemO[address, 4] = R[t];
TAG:aarch32/STL/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 _ (1)(1)(1)(1)
11:11 _ (1)
10:10 _ (1)
9:9 _ 0
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STL/A1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STL/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 0
5:4 _ 10
3:0 _ (1)(1)(1)(1)
TAG:aarch32/STL/T1_A:decode
t = UInt(Rt); n = UInt(Rn);
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/STL/A:index
Execute: aarch32/STL/A:execute
Decode: aarch32/STL/A1_A:decode@aarch32/STL/A1_A:diagram
Decode: aarch32/STL/T1_A:decode@aarch32/STL/T1_A:diagram
TAG:aarch32/STREX/A:execute
address = R[n] + imm32;
if AArch32.ExclusiveMonitorsPass(address,4) then
    MemA[address,4] = R[t];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STREX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STREX/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREX/T1_A:diagram
T32
31:21 _ 11101000010
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/STREX/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STREX/A:index
Execute: aarch32/STREX/A:execute
Decode: aarch32/STREX/A1_A:decode@aarch32/STREX/A1_A:diagram
Decode: aarch32/STREX/T1_A:decode@aarch32/STREX/T1_A:diagram
TAG:aarch32/VCLE_i/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            bits(esize) zero = FPZero('0');
            test_passed = FPCompareGE(zero, Elem[D[m+r],e,esize], StandardFPSCRValue());
        else
            test_passed = (SInt(Elem[D[m+r],e,esize]) <= 0);
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCLE_i/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLE_i/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLE_i/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLE_i/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLE_i/A:index
Execute: aarch32/VCLE_i/A:execute
Decode: aarch32/VCLE_i/A1_A:decode@aarch32/VCLE_i/A1_A:diagram
Decode: aarch32/VCLE_i/T1_A:decode@aarch32/VCLE_i/T1_A:diagram
TAG:aarch32/SHA1P/A:execute
CheckCryptoEnabled32();
X = Q[d>>1];
Y = Q[n>>1][31:0]; // Note: 32 bits wide
W = Q[m>>1];
for e = 0 to 3
    t = SHAparity(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y:X, 32);
Q[d>>1] = X;
TAG:aarch32/SHA1P/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1P/A1_A:decode
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1P/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:20 _ 01
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/SHA1P/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveSHA1Ext() then UNDEFINED;
if Q != '1' then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/SHA1P/A:index
Execute: aarch32/SHA1P/A:execute
Decode: aarch32/SHA1P/A1_A:decode@aarch32/SHA1P/A1_A:diagram
Decode: aarch32/SHA1P/T1_A:decode@aarch32/SHA1P/T1_A:diagram
TAG:aarch32/STLEXB/A:execute
address = R[n];
if AArch32.ExclusiveMonitorsPass(address,1) then
    MemO[address, 1] = R[t][7:0];
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STLEXB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 10
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLEXB/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEXB/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:7 _ 1
6:6 _ 1
5:4 _ 00
3:0 Rd xxxx
TAG:aarch32/STLEXB/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  n = UInt(Rn);
if d == 15 || t == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t then UNPREDICTABLE;

TAG:aarch32/STLEXB/A:index
Execute: aarch32/STLEXB/A:execute
Decode: aarch32/STLEXB/A1_A:decode@aarch32/STLEXB/A1_A:diagram
Decode: aarch32/STLEXB/T1_A:decode@aarch32/STLEXB/T1_A:diagram
TAG:aarch32/VCVT_xs/A:execute
CheckAdvSIMDEnabled();
bits(esize) result;
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[m+r],e,esize];
        if to_fixed then
            result = FPToFixed(op1, frac_bits, unsigned, StandardFPSCRValue(),
                               FPRounding_ZERO);
        else
            result = FixedToFP(op1, frac_bits, unsigned, StandardFPSCRValue(),
                               FPRounding_TIEEVEN);
        Elem[D[d+r],e,esize] = result;
TAG:aarch32/VCVT_xs/A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:10 _ 11
9:8 op xx
7:7 _ 0
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VCVT_xs/A1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if op[1] == '0' && !HaveFP16Ext() then UNDEFINED;
if op[1] == '0' && imm6 == '10xxxx' then UNDEFINED;
if imm6 == '0xxxxx' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
to_fixed = (op[0] == '1');  frac_bits = 64 - UInt(imm6);
unsigned = (U == '1');
case op[1] of
     when '0' esize = 16; elements = 4;
     when '1' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVT_xs/T1_A:diagram
T32
31:29 _ 111
28:28 U x
27:23 _ 11111
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:10 _ 11
9:8 op xx
7:7 _ 0
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VCVT_xs/T1_A:decode
if imm6 == '000xxx' then SEE "Related encodings";
if op[1] == '0' && !HaveFP16Ext() then UNDEFINED;
if op[1] == '0' && imm6 == '10xxxx' then UNDEFINED;
if imm6 == '0xxxxx' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
to_fixed = (op[0] == '1');  frac_bits = 64 - UInt(imm6);
unsigned = (U == '1');
case op[1] of
     when '0' esize = 16; elements = 4;
     when '1' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCVT_xs/A:index
Execute: aarch32/VCVT_xs/A:execute
Decode: aarch32/VCVT_xs/A1_A:decode@aarch32/VCVT_xs/A1_A:diagram
Decode: aarch32/VCVT_xs/T1_A:decode@aarch32/VCVT_xs/T1_A:diagram
TAG:aarch32/VLD2_m/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r], e] = MemU[address,ebytes];
        Elem[D[d2+r],e] = MemU[address+ebytes,ebytes];
        address = address + 2*ebytes;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + 16*regs;
TAG:aarch32/VLD2_m/T1A1_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 itype 100x
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD2_m/T1A1_A:decode
regs = 1;  if align == '11' then UNDEFINED;
if size == '11' then UNDEFINED;
inc = if itype == '1001' then 2 else 1;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD2_m/T2A2_A:diagram
A32
31:23 _ 111101000
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:8 _ 0011
7:6 size xx
5:4 align xx
3:0 Rm xxxx
TAG:aarch32/VLD2_m/T2A2_A:decode
regs = 2;  inc = 2;
if size == '11' then UNDEFINED;
alignment = if align == '00' then 1 else 4 << UInt(align);
ebytes = 1 << UInt(size);  elements = 8 DIV ebytes;
d = UInt(D:Vd);  d2 = d + inc;  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d2+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD2_m/A:index
Execute: aarch32/VLD2_m/A:execute
Decode: aarch32/VLD2_m/T1A1_A:decode@aarch32/VLD2_m/T1A1_A:diagram
Decode: aarch32/VLD2_m/T2A2_A:decode@aarch32/VLD2_m/T2A2_A:diagram
Decode: aarch32/VLD2_m/T1A1_A:decode@aarch32/VLD2_m/T1A1_A:diagram
Decode: aarch32/VLD2_m/T2A2_A:decode@aarch32/VLD2_m/T2A2_A:diagram
TAG:aarch32/MSR_r/AS:execute
if write_spsr then
    if PSTATE.M IN {M32_User,M32_System} then
        UNPREDICTABLE;
    else
        SPSRWriteByInstr(R[n], mask);
else
    // Attempts to change to an illegal mode will invoke the Illegal Execution state mechanism
    CPSRWriteByInstr(R[n], mask);
TAG:aarch32/MSR_r/A1_AS:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:22 R x
21:21 _ 1
20:20 _ 0
19:16 mask xxxx
15:12 _ (1)(1)(1)(1)
11:11 _ (0)
10:10 _ (0)
9:9 _ 0
8:8 _ (0)
7:4 _ 0000
3:0 Rn xxxx
TAG:aarch32/MSR_r/A1_AS:decode
n = UInt(Rn);  write_spsr = (R == '1');
if mask == '0000' then UNPREDICTABLE;
if n == 15 then UNPREDICTABLE;

TAG:aarch32/MSR_r/T1_AS:diagram
T32
31:21 _ 11110011100
20:20 R x
19:16 Rn xxxx
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:8 mask xxxx
7:7 _ (0)
6:6 _ (0)
5:5 _ 0
4:4 _ (0)
3:3 _ (0)
2:2 _ (0)
1:1 _ (0)
0:0 _ (0)
TAG:aarch32/MSR_r/T1_AS:decode
n = UInt(Rn);  write_spsr = (R == '1');
if mask == '0000' then UNPREDICTABLE;
if n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MSR_r/AS:index
Execute: aarch32/MSR_r/AS:execute
Decode: aarch32/MSR_r/A1_AS:decode@aarch32/MSR_r/A1_AS:diagram
Decode: aarch32/MSR_r/T1_AS:decode@aarch32/MSR_r/T1_AS:diagram
TAG:aarch32/STLEXD/A:execute
address = R[n];
// Create doubleword to store such that R[t] will be stored at address and R[t2] at address+4.
value = if BigEndian() then R[t]:R[t2] else R[t2]:R[t];
if AArch32.ExclusiveMonitorsPass(address, 8) then
    MemO[address, 8] = value;
    R[d] = ZeroExtend('0');
else
    R[d] = ZeroExtend('1');
TAG:aarch32/STLEXD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 01
20:20 _ 0
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 0
7:4 _ 1001
3:0 Rt xxxx
TAG:aarch32/STLEXD/A1_A:decode
d = UInt(Rd);  t = UInt(Rt);  t2 = t+1;  n = UInt(Rn);
if d == 15 || Rt[0] == '1' || t2 == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t || d == t2 then UNPREDICTABLE;

TAG:aarch32/STLEXD/T1_A:diagram
T32
31:21 _ 11101000110
20:20 _ 0
19:16 Rn xxxx
15:12 Rt xxxx
11:8 Rt2 xxxx
7:7 _ 1
6:6 _ 1
5:4 _ 11
3:0 Rd xxxx
TAG:aarch32/STLEXD/T1_A:decode
d = UInt(Rd);  t = UInt(Rt);  t2 = UInt(Rt2);  n = UInt(Rn);
if d == 15 || t == 15 || t2 == 15 || n == 15 then UNPREDICTABLE;
if d == n || d == t || d == t2 then UNPREDICTABLE;

TAG:aarch32/STLEXD/A:index
Execute: aarch32/STLEXD/A:execute
Decode: aarch32/STLEXD/A1_A:decode@aarch32/STLEXD/A1_A:diagram
Decode: aarch32/STLEXD/T1_A:decode@aarch32/STLEXD/T1_A:diagram
TAG:aarch32/AESMC/A:execute
CheckCryptoEnabled32();
Q[d>>1] = AESMixColumns(Q[m>>1]);
TAG:aarch32/AESMC/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESMC/A1_A:decode
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESMC/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 0111
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/AESMC/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAESExt() then UNDEFINED;
if size != '00' then UNDEFINED;
if Vd[0] == '1' || Vm[0] == '1' then UNDEFINED;
d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/AESMC/A:index
Execute: aarch32/AESMC/A:execute
Decode: aarch32/AESMC/A1_A:decode@aarch32/AESMC/A1_A:diagram
Decode: aarch32/AESMC/T1_A:decode@aarch32/AESMC/T1_A:diagram
TAG:aarch32/TSB/A:execute
TraceSynchronizationBarrier();
TAG:aarch32/TSB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:16 _ 0000
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:0 _ (0)(0)(0)(0)00010010
TAG:aarch32/TSB/A1_A:decode
if !HaveSelfHostedTrace() then EndOfInstruction(); // Instruction executes as NOP
if cond != '1110' then UNPREDICTABLE;              // ESB must be encoded with AL condition

TAG:aarch32/TSB/T1_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 0001
3:0 _ 0010
TAG:aarch32/TSB/T1_A:decode
if !HaveSelfHostedTrace() then EndOfInstruction(); // Instruction executes as NOP
if InITBlock() then UNPREDICTABLE;

TAG:aarch32/TSB/A:index
Execute: aarch32/TSB/A:execute
Decode: aarch32/TSB/A1_A:decode@aarch32/TSB/A1_A:diagram
Decode: aarch32/TSB/T1_A:decode@aarch32/TSB/T1_A:diagram
TAG:aarch32/AND_i/A:execute
result = R[n] AND imm32;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/AND_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 000
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/AND_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/AND_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0000
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/AND_i/T1_A:decode
if Rd == '1111' && S == '1' then SEE "TST (immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/AND_i/A:index
Execute: aarch32/AND_i/A:execute
Decode: aarch32/AND_i/A1_A:decode@aarch32/AND_i/A1_A:diagram
Decode: aarch32/AND_i/T1_A:decode@aarch32/AND_i/T1_A:diagram
TAG:aarch32/UHADD16/A:execute
sum1 = UInt(R[n][15:0]) + UInt(R[m][15:0]);
sum2 = UInt(R[n][31:16]) + UInt(R[m][31:16]);
R[d][15:0]  = sum1[16:1];
R[d][31:16] = sum2[16:1];
TAG:aarch32/UHADD16/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01100
22:20 _ 111
19:16 Rn xxxx
15:12 Rd xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ (1)
8:8 _ (1)
7:7 _ 0
6:5 _ 00
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/UHADD16/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/UHADD16/T1_A:diagram
T32
31:23 _ 111110101
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:7 _ 0
6:6 _ 1
5:5 _ 1
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/UHADD16/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UHADD16/A:index
Execute: aarch32/UHADD16/A:execute
Decode: aarch32/UHADD16/A1_A:decode@aarch32/UHADD16/A1_A:diagram
Decode: aarch32/UHADD16/T1_A:decode@aarch32/UHADD16/T1_A:diagram
TAG:aarch32/SMULBB/A:execute
operand1 = if n_high then R[n][31:16] else R[n][15:0];
operand2 = if m_high then R[m][31:16] else R[m][15:0];
result = SInt(operand1) * SInt(operand2);
R[d] = result[31:0];
// Signed overflow cannot occur
TAG:aarch32/SMULBB/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 11
20:20 _ 0
19:16 Rd xxxx
15:12 _ (0)(0)(0)(0)
11:8 Rm xxxx
7:7 _ 1
6:6 M x
5:5 N x
4:4 _ 0
3:0 Rn xxxx
TAG:aarch32/SMULBB/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
n_high = (N == '1');  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMULBB/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 001
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:5 N x
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMULBB/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);
n_high = (N == '1');  m_high = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMULBB/A:index
Execute: aarch32/SMULBB/A:execute
Decode: aarch32/SMULBB/A1_A:decode@aarch32/SMULBB/A1_A:diagram
Decode: aarch32/SMULBB/T1_A:decode@aarch32/SMULBB/T1_A:diagram
TAG:aarch32/EOR_i/A:execute
result = R[n] EOR imm32;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/EOR_i/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0010
23:21 _ 001
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/EOR_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/EOR_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0100
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/EOR_i/T1_A:decode
if Rd == '1111' && S == '1' then SEE "TEQ (immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if (d == 15 && !setflags) || n == 15 then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/EOR_i/A:index
Execute: aarch32/EOR_i/A:execute
Decode: aarch32/EOR_i/A1_A:decode@aarch32/EOR_i/A1_A:diagram
Decode: aarch32/EOR_i/T1_A:decode@aarch32/EOR_i/T1_A:diagram
TAG:aarch32/CMN_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], shifted, '0');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMN_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 11
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/CMN_rr/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
shift_t = DecodeRegShift(stype);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/CMN_rr/A:index
Execute: aarch32/CMN_rr/A:execute
Decode: aarch32/CMN_rr/A1_A:decode@aarch32/CMN_rr/A1_A:diagram
TAG:aarch32/BFC/A:execute
if msbit >= lsbit then
    R[d][msbit:lsbit] = Replicate('0', msbit-lsbit+1);
    // Other bits of R[d] are unchanged
else
    UNPREDICTABLE;
TAG:aarch32/BFC/A1_A:diagram
A32
31:28 cond xxxx
27:21 _ 0111110
20:16 msb xxxxx
15:12 Rd xxxx
11:7 lsb xxxxx
6:4 _ 001
3:0 _ 1111
TAG:aarch32/BFC/A1_A:decode
d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(lsb);
if d == 15 then UNPREDICTABLE;

TAG:aarch32/BFC/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 01
21:21 _ 1
20:20 _ 0
19:16 _ 1111
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 msb xxxxx
TAG:aarch32/BFC/T1_A:decode
d = UInt(Rd);  msbit = UInt(msb);  lsbit = UInt(imm3:imm2);
if d == 15 then UNPREDICTABLE;  // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/BFC/A:index
Execute: aarch32/BFC/A:execute
Decode: aarch32/BFC/A1_A:decode@aarch32/BFC/A1_A:diagram
Decode: aarch32/BFC/T1_A:decode@aarch32/BFC/T1_A:diagram
TAG:aarch32/VRSQRTS/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = FPRSqrtStep(Elem[D[n+r],e,esize], Elem[D[m+r],e,esize]);
TAG:aarch32/VRSQRTS/A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRSQRTS/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSQRTS/T1_A:diagram
T32
31:29 _ 111
28:28 _ 0
27:23 _ 11110
22:22 D x
21:21 _ 1
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1111
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VRSQRTS/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSQRTS/A:index
Execute: aarch32/VRSQRTS/A:execute
Decode: aarch32/VRSQRTS/A1_A:decode@aarch32/VRSQRTS/A1_A:diagram
Decode: aarch32/VRSQRTS/T1_A:decode@aarch32/VRSQRTS/T1_A:diagram
TAG:aarch32/UBFX/A:execute
msbit = lsbit + widthminus1;
if msbit <= 31 then
    R[d] = ZeroExtend(R[n][msbit:lsbit], 32);
else
    UNPREDICTABLE;
TAG:aarch32/UBFX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01111
22:22 _ 1
21:21 _ 1
20:16 widthm1 xxxxx
15:12 Rd xxxx
11:7 lsb xxxxx
6:4 _ 101
3:0 Rn xxxx
TAG:aarch32/UBFX/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);
lsbit = UInt(lsb);  widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/UBFX/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 11
21:21 _ 0
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 widthm1 xxxxx
TAG:aarch32/UBFX/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);
lsbit = UInt(imm3:imm2);  widthminus1 = UInt(widthm1);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/UBFX/A:index
Execute: aarch32/UBFX/A:execute
Decode: aarch32/UBFX/A1_A:decode@aarch32/UBFX/A1_A:diagram
Decode: aarch32/UBFX/T1_A:decode@aarch32/UBFX/T1_A:diagram
TAG:aarch32/LDRSB_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
R[t] = SignExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
TAG:aarch32/LDRSB_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRSB_r/A1_A:decode
if P == '0' && W == '1' then SEE "LDRSBT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/LDRSB_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 0
26:26 _ 1
25:25 _ 1
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRSB_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/LDRSB_r/T2_A:diagram
T32
31:23 _ 111110010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/LDRSB_r/T2_A:decode
if Rt == '1111' then SEE "PLI";
if Rn == '1111' then SEE "LDRSB (literal)";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSB_r/A:index
Execute: aarch32/LDRSB_r/A:execute
Decode: aarch32/LDRSB_r/A1_A:decode@aarch32/LDRSB_r/A1_A:diagram
Decode: aarch32/LDRSB_r/T1_A:decode@aarch32/LDRSB_r/T1_A:diagram
Decode: aarch32/LDRSB_r/T2_A:decode@aarch32/LDRSB_r/T2_A:diagram
TAG:aarch32/VNEG/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            if floating_point then
                Elem[D[d+r],e,esize] = FPNeg(Elem[D[m+r],e,esize]);
            else
                result = -SInt(Elem[D[m+r],e,esize]);
                Elem[D[d+r],e,esize] = result[esize-1:0];
else             // VFP instruction
    case esize of
        when 16 S[d] = Zeros(16) : FPNeg(S[m][15:0]);
        when 32 S[d] = FPNeg(S[m]);
        when 64 D[d] = FPNeg(D[m]);
TAG:aarch32/VNEG/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 111
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNEG/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
advsimd = TRUE;  floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VNEG/A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNEG/A2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VNEG/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 111
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNEG/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
advsimd = TRUE;  floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VNEG/T2_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 001
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 0
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VNEG/T2_A:decode
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VNEG/A:index
Execute: aarch32/VNEG/A:execute
Decode: aarch32/VNEG/A1_A:decode@aarch32/VNEG/A1_A:diagram
Decode: aarch32/VNEG/A2_A:decode@aarch32/VNEG/A2_A:diagram
Decode: aarch32/VNEG/T1_A:decode@aarch32/VNEG/T1_A:diagram
Decode: aarch32/VNEG/T2_A:decode@aarch32/VNEG/T2_A:diagram
TAG:aarch32/LDRB_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
R[t] = ZeroExtend(MemU[address,1],32);
if wback then R[n] = offset_addr;
TAG:aarch32/LDRB_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 011
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/LDRB_r/A1_A:decode
if P == '0' && W == '1' then SEE "LDRBT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/LDRB_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 1
26:26 _ 1
25:25 _ 0
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRB_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/LDRB_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/LDRB_r/T2_A:decode
if Rt == '1111' then SEE "PLD";
if Rn == '1111' then SEE "LDRB (literal)";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRB_r/A:index
Execute: aarch32/LDRB_r/A:execute
Decode: aarch32/LDRB_r/A1_A:decode@aarch32/LDRB_r/A1_A:diagram
Decode: aarch32/LDRB_r/T1_A:decode@aarch32/LDRB_r/T1_A:diagram
Decode: aarch32/LDRB_r/T2_A:decode@aarch32/LDRB_r/T2_A:diagram
TAG:aarch32/TST_rr/A:execute
shift_n = UInt(R[s][7:0]);
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = R[n] AND shifted;
PSTATE.N = result[31];
PSTATE.Z = IsZeroBit(result);
PSTATE.C = carry;
// PSTATE.V unchanged
TAG:aarch32/TST_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/TST_rr/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
shift_t = DecodeRegShift(stype);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/TST_rr/A:index
Execute: aarch32/TST_rr/A:execute
Decode: aarch32/TST_rr/A1_A:decode@aarch32/TST_rr/A1_A:diagram
TAG:aarch32/RSC_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(NOT(R[n]), shifted, PSTATE.C);
R[d] = result;
if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/RSC_rr/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 0000
23:21 _ 111
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/RSC_rr/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
setflags = (S == '1');  shift_t = DecodeRegShift(stype);
if d == 15 || n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/RSC_rr/A:index
Execute: aarch32/RSC_rr/A:execute
Decode: aarch32/RSC_rr/A1_A:decode@aarch32/RSC_rr/A1_A:diagram
TAG:aarch32/LDRSB_i/A:execute
offset_addr = if add then (R[n] + imm32) else (R[n] - imm32);
address = if index then offset_addr else R[n];
R[t] = SignExtend(MemU[address,1], 32);
if wback then R[n] = offset_addr;
TAG:aarch32/LDRSB_i/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 1
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 imm4H xxxx
7:7 _ 1
6:5 _ 10
4:4 _ 1
3:0 imm4L xxxx
TAG:aarch32/LDRSB_i/A1_A:decode
if Rn == '1111' then SEE "LDRSB (literal)";
if P == '0' && W == '1' then SEE "LDRSBT";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm4H:imm4L, 32);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
if t == 15 || (wback && n == t) then UNPREDICTABLE;

TAG:aarch32/LDRSB_i/T1_A:diagram
T32
31:23 _ 111110011
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/LDRSB_i/T1_A:decode
if Rt == '1111' then SEE "PLI";
if Rn == '1111' then SEE "LDRSB (literal)";
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm12, 32);
index = TRUE;  add = TRUE;  wback = FALSE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSB_i/T2_A:diagram
T32
31:23 _ 111110010
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ 1
10:10 P x
9:9 U x
8:8 W x
7:0 imm8 xxxxxxxx
TAG:aarch32/LDRSB_i/T2_A:decode
if Rt == '1111' && P == '1' && U == '0' && W == '0' then SEE "PLI";
if Rn == '1111' then SEE "LDRSB (literal)";
if P == '1' && U == '1' && W == '0' then SEE "LDRSBT";
if P == '0' && W == '0' then UNDEFINED;
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8, 32);
index = (P == '1');  add = (U == '1');  wback = (W == '1');
if (t == 15 && W == '1') || (wback && n == t) then UNPREDICTABLE;
// Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRSB_i/A:index
Execute: aarch32/LDRSB_i/A:execute
Decode: aarch32/LDRSB_i/A1_A:decode@aarch32/LDRSB_i/A1_A:diagram
Decode: aarch32/LDRSB_i/T1_A:decode@aarch32/LDRSB_i/T1_A:diagram
Decode: aarch32/LDRSB_i/T2_A:decode@aarch32/LDRSB_i/T2_A:diagram
TAG:aarch32/VLD1_a/A:execute
CheckAdvSIMDEnabled();
address = R[n];  iswrite = FALSE;
- = AArch32.CheckAlignment(address, alignment, AccType_VEC, iswrite);
bits(64) replicated_element = Replicate(MemU[address,ebytes]);
for r = 0 to regs-1
    D[d+r] = replicated_element;
if wback then
    if register_index then
        R[n] = R[n] + R[m];
    else
        R[n] = R[n] + ebytes;
TAG:aarch32/VLD1_a/T1A1_A:diagram
A32
31:23 _ 111101001
22:22 D x
21:21 _ 1
20:20 _ 0
19:16 Rn xxxx
15:12 Vd xxxx
11:10 _ 11
9:8 _ 00
7:6 size xx
5:5 T x
4:4 a x
3:0 Rm xxxx
TAG:aarch32/VLD1_a/T1A1_A:decode
if size == '11' || (size == '00' && a == '1') then UNDEFINED;
ebytes = 1 << UInt(size);  regs = if T == '0' then 1 else 2;
alignment = if a == '0' then 1 else ebytes;
d = UInt(D:Vd);  n = UInt(Rn);  m = UInt(Rm);
wback = (m != 15);  register_index = (m != 15 && m != 13);
if n == 15 || d+regs > 32 then UNPREDICTABLE;

TAG:aarch32/VLD1_a/A:index
Execute: aarch32/VLD1_a/A:execute
Decode: aarch32/VLD1_a/T1A1_A:decode@aarch32/VLD1_a/T1A1_A:diagram
Decode: aarch32/VLD1_a/T1A1_A:decode@aarch32/VLD1_a/T1A1_A:diagram
TAG:aarch32/VUSDOT/A:execute
CheckAdvSIMDEnabled();
bits(64) operand1;
bits(64) operand2;
bits(64) result;

for r = 0 to regs-1
    operand1 = Din[n+r];
    operand2 = Din[m+r];
    result = Din[d+r];
    for e = 0 to 1
        bits(32) res = Elem[result, e, 32];
        for b = 0 to 3
            element1 = UInt(Elem[operand1, 4 * e + b, 8]);
            element2 = SInt(Elem[operand2, 4 * e + b, 8]);
            res = res + element1 * element2;
        Elem[result, e, 32] = res;
    D[d+r] = result;
TAG:aarch32/VUSDOT/A1_A:diagram
A32
31:25 _ 1111110
24:23 _ 01
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VUSDOT/A1_A:decode
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VUSDOT/T1_A:diagram
T32
31:25 _ 1111110
24:23 _ 01
22:22 D x
21:20 _ 10
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 1
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VUSDOT/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32Int8MatMulExt() then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = if Q == '1' then 2 else 1;

TAG:aarch32/VUSDOT/A:index
Execute: aarch32/VUSDOT/A:execute
Decode: aarch32/VUSDOT/A1_A:decode@aarch32/VUSDOT/A1_A:diagram
Decode: aarch32/VUSDOT/T1_A:decode@aarch32/VUSDOT/T1_A:diagram
TAG:aarch32/VMVN_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = NOT(D[m+r]);
TAG:aarch32/VMVN_r/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1011
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMVN_r/T1A1_A:decode
if size != '00' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMVN_r/A:index
Execute: aarch32/VMVN_r/A:execute
Decode: aarch32/VMVN_r/T1A1_A:decode@aarch32/VMVN_r/T1A1_A:diagram
Decode: aarch32/VMVN_r/T1A1_A:decode@aarch32/VMVN_r/T1A1_A:diagram
TAG:aarch32/PUSH/A:execute
address = SP - 4*BitCount(registers);
for i = 0 to 14
    if registers[i] == '1' then
        if i == 13 && i != LowestSetBit(registers) then  // Only possible for encoding A1
            MemA[address,4] = bits(32) UNKNOWN;
        else
            if UnalignedAllowed then
                MemU[address,4] = R[i];
            else
                MemA[address,4] = R[i];
        address = address + 4;
if registers[15] == '1' then  // Only possible for encoding A1 or A2
    if UnalignedAllowed then
        MemU[address,4] = PCStoreValue();
    else
        MemA[address,4] = PCStoreValue();
SP = SP - 4*BitCount(registers);
TAG:aarch32/PUSH/T1_A:diagram
T16
31:28 _ 1011
27:27 _ 0
26:25 _ 10
24:24 M x
23:16 register_list xxxxxxxx
15:0 _ 0000000000000000
TAG:aarch32/PUSH/T1_A:decode
registers = '0':M:'000000':register_list;  UnalignedAllowed = FALSE;
if BitCount(registers) < 1 then UNPREDICTABLE;

TAG:aarch32/PUSH/A:index
Execute: aarch32/PUSH/A:execute
Decode: aarch32/PUSH/T1_A:decode@aarch32/PUSH/T1_A:diagram
TAG:aarch32/VMMLA/A:execute
CheckAdvSIMDEnabled();

bits(128) op1 = Q[n>>1];
bits(128) op2 = Q[m>>1];
bits(128) acc = Q[d>>1];

Q[d>>1] = BFMatMulAdd(acc, op1, op2);
TAG:aarch32/VMMLA/A1_A:diagram
A32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMMLA/A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = 2;

TAG:aarch32/VMMLA/T1_A:diagram
T32
31:25 _ 1111110
24:23 _ 00
22:22 D x
21:21 _ 0
20:20 _ 0
19:16 Vn xxxx
15:12 Vd xxxx
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:8 _ 0
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMMLA/T1_A:decode
if InITBlock() then UNPREDICTABLE;
if !HaveAArch32BF16Ext() then UNDEFINED;
if Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
integer d = UInt(D:Vd);
integer n = UInt(N:Vn);
integer m = UInt(M:Vm);
integer regs = 2;

TAG:aarch32/VMMLA/A:index
Execute: aarch32/VMMLA/A:execute
Decode: aarch32/VMMLA/A1_A:decode@aarch32/VMMLA/A1_A:diagram
Decode: aarch32/VMMLA/T1_A:decode@aarch32/VMMLA/T1_A:diagram
TAG:aarch32/DBG/A:execute

TAG:aarch32/DBG/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00110
22:22 _ 0
21:20 _ 10
19:18 _ 00
17:16 _ 00
15:15 _ (1)
14:14 _ (1)
13:13 _ (1)
12:12 _ (1)
11:4 _ (0)(0)(0)(0)1111
3:0 option xxxx
TAG:aarch32/DBG/A1_A:decode
// DBG executes as a NOP. The 'option' field is ignored

TAG:aarch32/DBG/T1_A:diagram
T32
31:20 _ 111100111010
19:19 _ (1)
18:18 _ (1)
17:17 _ (1)
16:16 _ (1)
15:14 _ 10
13:13 _ (0)
12:12 _ 0
11:11 _ (0)
10:8 _ 000
7:4 _ 1111
3:0 option xxxx
TAG:aarch32/DBG/T1_A:decode
// DBG executes as a NOP. The 'option' field is ignored

TAG:aarch32/DBG/A:index
Execute: aarch32/DBG/A:execute
Decode: aarch32/DBG/A1_A:decode@aarch32/DBG/A1_A:diagram
Decode: aarch32/DBG/T1_A:decode@aarch32/DBG/T1_A:diagram
TAG:aarch32/USAT/A:execute
operand = Shift(R[n], shift_t, shift_n, PSTATE.C);  // PSTATE.C ignored
(result, sat) = UnsignedSatQ(SInt(operand), saturate_to);
R[d] = ZeroExtend(result, 32);
if sat then
    PSTATE.Q = '1';
TAG:aarch32/USAT/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01101
22:22 _ 1
21:21 _ 1
20:16 sat_imm xxxxx
15:12 Rd xxxx
11:7 imm5 xxxxx
6:6 sh x
5:4 _ 01
3:0 Rn xxxx
TAG:aarch32/USAT/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
(shift_t, shift_n) = DecodeImmShift(sh:'0', imm5);
if d == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/USAT/T1_A:diagram
T32
31:27 _ 11110
26:26 _ (0)
25:24 _ 11
23:22 _ 10
21:21 sh x
20:20 _ 0
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:5 _ (0)
4:0 sat_imm xxxxx
TAG:aarch32/USAT/T1_A:decode
if sh == '1' && (imm3:imm2) == '00000' then SEE "USAT16";
d = UInt(Rd);  n = UInt(Rn);  saturate_to = UInt(sat_imm);
(shift_t, shift_n) = DecodeImmShift(sh:'0', imm3:imm2);
if d == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/USAT/A:index
Execute: aarch32/USAT/A:execute
Decode: aarch32/USAT/A1_A:decode@aarch32/USAT/A1_A:diagram
Decode: aarch32/USAT/T1_A:decode@aarch32/USAT/T1_A:diagram
TAG:aarch32/SMUSD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 - product2;
R[d] = result[31:0];
// Signed overflow cannot occur
TAG:aarch32/SMUSD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 000
19:16 Rd xxxx
15:12 _ 1111
11:8 Rm xxxx
7:6 _ 01
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMUSD/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE;

TAG:aarch32/SMUSD/T1_A:diagram
T32
31:23 _ 111110110
22:20 _ 100
19:16 Rn xxxx
15:12 _ 1111
11:8 Rd xxxx
7:6 _ 00
5:5 _ 0
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMUSD/T1_A:decode
d = UInt(Rd);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if d == 15 || n == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/SMUSD/A:index
Execute: aarch32/SMUSD/A:execute
Decode: aarch32/SMUSD/A1_A:decode@aarch32/SMUSD/A1_A:diagram
Decode: aarch32/SMUSD/T1_A:decode@aarch32/SMUSD/T1_A:diagram
TAG:aarch32/VABD_i/T2A2_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0111
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABD_i/T2A2_A:decode
if size == '11' then SEE "Related encodings";
if Vd[0] == '1' then UNDEFINED;
unsigned = (U == '1');  long_destination = TRUE;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = 1;

TAG:aarch32/VPADD_i/A:execute
CheckAdvSIMDEnabled();
bits(64) dest;
h = elements DIV 2;

for e = 0 to h-1
    Elem[dest,e,esize]   = Elem[D[n],2*e,esize] + Elem[D[n],2*e+1,esize];
    Elem[dest,e+h,esize] = Elem[D[m],2*e,esize] + Elem[D[m],2*e+1,esize];

D[d] = dest;
TAG:aarch32/VPADD_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VPADD_i/T1A1_A:decode
if size == '11' || Q == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VPADD_i/A:index
Execute: aarch32/VPADD_i/A:execute
Decode: aarch32/VPADD_i/T1A1_A:decode@aarch32/VPADD_i/T1A1_A:diagram
Decode: aarch32/VPADD_i/T1A1_A:decode@aarch32/VPADD_i/T1A1_A:diagram
TAG:aarch32/VCVTT/A:execute
CheckVFPEnabled(TRUE);

S[d][31:16] = FPConvertBF(S[m], FPSCR);
TAG:aarch32/VCVTT/T1A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 011
15:12 Vd xxxx
11:10 _ 10
9:8 _ 01
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCVTT/T1A1_A:decode
if !HaveAArch32BF16Ext() then UNDEFINED;
integer d = UInt(Vd:D);
integer m = UInt(Vm:M);

TAG:aarch32/VCVTT/A:index
Execute: aarch32/VCVTT/A:execute
Decode: aarch32/VCVTT/T1A1_A:decode@aarch32/VCVTT/T1A1_A:diagram
Decode: aarch32/VCVTT/T1A1_A:decode@aarch32/VCVTT/T1A1_A:diagram
TAG:aarch32/VQSUB/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        diff = Int(Elem[D[n+r],e,esize], unsigned) - Int(Elem[D[m+r],e,esize], unsigned);
        (Elem[D[d+r],e,esize], sat) = SatQ(diff, esize, unsigned);
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQSUB/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0010
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQSUB/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQSUB/A:index
Execute: aarch32/VQSUB/A:execute
Decode: aarch32/VQSUB/T1A1_A:decode@aarch32/VQSUB/T1A1_A:diagram
Decode: aarch32/VQSUB/T1A1_A:decode@aarch32/VQSUB/T1A1_A:diagram
TAG:aarch32/VQADD/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        sum = Int(Elem[D[n+r],e,esize], unsigned) + Int(Elem[D[m+r],e,esize], unsigned);
        (Elem[D[d+r],e,esize], sat) = SatQ(sum, esize, unsigned);
        if sat then FPSCR.QC = '1';
TAG:aarch32/VQADD/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0000
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VQADD/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VQADD/A:index
Execute: aarch32/VQADD/A:execute
Decode: aarch32/VQADD/T1A1_A:decode@aarch32/VQADD/T1A1_A:diagram
Decode: aarch32/VQADD/T1A1_A:decode@aarch32/VQADD/T1A1_A:diagram
TAG:aarch32/CMP_rr/A:execute
shift_n = UInt(R[s][7:0]);
shifted = Shift(R[m], shift_t, shift_n, PSTATE.C);
(result, nzcv) = AddWithCarry(R[n], NOT(shifted), '1');
PSTATE.[N,Z,C,V] = nzcv;
TAG:aarch32/CMP_rr/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00010
22:21 _ 10
20:20 _ 1
19:16 Rn xxxx
15:15 _ (0)
14:14 _ (0)
13:13 _ (0)
12:12 _ (0)
11:8 Rs xxxx
7:7 _ 0
6:5 stype xx
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/CMP_rr/A1_A:decode
n = UInt(Rn);  m = UInt(Rm);  s = UInt(Rs);
shift_t = DecodeRegShift(stype);
if n == 15 || m == 15 || s == 15 then UNPREDICTABLE;

TAG:aarch32/CMP_rr/A:index
Execute: aarch32/CMP_rr/A:execute
Decode: aarch32/CMP_rr/A1_A:decode@aarch32/CMP_rr/A1_A:diagram
TAG:aarch32/VDIV/A:execute
CheckVFPEnabled(TRUE);
case esize of
    when 16
        S[d] = Zeros(16) : FPDiv(S[n][15:0], S[m][15:0], FPSCR);
    when 32
        S[d] = FPDiv(S[n], S[m], FPSCR);
    when 64
        D[d] = FPDiv(D[n], D[m], FPSCR);
TAG:aarch32/VDIV/A1_A:diagram
A32
31:28 cond xxxx
27:24 _ 1110
23:23 _ 1
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDIV/A1_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VDIV/T1_A:diagram
T32
31:24 _ 11101110
23:23 _ 1
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VDIV/T1_A:decode
if size == '01' && InITBlock()  then UNPREDICTABLE;
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
case size of
    when '01' esize = 16; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); n = UInt(Vn:N); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); n = UInt(N:Vn); m = UInt(M:Vm);

TAG:aarch32/VDIV/A:index
Execute: aarch32/VDIV/A:execute
Decode: aarch32/VDIV/A1_A:decode@aarch32/VDIV/A1_A:diagram
Decode: aarch32/VDIV/T1_A:decode@aarch32/VDIV/T1_A:diagram
TAG:aarch32/VMOV_i/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if single_register then
    S[d] = imm32;
else
    for r = 0 to regs-1
        D[d+r] = imm64;
TAG:aarch32/VMOV_i/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 0xx0
7:7 _ 0
6:6 Q x
5:5 op 0
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMOV_i/T1A1_A:decode
if op == '0' && cmode[0] == '1' && cmode[3:2] != '11' then SEE "VORR (immediate)";
if op == '1' && cmode != '1110' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMOV_i/A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:16 imm4H xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ (0)
6:6 _ 0
5:5 _ (0)
4:4 _ 0
3:0 imm4L xxxx
TAG:aarch32/VMOV_i/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
single_register = (size != '11'); advsimd = FALSE;
bits(16) imm16;
bits(32) imm32;
bits(64) imm64;
case size of
    when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
    when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
    when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

TAG:aarch32/VMOV_i/T3A3_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 10x0
7:7 _ 0
6:6 Q x
5:5 op 0
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMOV_i/T3A3_A:decode
if op == '0' && cmode[0] == '1' && cmode[3:2] != '11' then SEE "VORR (immediate)";
if op == '1' && cmode != '1110' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMOV_i/T4A4_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 11xx
7:7 _ 0
6:6 Q x
5:5 op 0
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMOV_i/T4A4_A:decode
if op == '0' && cmode[0] == '1' && cmode[3:2] != '11' then SEE "VORR (immediate)";
if op == '1' && cmode != '1110' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMOV_i/T5A5_A:diagram
A32
31:25 _ 1111001
24:24 i x
23:23 _ 1
22:22 D x
21:19 _ 000
18:16 imm3 xxx
15:12 Vd xxxx
11:8 cmode 1110
7:7 _ 0
6:6 Q x
5:5 op 1
4:4 _ 1
3:0 imm4 xxxx
TAG:aarch32/VMOV_i/T5A5_A:decode
if op == '0' && cmode[0] == '1' && cmode[3:2] != '11' then SEE "VORR (immediate)";
if op == '1' && cmode != '1110' then SEE "Related encodings";
if Q == '1' && Vd[0] == '1' then UNDEFINED;
single_register = FALSE;  advsimd = TRUE;  imm64 = AdvSIMDExpandImm(op, cmode, i:imm3:imm4);
d = UInt(D:Vd);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VMOV_i/T2_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:16 imm4H xxxx
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ (0)
6:6 _ 0
5:5 _ (0)
4:4 _ 0
3:0 imm4L xxxx
TAG:aarch32/VMOV_i/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
single_register = (size != '11'); advsimd = FALSE;
bits(16) imm16;
bits(32) imm32;
bits(64) imm64;
case size of
    when '01' d = UInt(Vd:D);  imm16 = VFPExpandImm(imm4H:imm4L); imm32 = Zeros(16) : imm16;
    when '10' d = UInt(Vd:D);  imm32 = VFPExpandImm(imm4H:imm4L);
    when '11' d = UInt(D:Vd);  imm64 = VFPExpandImm(imm4H:imm4L);  regs = 1;

TAG:aarch32/VMOV_i/A:index
Execute: aarch32/VMOV_i/A:execute
Decode: aarch32/VMOV_i/T1A1_A:decode@aarch32/VMOV_i/T1A1_A:diagram
Decode: aarch32/VMOV_i/A2_A:decode@aarch32/VMOV_i/A2_A:diagram
Decode: aarch32/VMOV_i/T3A3_A:decode@aarch32/VMOV_i/T3A3_A:diagram
Decode: aarch32/VMOV_i/T4A4_A:decode@aarch32/VMOV_i/T4A4_A:diagram
Decode: aarch32/VMOV_i/T5A5_A:decode@aarch32/VMOV_i/T5A5_A:diagram
Decode: aarch32/VMOV_i/T1A1_A:decode@aarch32/VMOV_i/T1A1_A:diagram
Decode: aarch32/VMOV_i/T2_A:decode@aarch32/VMOV_i/T2_A:diagram
Decode: aarch32/VMOV_i/T3A3_A:decode@aarch32/VMOV_i/T3A3_A:diagram
Decode: aarch32/VMOV_i/T4A4_A:decode@aarch32/VMOV_i/T4A4_A:diagram
Decode: aarch32/VMOV_i/T5A5_A:decode@aarch32/VMOV_i/T5A5_A:diagram
TAG:aarch32/VMUL_s/A1_A:diagram
A32
31:25 _ 1111001
24:24 Q x
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:9 _ 100
8:8 F x
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_s/A1_A:decode
if size == '11' then SEE "Related encodings";
if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
floating_point = (F == '1');  long_destination = FALSE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VMUL_s/T1_A:diagram
T32
31:29 _ 111
28:28 Q x
27:23 _ 11111
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:9 _ 100
8:8 F x
7:7 N x
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VMUL_s/T1_A:decode
if size == '11' then SEE "Related encodings";
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if size == '00' || (F == '1' && size == '01' && !HaveFP16Ext()) then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = FALSE;  // "Don't care" value: TRUE produces same functionality
floating_point = (F == '1');  long_destination = FALSE;
d = UInt(D:Vd);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;
if size == '01' then esize = 16;  elements = 4;  m = UInt(Vm[2:0]);  index = UInt(M:Vm[3]);
if size == '10' then esize = 32;  elements = 2;  m = UInt(Vm);  index = UInt(M);

TAG:aarch32/VRSQRTE/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if floating_point then
            Elem[D[d+r],e,esize] = FPRSqrtEstimate(Elem[D[m+r],e,esize], StandardFPSCRValue());
        else
            Elem[D[d+r],e,esize] = UnsignedRSqrtEstimate(Elem[D[m+r],e,esize]);
TAG:aarch32/VRSQRTE/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 10
8:8 F x
7:7 _ 1
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRSQRTE/A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
floating_point = (F == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSQRTE/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 11
15:12 Vd xxxx
11:11 _ 0
10:9 _ 10
8:8 F x
7:7 _ 1
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VRSQRTE/T1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
if (size == '01' && !HaveFP16Ext()) || size IN {'00', '11'} then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
floating_point = (F == '1');
case size of
    when '01' esize = 16; elements = 4;
    when '10' esize = 32; elements = 2;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VRSQRTE/A:index
Execute: aarch32/VRSQRTE/A:execute
Decode: aarch32/VRSQRTE/A1_A:decode@aarch32/VRSQRTE/A1_A:diagram
Decode: aarch32/VRSQRTE/T1_A:decode@aarch32/VRSQRTE/T1_A:diagram
TAG:aarch32/VADDHN/A:execute
CheckAdvSIMDEnabled();
for e = 0 to elements-1
    result = Elem[Qin[n>>1],e,2*esize] + Elem[Qin[m>>1],e,2*esize];
    Elem[D[d],e,esize] = result[2*esize-1:esize];
TAG:aarch32/VADDHN/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 1
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0100
7:7 N x
6:6 _ 0
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VADDHN/T1A1_A:decode
if size == '11' then SEE "Related encodings";
if Vn[0] == '1' || Vm[0] == '1' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);

TAG:aarch32/VADDHN/A:index
Execute: aarch32/VADDHN/A:execute
Decode: aarch32/VADDHN/T1A1_A:decode@aarch32/VADDHN/T1A1_A:diagram
Decode: aarch32/VADDHN/T1A1_A:decode@aarch32/VADDHN/T1A1_A:diagram
TAG:aarch32/MVN_r/A:execute
(shifted, carry) = Shift_C(R[m], shift_t, shift_n, PSTATE.C);
result = NOT(shifted);
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/MVN_r/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 11
20:20 S x
19:16 _ (0)(0)(0)(0)
15:12 Rd xxxx
11:7 imm5 xxxxx
6:5 stype xx
4:4 _ 0
3:0 Rm xxxx
TAG:aarch32/MVN_r/A1_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm5);

TAG:aarch32/MVN_r/T1_A:diagram
T16
31:26 _ 010000
25:22 _ 1111
21:19 Rm xxx
18:16 Rd xxx
15:0 _ 0000000000000000
TAG:aarch32/MVN_r/T1_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = !InITBlock();
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/MVN_r/T2_A:diagram
T32
31:25 _ 1110101
24:21 _ 0011
20:20 S x
19:16 _ 1111
15:15 _ (0)
14:12 imm3 xxx
11:8 Rd xxxx
7:6 imm2 xx
5:4 stype xx
3:0 Rm xxxx
TAG:aarch32/MVN_r/T2_A:decode
d = UInt(Rd);  m = UInt(Rm);  setflags = (S == '1');
(shift_t, shift_n) = DecodeImmShift(stype, imm3:imm2);
if d == 15 || m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/MVN_r/A:index
Execute: aarch32/MVN_r/A:execute
Decode: aarch32/MVN_r/A1_A:decode@aarch32/MVN_r/A1_A:diagram
Decode: aarch32/MVN_r/T1_A:decode@aarch32/MVN_r/T1_A:diagram
Decode: aarch32/MVN_r/T2_A:decode@aarch32/MVN_r/T2_A:diagram
TAG:aarch32/VABS/A:execute
CheckAdvSIMDOrVFPEnabled(TRUE, advsimd);
if advsimd then  // Advanced SIMD instruction
    for r = 0 to regs-1
        for e = 0 to elements-1
            if floating_point then
                Elem[D[d+r],e,esize] = FPAbs(Elem[D[m+r],e,esize]);
            else
                result = Abs(SInt(Elem[D[m+r],e,esize]));
                Elem[D[d+r],e,esize] = result[esize-1:0];
else             // VFP instruction
    case esize of
        when 16 S[d] = Zeros(16) : FPAbs(S[m][15:0]);
        when 32 S[d] = FPAbs(S[m]);
        when 64 D[d] = FPAbs(D[m]);
TAG:aarch32/VABS/A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 110
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABS/A1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
advsimd = TRUE;  floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VABS/A2_A:diagram
A32
31:28 cond xxxx
27:23 _ 11101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 000
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABS/A2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && cond != '1110' then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VABS/T1_A:diagram
T32
31:23 _ 111111111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 01
15:12 Vd xxxx
11:11 _ 0
10:10 F x
9:7 _ 110
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABS/T1_A:decode
if size == '11' then UNDEFINED;
if F == '1' && ((size == '01' && !HaveFP16Ext()) || size == '00') then UNDEFINED;
if F == '1' && size == '01' && InITBlock() then UNPREDICTABLE;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
advsimd = TRUE;  floating_point = (F == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VABS/T2_A:diagram
T32
31:23 _ 111011101
22:22 D x
21:20 _ 11
19:19 _ 0
18:16 _ 000
15:12 Vd xxxx
11:10 _ 10
9:8 size xx
7:7 _ 1
6:6 _ 1
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VABS/T2_A:decode
if FPSCR.Len != '000' || FPSCR.Stride != '00' then UNDEFINED;
if size == '00' || (size == '01' && !HaveFP16Ext()) then UNDEFINED;
if size == '01' && InITBlock()  then UNPREDICTABLE;
advsimd = FALSE;
case size of
    when '01' esize = 16; d = UInt(Vd:D); m = UInt(Vm:M);
    when '10' esize = 32; d = UInt(Vd:D); m = UInt(Vm:M);
    when '11' esize = 64; d = UInt(D:Vd); m = UInt(M:Vm);

TAG:aarch32/VABS/A:index
Execute: aarch32/VABS/A:execute
Decode: aarch32/VABS/A1_A:decode@aarch32/VABS/A1_A:diagram
Decode: aarch32/VABS/A2_A:decode@aarch32/VABS/A2_A:diagram
Decode: aarch32/VABS/T1_A:decode@aarch32/VABS/T1_A:diagram
Decode: aarch32/VABS/T2_A:decode@aarch32/VABS/T2_A:diagram
TAG:aarch32/VCGE_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        op1 = Elem[D[n+r],e,esize];  op2 = Elem[D[m+r],e,esize];
        case vtype of
            when VCGEtype_signed    test_passed = (SInt(op1) >= SInt(op2));
            when VCGEtype_unsigned  test_passed = (UInt(op1) >= UInt(op2));
            when VCGEtype_fp        test_passed = FPCompareGE(op1, op2, StandardFPSCRValue());
        Elem[D[d+r],e,esize] = if test_passed then Ones(esize) else Zeros(esize);
TAG:aarch32/VCGE_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0011
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VCGE_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
vtype = if U == '1' then VCGEtype_unsigned else VCGEtype_signed;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGE_r/A2_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGE_r/A2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
vtype = VCGEtype_fp;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGE_r/T2_A:diagram
T32
31:29 _ 111
28:28 _ 1
27:23 _ 11110
22:22 D x
21:21 _ 0
20:20 sz x
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1110
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCGE_r/T2_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if sz == '1' && !HaveFP16Ext() then UNDEFINED;
if sz == '1' && InITBlock() then UNPREDICTABLE;
vtype = VCGEtype_fp;
case sz of
    when '0' esize = 32; elements = 2;
    when '1' esize = 16; elements = 4;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCGE_r/A:index
Execute: aarch32/VCGE_r/A:execute
Decode: aarch32/VCGE_r/T1A1_A:decode@aarch32/VCGE_r/T1A1_A:diagram
Decode: aarch32/VCGE_r/A2_A:decode@aarch32/VCGE_r/A2_A:diagram
Decode: aarch32/VCGE_r/T1A1_A:decode@aarch32/VCGE_r/T1A1_A:diagram
Decode: aarch32/VCGE_r/T2_A:decode@aarch32/VCGE_r/T2_A:diagram
TAG:aarch32/LDC_l/A:execute
offset_addr = if add then (Align(PC,4) + imm32) else (Align(PC,4) - imm32);
address = if index then offset_addr else Align(PC,4);

// System register write to DBGDTRTXint.
DBGDTR_EL0[] = MemA[address,4];
TAG:aarch32/LDC_l/T1A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 110
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 _ 1111
15:12 _ 0101
11:9 _ 111
8:8 _ 0
7:0 imm8 xxxxxxxx
TAG:aarch32/LDC_l/T1A1_A:decode
if P == '0' && U == '0' && W == '0' then UNDEFINED;
index = (P == '1');  add = (U == '1');  cp = 14;  imm32 = ZeroExtend(imm8:'00', 32);
if W == '1' || (P == '0' && CurrentInstrSet() != InstrSet_A32) then UNPREDICTABLE;

TAG:aarch32/LDC_l/A:index
Execute: aarch32/LDC_l/A:execute
Decode: aarch32/LDC_l/T1A1_A:decode@aarch32/LDC_l/T1A1_A:diagram
Decode: aarch32/LDC_l/T1A1_A:decode@aarch32/LDC_l/T1A1_A:diagram
TAG:aarch32/VSRI/A:execute
CheckAdvSIMDEnabled();
mask = LSR(Ones(esize), shift_amount);
for r = 0 to regs-1
    for e = 0 to elements-1
        shifted_op = LSR(Elem[D[m+r],e,esize], shift_amount);
        Elem[D[d+r],e,esize] = (Elem[D[d+r],e,esize] AND NOT(mask)) OR shifted_op;
TAG:aarch32/VSRI/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 1
22:22 D x
21:16 imm6 xxxxxx
15:12 Vd xxxx
11:8 _ 0100
7:7 L x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VSRI/T1A1_A:decode
if (L:imm6) == '0000xxx' then SEE "Related encodings";
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
case L:imm6 of
    when '0001xxx'  esize = 8;  elements = 8;  shift_amount = 16 - UInt(imm6);
    when '001xxxx'  esize = 16;  elements = 4;  shift_amount = 32 - UInt(imm6);
    when '01xxxxx'  esize = 32;  elements = 2;  shift_amount = 64 - UInt(imm6);
    when '1xxxxxx'  esize = 64;  elements = 1;  shift_amount = 64 - UInt(imm6);
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSRI/A:index
Execute: aarch32/VSRI/A:execute
Decode: aarch32/VSRI/T1A1_A:decode@aarch32/VSRI/T1A1_A:diagram
Decode: aarch32/VSRI/T1A1_A:decode@aarch32/VSRI/T1A1_A:diagram
TAG:aarch32/LDREX/A:execute
address = R[n] + imm32;
AArch32.SetExclusiveMonitors(address,4);
R[t] = MemA[address,4];
TAG:aarch32/LDREX/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00011
22:21 _ 00
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (1)
10:10 _ (1)
9:9 _ 1
8:8 _ 1
7:4 _ 1001
3:0 _ (1)(1)(1)(1)
TAG:aarch32/LDREX/A1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = Zeros(32); // Zero offset
if t == 15 || n == 15 then UNPREDICTABLE;

TAG:aarch32/LDREX/T1_A:diagram
T32
31:21 _ 11101000010
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:8 _ (1)(1)(1)(1)
7:0 imm8 xxxxxxxx
TAG:aarch32/LDREX/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  imm32 = ZeroExtend(imm8:'00', 32);
if t == 15 || n == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDREX/A:index
Execute: aarch32/LDREX/A:execute
Decode: aarch32/LDREX/A1_A:decode@aarch32/LDREX/A1_A:diagram
Decode: aarch32/LDREX/T1_A:decode@aarch32/LDREX/T1_A:diagram
TAG:aarch32/VCLZ/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        Elem[D[d+r],e,esize] = CountLeadingZeroBits(Elem[D[m+r],e,esize])[esize-1:0];
TAG:aarch32/VCLZ/T1A1_A:diagram
A32
31:23 _ 111100111
22:22 D x
21:20 _ 11
19:18 size xx
17:16 _ 00
15:12 Vd xxxx
11:11 _ 0
10:7 _ 1001
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VCLZ/T1A1_A:decode
if size == '11' then UNDEFINED;
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1') then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VCLZ/A:index
Execute: aarch32/VCLZ/A:execute
Decode: aarch32/VCLZ/T1A1_A:decode@aarch32/VCLZ/T1A1_A:diagram
Decode: aarch32/VCLZ/T1A1_A:decode@aarch32/VCLZ/T1A1_A:diagram
TAG:aarch32/VSHL_r/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        shift = SInt(Elem[D[n+r],e,esize][7:0]);
        result = Int(Elem[D[m+r],e,esize], unsigned) << shift;
        Elem[D[d+r],e,esize] = result[esize-1:0];
TAG:aarch32/VSHL_r/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 U x
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0100
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 0
3:0 Vm xxxx
TAG:aarch32/VSHL_r/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vm[0] == '1' || Vn[0] == '1') then UNDEFINED;
unsigned = (U == '1');
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  m = UInt(M:Vm);  n = UInt(N:Vn);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VSHL_r/A:index
Execute: aarch32/VSHL_r/A:execute
Decode: aarch32/VSHL_r/T1A1_A:decode@aarch32/VSHL_r/T1A1_A:diagram
Decode: aarch32/VSHL_r/T1A1_A:decode@aarch32/VSHL_r/T1A1_A:diagram
TAG:aarch32/SMLSLD/A:execute
operand2 = if m_swap then ROR(R[m],16) else R[m];
product1 = SInt(R[n][15:0]) * SInt(operand2[15:0]);
product2 = SInt(R[n][31:16]) * SInt(operand2[31:16]);
result = product1 - product2 + SInt(R[dHi]:R[dLo]);
R[dHi] = result[63:32];
R[dLo] = result[31:0];
TAG:aarch32/SMLSLD/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 01110
22:20 _ 100
19:16 RdHi xxxx
15:12 RdLo xxxx
11:8 Rm xxxx
7:6 _ 01
5:5 M x
4:4 _ 1
3:0 Rn xxxx
TAG:aarch32/SMLSLD/A1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLSLD/T1_A:diagram
T32
31:23 _ 111110111
22:20 _ 101
19:16 Rn xxxx
15:12 RdLo xxxx
11:8 RdHi xxxx
7:5 _ 110
4:4 M x
3:0 Rm xxxx
TAG:aarch32/SMLSLD/T1_A:decode
dLo = UInt(RdLo);  dHi = UInt(RdHi);  n = UInt(Rn);  m = UInt(Rm);  m_swap = (M == '1');
if dLo == 15 || dHi == 15 || n == 15 || m == 15 then UNPREDICTABLE;
// Armv8-A removes UPREDICTABLE for R13
if dHi == dLo then UNPREDICTABLE;

TAG:aarch32/SMLSLD/A:index
Execute: aarch32/SMLSLD/A:execute
Decode: aarch32/SMLSLD/A1_A:decode@aarch32/SMLSLD/A1_A:diagram
Decode: aarch32/SMLSLD/T1_A:decode@aarch32/SMLSLD/T1_A:diagram
TAG:aarch32/VTST/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    for e = 0 to elements-1
        if !IsZero(Elem[D[n+r],e,esize] AND Elem[D[m+r],e,esize]) then
            Elem[D[d+r],e,esize] = Ones(esize);
        else
            Elem[D[d+r],e,esize] = Zeros(esize);
TAG:aarch32/VTST/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 0
23:23 _ 0
22:22 D x
21:20 size xx
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 1000
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VTST/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
if size == '11' then UNDEFINED;
esize = 8 << UInt(size);  elements = 64 DIV esize;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VTST/A:index
Execute: aarch32/VTST/A:execute
Decode: aarch32/VTST/T1A1_A:decode@aarch32/VTST/T1A1_A:diagram
Decode: aarch32/VTST/T1A1_A:decode@aarch32/VTST/T1A1_A:diagram
TAG:aarch32/LDRH_r/A:execute
offset = Shift(R[m], shift_t, shift_n, PSTATE.C);
offset_addr = if add then (R[n] + offset) else (R[n] - offset);
address = if index then offset_addr else R[n];
data = MemU[address,2];
if wback then R[n] = offset_addr;
R[t] = ZeroExtend(data, 32);
TAG:aarch32/LDRH_r/A1_A:diagram
A32
31:28 cond xxxx
27:25 _ 000
24:24 P x
23:23 U x
22:22 _ 0
21:21 W x
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:11 _ (0)
10:10 _ (0)
9:9 _ (0)
8:8 _ (0)
7:7 _ 1
6:5 _ 01
4:4 _ 1
3:0 Rm xxxx
TAG:aarch32/LDRH_r/A1_A:decode
if P == '0' && W == '1' then SEE "LDRHT";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = (P == '1');  add = (U == '1');  wback = (P == '0') || (W == '1');
(shift_t, shift_n) = (SRType_LSL, 0);
if t == 15 || m == 15 then UNPREDICTABLE;
if wback && (n == 15 || n == t) then UNPREDICTABLE;

TAG:aarch32/LDRH_r/T1_A:diagram
T16
31:28 _ 0101
27:27 _ 1
26:26 _ 0
25:25 _ 1
24:22 Rm xxx
21:19 Rn xxx
18:16 Rt xxx
15:0 _ 0000000000000000
TAG:aarch32/LDRH_r/T1_A:decode
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, 0);

TAG:aarch32/LDRH_r/T2_A:diagram
T32
31:23 _ 111110000
22:21 _ 01
20:20 _ 1
19:16 Rn xxxx
15:12 Rt xxxx
11:6 _ 000000
5:4 imm2 xx
3:0 Rm xxxx
TAG:aarch32/LDRH_r/T2_A:decode
if Rn == '1111' then SEE "LDRH (literal)";
if Rt == '1111' then SEE "PLDW (register)";
t = UInt(Rt);  n = UInt(Rn);  m = UInt(Rm);
index = TRUE;  add = TRUE;  wback = FALSE;
(shift_t, shift_n) = (SRType_LSL, UInt(imm2));
if m == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/LDRH_r/A:index
Execute: aarch32/LDRH_r/A:execute
Decode: aarch32/LDRH_r/A1_A:decode@aarch32/LDRH_r/A1_A:diagram
Decode: aarch32/LDRH_r/T1_A:decode@aarch32/LDRH_r/T1_A:diagram
Decode: aarch32/LDRH_r/T2_A:decode@aarch32/LDRH_r/T2_A:diagram
TAG:aarch32/VEOR/A:execute
CheckAdvSIMDEnabled();
for r = 0 to regs-1
    D[d+r] = D[n+r] EOR D[m+r];
TAG:aarch32/VEOR/T1A1_A:diagram
A32
31:25 _ 1111001
24:24 _ 1
23:23 _ 0
22:22 D x
21:20 _ 00
19:16 Vn xxxx
15:12 Vd xxxx
11:8 _ 0001
7:7 N x
6:6 Q x
5:5 M x
4:4 _ 1
3:0 Vm xxxx
TAG:aarch32/VEOR/T1A1_A:decode
if Q == '1' && (Vd[0] == '1' || Vn[0] == '1' || Vm[0] == '1') then UNDEFINED;
d = UInt(D:Vd);  n = UInt(N:Vn);  m = UInt(M:Vm);  regs = if Q == '0' then 1 else 2;

TAG:aarch32/VEOR/A:index
Execute: aarch32/VEOR/A:execute
Decode: aarch32/VEOR/T1A1_A:decode@aarch32/VEOR/T1A1_A:diagram
Decode: aarch32/VEOR/T1A1_A:decode@aarch32/VEOR/T1A1_A:diagram
TAG:aarch32/ORR_i/A:execute
result = R[n] OR imm32;
if d == 15 then          // Can only occur for A32 encoding
    if setflags then
        ALUExceptionReturn(result);
    else
        ALUWritePC(result);
else
    R[d] = result;
    if setflags then
        PSTATE.N = result[31];
        PSTATE.Z = IsZeroBit(result);
        PSTATE.C = carry;
        // PSTATE.V unchanged
TAG:aarch32/ORR_i/A1_A:diagram
A32
31:28 cond xxxx
27:23 _ 00111
22:21 _ 00
20:20 S x
19:16 Rn xxxx
15:12 Rd xxxx
11:0 imm12 xxxxxxxxxxxx
TAG:aarch32/ORR_i/A1_A:decode
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = A32ExpandImm_C(imm12, PSTATE.C);

TAG:aarch32/ORR_i/T1_A:diagram
T32
31:27 _ 11110
26:26 i x
25:25 _ 0
24:21 _ 0010
20:20 S x
19:16 Rn xxxx
15:15 _ 0
14:12 imm3 xxx
11:8 Rd xxxx
7:0 imm8 xxxxxxxx
TAG:aarch32/ORR_i/T1_A:decode
if Rn == '1111' then SEE "MOV (immediate)";
d = UInt(Rd);  n = UInt(Rn);  setflags = (S == '1');
(imm32, carry) = T32ExpandImm_C(i:imm3:imm8, PSTATE.C);
if d == 15 then UNPREDICTABLE; // Armv8-A removes UNPREDICTABLE for R13

TAG:aarch32/ORR_i/A:index
Execute: aarch32/ORR_i/A:execute
Decode: aarch32/ORR_i/A1_A:decode@aarch32/ORR_i/A1_A:diagram
Decode: aarch32/ORR_i/T1_A:decode@aarch32/ORR_i/T1_A:diagram
TAG:aarch64/vector/arithmetic/unary/rbit:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;
bits(esize) rev;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    for i = 0 to esize-1
        rev[esize-1-i] = element[i];
    Elem[result, e, esize] = rev;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/rbit:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 _ 01
21:17 _ 10000
16:12 _ 00101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/rbit:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;

TAG:aarch64/vector/arithmetic/unary/rbit:index
Execute: aarch64/vector/arithmetic/unary/rbit:execute
Decode: aarch64/instrs/vector/arithmetic/unary/rbit:decode@aarch64/instrs/vector/arithmetic/unary/rbit:diagram
TAG:LD3H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:LD3H-Z.P.BI-Contiguous:index
Execute: LD3H-Z.P.BI-Contiguous:execute
Decode: LD3H-Z.P.BI-Contiguous:decode@LD3H-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/arithmetic/unary/clsz:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

integer count;
for e = 0 to elements-1
    if countop == CountOp_CLS then
        count = CountLeadingSignBits(Elem[operand, e, esize]);
    else
        count = CountLeadingZeroBits(Elem[operand, e, esize]);
    Elem[result, e, esize] = count[esize-1:0];
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/clsz:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 00100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/clsz:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;

TAG:aarch64/vector/arithmetic/unary/clsz:index
Execute: aarch64/vector/arithmetic/unary/clsz:execute
Decode: aarch64/instrs/vector/arithmetic/unary/clsz:decode@aarch64/instrs/vector/arithmetic/unary/clsz:diagram
TAG:PFIRST-P.P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) result = P[dn];
integer first = -1;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' && first == -1 then
        first = e;

if first >= 0 then
    ElemP[result, first, esize] = '1';

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[dn] = result;
TAG:PFIRST-P.P.P-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:10 _ 011000110000
9:9 _ 0
8:5 Pg xxxx
4:4 _ 0
3:0 Pdn xxxx
TAG:PFIRST-P.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer dn = UInt(Pdn);

TAG:PFIRST-P.P.P-_:index
Execute: PFIRST-P.P.P-_:execute
Decode: PFIRST-P.P.P-_:decode@PFIRST-P.P.P-_:diagram
TAG:aarch64/vector/logical:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand;
bits(datasize) result;

case operation of
    when ImmediateOp_MOVI
        result = imm;
    when ImmediateOp_MVNI
        result = NOT(imm);
    when ImmediateOp_ORR
        operand = V[rd];
        result = operand OR imm;
    when ImmediateOp_BIC
        operand = V[rd];
        result = operand AND NOT(imm);

V[rd] = result;
TAG:aarch64/instrs/vector/logical:diagram
A64
31:31 _ 0
30:30 Q x
29:29 op x
28:19 _ 0111100000
18:18 a x
17:17 b x
16:16 c x
15:12 cmode xxxx
11:11 _ 0
10:10 _ 1
9:9 d x
8:8 e x
7:7 f x
6:6 g x
5:5 h x
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/logical:decode
integer rd = UInt(Rd);

integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;
bits(64) imm64;

ImmediateOp operation;
case cmode:op of
    when '0xx00' operation = ImmediateOp_MOVI;
    when '0xx01' operation = ImmediateOp_MVNI;
    when '0xx10' operation = ImmediateOp_ORR;
    when '0xx11' operation = ImmediateOp_BIC;
    when '10x00' operation = ImmediateOp_MOVI;
    when '10x01' operation = ImmediateOp_MVNI;
    when '10x10' operation = ImmediateOp_ORR;
    when '10x11' operation = ImmediateOp_BIC;
    when '110x0' operation = ImmediateOp_MOVI;
    when '110x1' operation = ImmediateOp_MVNI;
    when '1110x' operation = ImmediateOp_MOVI;
    when '11110' operation = ImmediateOp_MOVI;
    when '11111' 
        // FMOV Dn,#imm is in main FP instruction set
        if Q == '0' then UNDEFINED;
        operation = ImmediateOp_MOVI;

imm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);
imm = Replicate(imm64, datasize DIV 64);

TAG:aarch64/vector/logical:index
Execute: aarch64/vector/logical:execute
Decode: aarch64/instrs/vector/logical:decode@aarch64/instrs/vector/logical:diagram
TAG:aarch64/vector/transfer/integer/move/unsigned:execute
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];

X[d] = ZeroExtend(Elem[operand, index, esize], datasize);
TAG:aarch64/instrs/vector/transfer/integer/move/unsigned:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:13 _ 01
12:12 _ 1
11:11 _ 1
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/integer/move/unsigned:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size;
case Q:imm5 of
    when '0xxxx1' size = 0;     // UMOV Wd, Vn.B
    when '0xxx10' size = 1;     // UMOV Wd, Vn.H
    when '0xx100' size = 2;     // UMOV Wd, Vn.S
    when '1x1000' size = 3;     // UMOV Xd, Vn.D
    otherwise     UNDEFINED;

integer idxdsize = if imm5[4] == '1' then 128 else 64;
integer index = UInt(imm5[4:size+1]);
integer esize = 8 << size;
integer datasize = if Q == '1' then 64 else 32;

TAG:aarch64/vector/transfer/integer/move/unsigned:index
Execute: aarch64/vector/transfer/integer/move/unsigned:execute
Decode: aarch64/instrs/vector/transfer/integer/move/unsigned:decode@aarch64/instrs/vector/transfer/integer/move/unsigned:diagram
TAG:aarch64/memory/single/general/immediate/signed/offset/normal:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/immediate/signed/offset/normal:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_NORMAL;
MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        memop = MemOp_PREFETCH;
        if opc[0] == '1' then UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/normal:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/normal:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/memory/single/general/immediate/signed/offset/normal:index
Execute: aarch64/memory/single/general/immediate/signed/offset/normal:execute
Postdecode: aarch64/memory/single/general/immediate/signed/offset/normal:postdecode
Decode: aarch64/instrs/memory/single/general/immediate/signed/offset/normal:decode@aarch64/instrs/memory/single/general/immediate/signed/offset/normal:diagram
TAG:SQINCP-R.P.R-SX:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(ssize) operand1 = X[dn];
bits(PL) operand2 = P[m];
bits(ssize) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

integer element = Int(operand1, unsigned);
(result, -) = SatQ(element + count, ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQINCP-R.P.R-SX:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 0
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:SQINCP-R.P.R-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQINCP-R.P.R-X:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 0
15:11 _ 10001
10:10 _ 1
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:SQINCP-R.P.R-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQINCP-R.P.R-SX:index
Execute: SQINCP-R.P.R-SX:execute
Decode: SQINCP-R.P.R-SX:decode@SQINCP-R.P.R-SX:diagram
Decode: SQINCP-R.P.R-X:decode@SQINCP-R.P.R-X:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/div-fp16:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPDiv(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/div:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/div:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/div-fp16:index
Execute: aarch64/vector/arithmetic/binary/uniform/div-fp16:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16:decode@aarch64/instrs/vector/arithmetic/binary/uniform/div-fp16:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/div:decode@aarch64/instrs/vector/arithmetic/binary/uniform/div:diagram
TAG:ST2D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST2D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:ST2D-Z.P.BI-Contiguous:index
Execute: ST2D-Z.P.BI-Contiguous:execute
Decode: ST2D-Z.P.BI-Contiguous:decode@ST2D-Z.P.BI-Contiguous:diagram
TAG:aarch64/integer/logical/shiftedreg:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);

if invert then operand2 = NOT(operand2);

case op of
    when LogicalOp_AND result = operand1 AND operand2;
    when LogicalOp_ORR result = operand1 OR  operand2;
    when LogicalOp_EOR result = operand1 EOR operand2;

if setflags then
    PSTATE.[N,Z,C,V] = result[datasize-1]:IsZeroBit(result):'00';

X[d] = result;
TAG:aarch64/instrs/integer/logical/shiftedreg:diagram
A64
31:31 sf x
30:29 opc xx
28:24 _ 01010
23:22 shift xx
21:21 N x
20:16 Rm xxxxx
15:10 imm6 xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/logical/shiftedreg:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean setflags;
LogicalOp op;
case opc of
    when '00' op = LogicalOp_AND; setflags = FALSE;
    when '01' op = LogicalOp_ORR; setflags = FALSE;
    when '10' op = LogicalOp_EOR; setflags = FALSE;
    when '11' op = LogicalOp_AND; setflags = TRUE;

if sf == '0' && imm6[5] == '1' then UNDEFINED;

ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);
boolean invert = (N == '1');

TAG:aarch64/integer/logical/shiftedreg:index
Execute: aarch64/integer/logical/shiftedreg:execute
Decode: aarch64/instrs/integer/logical/shiftedreg:decode@aarch64/instrs/integer/logical/shiftedreg:diagram
TAG:aarch64/memory/vector/multiple/no-wb:execute
CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(64) offs;
bits(datasize) rval;
integer tt;
constant integer ebytes = esize DIV 8;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

offs = Zeros();
for r = 0 to rpt-1
    for e = 0 to elements-1
        tt = (t + r) MOD 32;
        for s = 0 to selem-1
            rval = V[tt];
            if memop == MemOp_LOAD then
                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];
                V[tt] = rval;
            else // memop == MemOp_STORE
                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];
            offs = offs + ebytes;
            tt = (tt + 1) MOD 32;

if wback then
    if m != 31 then
        offs = X[m];
    if n == 31 then
        SP[] = address + offs;
    else
        X[n] = address + offs;
TAG:aarch64/memory/vector/multiple/no-wb:postdecode
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << UInt(size);
integer elements = datasize DIV esize;

integer rpt;    // number of iterations
integer selem;  // structure elements 

case opcode of
    when '0000' rpt = 1; selem = 4;     // LD/ST4 (4 registers)
    when '0010' rpt = 4; selem = 1;     // LD/ST1 (4 registers)
    when '0100' rpt = 1; selem = 3;     // LD/ST3 (3 registers)
    when '0110' rpt = 3; selem = 1;     // LD/ST1 (3 registers)
    when '0111' rpt = 1; selem = 1;     // LD/ST1 (1 register)
    when '1000' rpt = 1; selem = 2;     // LD/ST2 (2 registers)
    when '1010' rpt = 2; selem = 1;     // LD/ST1 (2 registers)
    otherwise UNDEFINED;

// .1D format only permitted with LD1 & ST1
if size:Q == '110' && selem != 1 then UNDEFINED;

TAG:aarch64/instrs/memory/vector/multiple/no-wb:diagram
A64
31:31 _ 0
30:30 Q x
29:23 _ 0011000
22:22 L x
21:16 _ 000000
15:12 opcode xxxx
11:10 size xx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/vector/multiple/no-wb:decode
integer t = UInt(Rt);
integer n = UInt(Rn);
integer m = integer UNKNOWN;
boolean wback = FALSE;
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/vector/multiple/post-inc:diagram
A64
31:31 _ 0
30:30 Q x
29:23 _ 0011001
22:22 L x
21:21 _ 0
20:16 Rm xxxxx
15:12 opcode xxxx
11:10 size xx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/vector/multiple/post-inc:decode
integer t = UInt(Rt);
integer n = UInt(Rn);
integer m = UInt(Rm);
boolean wback = TRUE;
boolean tag_checked = wback || n != 31;

TAG:aarch64/memory/vector/multiple/no-wb:index
Execute: aarch64/memory/vector/multiple/no-wb:execute
Postdecode: aarch64/memory/vector/multiple/no-wb:postdecode
Decode: aarch64/instrs/memory/vector/multiple/no-wb:decode@aarch64/instrs/memory/vector/multiple/no-wb:diagram
Decode: aarch64/instrs/memory/vector/multiple/post-inc:decode@aarch64/instrs/memory/vector/multiple/post-inc:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/mul/accum:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
bits(2*esize) accum;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    product = (element1 * element2)[2*esize-1:0];
    if sub_op then
        accum = Elem[operand3, e, 2*esize] - product;
    else
        accum = Elem[operand3, e, 2*esize] + product;
    Elem[result, e, 2*esize] = accum;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 10
13:13 o1 x
12:12 _ 0
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/mul/accum:index
Execute: aarch64/vector/arithmetic/binary/disparate/mul/accum:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/accum:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/diff:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) absdiff;

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    absdiff = Abs(element1 - element2)[esize-1:0];
    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/diff:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 0111
11:11 ac x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/diff:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean accumulate = (ac == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/diff:index
Execute: aarch64/vector/arithmetic/binary/uniform/diff:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/diff:decode@aarch64/instrs/vector/arithmetic/binary/uniform/diff:diagram
TAG:aarch64/integer/logical/immediate:execute
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = imm;

case op of
    when LogicalOp_AND result = operand1 AND operand2;
    when LogicalOp_ORR result = operand1 OR  operand2;
    when LogicalOp_EOR result = operand1 EOR operand2;

if setflags then
    PSTATE.[N,Z,C,V] = result[datasize-1]:IsZeroBit(result):'00';

if d == 31 && !setflags then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/logical/immediate:diagram
A64
31:31 sf x
30:29 opc xx
28:23 _ 100100
22:22 N x
21:16 immr xxxxxx
15:10 imms xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/logical/immediate:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
boolean setflags;
LogicalOp op;
case opc of
    when '00' op = LogicalOp_AND; setflags = FALSE;
    when '01' op = LogicalOp_ORR; setflags = FALSE;
    when '10' op = LogicalOp_EOR; setflags = FALSE;
    when '11' op = LogicalOp_AND; setflags = TRUE;

bits(datasize) imm;
if sf == '0' && N != '0' then UNDEFINED;
(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);

TAG:aarch64/integer/logical/immediate:index
Execute: aarch64/integer/logical/immediate:execute
Decode: aarch64/instrs/integer/logical/immediate:decode@aarch64/instrs/integer/logical/immediate:diagram
TAG:LD1SB-Z.P.BR-S16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1SB-Z.P.BR-S16:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BR-S16:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LD1SB-Z.P.BR-S32:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BR-S32:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LD1SB-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LD1SB-Z.P.BR-S16:index
Execute: LD1SB-Z.P.BR-S16:execute
Decode: LD1SB-Z.P.BR-S16:decode@LD1SB-Z.P.BR-S16:diagram
Decode: LD1SB-Z.P.BR-S32:decode@LD1SB-Z.P.BR-S32:diagram
Decode: LD1SB-Z.P.BR-S64:decode@LD1SB-Z.P.BR-S64:diagram
TAG:SMAX-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer maximum = Max(element1, element2);
        Elem[result, e, esize] = maximum[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SMAX-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SMAX-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SMAX-Z.P.ZZ-_:index
Execute: SMAX-Z.P.ZZ-_:execute
Decode: SMAX-Z.P.ZZ-_:decode@SMAX-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer round_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;

for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    product = (2 * element1 * element2) + round_const;
    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10110
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' || size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean rounding = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10110
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' || size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean rounding = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/simd:diagram
TAG:aarch64/vector/shift/right/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2;
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;

operand2 = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;
    Elem[result, e, esize] = Elem[operand2, e, esize] + element[esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/shift/right/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:14 _ 00
13:13 o1 x
12:12 o0 x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh[3] != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;

integer shift = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
boolean round = (o1 == '1');
boolean accumulate = (o0 == '1');

TAG:aarch64/instrs/vector/shift/right/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:14 _ 00
13:13 o1 x
12:12 o0 x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3]:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer shift = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
boolean round = (o1 == '1');
boolean accumulate = (o0 == '1');

TAG:aarch64/vector/shift/right/sisd:index
Execute: aarch64/vector/shift/right/sisd:execute
Decode: aarch64/instrs/vector/shift/right/sisd:decode@aarch64/instrs/vector/shift/right/sisd:diagram
Decode: aarch64/instrs/vector/shift/right/simd:decode@aarch64/instrs/vector/shift/right/simd:diagram
TAG:aarch64/memory/pair/general/post-idx:execute
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

boolean wb_unknown = FALSE;

if memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then
    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;        // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;    // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then
    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;   // value stored is pre-writeback
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_LOAD && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown && t == n then
            data1 = bits(datasize) UNKNOWN;
        else
            data1 = X[t];
        if rt_unknown && t2 == n then
            data2 = bits(datasize) UNKNOWN;
        else
            data2 = X[t2];
        Mem[address + 0     , dbytes, acctype] = data1;
        Mem[address + dbytes, dbytes, acctype] = data2;

    when MemOp_LOAD
        data1 = Mem[address + 0     , dbytes, acctype];
        data2 = Mem[address + dbytes, dbytes, acctype];
        if rt_unknown then
            data1 = bits(datasize) UNKNOWN;
            data2 = bits(datasize) UNKNOWN;
        if signed then
            X[t]  = SignExtend(data1, 64);
            X[t2] = SignExtend(data2, 64);
        else
            X[t]  = data1;
            X[t2] = data2;

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/pair/general/post-idx:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
AccType acctype = AccType_NORMAL;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
if L:opc[0] == '01' || opc == '11' then UNDEFINED;
boolean signed = (opc[0] != '0');
integer scale = 2 + UInt(opc[1]);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/pair/general/post-idx:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 0
25:23 _ 001
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/general/post-idx:decode
boolean wback  = TRUE;
boolean postindex = TRUE;

TAG:aarch64/instrs/memory/pair/general/pre-idx:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 0
25:23 _ 011
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/general/pre-idx:decode
boolean wback  = TRUE;
boolean postindex = FALSE;

TAG:aarch64/instrs/memory/pair/general/offset:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 0
25:23 _ 010
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/general/offset:decode
boolean wback  = FALSE;
boolean postindex = FALSE;

TAG:aarch64/memory/pair/general/post-idx:index
Execute: aarch64/memory/pair/general/post-idx:execute
Postdecode: aarch64/memory/pair/general/post-idx:postdecode
Decode: aarch64/instrs/memory/pair/general/post-idx:decode@aarch64/instrs/memory/pair/general/post-idx:diagram
Decode: aarch64/instrs/memory/pair/general/pre-idx:decode@aarch64/instrs/memory/pair/general/pre-idx:diagram
Decode: aarch64/instrs/memory/pair/general/offset:decode@aarch64/instrs/memory/pair/general/offset:diagram
TAG:aarch64/integer/pac/pacdb/dp_1src:execute
if source_is_sp then
    X[d] = AddPACDB(X[d], SP[]);
else
    X[d] = AddPACDB(X[d], X[n]);
TAG:aarch64/instrs/integer/pac/pacdb/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 011
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/pacdb/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // PACDB
    if n == 31 then source_is_sp = TRUE;
else // PACDZB
    if n != 31 then UNDEFINED;

TAG:aarch64/integer/pac/pacdb/dp_1src:index
Execute: aarch64/integer/pac/pacdb/dp_1src:execute
Decode: aarch64/instrs/integer/pac/pacdb/dp_1src:decode@aarch64/instrs/integer/pac/pacdb/dp_1src:diagram
TAG:aarch64/memory/exclusive/single:execute
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if memop == MemOp_LOAD && pair && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE then
    if s == t || (pair && s == t2) then
        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
        case c of
            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
            when Constraint_NONE       rt_unknown = FALSE;   // store original value
            when Constraint_UNDEF      UNDEFINED;
            when Constraint_NOP        EndOfInstruction();
    if s == n && n != 31 then
        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
        case c of
            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
            when Constraint_UNDEF      UNDEFINED;
            when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
elsif rn_unknown then
    address = bits(64) UNKNOWN;
else
    address = X[n];

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        elsif pair then
            bits(datasize DIV 2) el1 = X[t];
            bits(datasize DIV 2) el2 = X[t2];
            data = if BigEndian() then el1 : el2 else el2 : el1;
        else
            data = X[t];

        bit status = '1';
        // Check whether the Exclusives monitors are set to include the
        // physical memory locations corresponding to virtual address
        // range [address, address+dbytes-1].
        if AArch64.ExclusiveMonitorsPass(address, dbytes) then
            // This atomic write will be rejected if it does not refer
            // to the same physical locations after address translation.
            Mem[address, dbytes, acctype] = data;
            status = ExclusiveMonitorsStatus();
        X[s] = ZeroExtend(status, 32);

    when MemOp_LOAD
        // Tell the Exclusives monitors to record a sequence of one or more atomic
        // memory reads from virtual address range [address, address+dbytes-1].
        // The Exclusives monitor will only be set if all the reads are from the
        // same dbytes-aligned physical address, to allow for the possibility of
        // an atomicity break if the translation is changed between reads.
        AArch64.SetExclusiveMonitors(address, dbytes);

        if pair then
            if rt_unknown then
                // ConstrainedUNPREDICTABLE case
                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2
            elsif elsize == 32 then
                // 32-bit load exclusive pair (atomic)
                data = Mem[address, dbytes, acctype];
                if BigEndian() then
                    X[t]  = data[datasize-1:elsize];
                    X[t2] = data[elsize-1:0];
                else
                    X[t]  = data[elsize-1:0];
                    X[t2] = data[datasize-1:elsize];
            else // elsize == 64
                // 64-bit load exclusive pair (not atomic),
                // but must be 128-bit aligned
                if address != Align(address, dbytes) then
                    iswrite = FALSE;
                    secondstage = FALSE;
                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                X[t]  = Mem[address + 0, 8, acctype];
                X[t2] = Mem[address + 8, 8, acctype];
        else
            data = Mem[address, dbytes, acctype];
            X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/exclusive/single:diagram
A64
31:30 size xx
29:24 _ 001000
23:23 _ 0
22:22 L x
21:21 _ 0
20:16 Rs xxxxx
15:15 o0 x
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/exclusive/single:decode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2); // ignored by load/store single register
integer s = UInt(Rs);   // ignored by all loads and store-release

AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
boolean pair = FALSE;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
integer datasize = if pair then elsize * 2 else elsize;
boolean tag_checked = n != 31;

TAG:aarch64/memory/exclusive/single:index
Execute: aarch64/memory/exclusive/single:execute
Decode: aarch64/instrs/memory/exclusive/single:decode@aarch64/instrs/memory/exclusive/single:diagram
TAG:aarch64/memory/single/general/immediate/signed/offset/lda_stl:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/immediate/signed/offset/lda_stl:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_ORDERED;
MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        memop = MemOp_PREFETCH;
        if opc[0] == '1' then UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/lda_stl:diagram
A64
31:30 size xx
29:24 _ 011001
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/lda_stl:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/memory/single/general/immediate/signed/offset/lda_stl:index
Execute: aarch64/memory/single/general/immediate/signed/offset/lda_stl:execute
Postdecode: aarch64/memory/single/general/immediate/signed/offset/lda_stl:postdecode
Decode: aarch64/instrs/memory/single/general/immediate/signed/offset/lda_stl:decode@aarch64/instrs/memory/single/general/immediate/signed/offset/lda_stl:diagram
TAG:aarch64/memory/atomicops/ld:execute
bits(64) address;
bits(datasize) value;
bits(datasize) data;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

value = X[s];
if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

data = MemAtomic(address, op, value, ldacctype, stacctype);

if t != 31 then
    X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/atomicops/ld:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:23 A x
22:22 R x
21:21 _ 1
20:16 Rs xxxxx
15:15 _ 0
14:12 opc xxx
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/atomicops/ld:decode
if !HaveAtomicExt() then UNDEFINED;

integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);

integer datasize = 8 << UInt(size);
integer regsize = if datasize == 64 then 64 else 32;
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
MemAtomicOp op;
case opc of
    when '000' op = MemAtomicOp_ADD;
    when '001' op = MemAtomicOp_BIC;
    when '010' op = MemAtomicOp_EOR;
    when '011' op = MemAtomicOp_ORR;
    when '100' op = MemAtomicOp_SMAX;
    when '101' op = MemAtomicOp_SMIN;
    when '110' op = MemAtomicOp_UMAX;
    when '111' op = MemAtomicOp_UMIN;
boolean tag_checked = n != 31;

TAG:aarch64/memory/atomicops/ld:index
Execute: aarch64/memory/atomicops/ld:execute
Decode: aarch64/instrs/memory/atomicops/ld:decode@aarch64/instrs/memory/atomicops/ld:diagram
TAG:aarch64/integer/arithmetic/add-sub/extendedreg:execute
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = ExtendReg(m, extend_type, shift);
bits(4) nzcv;
bit carry_in;

if sub_op then
    operand2 = NOT(operand2);
    carry_in = '1';
else
    carry_in = '0';

(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

if setflags then 
    PSTATE.[N,Z,C,V] = nzcv;

if d == 31 && !setflags then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/add-sub/extendedreg:diagram
A64
31:31 sf x
30:30 op x
29:29 S x
28:24 _ 01011
23:22 _ 00
21:21 _ 1
20:16 Rm xxxxx
15:13 option xxx
12:10 imm3 xxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/add-sub/extendedreg:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
boolean setflags = (S == '1');
ExtendType extend_type = DecodeRegExtend(option);       
integer shift = UInt(imm3);
if shift > 4 then UNDEFINED;

TAG:aarch64/integer/arithmetic/add-sub/extendedreg:index
Execute: aarch64/integer/arithmetic/add-sub/extendedreg:execute
Decode: aarch64/instrs/integer/arithmetic/add-sub/extendedreg:decode@aarch64/instrs/integer/arithmetic/add-sub/extendedreg:diagram
TAG:aarch64/vector/shift/right-narrow/nonuniform/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;

for e = 0 to elements-1
    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);
    if sat then FPSR.QC = '1';

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:12 _ 1000
11:11 op x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then UNDEFINED;
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

TAG:aarch64/instrs/vector/shift/right-narrow/nonuniform/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:12 _ 1000
11:11 op x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-narrow/nonuniform/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

TAG:aarch64/vector/shift/right-narrow/nonuniform/sisd:index
Execute: aarch64/vector/shift/right-narrow/nonuniform/sisd:execute
Decode: aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd:decode@aarch64/instrs/vector/shift/right-narrow/nonuniform/sisd:diagram
Decode: aarch64/instrs/vector/shift/right-narrow/nonuniform/simd:decode@aarch64/instrs/vector/shift/right-narrow/nonuniform/simd:diagram
TAG:LD2B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:LD2B-Z.P.BI-Contiguous:index
Execute: LD2B-Z.P.BI-Contiguous:execute
Decode: LD2B-Z.P.BI-Contiguous:decode@LD2B-Z.P.BI-Contiguous:diagram
TAG:USMMLA-Z.ZZZ-_:execute
CheckSVEEnabled();
integer segments = VL DIV 128;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result = Zeros();
bits(128) op1, op2;
bits(128) res, addend;

for s = 0 to segments-1
    op1    = Elem[operand1, s, 128];
    op2    = Elem[operand2, s, 128];
    addend = Elem[operand3, s, 128];
    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);
    Elem[result, s, 128] = res;

Z[da] = result;
TAG:USMMLA-Z.ZZZ-_:diagram
A64
31:24 _ 01000101
23:23 _ 1
22:22 _ 0
21:21 _ 0
20:16 Zm xxxxx
15:10 _ 100110
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:USMMLA-Z.ZZZ-_:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_unsigned = TRUE;
boolean op2_unsigned = FALSE;

TAG:USMMLA-Z.ZZZ-_:index
Execute: USMMLA-Z.ZZZ-_:execute
Decode: USMMLA-Z.ZZZ-_:decode@USMMLA-Z.ZZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2 = Elem[operand2, index, esize];

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    if sub_op then element1 = FPNeg(element1);
    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11111
23:22 _ 00
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 01
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);

integer esize = 16;
integer datasize = esize;
integer elements = 1;
boolean sub_op = (o2 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 01
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi = M;
case sz:L of
    when '0x' index = UInt(H:L);
    when '10' index = UInt(H);
    when '11' UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
boolean sub_op = (o2 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 _ 00
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 01
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 01
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi = M;
case sz:L of
    when '0x' index = UInt(H:L);
    when '10' index = UInt(H);
    when '11' UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (o2 == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/fp/simd:diagram
TAG:SEL-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1;
    else
        Elem[result, e, esize] = element2;

Z[d] = result;
TAG:SEL-Z.P.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:14 _ 11
13:10 Pg xxxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SEL-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:SEL-Z.P.ZZ-_:index
Execute: SEL-Z.P.ZZ-_:execute
Decode: SEL-Z.P.ZZ-_:decode@SEL-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/wide:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, 2*esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    if sub_op then
        sum = element1 - element2;
    else
        sum = element1 + element2;
    Elem[result, e, 2*esize] = sum[2*esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 00
13:13 o1 x
12:12 _ 1
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/wide:index
Execute: aarch64/vector/arithmetic/binary/disparate/add-sub/wide:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide:decode@aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/wide:diagram
TAG:aarch64/vector/shift/right-narrow/logical:execute
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;

for e = 0 to elements-1
    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;
    Elem[result, e, esize] = element[esize-1:0];

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/shift/right-narrow/logical:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:12 _ 1000
11:11 op x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-narrow/logical:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');

TAG:aarch64/vector/shift/right-narrow/logical:index
Execute: aarch64/vector/shift/right-narrow/logical:execute
Decode: aarch64/instrs/vector/shift/right-narrow/logical:decode@aarch64/instrs/vector/shift/right-narrow/logical:diagram
TAG:aarch64/memory/atomicops/cas/single:execute
bits(64) address;
bits(datasize) comparevalue;
bits(datasize) newvalue;
bits(datasize) data;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

comparevalue = X[s];
newvalue = X[t];

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);

X[s] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/atomicops/cas/single:diagram
A64
31:30 size xx
29:24 _ 001000
23:23 _ 1
22:22 L x
21:21 _ 1
20:16 Rs xxxxx
15:15 o0 x
14:10 _ 11111
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/atomicops/cas/single:decode
if !HaveAtomicExt() then UNDEFINED;

integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

integer datasize = 8 << UInt(size);
integer regsize = if datasize == 64 then 64 else 32;
AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

TAG:aarch64/memory/atomicops/cas/single:index
Execute: aarch64/memory/atomicops/cas/single:execute
Decode: aarch64/instrs/memory/atomicops/cas/single:decode@aarch64/instrs/memory/atomicops/cas/single:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/diff:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) absdiff;

result = if accumulate then V[d] else Zeros();
for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    absdiff = Abs(element1 - element2)[2*esize-1:0];
    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/diff:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 01
13:13 op x
12:12 _ 1
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/diff:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean accumulate = (op == '0');
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/diff:index
Execute: aarch64/vector/arithmetic/binary/disparate/diff:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/diff:decode@aarch64/instrs/vector/arithmetic/binary/disparate/diff:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2 = Elem[operand2, index, esize];

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    if mulx_op then
        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
    else
        Elem[result, e, esize] = FPMul(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11111
23:22 _ 00
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1001
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);

integer esize = 16;
integer datasize = esize;
integer elements = 1;
boolean mulx_op = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1001
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi = M;
case sz:L of
    when '0x' index = UInt(H:L);
    when '10' index = UInt(H);
    when '11' UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
boolean mulx_op = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01111
23:22 _ 00
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1001
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean mulx_op = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1001
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi = M;
case sz:L of
    when '0x' index = UInt(H:L);
    when '10' index = UInt(H);
    when '11' UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean mulx_op = (U == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul/fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/fp/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/fp/simd:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
boolean test_passed;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if and_test then
        test_passed = !IsZero(element1 AND element2);
    else
        test_passed = (element1 == element2);
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean and_test = (U == '0');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean and_test = (U == '0');

TAG:aarch64/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/bitwise/simd:diagram
TAG:COMPACT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) result;
integer x = 0;

for e = 0 to elements-1
    Elem[result, e, esize] = Zeros();
    if ElemP[mask, e, esize] == '1' then
        bits(esize) element = Elem[operand1, e, esize];
        Elem[result, x, esize] = element;
        x = x + 1;

Z[d] = result;
TAG:COMPACT-Z.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:13 _ 100001100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:COMPACT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:COMPACT-Z.P.Z-_:index
Execute: COMPACT-Z.P.Z-_:execute
Decode: COMPACT-Z.P.Z-_:decode@COMPACT-Z.P.Z-_:diagram
TAG:ST1B-Z.P.BZ-D.x32.unscaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(VL) offset = Z[m];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1B-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1B-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1B-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:ST1B-Z.P.BZ-D.x32.unscaled:index
Execute: ST1B-Z.P.BZ-D.x32.unscaled:execute
Decode: ST1B-Z.P.BZ-D.x32.unscaled:decode@ST1B-Z.P.BZ-D.x32.unscaled:diagram
Decode: ST1B-Z.P.BZ-S.x32.unscaled:decode@ST1B-Z.P.BZ-S.x32.unscaled:diagram
Decode: ST1B-Z.P.BZ-D.64.unscaled:decode@ST1B-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/halving/rounding:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    Elem[result, e, esize] = (element1 + element2 + 1)[esize:1];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/add/halving/rounding:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/halving/rounding:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/rounding:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/cmp/int/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
boolean test_passed;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 0011
11:11 eq x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 0011
11:11 eq x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean cmp_eq = (eq == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/cmp/int/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/cmp/int/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/int/simd:diagram
TAG:SQDECP-R.P.R-SX:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(ssize) operand1 = X[dn];
bits(PL) operand2 = P[m];
bits(ssize) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

integer element = Int(operand1, unsigned);
(result, -) = SatQ(element - count, ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQDECP-R.P.R-SX:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 0
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:SQDECP-R.P.R-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQDECP-R.P.R-X:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 0
15:11 _ 10001
10:10 _ 1
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:SQDECP-R.P.R-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQDECP-R.P.R-SX:index
Execute: SQDECP-R.P.R-SX:execute
Decode: SQDECP-R.P.R-SX:decode@SQDECP-R.P.R-SX:diagram
Decode: SQDECP-R.P.R-X:decode@SQDECP-R.P.R-X:diagram
TAG:SQDECD-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQDECD-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECD-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQDECD-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECD-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQDECD-R.RS-SX:index
Execute: SQDECD-R.RS-SX:execute
Decode: SQDECD-R.RS-SX:decode@SQDECD-R.RS-SX:diagram
Decode: SQDECD-R.RS-X:decode@SQDECD-R.RS-X:diagram
TAG:PRFW-I.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) base;
bits(64) addr;
base = Z[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFW-I.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 2;
integer offset = UInt(imm5);

TAG:PRFW-I.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 2;
integer offset = UInt(imm5);

TAG:PRFW-I.P.AI-S:index
Execute: PRFW-I.P.AI-S:execute
Decode: PRFW-I.P.AI-S:decode@PRFW-I.P.AI-S:diagram
Decode: PRFW-I.P.AI-D:decode@PRFW-I.P.AI-D:diagram
TAG:UDOT-Z.ZZZi-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = UInt(Elem[operand2, 4 * s + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:UDOT-Z.ZZZi-S:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:UDOT-Z.ZZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:UDOT-Z.ZZZi-D:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:UDOT-Z.ZZZi-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:UDOT-Z.ZZZi-S:index
Execute: UDOT-Z.ZZZi-S:execute
Decode: UDOT-Z.ZZZi-S:decode@UDOT-Z.ZZZi-S:diagram
Decode: UDOT-Z.ZZZi-D:decode@UDOT-Z.ZZZi-D:diagram
TAG:SQDECW-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQDECW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQDECW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQDECW-Z.ZS-_:index
Execute: SQDECW-Z.ZS-_:execute
Decode: SQDECW-Z.ZS-_:decode@SQDECW-Z.ZS-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/logical/and-orr:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

if invert then operand2 = NOT(operand2);

case op of
    when LogicalOp_AND
        result = operand1 AND operand2;
    when LogicalOp_ORR
        result = operand1 OR operand2;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean invert = (size[0] == '1');
LogicalOp op = if size[1] == '1' then LogicalOp_ORR else LogicalOp_AND;

TAG:aarch64/vector/arithmetic/binary/uniform/logical/and-orr:index
Execute: aarch64/vector/arithmetic/binary/uniform/logical/and-orr:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr:decode@aarch64/instrs/vector/arithmetic/binary/uniform/logical/and-orr:diagram
TAG:ST1H-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(VL) offset = Z[m];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1H-Z.P.BZ-S.x32.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:ST1H-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:ST1H-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1H-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1H-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:ST1H-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:ST1H-Z.P.BZ-S.x32.scaled:index
Execute: ST1H-Z.P.BZ-S.x32.scaled:execute
Decode: ST1H-Z.P.BZ-S.x32.scaled:decode@ST1H-Z.P.BZ-S.x32.scaled:diagram
Decode: ST1H-Z.P.BZ-D.x32.scaled:decode@ST1H-Z.P.BZ-D.x32.scaled:diagram
Decode: ST1H-Z.P.BZ-D.x32.unscaled:decode@ST1H-Z.P.BZ-D.x32.unscaled:diagram
Decode: ST1H-Z.P.BZ-S.x32.unscaled:decode@ST1H-Z.P.BZ-S.x32.unscaled:diagram
Decode: ST1H-Z.P.BZ-D.64.scaled:decode@ST1H-Z.P.BZ-D.64.scaled:diagram
Decode: ST1H-Z.P.BZ-D.64.unscaled:decode@ST1H-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/integer/arithmetic/rev:execute
bits(datasize) operand = X[n];
bits(datasize) result;

integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV 8;
integer index = 0;
integer rev_index;
for c = 0 to containers-1
    rev_index = index + ((elements_per_container - 1) * 8);
    for e = 0 to elements_per_container-1
        result[rev_index + 7:rev_index] = operand[index + 7:index];
        index = index + 8;
        rev_index = rev_index - 8;

X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/rev:diagram
A64
31:31 sf x
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00000
15:12 _ 0000
11:10 opc xx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/rev:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer datasize = if sf == '1' then 64 else 32;

integer container_size;
case opc of
    when '00'
        Unreachable();
    when '01'
        container_size = 16;
    when '10'
        container_size = 32;
    when '11'
        if sf == '0' then UNDEFINED;
        container_size = 64;

TAG:aarch64/integer/arithmetic/rev:index
Execute: aarch64/integer/arithmetic/rev:execute
Decode: aarch64/instrs/integer/arithmetic/rev:decode@aarch64/instrs/integer/arithmetic/rev:diagram
TAG:DUP-Z.Zi-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) result;
bits(esize) element;

if index >= elements then
    element = Zeros();
else
    element = Elem[operand1, index, esize];
result = Replicate(element);

Z[d] = result;
TAG:DUP-Z.Zi-_:diagram
A64
31:24 _ 00000101
23:22 imm2 xx
21:21 _ 1
20:16 tsz xxxxx
15:10 _ 001000
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:DUP-Z.Zi-_:decode
if !HaveSVE() then UNDEFINED;
bits(7) imm = imm2:tsz;
case tsz of
    when '00000' UNDEFINED;
    when '10000' esize = 128; index = UInt(imm[6:5]);
    when 'x1000' esize = 64;  index = UInt(imm[6:4]);
    when 'xx100' esize = 32;  index = UInt(imm[6:3]);
    when 'xxx10' esize = 16;  index = UInt(imm[6:2]);
    when 'xxxx1' esize = 8;   index = UInt(imm[6:1]);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:DUP-Z.Zi-_:index
Execute: DUP-Z.Zi-_:execute
Decode: DUP-Z.Zi-_:decode@DUP-Z.Zi-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/mul/dmacc/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;

for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
    if sub_op then
        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
    else
        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
    if sat1 || sat2 then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 10
13:13 o1 x
12:12 _ 1
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '00' || size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
integer part = 0;

boolean sub_op = (o1 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 10
13:13 o1 x
12:12 _ 1
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '00' || size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean sub_op = (o1 == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/mul/dmacc/sisd:index
Execute: aarch64/vector/arithmetic/binary/disparate/mul/dmacc/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/dmacc/simd:diagram
TAG:FDUP-Z.I-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) result;

for e = 0 to elements-1
    Elem[result, e, esize] = imm;

Z[d] = result;
TAG:FDUP-Z.I-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 111
18:18 _ 0
17:17 _ 0
16:14 _ 111
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zd xxxxx
TAG:FDUP-Z.I-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer d = UInt(Zd);
bits(esize) imm = VFPExpandImm(imm8);

TAG:FDUP-Z.I-_:index
Execute: FDUP-Z.I-_:execute
Decode: FDUP-Z.I-_:decode@FDUP-Z.I-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/max-min/fp16/2008:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    if pair then
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    else
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];

    if minimum then
        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
    else
        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 a x
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (a == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o1 x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/max-min/fp16/2008:index
Execute: aarch64/vector/arithmetic/binary/uniform/max-min/fp16/2008:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/2008:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/2008:diagram
TAG:LDR-Z.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV 8;
bits(64) base;
integer offset = imm * elements;
bits(VL) result;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, FALSE);
for e = 0 to elements-1
    Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
    offset = offset + 1;

Z[t] = result;
TAG:LDR-Z.BI-_:diagram
A64
31:22 _ 1000010110
21:16 imm9h xxxxxx
15:13 _ 010
12:10 imm9l xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDR-Z.BI-_:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer imm = SInt(imm9h:imm9l);

TAG:LDR-Z.BI-_:index
Execute: LDR-Z.BI-_:execute
Decode: LDR-Z.BI-_:decode@LDR-Z.BI-_:diagram
TAG:FMLA-Z.ZZZi-H:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result = Z[da];

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, s, esize];
    bits(esize) element3 = Elem[result, e, esize];
    if op1_neg then element1 = FPNeg(element1);
    if op3_neg then element3 = FPNeg(element3);
    Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:FMLA-Z.ZZZi-H:diagram
A64
31:24 _ 01100100
23:23 _ 0
22:22 i3h x
21:21 _ 1
20:19 i3l xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLA-Z.ZZZi-H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer index = UInt(i3h:i3l);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = FALSE;
boolean op3_neg = FALSE;

TAG:FMLA-Z.ZZZi-S:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLA-Z.ZZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = FALSE;
boolean op3_neg = FALSE;

TAG:FMLA-Z.ZZZi-D:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLA-Z.ZZZi-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = FALSE;
boolean op3_neg = FALSE;

TAG:FMLA-Z.ZZZi-H:index
Execute: FMLA-Z.ZZZi-H:execute
Decode: FMLA-Z.ZZZi-H:decode@FMLA-Z.ZZZi-H:diagram
Decode: FMLA-Z.ZZZi-S:decode@FMLA-Z.ZZZi-S:diagram
Decode: FMLA-Z.ZZZi-D:decode@FMLA-Z.ZZZi-D:diagram
TAG:LASTA-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(rsize) result;
integer last = LastActiveElement(mask, esize);

if isBefore then
    if last < 0 then last = elements - 1;
else
    last = last + 1;
    if last >= elements then last = 0;
result = ZeroExtend(Elem[operand, last, esize]);

X[d] = result;
TAG:LASTA-R.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10000
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Rd xxxxx
TAG:LASTA-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = if esize < 64 then 32 else 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Rd);
boolean isBefore = FALSE;

TAG:LASTA-R.P.Z-_:index
Execute: LASTA-R.P.Z-_:execute
Decode: LASTA-R.P.Z-_:decode@LASTA-R.P.Z-_:diagram
TAG:LD2H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 2;

TAG:LD2H-Z.P.BR-Contiguous:index
Execute: LD2H-Z.P.BR-Contiguous:execute
Decode: LD2H-Z.P.BR-Contiguous:decode@LD2H-Z.P.BR-Contiguous:diagram
TAG:LASTB-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(rsize) result;
integer last = LastActiveElement(mask, esize);

if isBefore then
    if last < 0 then last = elements - 1;
else
    last = last + 1;
    if last >= elements then last = 0;
result = ZeroExtend(Elem[operand, last, esize]);

X[d] = result;
TAG:LASTB-R.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10000
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Rd xxxxx
TAG:LASTB-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = if esize < 64 then 32 else 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Rd);
boolean isBefore = TRUE;

TAG:LASTB-R.P.Z-_:index
Execute: LASTB-R.P.Z-_:execute
Decode: LASTB-R.P.Z-_:decode@LASTB-R.P.Z-_:diagram
TAG:aarch64/system/hints:execute
case op of
    when SystemHintOp_YIELD
        Hint_Yield();

    when SystemHintOp_DGH
        Hint_DGH();

    when SystemHintOp_WFE
        if IsEventRegisterSet() then
            ClearEventRegister();
        else
            if PSTATE.EL == EL0 then
                // Check for traps described by the OS which may be EL1 or EL2.
                AArch64.CheckForWFxTrap(EL1, TRUE);
            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
                // Check for traps described by the Hypervisor.
                AArch64.CheckForWFxTrap(EL2, TRUE);
            if HaveEL(EL3) && PSTATE.EL != EL3 then
                // Check for traps described by the Secure Monitor.
                AArch64.CheckForWFxTrap(EL3, TRUE);
            WaitForEvent();

    when SystemHintOp_WFI
        if !InterruptPending() then
            if PSTATE.EL == EL0 then
                // Check for traps described by the OS which may be EL1 or EL2.
                AArch64.CheckForWFxTrap(EL1, FALSE);
            if PSTATE.EL IN {EL0, EL1} && EL2Enabled() && !IsInHost() then
                // Check for traps described by the Hypervisor.
                AArch64.CheckForWFxTrap(EL2, FALSE);
            if HaveEL(EL3) && PSTATE.EL != EL3 then
                // Check for traps described by the Secure Monitor.
                AArch64.CheckForWFxTrap(EL3, FALSE);
            WaitForInterrupt();

    when SystemHintOp_SEV
        SendEvent();

    when SystemHintOp_SEVL
        SendEventLocal();

    when SystemHintOp_ESB
        SynchronizeErrors();
        AArch64.ESBOperation();
        if PSTATE.EL IN {EL0, EL1} && EL2Enabled() then AArch64.vESBOperation();
        TakeUnmaskedSErrorInterrupts();

    when SystemHintOp_PSB
        ProfilingSynchronizationBarrier();

    when SystemHintOp_TSB
        TraceSynchronizationBarrier();

    when SystemHintOp_CSDB
        ConsumptionOfSpeculativeDataBarrier();

    when SystemHintOp_BTI
        SetBTypeNext('00');

    otherwise // do nothing
TAG:aarch64/instrs/system/hints:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/system/hints:decode
SystemHintOp op;

case CRm:op2 of
    when '0000 000' op = SystemHintOp_NOP;
    when '0000 001' op = SystemHintOp_YIELD;
    when '0000 010' op = SystemHintOp_WFE;
    when '0000 011' op = SystemHintOp_WFI;
    when '0000 100' op = SystemHintOp_SEV;
    when '0000 101' op = SystemHintOp_SEVL;
    when '0000 110'
        if !HaveDGHExt() then EndOfInstruction();                  // Instruction executes as NOP
        op = SystemHintOp_DGH;
    when '0000 111' SEE "XPACLRI";
    when '0001 xxx'
        case op2 of
            when '000' SEE "PACIA1716";
            when '010' SEE "PACIB1716";
            when '100' SEE "AUTIA1716";
            when '110' SEE "AUTIB1716";
            otherwise EndOfInstruction();                          // Instruction executes as NOP
    when '0010 000'
        if !HaveRASExt() then EndOfInstruction();                  // Instruction executes as NOP
        op = SystemHintOp_ESB;
    when '0010 001'
        if !HaveStatisticalProfiling() then EndOfInstruction();    // Instruction executes as NOP
        op = SystemHintOp_PSB;
    when '0010 010'
        if !HaveSelfHostedTrace() then EndOfInstruction();         // Instruction executes as NOP
        op = SystemHintOp_TSB;
    when '0010 100'
        op = SystemHintOp_CSDB;
    when '0011 xxx'
        case op2 of
            when '000' SEE "PACIAZ";
            when '001' SEE "PACIASP";
            when '010' SEE "PACIBZ";
            when '011' SEE "PACIBSP";
            when '100' SEE "AUTIAZ";
            when '101' SEE "AUTHASP";
            when '110' SEE "AUTIBZ";
            when '111' SEE "AUTIBSP";
    when '0100 xx0'
        op = SystemHintOp_BTI;
        // Check branch target compatibility between BTI instruction and PSTATE.BTYPE
        SetBTypeCompatible(BTypeCompatible_BTI(op2[2:1]));
    otherwise EndOfInstruction();                                 // Instruction executes as NOP

TAG:aarch64/system/hints:index
Execute: aarch64/system/hints:execute
Decode: aarch64/instrs/system/hints:decode@aarch64/instrs/system/hints:diagram
TAG:LD1W-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1W-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001010
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LD1W-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LD1W-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1W-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1W-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:LD1W-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1W-Z.P.BZ-S.x32.scaled:index
Execute: LD1W-Z.P.BZ-S.x32.scaled:execute
Decode: LD1W-Z.P.BZ-S.x32.scaled:decode@LD1W-Z.P.BZ-S.x32.scaled:diagram
Decode: LD1W-Z.P.BZ-D.x32.scaled:decode@LD1W-Z.P.BZ-D.x32.scaled:diagram
Decode: LD1W-Z.P.BZ-D.x32.unscaled:decode@LD1W-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1W-Z.P.BZ-S.x32.unscaled:decode@LD1W-Z.P.BZ-S.x32.unscaled:diagram
Decode: LD1W-Z.P.BZ-D.64.scaled:decode@LD1W-Z.P.BZ-D.64.scaled:diagram
Decode: LD1W-Z.P.BZ-D.64.unscaled:decode@LD1W-Z.P.BZ-D.64.unscaled:diagram
TAG:BFMMLA-Z.ZZZ-_:execute
CheckSVEEnabled();
integer segments =  VL DIV 128;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;
bits(128) op1, op2;
bits(128) res, addend;

for s = 0 to segments-1
    op1    = Elem[operand1, s, 128];
    op2    = Elem[operand2, s, 128];
    addend = Elem[operand3, s, 128];
    res    = BFMatMulAdd(addend, op1, op2);
    Elem[result, s, 128] = res;

Z[da] = result;
TAG:BFMMLA-Z.ZZZ-_:diagram
A64
31:24 _ 01100100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 111001
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFMMLA-Z.ZZZ-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:BFMMLA-Z.ZZZ-_:index
Execute: BFMMLA-Z.ZZZ-_:execute
Decode: BFMMLA-Z.ZZZ-_:decode@BFMMLA-Z.ZZZ-_:diagram
TAG:aarch64/branch/unconditional/eret:execute
AArch64.CheckForERetTrap(pac, use_key_a);
bits(64) target = ELR[];
boolean auth_then_branch = TRUE;

if pac then
    if use_key_a then
        target = AuthIA(ELR[], SP[], auth_then_branch);
    else
        target = AuthIB(ELR[], SP[], auth_then_branch);

AArch64.ExceptionReturn(target, SPSR[]);
TAG:aarch64/instrs/branch/unconditional/eret:diagram
A64
31:25 _ 1101011
24:24 _ 0
23:21 _ 100
20:16 _ 11111
15:12 _ 0000
11:11 A x
10:10 M x
9:5 Rn xxxxx
4:0 op4 xxxxx
TAG:aarch64/instrs/branch/unconditional/eret:decode
if PSTATE.EL == EL0 then UNDEFINED;
boolean pac = (A == '1');
boolean use_key_a = (M == '0');

if !pac && op4 != '00000' then
    UNDEFINED;
elsif pac && (!HavePACExt() || op4 != '11111') then
    UNDEFINED;

if Rn != '11111' then 
    UNDEFINED;

TAG:aarch64/branch/unconditional/eret:index
Execute: aarch64/branch/unconditional/eret:execute
Decode: aarch64/instrs/branch/unconditional/eret:decode@aarch64/instrs/branch/unconditional/eret:diagram
TAG:aarch64/vector/reduce/fp16-maxnm/simd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/fp16-maxnm/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 o1 x
22:22 _ 0
21:17 _ 11000
16:12 _ 01100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp16-maxnm/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

TAG:aarch64/instrs/vector/reduce/fp-maxnm/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp-maxnm/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q != '01' then UNDEFINED; // .4S only

integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

TAG:aarch64/vector/reduce/fp16-maxnm/simd:index
Execute: aarch64/vector/reduce/fp16-maxnm/simd:execute
Decode: aarch64/instrs/vector/reduce/fp16-maxnm/simd:decode@aarch64/instrs/vector/reduce/fp16-maxnm/simd:diagram
Decode: aarch64/instrs/vector/reduce/fp-maxnm/simd:decode@aarch64/instrs/vector/reduce/fp-maxnm/simd:diagram
TAG:aarch64/float/arithmetic/max-min:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

case operation of
    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);
    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);
    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);
    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/max-min:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 01
13:12 op xx
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/max-min:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

FPMaxMinOp operation;
case op of
    when '00' operation = FPMaxMinOp_MAX;
    when '01' operation = FPMaxMinOp_MIN;
    when '10' operation = FPMaxMinOp_MAXNUM;
    when '11' operation = FPMaxMinOp_MINNUM;

TAG:aarch64/float/arithmetic/max-min:index
Execute: aarch64/float/arithmetic/max-min:execute
Decode: aarch64/instrs/float/arithmetic/max-min:decode@aarch64/instrs/float/arithmetic/max-min:diagram
TAG:aarch64/integer/bitfield:execute
bits(datasize) dst = if inzero then Zeros() else X[d];
bits(datasize) src = X[n];

// perform bitfield move on low bits
bits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);

// determine extension bits (sign, zero or dest register)
bits(datasize) top = if extend then Replicate(src[S]) else dst;

// combine extension bits and result bits
X[d] = (top AND NOT(tmask)) OR (bot AND tmask);
TAG:aarch64/instrs/integer/bitfield:diagram
A64
31:31 sf x
30:29 opc xx
28:23 _ 100110
22:22 N x
21:16 immr xxxxxx
15:10 imms xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/bitfield:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;

boolean inzero;
boolean extend;
integer R;
integer S;
bits(datasize) wmask;
bits(datasize) tmask;

case opc of
    when '00' inzero = TRUE;  extend = TRUE;    // SBFM
    when '01' inzero = FALSE; extend = FALSE;   // BFM
    when '10' inzero = TRUE;  extend = FALSE;   // UBFM
    when '11' UNDEFINED;

if sf == '1' && N != '1' then UNDEFINED;
if sf == '0' && (N != '0' || immr[5] != '0' || imms[5] != '0') then UNDEFINED;

R = UInt(immr);
S = UInt(imms);
(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);

TAG:aarch64/integer/bitfield:index
Execute: aarch64/integer/bitfield:execute
Decode: aarch64/instrs/integer/bitfield:decode@aarch64/instrs/integer/bitfield:diagram
TAG:aarch64/vector/arithmetic/unary/rev:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element = 0;
integer rev_element;
for c = 0 to containers-1
    rev_element = element + elements_per_container - 1;
    for e = 0 to elements_per_container-1
        Elem[result, rev_element, esize] = Elem[operand, element, esize];
        element = element + 1;
        rev_element = rev_element - 1;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/rev:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:13 _ 0000
12:12 o0 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/rev:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

// size=esize:   B(0),  H(1),  S(1), D(S)
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;

// op=REVx: 64(0), 32(1), 16(2)
bits(2) op = o0:U; 

// => op+size: 
//    64+B = 0, 64+H = 1, 64+S = 2, 64+D = X
//    32+B = 1, 32+H = 2, 32+S = X, 32+D = X
//    16+B = 2, 16+H = X, 16+S = X, 16+D = X
//     8+B = X,  8+H = X,  8+S = X,  8+D = X
// => 3-(op+size) (index bits in group)
//    64/B = 3, 64+H = 2, 64+S = 1, 64+D = X
//    32+B = 2, 32+H = 1, 32+S = X, 32+D = X
//    16+B = 1, 16+H = X, 16+S = X, 16+D = X
//     8+B = X,  8+H = X,  8+S = X,  8+D = X

// index bits within group: 1, 2, 3
if UInt(op)+UInt(size) >= 3 then UNDEFINED;

integer container_size;
case op of
    when '10' container_size = 16;
    when '01' container_size = 32;
    when '00' container_size = 64;

integer containers = datasize DIV container_size;
integer elements_per_container = container_size DIV esize;

TAG:aarch64/vector/arithmetic/unary/rev:index
Execute: aarch64/vector/arithmetic/unary/rev:execute
Decode: aarch64/instrs/vector/arithmetic/unary/rev:decode@aarch64/instrs/vector/arithmetic/unary/rev:diagram
TAG:LASTA-V.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer last = LastActiveElement(mask, esize);

if isBefore then
    if last < 0 then last = elements - 1;
else
    last = last + 1;
    if last >= elements then last = 0;
V[d] = Elem[operand, last, esize];
TAG:LASTA-V.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10001
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:LASTA-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean isBefore = FALSE;

TAG:LASTA-V.P.Z-_:index
Execute: LASTA-V.P.Z-_:execute
Decode: LASTA-V.P.Z-_:decode@LASTA-V.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/double/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(idxdsize)   operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
integer accum;
boolean sat1;
boolean sat2;

element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);
    if sub_op then
        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);
    else
        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);
    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);
    if sat1 || sat2 then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 11
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
integer part = 0;

boolean sub_op = (o2 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 11
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean sub_op = (o2 == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/double/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/double/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/double/simd:diagram
TAG:aarch64/integer/arithmetic/add-sub/carry:execute
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(4) nzcv;

if sub_op then
    operand2 = NOT(operand2);

(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);

if setflags then 
    PSTATE.[N,Z,C,V] = nzcv;

X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/add-sub/carry:diagram
A64
31:31 sf x
30:30 op x
29:29 S x
28:21 _ 11010000
20:16 Rm xxxxx
15:10 _ 000000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/add-sub/carry:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
boolean setflags = (S == '1');

TAG:aarch64/integer/arithmetic/add-sub/carry:index
Execute: aarch64/integer/arithmetic/add-sub/carry:execute
Decode: aarch64/instrs/integer/arithmetic/add-sub/carry:decode@aarch64/instrs/integer/arithmetic/add-sub/carry:diagram
TAG:WHILELS-P.P.RR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = Ones(PL);
bits(rsize) operand1 = X[n];
bits(rsize) operand2 = X[m];
bits(PL) result;
boolean last = TRUE;

for e = 0 to elements-1
    boolean cond;
    case op of
        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));

    last = last && cond;
    ElemP[result, e, esize] = if last then '1' else '0';
    operand1 = operand1 + 1;

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:WHILELS-P.P.RR-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 000
12:12 sf x
11:11 _ 1
10:10 _ 1
9:5 Rn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:WHILELS-P.P.RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = 32 << UInt(sf);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Pd);
boolean unsigned = TRUE;
SVECmp op = Cmp_LE;

TAG:WHILELS-P.P.RR-_:index
Execute: WHILELS-P.P.RR-_:execute
Decode: WHILELS-P.P.RR-_:decode@WHILELS-P.P.RR-_:diagram
TAG:UQSUB-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);

Z[dn] = result;
TAG:UQSUB-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 11
16:16 _ 1
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:UQSUB-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;
boolean unsigned = TRUE;

TAG:UQSUB-Z.ZI-_:index
Execute: UQSUB-Z.ZI-_:execute
Decode: UQSUB-Z.ZI-_:decode@UQSUB-Z.ZI-_:diagram
TAG:ADD-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    Elem[result, e, esize] = element1 + imm;

Z[dn] = result;
TAG:ADD-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 00
16:16 _ 0
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:ADD-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:ADD-Z.ZI-_:index
Execute: ADD-Z.ZI-_:execute
Decode: ADD-Z.ZI-_:decode@ADD-Z.ZI-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/max-min/fp16/1985:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    if pair then
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    else
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];

    if minimum then
        Elem[result, e, esize] = FPMin(element1, element2, FPCR);
    else
        Elem[result, e, esize] = FPMax(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o1 x
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 110
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o1 x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11110
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');
boolean minimum = (o1 == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/max-min/fp16/1985:index
Execute: aarch64/vector/arithmetic/binary/uniform/max-min/fp16/1985:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp16/1985:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/fp/1985:diagram
TAG:aarch64/vector/reduce/int-max:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer maxmin;
integer element;

maxmin = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
    element = Int(Elem[operand, e, esize], unsigned);
    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);

V[d] = maxmin[esize-1:0];
TAG:aarch64/instrs/vector/reduce/int-max:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 11000
16:16 op x
15:12 _ 1010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/int-max:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean min = (op == '1');

TAG:aarch64/vector/reduce/int-max:index
Execute: aarch64/vector/reduce/int-max:execute
Decode: aarch64/instrs/vector/reduce/int-max:decode@aarch64/instrs/vector/reduce/int-max:diagram
TAG:aarch64/integer/arithmetic/rbit:execute
bits(datasize) operand = X[n];
bits(datasize) result;

for i = 0 to datasize-1
    result[datasize-1-i] = operand[i];

X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/rbit:diagram
A64
31:31 sf x
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00000
15:12 _ 0000
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/rbit:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer datasize = if sf == '1' then 64 else 32;

TAG:aarch64/integer/arithmetic/rbit:index
Execute: aarch64/integer/arithmetic/rbit:execute
Decode: aarch64/instrs/integer/arithmetic/rbit:decode@aarch64/instrs/integer/arithmetic/rbit:diagram
TAG:UQDECB-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQDECB-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECB-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQDECB-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECB-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQDECB-R.RS-UW:index
Execute: UQDECB-R.RS-UW:execute
Decode: UQDECB-R.RS-UW:decode@UQDECB-R.RS-UW:diagram
Decode: UQDECB-R.RS-X:decode@UQDECB-R.RS-X:diagram
TAG:STNT1D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
constant integer mbytes = esize DIV 8;
bits(VL) src;
bits(PL) mask = P[g];

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];
src = Z[t];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    addr = addr + mbytes;
TAG:STNT1D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:20 _ 001
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);

TAG:STNT1D-Z.P.BI-Contiguous:index
Execute: STNT1D-Z.P.BI-Contiguous:execute
Decode: STNT1D-Z.P.BI-Contiguous:decode@STNT1D-Z.P.BI-Contiguous:diagram
TAG:aarch64/float/compare/cond:execute
CheckFPAdvSIMDEnabled64();

bits(datasize) operand1 = V[n];
bits(datasize) operand2;

operand2 = V[m];

if ConditionHolds(condition) then
    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);
PSTATE.[N,Z,C,V] = flags;
TAG:aarch64/instrs/float/compare/cond:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:12 cond xxxx
11:10 _ 01
9:5 Rn xxxxx
4:4 op x
3:0 nzcv xxxx
TAG:aarch64/instrs/float/compare/cond:decode
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean signal_all_nans = (op == '1');
bits(4) condition = cond;
bits(4) flags = nzcv;

TAG:aarch64/float/compare/cond:index
Execute: aarch64/float/compare/cond:execute
Decode: aarch64/instrs/float/compare/cond:decode@aarch64/instrs/float/compare/cond:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/accum:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    product = (UInt(element1) * UInt(element2))[esize-1:0];
    if sub_op then
        Elem[result, e, esize] = Elem[operand3, e, esize] - product;
    else
        Elem[result, e, esize] = Elem[operand3, e, esize] + product;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/accum:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/accum:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/accum:diagram
TAG:LD1B-Z.P.BZ-D.x32.unscaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1B-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1B-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1B-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1B-Z.P.BZ-D.x32.unscaled:index
Execute: LD1B-Z.P.BZ-D.x32.unscaled:execute
Decode: LD1B-Z.P.BZ-D.x32.unscaled:decode@LD1B-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1B-Z.P.BZ-S.x32.unscaled:decode@LD1B-Z.P.BZ-S.x32.unscaled:diagram
Decode: LD1B-Z.P.BZ-D.64.unscaled:decode@LD1B-Z.P.BZ-D.64.unscaled:diagram
TAG:ORR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 OR element2;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ORR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:ORR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:ORR-Z.P.ZZ-_:index
Execute: ORR-Z.P.ZZ-_:execute
Decode: ORR-Z.P.ZZ-_:decode@ORR-Z.P.ZZ-_:diagram
TAG:SMMLA-Z.ZZZ-_:execute
CheckSVEEnabled();
integer segments = VL DIV 128;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result = Zeros();
bits(128) op1, op2;
bits(128) res, addend;

for s = 0 to segments-1
    op1    = Elem[operand1, s, 128];
    op2    = Elem[operand2, s, 128];
    addend = Elem[operand3, s, 128];
    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);
    Elem[result, s, 128] = res;

Z[da] = result;
TAG:SMMLA-Z.ZZZ-_:diagram
A64
31:24 _ 01000101
23:23 _ 0
22:22 _ 0
21:21 _ 0
20:16 Zm xxxxx
15:10 _ 100110
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:SMMLA-Z.ZZZ-_:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_unsigned = FALSE;
boolean op2_unsigned = FALSE;

TAG:SMMLA-Z.ZZZ-_:index
Execute: SMMLA-Z.ZZZ-_:execute
Decode: SMMLA-Z.ZZZ-_:decode@SMMLA-Z.ZZZ-_:diagram
TAG:aarch64/vector/transfer/vector/insert:execute
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(128) result;

result = V[d];
Elem[result, dst_index, esize] = Elem[operand, src_index, esize];
V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/insert:diagram
A64
31:31 _ 0
30:30 _ 1
29:29 _ 1
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:11 imm4 xxxx
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/insert:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;

integer dst_index = UInt(imm5[4:size+1]);
integer src_index = UInt(imm4[3:size]);
integer idxdsize = if imm4[3] == '1' then 128 else 64; 
// imm4[size-1:0] is IGNORED 

integer esize = 8 << size;

TAG:aarch64/vector/transfer/vector/insert:index
Execute: aarch64/vector/transfer/vector/insert:execute
Decode: aarch64/instrs/vector/transfer/vector/insert:decode@aarch64/instrs/vector/transfer/vector/insert:diagram
TAG:LDFF1B-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1B-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1B-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1B-Z.P.AI-S:index
Execute: LDFF1B-Z.P.AI-S:execute
Decode: LDFF1B-Z.P.AI-S:decode@LDFF1B-Z.P.AI-S:diagram
Decode: LDFF1B-Z.P.AI-D:decode@LDFF1B-Z.P.AI-D:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/mul/poly:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1110
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '01' || size == '10' then UNDEFINED;
if size == '11' && !HaveBit128PMULLExt() then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/disparate/mul/poly:index
Execute: aarch64/vector/arithmetic/binary/disparate/mul/poly:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/poly:diagram
TAG:aarch64/memory/single/general/register:execute
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/register:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
AccType acctype = AccType_NORMAL;
MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        memop = MemOp_PREFETCH;
        if opc[0] == '1' then UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH;

TAG:aarch64/instrs/memory/single/general/register:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:22 opc xx
21:21 _ 1
20:16 Rm xxxxx
15:13 option xxx
12:12 S x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/register:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
if option[1] == '0' then UNDEFINED;             // sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

TAG:aarch64/memory/single/general/register:index
Execute: aarch64/memory/single/general/register:execute
Postdecode: aarch64/memory/single/general/register:postdecode
Decode: aarch64/instrs/memory/single/general/register:decode@aarch64/instrs/memory/single/general/register:diagram
TAG:MUL-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    integer element2 = UInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        integer product = element1 * element2;
        Elem[result, e, esize] = product[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:MUL-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0100
17:17 _ 0
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:MUL-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:MUL-Z.P.ZZ-_:index
Execute: MUL-Z.P.ZZ-_:execute
Decode: MUL-Z.P.ZZ-_:decode@MUL-Z.P.ZZ-_:diagram
TAG:aarch64/vector/reduce/fp16-max/simd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/fp16-max/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 o1 x
22:22 _ 0
21:17 _ 11000
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp16-max/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

TAG:aarch64/instrs/vector/reduce/fp-max/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp-max/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q != '01' then UNDEFINED;

integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

TAG:aarch64/vector/reduce/fp16-max/simd:index
Execute: aarch64/vector/reduce/fp16-max/simd:execute
Decode: aarch64/instrs/vector/reduce/fp16-max/simd:decode@aarch64/instrs/vector/reduce/fp16-max/simd:diagram
Decode: aarch64/instrs/vector/reduce/fp-max/simd:decode@aarch64/instrs/vector/reduce/fp-max/simd:diagram
TAG:LD4B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 4;

TAG:LD4B-Z.P.BR-Contiguous:index
Execute: LD4B-Z.P.BR-Contiguous:execute
Decode: LD4B-Z.P.BR-Contiguous:decode@LD4B-Z.P.BR-Contiguous:diagram
TAG:MSB-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    integer element2 = UInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        integer product = element1 * element2;
        if sub_op then
            Elem[result, e, esize] = Elem[operand3, e, esize] - product;
        else
            Elem[result, e, esize] = Elem[operand3, e, esize] + product;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:MSB-Z.P.ZZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:14 _ 11
13:13 _ 1
12:10 Pg xxx
9:5 Za xxxxx
4:0 Zdn xxxxx
TAG:MSB-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean sub_op = TRUE;

TAG:MSB-Z.P.ZZZ-_:index
Execute: MSB-Z.P.ZZZ-_:execute
Decode: MSB-Z.P.ZZZ-_:decode@MSB-Z.P.ZZZ-_:diagram
TAG:INCP-R.P.R-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) operand1 = X[dn];
bits(PL) operand2 = P[m];
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

X[dn] = operand1 + count;
TAG:INCP-R.P.R-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1011
17:17 _ 0
16:16 _ 0
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:INCP-R.P.R-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);

TAG:INCP-R.P.R-_:index
Execute: INCP-R.P.R-_:execute
Decode: INCP-R.P.R-_:decode@INCP-R.P.R-_:diagram
TAG:aarch64/float/arithmetic/mul/product:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

result = FPMul(operand1, operand2, FPCR);

if negated then result = FPNeg(result);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/mul/product:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:15 op x
14:12 _ 000
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/mul/product:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean negated = (op == '1');

TAG:aarch64/float/arithmetic/mul/product:index
Execute: aarch64/float/arithmetic/mul/product:execute
Decode: aarch64/instrs/float/arithmetic/mul/product:decode@aarch64/instrs/float/arithmetic/mul/product:diagram
TAG:aarch64/vector/arithmetic/unary/diff-neg/sat/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean sat;

for e = 0 to elements-1
    element = SInt(Elem[operand, e, esize]);
    if neg then
        element = -element;
    else
        element = Abs(element);
    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 00111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean neg = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 00111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

TAG:aarch64/vector/arithmetic/unary/diff-neg/sat/sisd:index
Execute: aarch64/vector/arithmetic/unary/diff-neg/sat/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/sat/simd:diagram
TAG:aarch64/vector/arithmetic/binary/element/dotp:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128) operand2 = V[m];
bits(datasize) result = V[d];
for e = 0 to elements-1 
    integer res = 0;
    integer element1, element2;
    for i = 0 to 3
        if signed then  
            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);
        else 
            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);
        res = res + element1 * element2; 
    Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/dotp:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1110
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/dotp:decode
if !HaveDOTPExt() then UNDEFINED;
if size  != '10' then UNDEFINED;
boolean signed = (U=='0');

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer index = UInt(H:L);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/element/dotp:index
Execute: aarch64/vector/arithmetic/binary/element/dotp:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/dotp:decode@aarch64/instrs/vector/arithmetic/binary/element/dotp:diagram
TAG:aarch64/float/compare/uncond:execute
CheckFPAdvSIMDEnabled64();

bits(datasize) operand1 = V[n];
bits(datasize) operand2;

operand2 = if cmp_with_zero then FPZero('0') else V[m];

PSTATE.[N,Z,C,V] = FPCompare(operand1, operand2, signal_all_nans, FPCR);
TAG:aarch64/instrs/float/compare/uncond:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 00
13:10 _ 1000
9:5 Rn xxxxx
4:3 opc xx
2:0 _ 000
TAG:aarch64/instrs/float/compare/uncond:decode
integer n = UInt(Rn);
integer m = UInt(Rm);   // ignored when opc[0] == '1'

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean signal_all_nans = (opc[1] == '1');
boolean cmp_with_zero = (opc[0] == '1');

TAG:aarch64/float/compare/uncond:index
Execute: aarch64/float/compare/uncond:execute
Decode: aarch64/instrs/float/compare/uncond:decode@aarch64/instrs/float/compare/uncond:diagram
TAG:aarch64/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 o2 x
22:17 _ 111100
16:13 _ 1101
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 o2 x
22:22 sz x
21:17 _ 10000
16:13 _ 1101
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o2 x
22:17 _ 111100
16:13 _ 1101
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o2 x
22:22 sz x
21:17 _ 10000
16:13 _ 1101
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

FPRounding rounding = FPDecodeRounding(o1:o2);
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:index
Execute: aarch64/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/bulk/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/float/bulk/simd:diagram
TAG:aarch64/system/barriers/dsb:execute
DataSynchronizationBarrier(domain, types);
TAG:aarch64/instrs/system/barriers/dsb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/dsb:decode
case CRm[3:2] of
    when '00' domain = MBReqDomain_OuterShareable;
    when '01' domain = MBReqDomain_Nonshareable; 
    when '10' domain = MBReqDomain_InnerShareable;
    when '11' domain = MBReqDomain_FullSystem;
case CRm[1:0] of
    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
    when '01' types = MBReqTypes_Reads;
    when '10' types = MBReqTypes_Writes;
    when '11' types = MBReqTypes_All;

TAG:aarch64/system/barriers/dsb:index
Execute: aarch64/system/barriers/dsb:execute
Decode: aarch64/instrs/system/barriers/dsb:decode@aarch64/instrs/system/barriers/dsb:diagram
TAG:aarch64/integer/tags/mcsubtag:execute
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);
bits(16) exclude = GCR_EL1.Exclude;
bits(64) result;
bits(4) rtag;

if AArch64.AllocationTagAccessIsEnabled() then
    rtag = AArch64.ChooseNonExcludedTag(start_tag, tag_offset, exclude);
else
    rtag = '0000';

if ADD then
    (result, -) = AddWithCarry(operand1, offset, '0');
else
    (result, -) = AddWithCarry(operand1, NOT(offset), '1');

result = AArch64.AddressWithAllocationTag(result, rtag);

if d == 31 then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/tags/mcsubtag:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:23 _ 100011
22:22 _ 0
21:16 uimm6 xxxxxx
15:14 op3 xx
13:10 uimm4 xxxx
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/tags/mcsubtag:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
bits(4) tag_offset = uimm4;
bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
boolean ADD = FALSE;

TAG:aarch64/integer/tags/mcsubtag:index
Execute: aarch64/integer/tags/mcsubtag:execute
Decode: aarch64/instrs/integer/tags/mcsubtag:decode@aarch64/instrs/integer/tags/mcsubtag:diagram
TAG:aarch64/integer/conditional/compare/immediate:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = imm;
bit carry_in = '0';

if ConditionHolds(condition) then
    if sub_op then
        operand2 = NOT(operand2);
        carry_in = '1';
    (-, flags) = AddWithCarry(operand1, operand2, carry_in);
PSTATE.[N,Z,C,V] = flags;
TAG:aarch64/instrs/integer/conditional/compare/immediate:diagram
A64
31:31 sf x
30:30 op x
29:29 _ 1
28:21 _ 11010010
20:16 imm5 xxxxx
15:12 cond xxxx
11:11 _ 1
10:10 _ 0
9:5 Rn xxxxx
4:4 _ 0
3:0 nzcv xxxx
TAG:aarch64/instrs/integer/conditional/compare/immediate:decode
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
bits(4) condition = cond;
bits(4) flags = nzcv;
bits(datasize) imm = ZeroExtend(imm5, datasize);

TAG:aarch64/integer/conditional/compare/immediate:index
Execute: aarch64/integer/conditional/compare/immediate:execute
Decode: aarch64/instrs/integer/conditional/compare/immediate:decode@aarch64/instrs/integer/conditional/compare/immediate:diagram
TAG:aarch64/integer/arithmetic/div:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
integer result;

if IsZero(operand2) then
    result = 0;
else
    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));

X[d] = result[datasize-1:0];
TAG:aarch64/instrs/integer/arithmetic/div:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Rm xxxxx
15:11 _ 00001
10:10 o1 x
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/div:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean unsigned = (o1 == '0');

TAG:aarch64/integer/arithmetic/div:index
Execute: aarch64/integer/arithmetic/div:execute
Decode: aarch64/instrs/integer/arithmetic/div:decode@aarch64/instrs/integer/arithmetic/div:diagram
TAG:BFDOT-Z.ZZZi-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
integer eltspersegment = 128 DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
    bits(16) elt2_a = Elem[operand2, 2 * s + 0, 16];
    bits(16) elt2_b = Elem[operand2, 2 * s + 1, 16];

    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);

Z[da] = result;
TAG:BFDOT-Z.ZZZi-_:diagram
A64
31:23 _ 011001000
22:22 _ 1
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:10 _ 010000
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFDOT-Z.ZZZi-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer index = UInt(i2);

TAG:BFDOT-Z.ZZZi-_:index
Execute: BFDOT-Z.ZZZi-_:execute
Decode: BFDOT-Z.ZZZi-_:decode@BFDOT-Z.ZZZi-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/shift/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

integer round_const = 0;
integer shift;
integer element;
boolean sat;

for e = 0 to elements-1
    shift = SInt(Elem[operand2, e, esize][7:0]);
    if rounding then
        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift 
    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;
    if saturating then
        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
        if sat then FPSR.QC = '1';
    else
        Elem[result, e, esize] = element[esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:12 R x
11:11 S x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');
if S == '0' && size != '11' then UNDEFINED;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:12 R x
11:11 S x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');
boolean rounding = (R == '1');
boolean saturating = (S == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/shift/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/shift/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/shift/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/shift/simd:diagram
TAG:aarch64/memory/atomicops/swp:execute
bits(64) address;
bits(datasize) data;
bits(datasize) store_value;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

store_value = X[s];
data = MemAtomic(address, MemAtomicOp_SWP, store_value, ldacctype, stacctype);
X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/atomicops/swp:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:23 A x
22:22 R x
21:21 _ 1
20:16 Rs xxxxx
15:15 _ 1
14:12 _ 000
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/atomicops/swp:decode
if !HaveAtomicExt() then UNDEFINED;

integer t = UInt(Rt);
integer n = UInt(Rn);
integer s = UInt(Rs);

integer datasize = 8 << UInt(size);
integer regsize = if datasize == 64 then 64 else 32;
AccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if R == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

TAG:aarch64/memory/atomicops/swp:index
Execute: aarch64/memory/atomicops/swp:execute
Decode: aarch64/instrs/memory/atomicops/swp:decode@aarch64/instrs/memory/atomicops/swp:diagram
TAG:aarch64/memory/single/general/immediate/signed/offset/unpriv:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/immediate/signed/offset/unpriv:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);

unpriv_at_el1 = PSTATE.EL == EL1 && !(EL2Enabled() && HaveNVExt() && HCR_EL2.[NV,NV1] == '11');
unpriv_at_el2 = PSTATE.EL == EL2 && HaveVirtHostExt() && HCR_EL2.[E2H,TGE] == '11';

user_access_override = HaveUAOExt() && PSTATE.UAO == '1';
if !user_access_override && (unpriv_at_el1 || unpriv_at_el2) then
    acctype = AccType_UNPRIV;
else
    acctype = AccType_NORMAL;

MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 10
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/memory/single/general/immediate/signed/offset/unpriv:index
Execute: aarch64/memory/single/general/immediate/signed/offset/unpriv:execute
Postdecode: aarch64/memory/single/general/immediate/signed/offset/unpriv:postdecode
Decode: aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv:decode@aarch64/instrs/memory/single/general/immediate/signed/offset/unpriv:diagram
TAG:LD2W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:LD2W-Z.P.BI-Contiguous:index
Execute: LD2W-Z.P.BI-Contiguous:execute
Decode: LD2W-Z.P.BI-Contiguous:decode@LD2W-Z.P.BI-Contiguous:diagram
TAG:PNEXT-P.P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand = P[dn];
bits(PL) result;

integer next = LastActiveElement(operand, esize) + 1;

while next < elements && (ElemP[mask, next, esize] == '0') do
    next = next + 1;

result = Zeros();
if next < elements then
    ElemP[result, next, esize] = '1';

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[dn] = result;
TAG:PNEXT-P.P.P-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:10 _ 011001110001
9:9 _ 0
8:5 Pg xxxx
4:4 _ 0
3:0 Pdn xxxx
TAG:PNEXT-P.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Pdn);

TAG:PNEXT-P.P.P-_:index
Execute: PNEXT-P.P.P-_:execute
Decode: PNEXT-P.P.P-_:decode@PNEXT-P.P.P-_:diagram
TAG:SQINCW-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQINCW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQINCW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQINCW-Z.ZS-_:index
Execute: SQINCW-Z.ZS-_:execute
Decode: SQINCW-Z.ZS-_:decode@SQINCW-Z.ZS-_:diagram
TAG:ST4D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST4D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:ST4D-Z.P.BI-Contiguous:index
Execute: ST4D-Z.P.BI-Contiguous:execute
Decode: ST4D-Z.P.BI-Contiguous:decode@ST4D-Z.P.BI-Contiguous:diagram
TAG:aarch64/float/arithmetic/mul/add-sub:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operanda = V[a];
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

if opa_neg then operanda = FPNeg(operanda);
if op1_neg then operand1 = FPNeg(operand1);
result = FPMulAdd(operanda, operand1, operand2, FPCR);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/mul/add-sub:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11111
23:22 ftype xx
21:21 o1 x
20:16 Rm xxxxx
15:15 o0 x
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/mul/add-sub:decode
integer d = UInt(Rd);
integer a = UInt(Ra);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean opa_neg = (o1 == '1');
boolean op1_neg = (o0 != o1);

TAG:aarch64/float/arithmetic/mul/add-sub:index
Execute: aarch64/float/arithmetic/mul/add-sub:execute
Decode: aarch64/instrs/float/arithmetic/mul/add-sub:decode@aarch64/instrs/float/arithmetic/mul/add-sub:diagram
TAG:SQDECH-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQDECH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQDECH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQDECH-Z.ZS-_:index
Execute: SQDECH-Z.ZS-_:execute
Decode: SQDECH-Z.ZS-_:decode@SQDECH-Z.ZS-_:diagram
TAG:aarch64/float/arithmetic/round/frint_32_64:execute
CheckFPAdvSIMDEnabled64();

bits(datasize) result;
bits(datasize) operand = V[n];

result = FPRoundIntN(operand, FPCR, rounding, intsize);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/round/frint_32_64:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:17 _ 0100
16:15 op xx
14:10 _ 10000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/round/frint_32_64:decode
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '1x' UNDEFINED;

integer intsize = if op[1] == '0' then 32 else 64;

FPRounding rounding = if op[0] == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

TAG:aarch64/float/arithmetic/round/frint_32_64:index
Execute: aarch64/float/arithmetic/round/frint_32_64:execute
Decode: aarch64/instrs/float/arithmetic/round/frint_32_64:decode@aarch64/instrs/float/arithmetic/round/frint_32_64:diagram
TAG:PUNPKHI-P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) operand = P[n];
bits(PL) result;

for e = 0 to elements-1
    ElemP[result, e, esize] = ElemP[operand, if hi then e + elements else e, esize DIV 2];

P[d] = result;
TAG:PUNPKHI-P.P-_:diagram
A64
31:17 _ 000001010011000
16:16 _ 1
15:10 _ 010000
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:PUNPKHI-P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean hi = TRUE;

TAG:PUNPKLO-P.P-_:diagram
A64
31:17 _ 000001010011000
16:16 _ 0
15:10 _ 010000
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:PUNPKLO-P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean hi = FALSE;

TAG:PUNPKHI-P.P-_:index
Execute: PUNPKHI-P.P-_:execute
Decode: PUNPKHI-P.P-_:decode@PUNPKHI-P.P-_:diagram
Decode: PUNPKLO-P.P-_:decode@PUNPKLO-P.P-_:diagram
TAG:LD2D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 2;

TAG:LD2D-Z.P.BR-Contiguous:index
Execute: LD2D-Z.P.BR-Contiguous:execute
Decode: LD2D-Z.P.BR-Contiguous:decode@LD2D-Z.P.BR-Contiguous:diagram
TAG:aarch64/branch/conditional/compare:execute
bits(datasize) operand1 = X[t];

if IsZero(operand1) == iszero then
    BranchTo(PC[] + offset, BranchType_DIR);
TAG:aarch64/instrs/branch/conditional/compare:diagram
A64
31:31 sf x
30:25 _ 011010
24:24 op x
23:5 imm19 xxxxxxxxxxxxxxxxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/branch/conditional/compare:decode
integer t = UInt(Rt);
integer datasize = if sf == '1' then 64 else 32;
boolean iszero = (op == '0');
bits(64) offset = SignExtend(imm19:'00', 64);

TAG:aarch64/branch/conditional/compare:index
Execute: aarch64/branch/conditional/compare:execute
Decode: aarch64/instrs/branch/conditional/compare:decode@aarch64/instrs/branch/conditional/compare:diagram
TAG:FCMEQ-P.P.Z0-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(PL) result;

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        case op of
            when Cmp_EQ res = FPCompareEQ(element, 0[esize-1:0], FPCR);
            when Cmp_GE res = FPCompareGE(element, 0[esize-1:0], FPCR);
            when Cmp_GT res = FPCompareGT(element, 0[esize-1:0], FPCR);
            when Cmp_NE res = FPCompareNE(element, 0[esize-1:0], FPCR);
            when Cmp_LT res = FPCompareGT(0[esize-1:0], element, FPCR);
            when Cmp_LE res = FPCompareGE(0[esize-1:0], element, FPCR);
        ElemP[result, e, esize] = if res then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

P[d] = result;
TAG:FCMEQ-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 1
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMEQ-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_EQ;

TAG:FCMGT-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 0
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FCMGT-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;

TAG:FCMGE-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 0
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMGE-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;

TAG:FCMLT-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 0
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMLT-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LT;

TAG:FCMLE-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 0
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FCMLE-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LE;

TAG:FCMNE-P.P.Z0-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0100
17:17 _ 1
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMNE-P.P.Z0-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_NE;

TAG:FCMEQ-P.P.Z0-_:index
Execute: FCMEQ-P.P.Z0-_:execute
Decode: FCMEQ-P.P.Z0-_:decode@FCMEQ-P.P.Z0-_:diagram
Decode: FCMGT-P.P.Z0-_:decode@FCMGT-P.P.Z0-_:diagram
Decode: FCMGE-P.P.Z0-_:decode@FCMGE-P.P.Z0-_:diagram
Decode: FCMLT-P.P.Z0-_:decode@FCMLT-P.P.Z0-_:diagram
Decode: FCMLE-P.P.Z0-_:decode@FCMLE-P.P.Z0-_:diagram
Decode: FCMNE-P.P.Z0-_:decode@FCMNE-P.P.Z0-_:diagram
TAG:SUNPKHI-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer hsize = esize DIV 2;
bits(VL) operand = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];
    Elem[result, e, esize] = Extend(element, esize, unsigned);

Z[d] = result;
TAG:SUNPKHI-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1100
17:17 _ 0
16:16 _ 1
15:10 _ 001110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SUNPKHI-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = FALSE;
boolean hi = TRUE;

TAG:SUNPKLO-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1100
17:17 _ 0
16:16 _ 0
15:10 _ 001110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SUNPKLO-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = FALSE;
boolean hi = FALSE;

TAG:SUNPKHI-Z.Z-_:index
Execute: SUNPKHI-Z.Z-_:execute
Decode: SUNPKHI-Z.Z-_:decode@SUNPKHI-Z.Z-_:diagram
Decode: SUNPKLO-Z.Z-_:decode@SUNPKLO-Z.Z-_:diagram
TAG:TBL-Z.ZZ-1:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer idx = UInt(Elem[operand2, e, esize]);
    Elem[result, e, esize] = if idx < elements then Elem[operand1, idx, esize] else Zeros();

Z[d] = result;
TAG:TBL-Z.ZZ-1:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:TBL-Z.ZZ-1:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:TBL-Z.ZZ-1:index
Execute: TBL-Z.ZZ-1:execute
Decode: TBL-Z.ZZ-1:decode@TBL-Z.ZZ-1:diagram
TAG:aarch64/memory/vector/single/no-wb:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(64) offs;
bits(128) rval;
bits(esize) element;
constant integer ebytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

offs = Zeros();
if replicate then
    // load and replicate to all elements
    for s = 0 to selem-1
        element = Mem[address + offs, ebytes, AccType_VEC];
        // replicate to fill 128- or 64-bit register
        V[t] = Replicate(element, datasize DIV esize);
        offs = offs + ebytes;
        t = (t + 1) MOD 32;
else
    // load/store one element per register
    for s = 0 to selem-1
        rval = V[t];
        if memop == MemOp_LOAD then
            // insert into one lane of 128-bit register
            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];
            V[t] = rval;
        else // memop == MemOp_STORE
            // extract from one lane of 128-bit register
            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];
        offs = offs + ebytes;
        t = (t + 1) MOD 32;

if wback then
    if m != 31 then
        offs = X[m];
    if n == 31 then
        SP[] = address + offs;
    else
        X[n] = address + offs;
TAG:aarch64/memory/vector/single/no-wb:postdecode
integer scale = UInt(opcode[2:1]);
integer selem = UInt(opcode[0]:R) + 1;
boolean replicate = FALSE;
integer index;

case scale of
    when 3
        // load and replicate
        if L == '0' || S == '1' then UNDEFINED;
        scale = UInt(size);
        replicate = TRUE;
    when 0
        index = UInt(Q:S:size);         // B[0-15]
    when 1
        if size[0] == '1' then UNDEFINED;
        index = UInt(Q:S:size[1]);      // H[0-7]
    when 2
        if size[1] == '1' then UNDEFINED;
        if size[0] == '0' then
            index = UInt(Q:S);          // S[0-3]
        else
            if S == '1' then UNDEFINED;
            index = UInt(Q);            // D[0-1]
            scale = 3;

MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = if Q == '1' then 128 else 64;
integer esize = 8 << scale;

TAG:aarch64/instrs/memory/vector/single/no-wb:diagram
A64
31:31 _ 0
30:30 Q x
29:23 _ 0011010
22:22 L x
21:21 R x
20:16 _ 00000
15:13 opcode xxx
12:12 S x
11:10 size xx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/vector/single/no-wb:decode
integer t = UInt(Rt);
integer n = UInt(Rn);
integer m = integer UNKNOWN;
boolean wback = FALSE;
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/vector/single/post-inc:diagram
A64
31:31 _ 0
30:30 Q x
29:23 _ 0011011
22:22 L x
21:21 R x
20:16 Rm xxxxx
15:13 opcode xxx
12:12 S x
11:10 size xx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/vector/single/post-inc:decode
integer t = UInt(Rt);
integer n = UInt(Rn);
integer m = UInt(Rm);
boolean wback = TRUE;
boolean tag_checked = wback || n != 31;

TAG:aarch64/memory/vector/single/no-wb:index
Execute: aarch64/memory/vector/single/no-wb:execute
Postdecode: aarch64/memory/vector/single/no-wb:postdecode
Decode: aarch64/instrs/memory/vector/single/no-wb:decode@aarch64/instrs/memory/vector/single/no-wb:diagram
Decode: aarch64/instrs/memory/vector/single/post-inc:decode@aarch64/instrs/memory/vector/single/post-inc:diagram
TAG:aarch64/integer/arithmetic/address/pc-rel:execute
bits(64) base = PC[];

if page then
    base[11:0] = Zeros(12);

X[d] = base + imm;
TAG:aarch64/instrs/integer/arithmetic/address/pc-rel:diagram
A64
31:31 op x
30:29 immlo xx
28:24 _ 10000
23:5 immhi xxxxxxxxxxxxxxxxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/address/pc-rel:decode
integer d = UInt(Rd);
boolean page = (op == '1');
bits(64) imm;

if page then
    imm = SignExtend(immhi:immlo:Zeros(12), 64);
else
    imm = SignExtend(immhi:immlo, 64);

TAG:aarch64/integer/arithmetic/address/pc-rel:index
Execute: aarch64/integer/arithmetic/address/pc-rel:execute
Decode: aarch64/instrs/integer/arithmetic/address/pc-rel:decode@aarch64/instrs/integer/arithmetic/address/pc-rel:diagram
TAG:FRINTI-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

Z[d] = result;
TAG:FRINTI-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 11
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTI-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:FRINTX-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 11
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTX-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:FRINTA-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 10
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTA-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRounding_TIEAWAY;

TAG:FRINTN-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 00
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTN-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRounding_TIEEVEN;

TAG:FRINTZ-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 01
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTZ-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FRINTM-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 01
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTM-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRounding_NEGINF;

TAG:FRINTP-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 00
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRINTP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean exact = FALSE;
FPRounding rounding = FPRounding_POSINF;

TAG:FRINTI-Z.P.Z-_:index
Execute: FRINTI-Z.P.Z-_:execute
Decode: FRINTI-Z.P.Z-_:decode@FRINTI-Z.P.Z-_:diagram
Decode: FRINTX-Z.P.Z-_:decode@FRINTX-Z.P.Z-_:diagram
Decode: FRINTA-Z.P.Z-_:decode@FRINTA-Z.P.Z-_:diagram
Decode: FRINTN-Z.P.Z-_:decode@FRINTN-Z.P.Z-_:diagram
Decode: FRINTZ-Z.P.Z-_:decode@FRINTZ-Z.P.Z-_:diagram
Decode: FRINTM-Z.P.Z-_:decode@FRINTM-Z.P.Z-_:diagram
Decode: FRINTP-Z.P.Z-_:decode@FRINTP-Z.P.Z-_:diagram
TAG:NAND-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = NOT(element1 AND element2);
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:NAND-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:NAND-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:NANDS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:NANDS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:NAND-P.P.PP-Z:index
Execute: NAND-P.P.PP-Z:execute
Decode: NAND-P.P.PP-Z:decode@NAND-P.P.PP-Z:diagram
Decode: NANDS-P.P.PP-Z:decode@NANDS-P.P.PP-Z:diagram
TAG:aarch64/vector/shift/right-narrow/uniform/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize*2) operand = V[n];
bits(datasize) result;
integer round_const = if round then (1 << (shift - 1)) else 0;
integer element;
boolean sat;

for e = 0 to elements-1
    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;
    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);
    if sat then FPSR.QC = '1';

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/shift/right-narrow/uniform/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:12 _ 1001
11:11 op x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-narrow/uniform/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then UNDEFINED;
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;
integer part = 0;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/shift/right-narrow/uniform/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:12 _ 1001
11:11 op x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-narrow/uniform/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

integer shift = (2 * esize) - UInt(immh:immb);
boolean round = (op == '1');
boolean unsigned = (U == '1');

TAG:aarch64/vector/shift/right-narrow/uniform/sisd:index
Execute: aarch64/vector/shift/right-narrow/uniform/sisd:execute
Decode: aarch64/instrs/vector/shift/right-narrow/uniform/sisd:decode@aarch64/instrs/vector/shift/right-narrow/uniform/sisd:diagram
Decode: aarch64/instrs/vector/shift/right-narrow/uniform/simd:decode@aarch64/instrs/vector/shift/right-narrow/uniform/simd:diagram
TAG:SMIN-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer minimum = Min(element1, element2);
        Elem[result, e, esize] = minimum[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SMIN-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 1
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SMIN-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SMIN-Z.P.ZZ-_:index
Execute: SMIN-Z.P.ZZ-_:execute
Decode: SMIN-Z.P.ZZ-_:decode@SMIN-Z.P.ZZ-_:diagram
TAG:aarch64/vector/shift/left-long:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(datasize*2) result;
integer element;

for e = 0 to elements-1
    element = Int(Elem[operand, e, esize], unsigned) << shift;
    Elem[result, e, 2*esize] = element[2*esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/shift/left-long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 10100
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left-long:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3] == '1' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

integer shift = UInt(immh:immb) - esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/shift/left-long:index
Execute: aarch64/vector/shift/left-long:execute
Decode: aarch64/instrs/vector/shift/left-long:decode@aarch64/instrs/vector/shift/left-long:diagram
TAG:CTERMEQ-RR-_:execute
CheckSVEEnabled();
bits(esize) operand1 = X[n];
bits(esize) operand2 = X[m];
integer element1 = UInt(operand1);
integer element2 = UInt(operand2);
boolean term;

case op of
    when Cmp_EQ term = element1 == element2;
    when Cmp_NE term = element1 != element2;
if term then
    PSTATE.N = '1';
    PSTATE.V = '0';
else
    PSTATE.N = '0';
    PSTATE.V = (NOT PSTATE.C);
TAG:CTERMEQ-RR-_:diagram
A64
31:30 _ 00
29:24 _ 100101
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:10 _ 001000
9:5 Rn xxxxx
4:4 _ 0
3:3 _ 0
2:2 _ 0
1:0 _ 00
TAG:CTERMEQ-RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32 << UInt(sz);
integer n = UInt(Rn);
integer m = UInt(Rm);
SVECmp op = Cmp_EQ;

TAG:CTERMNE-RR-_:diagram
A64
31:30 _ 00
29:24 _ 100101
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:10 _ 001000
9:5 Rn xxxxx
4:4 _ 1
3:3 _ 0
2:2 _ 0
1:0 _ 00
TAG:CTERMNE-RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32 << UInt(sz);
integer n = UInt(Rn);
integer m = UInt(Rm);
SVECmp op = Cmp_NE;

TAG:CTERMEQ-RR-_:index
Execute: CTERMEQ-RR-_:execute
Decode: CTERMEQ-RR-_:decode@CTERMEQ-RR-_:diagram
Decode: CTERMNE-RR-_:decode@CTERMNE-RR-_:diagram
TAG:SQINCH-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQINCH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQINCH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQINCH-Z.ZS-_:index
Execute: SQINCH-Z.ZS-_:execute
Decode: SQINCH-Z.ZS-_:decode@SQINCH-Z.ZS-_:diagram
TAG:WHILELT-P.P.RR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = Ones(PL);
bits(rsize) operand1 = X[n];
bits(rsize) operand2 = X[m];
bits(PL) result;
boolean last = TRUE;

for e = 0 to elements-1
    boolean cond;
    case op of
        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));

    last = last && cond;
    ElemP[result, e, esize] = if last then '1' else '0';
    operand1 = operand1 + 1;

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:WHILELT-P.P.RR-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 000
12:12 sf x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:WHILELT-P.P.RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = 32 << UInt(sf);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Pd);
boolean unsigned = FALSE;
SVECmp op = Cmp_LT;

TAG:WHILELT-P.P.RR-_:index
Execute: WHILELT-P.P.RR-_:execute
Decode: WHILELT-P.P.RR-_:decode@WHILELT-P.P.RR-_:diagram
TAG:SQDECB-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQDECB-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECB-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQDECB-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECB-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQDECB-R.RS-SX:index
Execute: SQDECB-R.RS-SX:execute
Decode: SQDECB-R.RS-SX:decode@SQDECB-R.RS-SX:diagram
Decode: SQDECB-R.RS-X:decode@SQDECB-R.RS-X:diagram
TAG:PRFB-I.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;
bits(VL) offset;

if n == 31 then
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFB-I.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 0;

TAG:PRFB-I.P.BZ-D.x32.scaled:diagram
A64
31:23 _ 110001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 0;

TAG:PRFB-I.P.BZ-D.64.scaled:diagram
A64
31:21 _ 11000100011
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:PRFB-I.P.BZ-S.x32.scaled:index
Execute: PRFB-I.P.BZ-S.x32.scaled:execute
Decode: PRFB-I.P.BZ-S.x32.scaled:decode@PRFB-I.P.BZ-S.x32.scaled:diagram
Decode: PRFB-I.P.BZ-D.x32.scaled:decode@PRFB-I.P.BZ-D.x32.scaled:diagram
Decode: PRFB-I.P.BZ-D.64.scaled:decode@PRFB-I.P.BZ-D.64.scaled:diagram
TAG:aarch64/vector/crypto/sha2op/sha1-sched1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand1 EOR LSR(operand2, 32);
result[31:0]   = ROL(T[31:0],   1);
result[63:32]  = ROL(T[63:32],  1);
result[95:64]  = ROL(T[95:64],  1);
result[127:96] = ROL(T[127:96], 1) EOR ROL(T[31:0], 2);
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sha2op/sha1-sched1:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:17 _ 10100
16:12 _ 00001
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha2op/sha1-sched1:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha2op/sha1-sched1:index
Execute: aarch64/vector/crypto/sha2op/sha1-sched1:execute
Decode: aarch64/instrs/vector/crypto/sha2op/sha1-sched1:decode@aarch64/instrs/vector/crypto/sha2op/sha1-sched1:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;

for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    element3 = SInt(Elem[operand3, e, esize]);
    if sub_op then
        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
    else
        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:12 _ 000
11:11 S x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:decode
if !HaveQRDMLAHExt() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' || size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:12 _ 000
11:11 S x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd:decode
if !HaveQRDMLAHExt() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' || size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean rounding = TRUE;
boolean sub_op = (S == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/doubling/accum/simd:diagram
TAG:aarch64/float/arithmetic/round/frint:execute
CheckFPAdvSIMDEnabled64();

bits(datasize) result;
bits(datasize) operand = V[n];

result = FPRoundInt(operand, FPCR, rounding, exact);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/round/frint:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:18 _ 001
17:15 rmode xxx
14:10 _ 10000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/round/frint:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean exact = FALSE;
FPRounding rounding;
case rmode of
    when '0xx' rounding = FPDecodeRounding(rmode[1:0]);
    when '100' rounding = FPRounding_TIEAWAY;
    when '101' UNDEFINED;
    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
    when '111' rounding = FPRoundingMode(FPCR);

TAG:aarch64/float/arithmetic/round/frint:index
Execute: aarch64/float/arithmetic/round/frint:execute
Decode: aarch64/instrs/float/arithmetic/round/frint:decode@aarch64/instrs/float/arithmetic/round/frint:diagram
TAG:aarch64/vector/shift/left-sat/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;
integer element;
boolean sat;

for e = 0 to elements-1
    element = Int(Elem[operand, e, esize], src_unsigned) << shift;
    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/shift/left-sat/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:13 _ 011
12:12 op x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left-sat/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = esize;
integer elements = 1;

integer shift = UInt(immh:immb) - esize;

boolean src_unsigned;
boolean dst_unsigned;
case op:U of
    when '00' UNDEFINED;
    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

TAG:aarch64/instrs/vector/shift/left-sat/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:13 _ 011
12:12 op x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left-sat/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3]:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer shift = UInt(immh:immb) - esize;

boolean src_unsigned;
boolean dst_unsigned;
case op:U of
    when '00' UNDEFINED;
    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;
    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;
    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;

TAG:aarch64/vector/shift/left-sat/sisd:index
Execute: aarch64/vector/shift/left-sat/sisd:execute
Decode: aarch64/instrs/vector/shift/left-sat/sisd:decode@aarch64/instrs/vector/shift/left-sat/sisd:diagram
Decode: aarch64/instrs/vector/shift/left-sat/simd:decode@aarch64/instrs/vector/shift/left-sat/simd:diagram
TAG:UQINCP-R.P.R-UW:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(ssize) operand1 = X[dn];
bits(PL) operand2 = P[m];
bits(ssize) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

integer element = Int(operand1, unsigned);
(result, -) = SatQ(element + count, ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQINCP-R.P.R-UW:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 1
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:UQINCP-R.P.R-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQINCP-R.P.R-X:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 1
15:11 _ 10001
10:10 _ 1
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:UQINCP-R.P.R-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQINCP-R.P.R-UW:index
Execute: UQINCP-R.P.R-UW:execute
Decode: UQINCP-R.P.R-UW:decode@UQINCP-R.P.R-UW:diagram
Decode: UQINCP-R.P.R-X:decode@UQINCP-R.P.R-X:diagram
TAG:aarch64/vector/reduce/add/simd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/add/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:17 _ 11000
16:12 _ 11011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/add/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

ReduceOp op = ReduceOp_ADD;

TAG:aarch64/vector/reduce/add/simd:index
Execute: aarch64/vector/reduce/add/simd:execute
Decode: aarch64/instrs/vector/reduce/add/simd:decode@aarch64/instrs/vector/reduce/add/simd:diagram
TAG:FADD-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPAdd(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FADD-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FADD-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

TAG:FADD-Z.P.ZS-_:index
Execute: FADD-Z.P.ZS-_:execute
Decode: FADD-Z.P.ZS-_:decode@FADD-Z.P.ZS-_:diagram
TAG:SDOT-Z.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:SDOT-Z.ZZZ-_:diagram
A64
31:24 _ 01000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:SDOT-Z.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:SDOT-Z.ZZZ-_:index
Execute: SDOT-Z.ZZZ-_:execute
Decode: SDOT-Z.ZZZ-_:decode@SDOT-Z.ZZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/long:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    if sub_op then
        sum = element1 - element2;
    else
        sum = element1 + element2;
    Elem[result, e, 2*esize] = sum[2*esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 00
13:13 o1 x
12:12 _ 0
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/long:index
Execute: aarch64/vector/arithmetic/binary/disparate/add-sub/long:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long:decode@aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/long:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mat-mul/int/mla:execute
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) addend   = V[d];

V[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/mla:diagram
A64
31:31 _ 0
30:30 _ 1
29:29 U x
28:24 _ 01110
23:22 _ 10
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:12 _ 010
11:11 B x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/mla:decode
if !HaveInt8MatMulExt() then UNDEFINED;
case B:U of
    when '00' op1_unsigned = FALSE; op2_unsigned = FALSE;
    when '01' op1_unsigned = TRUE;  op2_unsigned = TRUE;
    when '10' op1_unsigned = TRUE;  op2_unsigned = FALSE;
    when '11' UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

TAG:aarch64/vector/arithmetic/binary/uniform/mat-mul/int/mla:index
Execute: aarch64/vector/arithmetic/binary/uniform/mat-mul/int/mla:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/mla:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/mla:diagram
TAG:aarch64/integer/pac/strip/dp_1src:execute
if HavePACExt() then
    X[d] = Strip(X[d], data);
TAG:aarch64/instrs/integer/pac/strip/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 1
13:11 _ 000
10:10 D x
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/strip/dp_1src:decode
boolean data = (D == '1');
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if n != 31 then UNDEFINED;

TAG:aarch64/instrs/integer/pac/strip/hint:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 _ 0000
7:5 _ 111
4:0 _ 11111
TAG:aarch64/instrs/integer/pac/strip/hint:decode
integer d = 30;
boolean data = FALSE;

TAG:aarch64/integer/pac/strip/dp_1src:index
Execute: aarch64/integer/pac/strip/dp_1src:execute
Decode: aarch64/instrs/integer/pac/strip/dp_1src:decode@aarch64/instrs/integer/pac/strip/dp_1src:diagram
Decode: aarch64/instrs/integer/pac/strip/hint:decode@aarch64/instrs/integer/pac/strip/hint:diagram
TAG:PRFW-I.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;
bits(VL) offset;

if n == 31 then
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFW-I.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 2;

TAG:PRFW-I.P.BZ-D.x32.scaled:diagram
A64
31:23 _ 110001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 2;

TAG:PRFW-I.P.BZ-D.64.scaled:diagram
A64
31:21 _ 11000100011
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:PRFW-I.P.BZ-S.x32.scaled:index
Execute: PRFW-I.P.BZ-S.x32.scaled:execute
Decode: PRFW-I.P.BZ-S.x32.scaled:decode@PRFW-I.P.BZ-S.x32.scaled:diagram
Decode: PRFW-I.P.BZ-D.x32.scaled:decode@PRFW-I.P.BZ-D.x32.scaled:diagram
Decode: PRFW-I.P.BZ-D.64.scaled:decode@PRFW-I.P.BZ-D.64.scaled:diagram
TAG:ADDPL-R.RI-_:execute
CheckSVEEnabled();
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(64) result = operand1 + (imm * (PL DIV 8));

if d == 31 then
    SP[] = result;
else
    X[d] = result;
TAG:ADDPL-R.RI-_:diagram
A64
31:23 _ 000001000
22:22 _ 1
21:21 _ 1
20:16 Rn xxxxx
15:11 _ 01010
10:5 imm6 xxxxxx
4:0 Rd xxxxx
TAG:ADDPL-R.RI-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);
integer imm = SInt(imm6);

TAG:ADDPL-R.RI-_:index
Execute: ADDPL-R.RI-_:execute
Decode: ADDPL-R.RI-_:decode@ADDPL-R.RI-_:diagram
TAG:aarch64/vector/arithmetic/unary/cmp/fp16/bulk/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    case comparison of
        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 1
22:17 _ 111100
16:13 _ 0110
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:13 _ 0110
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:13 _ 0110
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:13 _ 0110
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/vector/arithmetic/unary/cmp/fp16/bulk/sisd:index
Execute: aarch64/vector/arithmetic/unary/cmp/fp16/bulk/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/fp16/bulk/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/float/bulk/simd:diagram
TAG:SQDECP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    integer element = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);

Z[dn] = result;
TAG:SQDECP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 0
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:SQDECP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);
boolean unsigned = FALSE;

TAG:SQDECP-Z.P.Z-_:index
Execute: SQDECP-Z.P.Z-_:execute
Decode: SQDECP-Z.P.Z-_:decode@SQDECP-Z.P.Z-_:diagram
TAG:UQDECW-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQDECW-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECW-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQDECW-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECW-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQDECW-R.RS-UW:index
Execute: UQDECW-R.RS-UW:execute
Decode: UQDECW-R.RS-UW:decode@UQDECW-R.RS-UW:diagram
Decode: UQDECW-R.RS-X:decode@UQDECW-R.RS-X:diagram
TAG:LSLR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element1), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSL(element2, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSLR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 1
17:17 _ 1
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSLR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSLR-Z.P.ZZ-_:index
Execute: LSLR-Z.P.ZZ-_:execute
Decode: LSLR-Z.P.ZZ-_:decode@LSLR-Z.P.ZZ-_:diagram
TAG:UQDECH-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQDECH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQDECH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQDECH-Z.ZS-_:index
Execute: UQDECH-Z.ZS-_:execute
Decode: UQDECH-Z.ZS-_:decode@UQDECH-Z.ZS-_:diagram
TAG:ST1D-Z.P.BR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    offset = offset + 1;
TAG:ST1D-Z.P.BR-_:diagram
A64
31:25 _ 1110010
24:23 _ 11
22:22 _ 1
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BR-_:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;

TAG:ST1D-Z.P.BR-_:index
Execute: ST1D-Z.P.BR-_:execute
Decode: ST1D-Z.P.BR-_:decode@ST1D-Z.P.BR-_:diagram
TAG:aarch64/udf:execute
// No operation.
TAG:aarch64/instrs/udf:diagram
A64
31:16 _ 0000000000000000
15:0 imm16 xxxxxxxxxxxxxxxx
TAG:aarch64/instrs/udf:decode
// The imm16 field is ignored by hardware.
UNDEFINED;

TAG:aarch64/udf:index
Execute: aarch64/udf:execute
Decode: aarch64/instrs/udf:decode@aarch64/instrs/udf:diagram
TAG:aarch64/vector/transfer/integer/move/signed:execute
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];

X[d] = SignExtend(Elem[operand, index, esize], datasize);
TAG:aarch64/instrs/vector/transfer/integer/move/signed:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:13 _ 01
12:12 _ 0
11:11 _ 1
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/integer/move/signed:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size;
case Q:imm5 of
    when 'xxxxx1' size = 0;     // SMOV [WX]d, Vn.B
    when 'xxxx10' size = 1;     // SMOV [WX]d, Vn.H
    when '1xx100' size = 2;     // SMOV Xd, Vn.S
    otherwise     UNDEFINED;

integer idxdsize = if imm5[4] == '1' then 128 else 64;
integer index = UInt(imm5[4:size+1]);
integer esize = 8 << size;
integer datasize = if Q == '1' then 64 else 32;

TAG:aarch64/vector/transfer/integer/move/signed:index
Execute: aarch64/vector/transfer/integer/move/signed:execute
Decode: aarch64/instrs/vector/transfer/integer/move/signed:decode@aarch64/instrs/vector/transfer/integer/move/signed:diagram
TAG:PRFD-I.P.BR-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) offset = X[m];
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + (UInt(offset) << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
    offset = offset + 1;
TAG:PRFD-I.P.BR-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.BR-S:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 3;

TAG:PRFD-I.P.BR-S:index
Execute: PRFD-I.P.BR-S:execute
Decode: PRFD-I.P.BR-S:decode@PRFD-I.P.BR-S:diagram
TAG:aarch64/float/arithmetic/add-sub:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

if sub_op then
    result = FPSub(operand1, operand2, FPCR);
else
    result = FPAdd(operand1, operand2, FPCR);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/add-sub:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 001
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/add-sub:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

boolean sub_op = (op == '1');

TAG:aarch64/float/arithmetic/add-sub:index
Execute: aarch64/float/arithmetic/add-sub:execute
Decode: aarch64/instrs/float/arithmetic/add-sub:decode@aarch64/instrs/float/arithmetic/add-sub:diagram
TAG:aarch64/system/exceptions/debug/exception:execute
DCPSInstruction(target_level);
TAG:aarch64/instrs/system/exceptions/debug/exception:diagram
A64
31:24 _ 11010100
23:21 _ 101
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 LL xx
TAG:aarch64/instrs/system/exceptions/debug/exception:decode
bits(2) target_level = LL;
if LL == '00' then UNDEFINED;
if !Halted() then UNDEFINED;

TAG:aarch64/system/exceptions/debug/exception:index
Execute: aarch64/system/exceptions/debug/exception:execute
Decode: aarch64/instrs/system/exceptions/debug/exception:decode@aarch64/instrs/system/exceptions/debug/exception:diagram
TAG:UMULH-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer product = (element1 * element2) >> esize;
        Elem[result, e, esize] = product[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UMULH-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0100
17:17 _ 1
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UMULH-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UMULH-Z.P.ZZ-_:index
Execute: UMULH-Z.P.ZZ-_:execute
Decode: UMULH-Z.P.ZZ-_:decode@UMULH-Z.P.ZZ-_:diagram
TAG:UABD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer absdiff = Abs(element1 - element2);
        Elem[result, e, esize] = absdiff[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UABD-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UABD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UABD-Z.P.ZZ-_:index
Execute: UABD-Z.P.ZZ-_:execute
Decode: UABD-Z.P.ZZ-_:decode@UABD-Z.P.ZZ-_:diagram
TAG:aarch64/vector/crypto/sm4/sm4enckey:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(32) intval; 
bits(8) sboxout;
bits(128) result;
bits(32) const;
bits(128) roundresult;

roundresult = V[n];
for index = 0 to 3 
    const = Elem[Vm,index,32];

    intval = roundresult[127:96] EOR roundresult[95:64] EOR roundresult[63:32] EOR const; 

    for i = 0 to 3  
        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); 

    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);
    intval = intval EOR roundresult[31:0]; 

    roundresult[31:0] = roundresult[63:32];
    roundresult[63:32] = roundresult[95:64];
    roundresult[95:64] = roundresult[127:96];
    roundresult[127:96] = intval; 
V[d] = roundresult;
TAG:aarch64/instrs/vector/crypto/sm4/sm4enckey:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 1
13:12 _ 00
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm4/sm4enckey:decode
if !HaveSM4Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sm4/sm4enckey:index
Execute: aarch64/vector/crypto/sm4/sm4enckey:execute
Decode: aarch64/instrs/vector/crypto/sm4/sm4enckey:decode@aarch64/instrs/vector/crypto/sm4/sm4enckey:diagram
TAG:LD1D-Z.P.BZ-D.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1D-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 3;

TAG:LD1D-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1D-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 3;

TAG:LD1D-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1D-Z.P.BZ-D.x32.scaled:index
Execute: LD1D-Z.P.BZ-D.x32.scaled:execute
Decode: LD1D-Z.P.BZ-D.x32.scaled:decode@LD1D-Z.P.BZ-D.x32.scaled:diagram
Decode: LD1D-Z.P.BZ-D.x32.unscaled:decode@LD1D-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1D-Z.P.BZ-D.64.scaled:decode@LD1D-Z.P.BZ-D.64.scaled:diagram
Decode: LD1D-Z.P.BZ-D.64.unscaled:decode@LD1D-Z.P.BZ-D.64.unscaled:diagram
TAG:UMMLA-Z.ZZZ-_:execute
CheckSVEEnabled();
integer segments = VL DIV 128;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result = Zeros();
bits(128) op1, op2;
bits(128) res, addend;

for s = 0 to segments-1
    op1    = Elem[operand1, s, 128];
    op2    = Elem[operand2, s, 128];
    addend = Elem[operand3, s, 128];
    res    = MatMulAdd(addend, op1, op2, op1_unsigned, op2_unsigned);
    Elem[result, s, 128] = res;

Z[da] = result;
TAG:UMMLA-Z.ZZZ-_:diagram
A64
31:24 _ 01000101
23:23 _ 1
22:22 _ 1
21:21 _ 0
20:16 Zm xxxxx
15:10 _ 100110
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:UMMLA-Z.ZZZ-_:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_unsigned = TRUE;
boolean op2_unsigned = TRUE;

TAG:UMMLA-Z.ZZZ-_:index
Execute: UMMLA-Z.ZZZ-_:execute
Decode: UMMLA-Z.ZZZ-_:decode@UMMLA-Z.ZZZ-_:diagram
TAG:LDFF1H-Z.P.BR-U16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1H-Z.P.BR-U16:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BR-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LDFF1H-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LDFF1H-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LDFF1H-Z.P.BR-U16:index
Execute: LDFF1H-Z.P.BR-U16:execute
Decode: LDFF1H-Z.P.BR-U16:decode@LDFF1H-Z.P.BR-U16:diagram
Decode: LDFF1H-Z.P.BR-U32:decode@LDFF1H-Z.P.BR-U32:diagram
Decode: LDFF1H-Z.P.BR-U64:decode@LDFF1H-Z.P.BR-U64:diagram
TAG:aarch64/float/convert/int:execute
CheckFPAdvSIMDEnabled64();

bits(fltsize) fltval;
bits(intsize) intval;

case op of
    when FPConvOp_CVT_FtoI
        fltval = V[n];
        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);
        X[d] = intval;
    when FPConvOp_CVT_ItoF
        intval = X[n];
        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);
        V[d] = fltval;
    when FPConvOp_MOV_FtoI
        fltval = Vpart[n,part];
        intval = ZeroExtend(fltval, intsize);
        X[d] = intval;
    when FPConvOp_MOV_ItoF
        intval = X[n];
        fltval = intval[fltsize-1:0];
        Vpart[d,part] = fltval;
    when FPConvOp_CVT_FtoI_JS
        bit Z;
        fltval = V[n];
        (intval, Z) = FPToFixedJS(fltval, FPCR, TRUE);
        PSTATE.[N,Z,C,V] = '0':Z:'00';
        X[d] = intval;
TAG:aarch64/instrs/float/convert/int:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:19 rmode xx
18:16 opcode xxx
15:10 _ 000000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/convert/int:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPConvOp op;
FPRounding rounding;
boolean unsigned;
integer part;

case ftype of
    when '00'
        fltsize = 32;
    when '01'
        fltsize = 64;
    when '10'
        if opcode[2:1]:rmode != '11 01' then UNDEFINED;
        fltsize = 128;
    when '11'
        if HaveFP16Ext() then
            fltsize = 16;
        else
            UNDEFINED;

case opcode[2:1]:rmode of
    when '00 xx'        // FCVT[NPMZ][US]
        rounding = FPDecodeRounding(rmode);
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_FtoI;
    when '01 00'        // [US]CVTF
        rounding = FPRoundingMode(FPCR);
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_ItoF;
    when '10 00'        // FCVTA[US]
        rounding = FPRounding_TIEAWAY;
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_FtoI;
    when '11 00'        // FMOV
        if fltsize != 16 && fltsize != intsize then UNDEFINED;
        op = if opcode[0] == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
        part = 0;
    when '11 01'        // FMOV D[1]
        if intsize != 64 || fltsize != 128 then UNDEFINED;
        op = if opcode[0] == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;
        part = 1;
        fltsize = 64;  // size of D[1] is 64
    when '11 11'       // FJCVTZS
        if !HaveFJCVTZSExt() then UNDEFINED;
        rounding = FPRounding_ZERO;
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_FtoI_JS;
    otherwise 
        UNDEFINED;

TAG:aarch64/float/convert/int:index
Execute: aarch64/float/convert/int:execute
Decode: aarch64/instrs/float/convert/int:decode@aarch64/instrs/float/convert/int:diagram
TAG:FSUB-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPSub(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FSUB-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 000
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FSUB-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FSUB-Z.P.ZZ-_:index
Execute: FSUB-Z.P.ZZ-_:execute
Decode: FSUB-Z.P.ZZ-_:decode@FSUB-Z.P.ZZ-_:diagram
TAG:aarch64/vector/shift/left-insert/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;
bits(esize) mask = LSL(Ones(esize), shift);
bits(esize) shifted;

for e = 0 to elements-1
    shifted = LSL(Elem[operand, e, esize], shift);
    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
V[d] = result;
TAG:aarch64/instrs/vector/shift/left-insert/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left-insert/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh[3] != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;

integer shift = UInt(immh:immb) - esize;

TAG:aarch64/instrs/vector/shift/left-insert/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left-insert/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3]:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer shift = UInt(immh:immb) - esize;

TAG:aarch64/vector/shift/left-insert/sisd:index
Execute: aarch64/vector/shift/left-insert/sisd:execute
Decode: aarch64/instrs/vector/shift/left-insert/sisd:decode@aarch64/instrs/vector/shift/left-insert/sisd:diagram
Decode: aarch64/instrs/vector/shift/left-insert/simd:decode@aarch64/instrs/vector/shift/left-insert/simd:diagram
TAG:INCD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    Elem[result, e, esize] = Elem[operand1, e, esize] + (count * imm);

Z[dn] = result;
TAG:INCD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:INCD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:INCH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:INCW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCD-Z.ZS-_:index
Execute: INCD-Z.ZS-_:execute
Decode: INCD-Z.ZS-_:decode@INCD-Z.ZS-_:diagram
Decode: INCH-Z.ZS-_:decode@INCH-Z.ZS-_:diagram
Decode: INCW-Z.ZS-_:decode@INCW-Z.ZS-_:diagram
TAG:aarch64/vector/arithmetic/unary/float/narrow:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;

for e = 0 to elements-1
    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/float/narrow:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 10110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/narrow:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16 << UInt(sz);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/float/narrow:index
Execute: aarch64/vector/arithmetic/unary/float/narrow:execute
Decode: aarch64/instrs/vector/arithmetic/unary/float/narrow:decode@aarch64/instrs/vector/arithmetic/unary/float/narrow:diagram
TAG:aarch64/memory/pair/simdfp/post-idx:execute
CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if memop == MemOp_LOAD && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        data1 = V[t];
        data2 = V[t2];
        Mem[address + 0     , dbytes, acctype] = data1;
        Mem[address + dbytes, dbytes, acctype] = data2;

    when MemOp_LOAD
        data1 = Mem[address + 0     , dbytes, acctype];
        data2 = Mem[address + dbytes, dbytes, acctype];
        if rt_unknown then
            data1 = bits(datasize) UNKNOWN;
            data2 = bits(datasize) UNKNOWN;
        V[t]  = data1;
        V[t2] = data2;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/pair/simdfp/post-idx:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
AccType acctype = AccType_VEC;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/pair/simdfp/post-idx:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 1
25:23 _ 001
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/simdfp/post-idx:decode
boolean wback  = TRUE;
boolean postindex = TRUE;

TAG:aarch64/instrs/memory/pair/simdfp/pre-idx:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 1
25:23 _ 011
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/simdfp/pre-idx:decode
boolean wback  = TRUE;
boolean postindex = FALSE;

TAG:aarch64/instrs/memory/pair/simdfp/offset:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 1
25:23 _ 010
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/simdfp/offset:decode
boolean wback  = FALSE;
boolean postindex = FALSE;

TAG:aarch64/memory/pair/simdfp/post-idx:index
Execute: aarch64/memory/pair/simdfp/post-idx:execute
Postdecode: aarch64/memory/pair/simdfp/post-idx:postdecode
Decode: aarch64/instrs/memory/pair/simdfp/post-idx:decode@aarch64/instrs/memory/pair/simdfp/post-idx:diagram
Decode: aarch64/instrs/memory/pair/simdfp/pre-idx:decode@aarch64/instrs/memory/pair/simdfp/pre-idx:diagram
Decode: aarch64/instrs/memory/pair/simdfp/offset:decode@aarch64/instrs/memory/pair/simdfp/offset:diagram
TAG:FMINV-V.P.Z-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) identity = FPInfinity('0');

V[d] = ReducePredicated(ReduceOp_FMIN, operand, mask, identity);
TAG:FMINV-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 11
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:FMINV-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:FMINV-V.P.Z-_:index
Execute: FMINV-V.P.Z-_:execute
Decode: FMINV-V.P.Z-_:decode@FMINV-V.P.Z-_:diagram
TAG:aarch64/integer/conditional/select:execute
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];

if ConditionHolds(condition) then
    result = operand1;
else
    result = operand2;
    if else_inv then result = NOT(result);
    if else_inc then result = result + 1;

X[d] = result;
TAG:aarch64/instrs/integer/conditional/select:diagram
A64
31:31 sf x
30:30 op x
29:29 _ 0
28:21 _ 11010100
20:16 Rm xxxxx
15:12 cond xxxx
11:11 _ 0
10:10 o2 x
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/conditional/select:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
bits(4) condition = cond;
boolean else_inv = (op == '1');
boolean else_inc = (o2 == '1');

TAG:aarch64/integer/conditional/select:index
Execute: aarch64/integer/conditional/select:execute
Decode: aarch64/instrs/integer/conditional/select:decode@aarch64/instrs/integer/conditional/select:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/high/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer rounding_const = if rounding then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer element3;
integer product;
boolean sat;

element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    element3 = SInt(Elem[operand3, e, esize]);
    if sub_op then
        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);
    else
        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);
    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:14 _ 11
13:13 S x
12:12 _ 1
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd:decode
if !HaveQRDMLAHExt() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;

boolean rounding = TRUE;
boolean sub_op = (S  == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:14 _ 11
13:13 S x
12:12 _ 1
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd:decode
if !HaveQRDMLAHExt() then UNDEFINED;

integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean rounding = TRUE;
boolean sub_op = (S  == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/high/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/high/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/high/simd:diagram
TAG:PTRUE-P.S-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(PL) result;

for e = 0 to elements-1
    ElemP[result, e, esize] = if e < count then '1' else '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(result, result, esize);
P[d] = result;
TAG:PTRUE-P.S-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:17 _ 01100
16:16 _ 0
15:10 _ 111000
9:5 pattern xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:PTRUE-P.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer d = UInt(Pd);
boolean setflags = FALSE;
bits(5) pat = pattern;

TAG:PTRUES-P.S-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:17 _ 01100
16:16 _ 1
15:10 _ 111000
9:5 pattern xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:PTRUES-P.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer d = UInt(Pd);
boolean setflags = TRUE;
bits(5) pat = pattern;

TAG:PTRUE-P.S-_:index
Execute: PTRUE-P.S-_:execute
Decode: PTRUE-P.S-_:decode@PTRUE-P.S-_:diagram
Decode: PTRUES-P.S-_:decode@PTRUES-P.S-_:diagram
TAG:FDIV-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPDiv(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FDIV-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 110
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FDIV-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FDIV-Z.P.ZZ-_:index
Execute: FDIV-Z.P.ZZ-_:execute
Decode: FDIV-Z.P.ZZ-_:decode@FDIV-Z.P.ZZ-_:diagram
TAG:FACGT-P.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(PL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        case op of
            when Cmp_GE res = FPCompareGE(FPAbs(element1), FPAbs(element2), FPCR);
            when Cmp_GT res = FPCompareGT(FPAbs(element1), FPAbs(element2), FPCR);
        ElemP[result, e, esize] = if res then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

P[d] = result;
TAG:FACGT-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FACGT-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;

TAG:FACGE-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FACGE-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;

TAG:FACGT-P.P.ZZ-_:index
Execute: FACGT-P.P.ZZ-_:execute
Decode: FACGT-P.P.ZZ-_:decode@FACGT-P.P.ZZ-_:diagram
Decode: FACGE-P.P.ZZ-_:decode@FACGE-P.P.ZZ-_:diagram
TAG:LD1SH-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SH-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001001
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LD1SH-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LD1SH-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1SH-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1SH-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:LD1SH-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1SH-Z.P.BZ-S.x32.scaled:index
Execute: LD1SH-Z.P.BZ-S.x32.scaled:execute
Decode: LD1SH-Z.P.BZ-S.x32.scaled:decode@LD1SH-Z.P.BZ-S.x32.scaled:diagram
Decode: LD1SH-Z.P.BZ-D.x32.scaled:decode@LD1SH-Z.P.BZ-D.x32.scaled:diagram
Decode: LD1SH-Z.P.BZ-D.x32.unscaled:decode@LD1SH-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1SH-Z.P.BZ-S.x32.unscaled:decode@LD1SH-Z.P.BZ-S.x32.unscaled:diagram
Decode: LD1SH-Z.P.BZ-D.64.scaled:decode@LD1SH-Z.P.BZ-D.64.scaled:diagram
Decode: LD1SH-Z.P.BZ-D.64.unscaled:decode@LD1SH-Z.P.BZ-D.64.unscaled:diagram
TAG:UUNPKHI-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer hsize = esize DIV 2;
bits(VL) operand = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(hsize) element = if hi then Elem[operand, e + elements, hsize] else Elem[operand, e, hsize];
    Elem[result, e, esize] = Extend(element, esize, unsigned);

Z[d] = result;
TAG:UUNPKHI-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1100
17:17 _ 1
16:16 _ 1
15:10 _ 001110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UUNPKHI-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = TRUE;
boolean hi = TRUE;

TAG:UUNPKLO-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1100
17:17 _ 1
16:16 _ 0
15:10 _ 001110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UUNPKLO-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = TRUE;
boolean hi = FALSE;

TAG:UUNPKHI-Z.Z-_:index
Execute: UUNPKHI-Z.Z-_:execute
Decode: UUNPKHI-Z.Z-_:decode@UUNPKHI-Z.Z-_:diagram
Decode: UUNPKLO-Z.Z-_:decode@UUNPKLO-Z.Z-_:diagram
TAG:CNT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = BitCount(element)[esize-1:0];

Z[d] = result;
TAG:CNT-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:CNT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:CNT-Z.P.Z-_:index
Execute: CNT-Z.P.Z-_:execute
Decode: CNT-Z.P.Z-_:decode@CNT-Z.P.Z-_:diagram
TAG:aarch64/vector/reduce/fp16-maxnm/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/fp16-maxnm/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp16-maxnm/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
if sz == '1' then UNDEFINED;
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

TAG:aarch64/instrs/vector/reduce/fp-maxnm/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp-maxnm/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;

TAG:aarch64/vector/reduce/fp16-maxnm/sisd:index
Execute: aarch64/vector/reduce/fp16-maxnm/sisd:execute
Decode: aarch64/instrs/vector/reduce/fp16-maxnm/sisd:decode@aarch64/instrs/vector/reduce/fp16-maxnm/sisd:diagram
Decode: aarch64/instrs/vector/reduce/fp-maxnm/sisd:decode@aarch64/instrs/vector/reduce/fp-maxnm/sisd:diagram
TAG:PFALSE-P-_:execute
CheckSVEEnabled();
P[d] = Zeros(PL);
TAG:PFALSE-P-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:10 _ 011000111001
9:4 _ 000000
3:0 Pd xxxx
TAG:PFALSE-P-_:decode
if !HaveSVE() then UNDEFINED;
integer d = UInt(Pd);

TAG:PFALSE-P-_:index
Execute: PFALSE-P-_:execute
Decode: PFALSE-P-_:decode@PFALSE-P-_:diagram
TAG:aarch64/integer/arithmetic/cnt:execute
integer result;
bits(datasize) operand1 = X[n];

if opcode == CountOp_CLZ then
    result = CountLeadingZeroBits(operand1);
else
    result = CountLeadingSignBits(operand1);

X[d] = result[datasize-1:0];
TAG:aarch64/instrs/integer/arithmetic/cnt:diagram
A64
31:31 sf x
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00000
15:11 _ 00010
10:10 op x
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/cnt:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
CountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;

TAG:aarch64/integer/arithmetic/cnt:index
Execute: aarch64/integer/arithmetic/cnt:execute
Decode: aarch64/instrs/integer/arithmetic/cnt:decode@aarch64/instrs/integer/arithmetic/cnt:diagram
TAG:CPY-Z.P.V-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = V[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = operand1;

Z[d] = result;
TAG:CPY-Z.P.V-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:13 _ 100000100
12:10 Pg xxx
9:5 Vn xxxxx
4:0 Zd xxxxx
TAG:CPY-Z.P.V-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Vn);
integer d = UInt(Zd);

TAG:CPY-Z.P.V-_:index
Execute: CPY-Z.P.V-_:execute
Decode: CPY-Z.P.V-_:decode@CPY-Z.P.V-_:diagram
TAG:aarch64/vector/reduce/add/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/add/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:22 size xx
21:17 _ 11000
16:12 _ 11011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/add/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size != '11' then UNDEFINED;

integer esize = 8 << UInt(size);
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = ReduceOp_ADD;

TAG:aarch64/vector/reduce/add/sisd:index
Execute: aarch64/vector/reduce/add/sisd:execute
Decode: aarch64/instrs/vector/reduce/add/sisd:decode@aarch64/instrs/vector/reduce/add/sisd:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/saturating/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;
boolean sat;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    sum = element1 + element2;
    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/add/saturating/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/saturating/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/saturating/simd:diagram
TAG:LDFF1B-Z.P.BZ-D.x32.unscaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1B-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1B-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1B-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1B-Z.P.BZ-D.x32.unscaled:index
Execute: LDFF1B-Z.P.BZ-D.x32.unscaled:execute
Decode: LDFF1B-Z.P.BZ-D.x32.unscaled:decode@LDFF1B-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1B-Z.P.BZ-S.x32.unscaled:decode@LDFF1B-Z.P.BZ-S.x32.unscaled:diagram
Decode: LDFF1B-Z.P.BZ-D.64.unscaled:decode@LDFF1B-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/memory/literal/general:execute
bits(64) address = PC[] + offset;
bits(size*8) data;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

case memop of
    when MemOp_LOAD
        data = Mem[address, size, AccType_NORMAL];
        if signed then
            X[t] = SignExtend(data, 64);
        else
            X[t] = data;

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);
TAG:aarch64/instrs/memory/literal/general:diagram
A64
31:30 opc xx
29:27 _ 011
26:26 _ 0
25:24 _ 00
23:5 imm19 xxxxxxxxxxxxxxxxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/literal/general:decode
integer t = UInt(Rt);
MemOp memop = MemOp_LOAD;
boolean signed = FALSE;
integer size;
bits(64) offset;

case opc of
    when '00'
        size = 4;
    when '01'
        size = 8;
    when '10'
        size = 4;
        signed = TRUE;
    when '11'
        memop = MemOp_PREFETCH;

offset = SignExtend(imm19:'00', 64);
boolean tag_checked = FALSE;

TAG:aarch64/memory/literal/general:index
Execute: aarch64/memory/literal/general:execute
Decode: aarch64/instrs/memory/literal/general:decode@aarch64/instrs/memory/literal/general:diagram
TAG:PRFD-I.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) base;
bits(64) addr;
base = Z[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFD-I.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 3;
integer offset = UInt(imm5);

TAG:PRFD-I.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 3;
integer offset = UInt(imm5);

TAG:PRFD-I.P.AI-S:index
Execute: PRFD-I.P.AI-S:execute
Decode: PRFD-I.P.AI-S:decode@PRFD-I.P.AI-S:diagram
Decode: PRFD-I.P.AI-D:decode@PRFD-I.P.AI-D:diagram
TAG:LD1SW-Z.P.BI-S64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1SW-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SW-Z.P.BI-S64:index
Execute: LD1SW-Z.P.BI-S64:execute
Decode: LD1SW-Z.P.BI-S64:decode@LD1SW-Z.P.BI-S64:diagram
TAG:aarch64/vector/shift/conv/float/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);

V[d] = result;
TAG:aarch64/instrs/vector/shift/conv/float/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/conv/float/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = esize;
integer elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

TAG:aarch64/instrs/vector/shift/conv/float/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/conv/float/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh[3]:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRounding_ZERO;

TAG:aarch64/vector/shift/conv/float/sisd:index
Execute: aarch64/vector/shift/conv/float/sisd:execute
Decode: aarch64/instrs/vector/shift/conv/float/sisd:decode@aarch64/instrs/vector/shift/conv/float/sisd:diagram
Decode: aarch64/instrs/vector/shift/conv/float/simd:decode@aarch64/instrs/vector/shift/conv/float/simd:diagram
TAG:LD1SH-Z.P.BI-S32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1SH-Z.P.BI-S32:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SH-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SH-Z.P.BI-S32:index
Execute: LD1SH-Z.P.BI-S32:execute
Decode: LD1SH-Z.P.BI-S32:decode@LD1SH-Z.P.BI-S32:diagram
Decode: LD1SH-Z.P.BI-S64:decode@LD1SH-Z.P.BI-S64:diagram
TAG:LSL-Z.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    Elem[result, e, esize] = LSL(element1, shift);

Z[d] = result;
TAG:LSL-Z.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1000
11:11 _ 1
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:LSL-Z.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:LSL-Z.ZW-_:index
Execute: LSL-Z.ZW-_:execute
Decode: LSL-Z.ZW-_:decode@LSL-Z.ZW-_:diagram
TAG:aarch64/integer/arithmetic/mul/uniform/add-sub:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(destsize) operand3 = X[a];

integer result;

if sub_op then
    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));
else
    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));

X[d] = result[destsize-1:0];
TAG:aarch64/instrs/integer/arithmetic/mul/uniform/add-sub:diagram
A64
31:31 sf x
30:29 _ 00
28:24 _ 11011
23:21 _ 000
20:16 Rm xxxxx
15:15 o0 x
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/mul/uniform/add-sub:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);
integer destsize = if sf == '1' then 64 else 32;
integer datasize = destsize;
boolean sub_op = (o0 == '1');

TAG:aarch64/integer/arithmetic/mul/uniform/add-sub:index
Execute: aarch64/integer/arithmetic/mul/uniform/add-sub:execute
Decode: aarch64/instrs/integer/arithmetic/mul/uniform/add-sub:decode@aarch64/instrs/integer/arithmetic/mul/uniform/add-sub:diagram
TAG:aarch64/memory/pair/general/no-alloc:execute
bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if memop == MemOp_LOAD && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown && t == n then
            data1 = bits(datasize) UNKNOWN;
        else
            data1 = X[t];
        if rt_unknown && t2 == n then
            data2 = bits(datasize) UNKNOWN;
        else
            data2 = X[t2];
        Mem[address + 0     , dbytes, acctype] = data1;
        Mem[address + dbytes, dbytes, acctype] = data2;

    when MemOp_LOAD
        data1 = Mem[address + 0     , dbytes, acctype];
        data2 = Mem[address + dbytes, dbytes, acctype];
        if rt_unknown then
            data1 = bits(datasize) UNKNOWN;
            data2 = bits(datasize) UNKNOWN;
        X[t]  = data1;
        X[t2] = data2;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/pair/general/no-alloc:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
AccType acctype = AccType_STREAM;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
if opc[0] == '1' then UNDEFINED;
integer scale = 2 + UInt(opc[1]);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/pair/general/no-alloc:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 0
25:23 _ 000
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/general/no-alloc:decode
boolean wback  = FALSE;
boolean postindex = FALSE;

TAG:aarch64/memory/pair/general/no-alloc:index
Execute: aarch64/memory/pair/general/no-alloc:execute
Postdecode: aarch64/memory/pair/general/no-alloc:postdecode
Decode: aarch64/instrs/memory/pair/general/no-alloc:decode@aarch64/instrs/memory/pair/general/no-alloc:diagram
TAG:LD2B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 2;

TAG:LD2B-Z.P.BR-Contiguous:index
Execute: LD2B-Z.P.BR-Contiguous:execute
Decode: LD2B-Z.P.BR-Contiguous:decode@LD2B-Z.P.BR-Contiguous:diagram
TAG:ST2B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST2B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 2;

TAG:ST2B-Z.P.BR-Contiguous:index
Execute: ST2B-Z.P.BR-Contiguous:execute
Decode: ST2B-Z.P.BR-Contiguous:decode@ST2B-Z.P.BR-Contiguous:diagram
TAG:ST3B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST3B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:ST3B-Z.P.BI-Contiguous:index
Execute: ST3B-Z.P.BI-Contiguous:execute
Decode: ST3B-Z.P.BI-Contiguous:decode@ST3B-Z.P.BI-Contiguous:diagram
TAG:UMAX-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    Elem[result, e, esize] = Max(element1, imm)[esize-1:0];

Z[dn] = result;
TAG:UMAX-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 101
18:17 _ 00
16:16 _ 1
15:14 _ 11
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:UMAX-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
boolean unsigned = TRUE;
integer imm = Int(imm8, unsigned);

TAG:UMAX-Z.ZI-_:index
Execute: UMAX-Z.ZI-_:execute
Decode: UMAX-Z.ZI-_:decode@UMAX-Z.ZI-_:diagram
TAG:LD1B-Z.P.BI-U8:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1B-Z.P.BI-U8:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BI-U8:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1B-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1B-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1B-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1B-Z.P.BI-U8:index
Execute: LD1B-Z.P.BI-U8:execute
Decode: LD1B-Z.P.BI-U8:decode@LD1B-Z.P.BI-U8:diagram
Decode: LD1B-Z.P.BI-U16:decode@LD1B-Z.P.BI-U16:diagram
Decode: LD1B-Z.P.BI-U32:decode@LD1B-Z.P.BI-U32:diagram
Decode: LD1B-Z.P.BI-U64:decode@LD1B-Z.P.BI-U64:diagram
TAG:LD4H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 4;

TAG:LD4H-Z.P.BR-Contiguous:index
Execute: LD4H-Z.P.BR-Contiguous:execute
Decode: LD4H-Z.P.BR-Contiguous:decode@LD4H-Z.P.BR-Contiguous:diagram
TAG:aarch64/vector/transfer/integer/insert:execute
CheckFPAdvSIMDEnabled64();
bits(esize) element = X[n];
bits(datasize) result;

result = V[d];
Elem[result, index, esize] = element;
V[d] = result;
TAG:aarch64/instrs/vector/transfer/integer/insert:diagram
A64
31:31 _ 0
30:30 _ 1
29:29 _ 0
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:11 _ 0011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/integer/insert:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size = LowestSetBit(imm5);

if size > 3 then UNDEFINED;
integer index = UInt(imm5[4:size+1]);

integer esize = 8 << size;
integer datasize = 128;

TAG:aarch64/vector/transfer/integer/insert:index
Execute: aarch64/vector/transfer/integer/insert:execute
Decode: aarch64/instrs/vector/transfer/integer/insert:decode@aarch64/instrs/vector/transfer/integer/insert:diagram
TAG:aarch64/memory/single/simdfp/immediate/signed/post-idx:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        data = V[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        V[t] = data;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/simdfp/immediate/signed/post-idx:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_VEC;
MemOp memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 1
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 01
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx:decode
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(opc[1]:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 1
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 11
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx:decode
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(opc[1]:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/instrs/memory/single/simdfp/immediate/unsigned:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 1
25:24 _ 01
23:22 opc xx
21:10 imm12 xxxxxxxxxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/simdfp/immediate/unsigned:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(opc[1]:size);
if scale > 4 then UNDEFINED;
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

TAG:aarch64/memory/single/simdfp/immediate/signed/post-idx:index
Execute: aarch64/memory/single/simdfp/immediate/signed/post-idx:execute
Postdecode: aarch64/memory/single/simdfp/immediate/signed/post-idx:postdecode
Decode: aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx:decode@aarch64/instrs/memory/single/simdfp/immediate/signed/post-idx:diagram
Decode: aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx:decode@aarch64/instrs/memory/single/simdfp/immediate/signed/pre-idx:diagram
Decode: aarch64/instrs/memory/single/simdfp/immediate/unsigned:decode@aarch64/instrs/memory/single/simdfp/immediate/unsigned:diagram
TAG:ASRD-Z.P.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = SInt(Elem[operand1, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        if element1 < 0 then
            element1 = element1 + ((1 << shift) - 1);
        Elem[result, e, esize] = (element1 >> shift)[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ASRD-Z.P.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:20 _ 00
19:19 _ 0
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:8 tszl xx
7:5 imm3 xxx
4:0 Zdn xxxxx
TAG:ASRD-Z.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer shift = (2 * esize) - UInt(tsize:imm3);

TAG:ASRD-Z.P.ZI-_:index
Execute: ASRD-Z.P.ZI-_:execute
Decode: ASRD-Z.P.ZI-_:decode@ASRD-Z.P.ZI-_:diagram
TAG:STNT1B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset = X[m];
bits(VL) src;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

src = Z[t];
for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    offset = offset + 1;
TAG:STNT1B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;

TAG:STNT1B-Z.P.BR-Contiguous:index
Execute: STNT1B-Z.P.BR-Contiguous:execute
Decode: STNT1B-Z.P.BR-Contiguous:decode@STNT1B-Z.P.BR-Contiguous:diagram
TAG:FRECPX-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPRecpX(element, FPCR);

Z[d] = result;
TAG:FRECPX-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0011
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRECPX-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FRECPX-Z.P.Z-_:index
Execute: FRECPX-Z.P.Z-_:execute
Decode: FRECPX-Z.P.Z-_:decode@FRECPX-Z.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/unary/fp16/round:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/round:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o2 x
22:17 _ 111100
16:13 _ 1100
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/round:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
    when '0xx' rounding = FPDecodeRounding(o1:o2);
    when '100' rounding = FPRounding_TIEAWAY;
    when '101' UNDEFINED;
    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
    when '111' rounding = FPRoundingMode(FPCR);

TAG:aarch64/instrs/vector/arithmetic/unary/float/round:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 o2 x
22:22 sz x
21:17 _ 10000
16:13 _ 1100
12:12 o1 x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/round:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean exact = FALSE;
FPRounding rounding;
case U:o1:o2 of
    when '0xx' rounding = FPDecodeRounding(o1:o2);
    when '100' rounding = FPRounding_TIEAWAY;
    when '101' UNDEFINED;
    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;
    when '111' rounding = FPRoundingMode(FPCR);

TAG:aarch64/vector/arithmetic/unary/fp16/round:index
Execute: aarch64/vector/arithmetic/unary/fp16/round:execute
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/round:decode@aarch64/instrs/vector/arithmetic/unary/fp16/round:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/round:decode@aarch64/instrs/vector/arithmetic/unary/float/round:diagram
TAG:STR-P.BI-_:execute
CheckSVEEnabled();
integer elements = PL DIV 8;
bits(PL) src;
bits(64) base;
integer offset = imm * elements;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

src = P[t];
boolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, TRUE);
for e = 0 to elements-1
    AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];
    offset = offset + 1;
TAG:STR-P.BI-_:diagram
A64
31:22 _ 1110010110
21:16 imm9h xxxxxx
15:13 _ 000
12:10 imm9l xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 Pt xxxx
TAG:STR-P.BI-_:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Pt);
integer n = UInt(Rn);
integer imm = SInt(imm9h:imm9l);

TAG:STR-P.BI-_:index
Execute: STR-P.BI-_:execute
Decode: STR-P.BI-_:decode@STR-P.BI-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/fused:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if sub_op then element1 = FPNeg(element1);
    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 a x
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (a == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 op x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (op == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/fused:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/fp16/fused:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/fused:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/fused:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/extended/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/extended/simd:diagram
TAG:aarch64/memory/exclusive/pair:execute
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;
boolean rn_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if memop == MemOp_LOAD && pair && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE then
    if s == t || (pair && s == t2) then
        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);
        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
        case c of
            when Constraint_UNKNOWN    rt_unknown = TRUE;    // store UNKNOWN value
            when Constraint_NONE       rt_unknown = FALSE;   // store original value
            when Constraint_UNDEF      UNDEFINED;
            when Constraint_NOP        EndOfInstruction();
    if s == n && n != 31 then
        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);
        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};
        case c of
            when Constraint_UNKNOWN    rn_unknown = TRUE;    // address is UNKNOWN
            when Constraint_NONE       rn_unknown = FALSE;   // address is original base
            when Constraint_UNDEF      UNDEFINED;
            when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
elsif rn_unknown then
    address = bits(64) UNKNOWN;
else
    address = X[n];

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        elsif pair then
            bits(datasize DIV 2) el1 = X[t];
            bits(datasize DIV 2) el2 = X[t2];
            data = if BigEndian() then el1 : el2 else el2 : el1;
        else
            data = X[t];

        bit status = '1';
        // Check whether the Exclusives monitors are set to include the
        // physical memory locations corresponding to virtual address
        // range [address, address+dbytes-1].
        if AArch64.ExclusiveMonitorsPass(address, dbytes) then
            // This atomic write will be rejected if it does not refer
            // to the same physical locations after address translation.
            Mem[address, dbytes, acctype] = data;
            status = ExclusiveMonitorsStatus();
        X[s] = ZeroExtend(status, 32);

    when MemOp_LOAD
        // Tell the Exclusives monitors to record a sequence of one or more atomic
        // memory reads from virtual address range [address, address+dbytes-1].
        // The Exclusives monitor will only be set if all the reads are from the
        // same dbytes-aligned physical address, to allow for the possibility of
        // an atomicity break if the translation is changed between reads.
        AArch64.SetExclusiveMonitors(address, dbytes);

        if pair then
            if rt_unknown then
                // ConstrainedUNPREDICTABLE case
                X[t]  = bits(datasize) UNKNOWN;        // In this case t = t2
            elsif elsize == 32 then
                // 32-bit load exclusive pair (atomic)
                data = Mem[address, dbytes, acctype];
                if BigEndian() then
                    X[t]  = data[datasize-1:elsize];
                    X[t2] = data[elsize-1:0];
                else
                    X[t]  = data[elsize-1:0];
                    X[t2] = data[datasize-1:elsize];
            else // elsize == 64
                // 64-bit load exclusive pair (not atomic),
                // but must be 128-bit aligned
                if address != Align(address, dbytes) then
                    iswrite = FALSE;
                    secondstage = FALSE;
                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));
                X[t]  = Mem[address + 0, 8, acctype];
                X[t2] = Mem[address + 8, 8, acctype];
        else
            data = Mem[address, dbytes, acctype];
            X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/exclusive/pair:diagram
A64
31:31 _ 1
30:30 sz x
29:24 _ 001000
23:23 _ 0
22:22 L x
21:21 _ 1
20:16 Rs xxxxx
15:15 o0 x
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/exclusive/pair:decode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2); // ignored by load/store single register
integer s = UInt(Rs);   // ignored by all loads and store-release

AccType acctype = if o0 == '1' then AccType_ORDEREDATOMIC else AccType_ATOMIC;
boolean pair = TRUE;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer elsize = 32 << UInt(sz);
integer regsize = if elsize == 64 then 64 else 32;
integer datasize = if pair then elsize * 2 else elsize;
boolean tag_checked = n != 31;

TAG:aarch64/memory/exclusive/pair:index
Execute: aarch64/memory/exclusive/pair:execute
Decode: aarch64/instrs/memory/exclusive/pair:decode@aarch64/instrs/memory/exclusive/pair:diagram
TAG:ST3H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST3H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:ST3H-Z.P.BI-Contiguous:index
Execute: ST3H-Z.P.BI-Contiguous:execute
Decode: ST3H-Z.P.BI-Contiguous:decode@ST3H-Z.P.BI-Contiguous:diagram
TAG:LD1SW-Z.P.BZ-D.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SW-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LD1SW-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1SW-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:LD1SW-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1SW-Z.P.BZ-D.x32.scaled:index
Execute: LD1SW-Z.P.BZ-D.x32.scaled:execute
Decode: LD1SW-Z.P.BZ-D.x32.scaled:decode@LD1SW-Z.P.BZ-D.x32.scaled:diagram
Decode: LD1SW-Z.P.BZ-D.x32.unscaled:decode@LD1SW-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1SW-Z.P.BZ-D.64.scaled:decode@LD1SW-Z.P.BZ-D.64.scaled:diagram
Decode: LD1SW-Z.P.BZ-D.64.unscaled:decode@LD1SW-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/recps-fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRecipStepFused(element1, element2);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/recps-fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/recps-fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/recps/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/recps-fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/recps/simd:diagram
TAG:LD4D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 4;

TAG:LD4D-Z.P.BR-Contiguous:index
Execute: LD4D-Z.P.BR-Contiguous:execute
Decode: LD4D-Z.P.BR-Contiguous:decode@LD4D-Z.P.BR-Contiguous:diagram
TAG:NOR-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = NOT(element1 OR element2);
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:NOR-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:NOR-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:NORS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:NORS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:NOR-P.P.PP-Z:index
Execute: NOR-P.P.PP-Z:execute
Decode: NOR-P.P.PP-Z:decode@NOR-P.P.PP-Z:diagram
Decode: NORS-P.P.PP-Z:decode@NORS-P.P.PP-Z:diagram
TAG:UDIVR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer quotient;
        if element1 == 0 then
            quotient = 0;
        else
            quotient = RoundTowardsZero(Real(element2) / Real(element1));
        Elem[result, e, esize] = quotient[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UDIVR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0101
17:17 _ 1
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UDIVR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UDIVR-Z.P.ZZ-_:index
Execute: UDIVR-Z.P.ZZ-_:execute
Decode: UDIVR-Z.P.ZZ-_:decode@UDIVR-Z.P.ZZ-_:diagram
TAG:aarch64/system/barriers/dmb:execute
DataMemoryBarrier(domain, types);
TAG:aarch64/instrs/system/barriers/dmb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/dmb:decode
case CRm[3:2] of
    when '00' domain = MBReqDomain_OuterShareable;
    when '01' domain = MBReqDomain_Nonshareable; 
    when '10' domain = MBReqDomain_InnerShareable;
    when '11' domain = MBReqDomain_FullSystem;
case CRm[1:0] of
    when '00' types = MBReqTypes_All; domain = MBReqDomain_FullSystem;
    when '01' types = MBReqTypes_Reads;
    when '10' types = MBReqTypes_Writes;
    when '11' types = MBReqTypes_All;

TAG:aarch64/system/barriers/dmb:index
Execute: aarch64/system/barriers/dmb:execute
Decode: aarch64/instrs/system/barriers/dmb:decode@aarch64/instrs/system/barriers/dmb:diagram
TAG:aarch64/vector/transfer/vector/permute/transpose:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

for p = 0 to pairs-1
    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];

V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/permute/transpose:diagram
A64
31:31 _ 0
30:30 Q x
29:24 _ 001110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:14 op x
13:12 _ 10
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/permute/transpose:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

TAG:aarch64/vector/transfer/vector/permute/transpose:index
Execute: aarch64/vector/transfer/vector/permute/transpose:execute
Decode: aarch64/instrs/vector/transfer/vector/permute/transpose:decode@aarch64/instrs/vector/transfer/vector/permute/transpose:diagram
TAG:aarch64/integer/ins-ext/insert/movewide:execute
bits(datasize) result;

if opcode == MoveWideOp_K then
    result = X[d];
else
    result = Zeros();

result[pos+15:pos] = imm;
if opcode == MoveWideOp_N then
    result = NOT(result);
X[d] = result;
TAG:aarch64/instrs/integer/ins-ext/insert/movewide:diagram
A64
31:31 sf x
30:29 opc xx
28:23 _ 100101
22:21 hw xx
20:5 imm16 xxxxxxxxxxxxxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/ins-ext/insert/movewide:decode
integer d = UInt(Rd);
integer datasize = if sf == '1' then 64 else 32;
bits(16) imm = imm16;
integer pos;
MoveWideOp opcode;

case opc of
    when '00' opcode = MoveWideOp_N;
    when '10' opcode = MoveWideOp_Z;
    when '11' opcode = MoveWideOp_K;
    otherwise UNDEFINED;

if sf == '0' && hw[1] == '1' then UNDEFINED;
pos = UInt(hw:'0000');

TAG:aarch64/integer/ins-ext/insert/movewide:index
Execute: aarch64/integer/ins-ext/insert/movewide:execute
Decode: aarch64/instrs/integer/ins-ext/insert/movewide:decode@aarch64/instrs/integer/ins-ext/insert/movewide:diagram
TAG:aarch64/vector/transfer/vector/permute/unzip:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operandl = V[n];
bits(datasize) operandh = V[m];
bits(datasize) result;

bits(datasize*2) zipped = operandh:operandl;
for e = 0 to elements-1
    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];

V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/permute/unzip:diagram
A64
31:31 _ 0
30:30 Q x
29:24 _ 001110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:14 op x
13:12 _ 01
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/permute/unzip:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);

TAG:aarch64/vector/transfer/vector/permute/unzip:index
Execute: aarch64/vector/transfer/vector/permute/unzip:execute
Decode: aarch64/instrs/vector/transfer/vector/permute/unzip:decode@aarch64/instrs/vector/transfer/vector/permute/unzip:diagram
TAG:ASRR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element1), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = ASR(element2, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ASRR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:ASRR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:ASRR-Z.P.ZZ-_:index
Execute: ASRR-Z.P.ZZ-_:execute
Decode: ASRR-Z.P.ZZ-_:decode@ASRR-Z.P.ZZ-_:diagram
TAG:aarch64/vector/crypto/sm3/sm3partw1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) result; 

result[95:0] = (Vd EOR Vn)[95:0] EOR (ROL(Vm[127:96],15):ROL(Vm[95:64],15):ROL(Vm[63:32],15));

for i = 0 to 3
    if i == 3 then 
        result[127:96] = (Vd EOR Vn)[127:96] EOR (ROL(result[31:0],15));
    result[(32*i)+31:(32*i)] = result[(32*i)+31:(32*i)] EOR ROL(result[(32*i)+31:(32*i)],15) EOR ROL(result[(32*i)+31:(32*i)],23);
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3partw1:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 1
13:12 _ 00
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3partw1:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sm3/sm3partw1:index
Execute: aarch64/vector/crypto/sm3/sm3partw1:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3partw1:decode@aarch64/instrs/vector/crypto/sm3/sm3partw1:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/max-min/pair:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
integer element1;
integer element2;
integer maxmin;

for e = 0 to elements-1
    element1 = Int(Elem[concat, 2*e, esize], unsigned);
    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);
    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
    Elem[result, e, esize] = maxmin[esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1010
11:11 o1 x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/max-min/pair:index
Execute: aarch64/vector/arithmetic/binary/uniform/max-min/pair:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/pair:diagram
TAG:aarch64/integer/tags/mcsettaganddatapairpost:execute
bits(64) address;
bits(64) data1;
bits(64) data2;

SetTagCheckedInstruction(FALSE);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

data1 = X[t];
data2 = X[t2];

if !postindex then
    address = address + offset;

Mem[address, 8, AccType_NORMAL] = data1;
Mem[address+8, 8, AccType_NORMAL] = data2;

AArch64.MemTag[address, AccType_NORMAL] = AArch64.AllocationTagFromAddress(address);

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/integer/tags/mcsettaganddatapairpost:diagram
A64
31:31 _ 0
30:30 _ 1
29:27 _ 101
26:26 _ 0
25:23 _ 001
22:22 _ 0
21:15 simm7 xxxxxxx
14:10 Xt2 xxxxx
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettaganddatapairpost:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;

TAG:aarch64/instrs/integer/tags/mcsettaganddatapairpre:diagram
A64
31:31 _ 0
30:30 _ 1
29:27 _ 101
26:26 _ 0
25:23 _ 011
22:22 _ 0
21:15 simm7 xxxxxxx
14:10 Xt2 xxxxx
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettaganddatapairpre:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;

TAG:aarch64/instrs/integer/tags/mcsettaganddatapair:diagram
A64
31:31 _ 0
30:30 _ 1
29:27 _ 101
26:26 _ 0
25:23 _ 010
22:22 _ 0
21:15 simm7 xxxxxxx
14:10 Xt2 xxxxx
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettaganddatapair:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
integer t2 = UInt(Xt2);
bits(64) offset = LSL(SignExtend(simm7, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;

TAG:aarch64/integer/tags/mcsettaganddatapairpost:index
Execute: aarch64/integer/tags/mcsettaganddatapairpost:execute
Decode: aarch64/instrs/integer/tags/mcsettaganddatapairpost:decode@aarch64/instrs/integer/tags/mcsettaganddatapairpost:diagram
Decode: aarch64/instrs/integer/tags/mcsettaganddatapairpre:decode@aarch64/instrs/integer/tags/mcsettaganddatapairpre:diagram
Decode: aarch64/instrs/integer/tags/mcsettaganddatapair:decode@aarch64/instrs/integer/tags/mcsettaganddatapair:diagram
TAG:UQINCD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQINCD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQINCD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQINCD-Z.ZS-_:index
Execute: UQINCD-Z.ZS-_:execute
Decode: UQINCD-Z.ZS-_:decode@UQINCD-Z.ZS-_:diagram
TAG:aarch64/vector/crypto/sha2op/sha1-hash:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed
V[d] = ROL(operand, 30);
TAG:aarch64/instrs/vector/crypto/sha2op/sha1-hash:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:17 _ 10100
16:12 _ 00000
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha2op/sha1-hash:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha2op/sha1-hash:index
Execute: aarch64/vector/crypto/sha2op/sha1-hash:execute
Decode: aarch64/instrs/vector/crypto/sha2op/sha1-hash:decode@aarch64/instrs/vector/crypto/sha2op/sha1-hash:diagram
TAG:aarch64/integer/tags/mcsettagpairpost:execute
bits(64) address;
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);

SetTagCheckedInstruction(FALSE);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if !postindex then
    address = address + offset;

if zero_data then
    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
    Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);

AArch64.MemTag[address, AccType_NORMAL] = tag;
AArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/integer/tags/mcsettagpairpost:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 0
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpairpost:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;
boolean zero_data = FALSE;

TAG:aarch64/instrs/integer/tags/mcsettagpairpre:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpairpre:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;
boolean zero_data = FALSE;

TAG:aarch64/instrs/integer/tags/mcsettagpair:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpair:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;
boolean zero_data = FALSE;

TAG:aarch64/integer/tags/mcsettagpairpost:index
Execute: aarch64/integer/tags/mcsettagpairpost:execute
Decode: aarch64/instrs/integer/tags/mcsettagpairpost:decode@aarch64/instrs/integer/tags/mcsettagpairpost:diagram
Decode: aarch64/instrs/integer/tags/mcsettagpairpre:decode@aarch64/instrs/integer/tags/mcsettagpairpre:diagram
Decode: aarch64/instrs/integer/tags/mcsettagpair:decode@aarch64/instrs/integer/tags/mcsettagpair:diagram
TAG:aarch64/memory/ordered:execute
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

case memop of
    when MemOp_STORE
        data = X[t];
        Mem[address, dbytes, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, dbytes, acctype];
        X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/ordered:diagram
A64
31:30 size xx
29:24 _ 001000
23:23 _ 1
22:22 L x
21:21 _ 0
20:16 Rs xxxxx
15:15 o0 x
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/ordered:decode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2); // ignored by load/store single register
integer s = UInt(Rs);   // ignored by all loads and store-release

AccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
integer datasize = elsize;
boolean tag_checked = n != 31;

TAG:aarch64/memory/ordered:index
Execute: aarch64/memory/ordered:execute
Decode: aarch64/instrs/memory/ordered:decode@aarch64/instrs/memory/ordered:diagram
TAG:MLA-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    integer element2 = UInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        integer product = element1 * element2;
        if sub_op then
            Elem[result, e, esize] = Elem[operand3, e, esize] - product;
        else
            Elem[result, e, esize] = Elem[operand3, e, esize] + product;
    else
        Elem[result, e, esize] = Elem[operand3, e, esize];

Z[da] = result;
TAG:MLA-Z.P.ZZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:14 _ 01
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:MLA-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean sub_op = FALSE;

TAG:MLA-Z.P.ZZZ-_:index
Execute: MLA-Z.P.ZZZ-_:execute
Decode: MLA-Z.P.ZZZ-_:decode@MLA-Z.P.ZZZ-_:diagram
TAG:FCMEQ-P.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(PL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        case op of
            when Cmp_EQ res = FPCompareEQ(element1, element2, FPCR);
            when Cmp_GE res = FPCompareGE(element1, element2, FPCR);
            when Cmp_GT res = FPCompareGT(element1, element2, FPCR);
            when Cmp_UN res = FPCompareUN(element1, element2, FPCR);
            when Cmp_NE res = FPCompareNE(element1, element2, FPCR);
            when Cmp_LT res = FPCompareGT(element2, element1, FPCR);
            when Cmp_LE res = FPCompareGE(element2, element1, FPCR);
        ElemP[result, e, esize] = if res then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

P[d] = result;
TAG:FCMEQ-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMEQ-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_EQ;

TAG:FCMGT-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FCMGT-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;

TAG:FCMGE-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMGE-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;

TAG:FCMNE-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:FCMNE-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_NE;

TAG:FCMUO-P.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:FCMUO-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_UN;

TAG:FCMEQ-P.P.ZZ-_:index
Execute: FCMEQ-P.P.ZZ-_:execute
Decode: FCMEQ-P.P.ZZ-_:decode@FCMEQ-P.P.ZZ-_:diagram
Decode: FCMGT-P.P.ZZ-_:decode@FCMGT-P.P.ZZ-_:diagram
Decode: FCMGE-P.P.ZZ-_:decode@FCMGE-P.P.ZZ-_:diagram
Decode: FCMNE-P.P.ZZ-_:decode@FCMNE-P.P.ZZ-_:diagram
Decode: FCMUO-P.P.ZZ-_:decode@FCMUO-P.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/unary/float/round/frint_32_64:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRoundIntN(element, FPCR, rounding, intsize);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/float/round/frint_32_64:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:13 _ 1111
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/round/frint_32_64:decode
if !HaveFrintExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer intsize = if op == '0' then 32 else 64; 
FPRounding rounding = if U == '0' then FPRounding_ZERO else FPRoundingMode(FPCR);

TAG:aarch64/vector/arithmetic/unary/float/round/frint_32_64:index
Execute: aarch64/vector/arithmetic/unary/float/round/frint_32_64:execute
Decode: aarch64/instrs/vector/arithmetic/unary/float/round/frint_32_64:decode@aarch64/instrs/vector/arithmetic/unary/float/round/frint_32_64:diagram
TAG:PRFH-I.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) base;
bits(64) addr;
base = Z[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFH-I.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 1;
integer offset = UInt(imm5);

TAG:PRFH-I.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 1;
integer offset = UInt(imm5);

TAG:PRFH-I.P.AI-S:index
Execute: PRFH-I.P.AI-S:execute
Decode: PRFH-I.P.AI-S:decode@PRFH-I.P.AI-S:diagram
Decode: PRFH-I.P.AI-D:decode@PRFH-I.P.AI-D:diagram
TAG:aarch64/integer/arithmetic/add-sub/shiftedreg:execute
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);
bits(4) nzcv;
bit carry_in;

if sub_op then
    operand2 = NOT(operand2);
    carry_in = '1';
else
    carry_in = '0';

(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

if setflags then 
    PSTATE.[N,Z,C,V] = nzcv;

X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/add-sub/shiftedreg:diagram
A64
31:31 sf x
30:30 op x
29:29 S x
28:24 _ 01011
23:22 shift xx
21:21 _ 0
20:16 Rm xxxxx
15:10 imm6 xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/add-sub/shiftedreg:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
boolean setflags = (S == '1');

if shift == '11' then UNDEFINED;
if sf == '0' && imm6[5] == '1' then UNDEFINED;

ShiftType shift_type = DecodeShift(shift);
integer shift_amount = UInt(imm6);

TAG:aarch64/integer/arithmetic/add-sub/shiftedreg:index
Execute: aarch64/integer/arithmetic/add-sub/shiftedreg:execute
Decode: aarch64/instrs/integer/arithmetic/add-sub/shiftedreg:decode@aarch64/instrs/integer/arithmetic/add-sub/shiftedreg:diagram
TAG:LD1W-Z.P.BR-U32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1W-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;

TAG:LD1W-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;

TAG:LD1W-Z.P.BR-U32:index
Execute: LD1W-Z.P.BR-U32:execute
Decode: LD1W-Z.P.BR-U32:decode@LD1W-Z.P.BR-U32:diagram
Decode: LD1W-Z.P.BR-U64:decode@LD1W-Z.P.BR-U64:diagram
TAG:CLASTA-V.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = V[dn];
bits(VL) operand2 = Z[m];
bits(esize) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = ZeroExtend(operand1);
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    result = Elem[operand2, last, esize];

V[dn] = result;
TAG:CLASTA-V.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10101
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Vdn xxxxx
TAG:CLASTA-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Vdn);
integer m = UInt(Zm);
boolean isBefore = FALSE;

TAG:CLASTA-V.P.Z-_:index
Execute: CLASTA-V.P.Z-_:execute
Decode: CLASTA-V.P.Z-_:decode@CLASTA-V.P.Z-_:diagram
TAG:SUB-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 - element2;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SUB-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 000
18:17 _ 00
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SUB-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:SUB-Z.P.ZZ-_:index
Execute: SUB-Z.P.ZZ-_:execute
Decode: SUB-Z.P.ZZ-_:decode@SUB-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/logical/bsl-eor:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1;
bits(datasize) operand2;
bits(datasize) operand3;
bits(datasize) operand4 = V[n];

case op of
    when VBitOp_VEOR
        operand1 = V[m];
        operand2 = Zeros();
        operand3 = Ones();
    when VBitOp_VBSL
        operand1 = V[m];
        operand2 = operand1;
        operand3 = V[d];
    when VBitOp_VBIT
        operand1 = V[d];
        operand2 = operand1;
        operand3 = V[m];
    when VBitOp_VBIF
        operand1 = V[d];
        operand2 = operand1;
        operand3 = NOT(V[m]);

V[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 opc2 xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

VBitOp op;

case opc2 of
    when '00' op = VBitOp_VEOR;
    when '01' op = VBitOp_VBSL;
    when '10' op = VBitOp_VBIT;
    when '11' op = VBitOp_VBIF;

TAG:aarch64/vector/arithmetic/binary/uniform/logical/bsl-eor:index
Execute: aarch64/vector/arithmetic/binary/uniform/logical/bsl-eor:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor:decode@aarch64/instrs/vector/arithmetic/binary/uniform/logical/bsl-eor:diagram
TAG:CMPEQ-P.P.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(PL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, (e * esize) DIV 64, 64], unsigned);
    if ElemP[mask, e, esize] == '1' then
        boolean cond;
        case op of
            when Cmp_EQ cond = element1 == element2;
            when Cmp_NE cond = element1 != element2;
            when Cmp_GE cond = element1 >= element2;
            when Cmp_LT cond = element1 <  element2;
            when Cmp_GT cond = element1 >  element2;
            when Cmp_LE cond = element1 <= element2;
        ElemP[result, e, esize] = if cond then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:CMPEQ-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPEQ-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_EQ;
boolean unsigned = FALSE;

TAG:CMPGT-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPGT-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
boolean unsigned = FALSE;

TAG:CMPGE-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPGE-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
boolean unsigned = FALSE;

TAG:CMPHI-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPHI-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
boolean unsigned = TRUE;

TAG:CMPHS-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPHS-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
boolean unsigned = TRUE;

TAG:CMPLT-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPLT-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_LT;
boolean unsigned = FALSE;

TAG:CMPLE-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPLE-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_LE;
boolean unsigned = FALSE;

TAG:CMPLO-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPLO-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_LT;
boolean unsigned = TRUE;

TAG:CMPLS-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPLS-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_LE;
boolean unsigned = TRUE;

TAG:CMPNE-P.P.ZW-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPNE-P.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_NE;
boolean unsigned = FALSE;

TAG:CMPEQ-P.P.ZW-_:index
Execute: CMPEQ-P.P.ZW-_:execute
Decode: CMPEQ-P.P.ZW-_:decode@CMPEQ-P.P.ZW-_:diagram
Decode: CMPGT-P.P.ZW-_:decode@CMPGT-P.P.ZW-_:diagram
Decode: CMPGE-P.P.ZW-_:decode@CMPGE-P.P.ZW-_:diagram
Decode: CMPHI-P.P.ZW-_:decode@CMPHI-P.P.ZW-_:diagram
Decode: CMPHS-P.P.ZW-_:decode@CMPHS-P.P.ZW-_:diagram
Decode: CMPLT-P.P.ZW-_:decode@CMPLT-P.P.ZW-_:diagram
Decode: CMPLE-P.P.ZW-_:decode@CMPLE-P.P.ZW-_:diagram
Decode: CMPLO-P.P.ZW-_:decode@CMPLO-P.P.ZW-_:diagram
Decode: CMPLS-P.P.ZW-_:decode@CMPLS-P.P.ZW-_:diagram
Decode: CMPNE-P.P.ZW-_:decode@CMPNE-P.P.ZW-_:diagram
TAG:aarch64/branch/conditional/cond:execute
if ConditionHolds(condition) then
    BranchTo(PC[] + offset, BranchType_DIR);
TAG:aarch64/instrs/branch/conditional/cond:diagram
A64
31:25 _ 0101010
24:24 _ 0
23:5 imm19 xxxxxxxxxxxxxxxxxxx
4:4 _ 0
3:0 cond xxxx
TAG:aarch64/instrs/branch/conditional/cond:decode
bits(64) offset = SignExtend(imm19:'00', 64);
bits(4) condition = cond;

TAG:aarch64/branch/conditional/cond:index
Execute: aarch64/branch/conditional/cond:execute
Decode: aarch64/instrs/branch/conditional/cond:decode@aarch64/instrs/branch/conditional/cond:diagram
TAG:aarch64/integer/flags/setf:execute
bits(32) tmpreg = X[n];
PSTATE.N = tmpreg[msb];
PSTATE.Z = if (tmpreg[msb:0] == Zeros(msb+1)) then '1' else '0';
PSTATE.V = tmpreg[msb+1] EOR tmpreg[msb];
//PSTATE.C unchanged;
TAG:aarch64/instrs/integer/flags/setf:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 1
28:21 _ 11010000
20:15 _ 000000
14:14 sz x
13:10 _ 0010
9:5 Rn xxxxx
4:4 _ 0
3:0 _ 1101
TAG:aarch64/instrs/integer/flags/setf:decode
if !HaveFlagManipulateExt() || sf != '0' then UNDEFINED;
integer msb = if sz=='1' then 15 else 7;
integer n = UInt(Rn);

TAG:aarch64/integer/flags/setf:index
Execute: aarch64/integer/flags/setf:execute
Decode: aarch64/instrs/integer/flags/setf:decode@aarch64/instrs/integer/flags/setf:diagram
TAG:CNTP-R.P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand = P[n];
bits(64) sum = Zeros();

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' && ElemP[operand, e, esize] == '1' then
        sum = sum + 1;
X[d] = sum;
TAG:CNTP-R.P.P-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 00
16:16 _ 0
15:14 _ 10
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:0 Rd xxxxx
TAG:CNTP-R.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Pn);
integer d = UInt(Rd);

TAG:CNTP-R.P.P-_:index
Execute: CNTP-R.P.P-_:execute
Decode: CNTP-R.P.P-_:decode@CNTP-R.P.P-_:diagram
TAG:DECP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    Elem[result, e, esize] = Elem[operand1, e, esize] - count;

Z[dn] = result;
TAG:DECP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1011
17:17 _ 0
16:16 _ 1
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:DECP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);

TAG:DECP-Z.P.Z-_:index
Execute: DECP-Z.P.Z-_:execute
Decode: DECP-Z.P.Z-_:decode@DECP-Z.P.Z-_:diagram
TAG:LD1RQD-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(64) offset;
bits(128) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQD-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQD-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;

TAG:LD1RQD-Z.P.BR-Contiguous:index
Execute: LD1RQD-Z.P.BR-Contiguous:execute
Decode: LD1RQD-Z.P.BR-Contiguous:decode@LD1RQD-Z.P.BR-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/max-min/single:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer maxmin;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);
    Elem[result, e, esize] = maxmin[esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 0110
11:11 o1 x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean minimum = (o1 == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/max-min/single:index
Execute: aarch64/vector/arithmetic/binary/uniform/max-min/single:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single:decode@aarch64/instrs/vector/arithmetic/binary/uniform/max-min/single:diagram
TAG:LDFF1D-Z.P.BR-U64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1D-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;

TAG:LDFF1D-Z.P.BR-U64:index
Execute: LDFF1D-Z.P.BR-U64:execute
Decode: LDFF1D-Z.P.BR-U64:decode@LDFF1D-Z.P.BR-U64:diagram
TAG:RBIT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = BitReverse(element);

Z[d] = result;
TAG:RBIT-Z.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1001
17:17 _ 1
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:RBIT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:RBIT-Z.P.Z-_:index
Execute: RBIT-Z.P.Z-_:execute
Decode: RBIT-Z.P.Z-_:decode@RBIT-Z.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/mul/product:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    Elem[result, e, 2*esize] = (element1 * element2)[2*esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/product:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:12 _ 0
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/product:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/mul/product:index
Execute: aarch64/vector/arithmetic/binary/disparate/mul/product:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/product:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/product:diagram
TAG:LD2H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:LD2H-Z.P.BI-Contiguous:index
Execute: LD2H-Z.P.BI-Contiguous:execute
Decode: LD2H-Z.P.BI-Contiguous:decode@LD2H-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/sub/saturating/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;
boolean sat;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    diff = element1 - element2;
    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00101
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00101
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/sub/saturating/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/sub/saturating/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/saturating/simd:diagram
TAG:BIC-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1 AND (NOT element2);
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:BIC-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:BIC-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:BICS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:BICS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:BIC-P.P.PP-Z:index
Execute: BIC-P.P.PP-Z:execute
Decode: BIC-P.P.PP-Z:decode@BIC-P.P.PP-Z:diagram
Decode: BICS-P.P.PP-Z:decode@BICS-P.P.PP-Z:diagram
TAG:aarch64/memory/single/general/immediate/signed/post-idx:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/immediate/signed/post-idx:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_NORMAL;
MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/general/immediate/signed/post-idx:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 01
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/post-idx:decode
boolean wback = TRUE;
boolean postindex = TRUE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/instrs/memory/single/general/immediate/signed/pre-idx:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 11
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/pre-idx:decode
boolean wback = TRUE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/instrs/memory/single/general/immediate/unsigned:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 01
23:22 opc xx
21:10 imm12 xxxxxxxxxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/unsigned:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(size);
bits(64) offset = LSL(ZeroExtend(imm12, 64), scale);

TAG:aarch64/memory/single/general/immediate/signed/post-idx:index
Execute: aarch64/memory/single/general/immediate/signed/post-idx:execute
Postdecode: aarch64/memory/single/general/immediate/signed/post-idx:postdecode
Decode: aarch64/instrs/memory/single/general/immediate/signed/post-idx:decode@aarch64/instrs/memory/single/general/immediate/signed/post-idx:diagram
Decode: aarch64/instrs/memory/single/general/immediate/signed/pre-idx:decode@aarch64/instrs/memory/single/general/immediate/signed/pre-idx:diagram
Decode: aarch64/instrs/memory/single/general/immediate/unsigned:decode@aarch64/instrs/memory/single/general/immediate/unsigned:diagram
TAG:aarch64/integer/arithmetic/mul/widening/64-128hi:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];

integer result;

result = Int(operand1, unsigned) * Int(operand2, unsigned);

X[d] = result[127:64];
TAG:aarch64/instrs/integer/arithmetic/mul/widening/64-128hi:diagram
A64
31:31 _ 1
30:29 _ 00
28:24 _ 11011
23:23 U x
22:21 _ 10
20:16 Rm xxxxx
15:15 _ 0
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/mul/widening/64-128hi:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);           // ignored by UMULH/SMULH
integer destsize = 64;
integer datasize = destsize;
boolean unsigned = (U == '1');

TAG:aarch64/integer/arithmetic/mul/widening/64-128hi:index
Execute: aarch64/integer/arithmetic/mul/widening/64-128hi:execute
Decode: aarch64/instrs/integer/arithmetic/mul/widening/64-128hi:decode@aarch64/instrs/integer/arithmetic/mul/widening/64-128hi:diagram
TAG:ORN-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1 OR (NOT element2);
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:ORN-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:ORN-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:ORNS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:ORNS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:ORN-P.P.PP-Z:index
Execute: ORN-P.P.PP-Z:execute
Decode: ORN-P.P.PP-Z:decode@ORN-P.P.PP-Z:diagram
Decode: ORNS-P.P.PP-Z:decode@ORNS-P.P.PP-Z:diagram
TAG:FRECPE-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);

Z[d] = result;
TAG:FRECPE-Z.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 001
18:17 _ 11
16:16 _ 0
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRECPE-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FRECPE-Z.Z-_:index
Execute: FRECPE-Z.Z-_:execute
Decode: FRECPE-Z.Z-_:decode@FRECPE-Z.Z-_:diagram
TAG:RDVL-R.I-_:execute
CheckSVEEnabled();
integer len = imm * (VL DIV 8);
X[d] = len[63:0];
TAG:RDVL-R.I-_:diagram
A64
31:23 _ 000001001
22:22 _ 0
21:21 _ 1
20:17 _ 1111
16:16 _ 1
15:11 _ 01010
10:5 imm6 xxxxxx
4:0 Rd xxxxx
TAG:RDVL-R.I-_:decode
if !HaveSVE() then UNDEFINED;
integer d = UInt(Rd);
integer imm = SInt(imm6);

TAG:RDVL-R.I-_:index
Execute: RDVL-R.I-_:execute
Decode: RDVL-R.I-_:decode@RDVL-R.I-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/cmp/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
boolean test_passed;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if abs then
        element1 = FPAbs(element1);
        element2 = FPAbs(element2);
    case cmp of
        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);
        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);
        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 E x
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:12 _ 10
11:11 ac x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;

case E:U:ac of
    when '000' cmp = CompareOp_EQ; abs = FALSE;
    when '010' cmp = CompareOp_GE; abs = FALSE;
    when '011' cmp = CompareOp_GE; abs = TRUE;
    when '110' cmp = CompareOp_GT; abs = FALSE;
    when '111' cmp = CompareOp_GT; abs = TRUE;
    otherwise  UNDEFINED;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 E x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1110
11:11 ac x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
CompareOp cmp;
boolean abs;

case E:U:ac of
    when '000' cmp = CompareOp_EQ; abs = FALSE;
    when '010' cmp = CompareOp_GE; abs = FALSE;
    when '011' cmp = CompareOp_GE; abs = TRUE;
    when '110' cmp = CompareOp_GT; abs = FALSE;
    when '111' cmp = CompareOp_GT; abs = TRUE;
    otherwise  UNDEFINED;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 E x
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:12 _ 10
11:11 ac x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;

case E:U:ac of
    when '000' cmp = CompareOp_EQ; abs = FALSE;
    when '010' cmp = CompareOp_GE; abs = FALSE;
    when '011' cmp = CompareOp_GE; abs = TRUE;
    when '110' cmp = CompareOp_GT; abs = FALSE;
    when '111' cmp = CompareOp_GT; abs = TRUE;
    otherwise  UNDEFINED;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 E x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1110
11:11 ac x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
CompareOp cmp;
boolean abs;

case E:U:ac of
    when '000' cmp = CompareOp_EQ; abs = FALSE;
    when '010' cmp = CompareOp_GE; abs = FALSE;
    when '011' cmp = CompareOp_GE; abs = TRUE;
    when '110' cmp = CompareOp_GT; abs = FALSE;
    when '111' cmp = CompareOp_GT; abs = TRUE;
    otherwise  UNDEFINED;

TAG:aarch64/vector/arithmetic/binary/uniform/cmp/fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/cmp/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/cmp/fp/simd:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/long:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(idxdsize)   operand2 = V[m];
bits(2*datasize) operand3 = V[d];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;

element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    product = (element1 * element2)[2*esize-1:0];
    if sub_op then
        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;
    else
        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 10
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');
boolean sub_op = (o2 == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/long:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/long:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/long:diagram
TAG:aarch64/branch/unconditional/register:execute
bits(64) target = X[n];
boolean auth_then_branch = TRUE;

if pac then
    bits(64) modifier = if source_is_sp then SP[] else X[m];

    if use_key_a then
        target = AuthIA(target, modifier, auth_then_branch);
    else
        target = AuthIB(target, modifier, auth_then_branch);

if branch_type == BranchType_INDCALL then X[30] = PC[] + 4;

// Value in BTypeNext will be used to set PSTATE.BTYPE
case branch_type of
    when BranchType_INDIR           // BR, BRAA, BRAB, BRAAZ, BRABZ
        if InGuardedPage then
            if n == 16 || n == 17 then
                BTypeNext = '01';
            else
                BTypeNext = '11';
        else
            BTypeNext = '01';
    when BranchType_INDCALL         // BLR, BLRAA, BLRAB, BLRAAZ, BLRABZ
        BTypeNext = '10';
    when BranchType_RET             // RET, RETAA, RETAB 
        BTypeNext = '00';

BranchTo(target, branch_type);
TAG:aarch64/instrs/branch/unconditional/register:diagram
A64
31:25 _ 1101011
24:24 Z x
23:23 _ 0
22:21 op xx
20:16 _ 11111
15:12 _ 0000
11:11 A x
10:10 M x
9:5 Rn xxxxx
4:0 Rm xxxxx
TAG:aarch64/instrs/branch/unconditional/register:decode
integer n = UInt(Rn);
BranchType branch_type;
integer m = UInt(Rm);
boolean pac = (A == '1');
boolean use_key_a = (M == '0');
boolean source_is_sp = ((Z == '1') && (m == 31));

if !pac && m != 0 then 
    UNDEFINED;
elsif pac && !HavePACExt() then 
    UNDEFINED;

case op of
    when '00' branch_type = BranchType_INDIR;
    when '01' branch_type = BranchType_INDCALL;
    when '10' branch_type = BranchType_RET;
    otherwise UNDEFINED;

if pac then
    if Z == '0' && m != 31 then
        UNDEFINED;

    if branch_type == BranchType_RET then
        if n != 31 then UNDEFINED;
        n = 30;
        source_is_sp = TRUE;

TAG:aarch64/branch/unconditional/register:index
Execute: aarch64/branch/unconditional/register:execute
Decode: aarch64/instrs/branch/unconditional/register:decode@aarch64/instrs/branch/unconditional/register:diagram
TAG:LD3B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:LD3B-Z.P.BI-Contiguous:index
Execute: LD3B-Z.P.BI-Contiguous:execute
Decode: LD3B-Z.P.BI-Contiguous:decode@LD3B-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/crypto/sm3/sm3tt1a:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result; 
bits(32) TT1;
bits(32) SS2;

WjPrime = Elem[Vm,i,32];
SS2 = Vn[127:96] EOR ROL(Vd[127:96],12); 
TT1 = Vd[63:32] EOR (Vd[127:96] EOR Vd[95:64]);
TT1 = (TT1 + Vd[31:0] + SS2 + WjPrime)[31:0];
result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],9); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT1; 
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt1a:diagram
A64
31:21 _ 11001110010
20:16 Rm xxxxx
15:14 _ 10
13:12 imm2 xx
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt1a:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer i = UInt(imm2);

TAG:aarch64/vector/crypto/sm3/sm3tt1a:index
Execute: aarch64/vector/crypto/sm3/sm3tt1a:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3tt1a:decode@aarch64/instrs/vector/crypto/sm3/sm3tt1a:diagram
TAG:aarch64/vector/arithmetic/unary/cmp/int/bulk/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;

for e = 0 to elements-1
    element = SInt(Elem[operand, e, esize]);
    case comparison of
        when CompareOp_GT test_passed = element > 0;
        when CompareOp_GE test_passed = element >= 0;
        when CompareOp_EQ test_passed = element == 0;
        when CompareOp_LE test_passed = element <= 0;
        when CompareOp_LT test_passed = element < 0;
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:13 _ 0100
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:13 _ 0100
12:12 op x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison;
case op:U of
    when '00' comparison = CompareOp_GT;
    when '01' comparison = CompareOp_GE;
    when '10' comparison = CompareOp_EQ;
    when '11' comparison = CompareOp_LE;

TAG:aarch64/vector/arithmetic/unary/cmp/int/bulk/sisd:index
Execute: aarch64/vector/arithmetic/unary/cmp/int/bulk/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/int/bulk/simd:diagram
TAG:NOT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = NOT element;

Z[d] = result;
TAG:NOT-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 11
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:NOT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:NOT-Z.P.Z-_:index
Execute: NOT-Z.P.Z-_:execute
Decode: NOT-Z.P.Z-_:decode@NOT-Z.P.Z-_:diagram
TAG:LDNT1B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LDNT1B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;

TAG:LDNT1B-Z.P.BR-Contiguous:index
Execute: LDNT1B-Z.P.BR-Contiguous:execute
Decode: LDNT1B-Z.P.BR-Contiguous:decode@LDNT1B-Z.P.BR-Contiguous:diagram
TAG:LD3W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:LD3W-Z.P.BI-Contiguous:index
Execute: LD3W-Z.P.BI-Contiguous:execute
Decode: LD3W-Z.P.BI-Contiguous:decode@LD3W-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/crypto/sha3op/sha1-hash/choose:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
    t = SHAchoose(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
V[d] = X;
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:12 _ 000
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha3op/sha1-hash/choose:index
Execute: aarch64/vector/crypto/sha3op/sha1-hash/choose:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose:decode@aarch64/instrs/vector/crypto/sha3op/sha1-hash/choose:diagram
TAG:SQDECD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQDECD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQDECD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQDECD-Z.ZS-_:index
Execute: SQDECD-Z.ZS-_:execute
Decode: SQDECD-Z.ZS-_:decode@SQDECD-Z.ZS-_:diagram
TAG:aarch64/vector/transfer/vector/table:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) indices = V[m];
bits(128*regs) table = Zeros();
bits(datasize) result;
integer index;

// Create table from registers
for i = 0 to regs - 1
    table[128*i+127:128*i] = V[n];
    n = (n + 1) MOD 32;

result = if is_tbl then Zeros() else V[d];
for i = 0 to elements - 1
    index = UInt(Elem[indices, i, 8]);
    if index < 16 * regs then
        Elem[result, i, 8] = Elem[table, index, 8];

V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/table:diagram
A64
31:31 _ 0
30:30 Q x
29:24 _ 001110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:13 len xx
12:12 op x
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/table:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;
integer regs = UInt(len) + 1;
boolean is_tbl = (op == '0');

TAG:aarch64/vector/transfer/vector/table:index
Execute: aarch64/vector/transfer/vector/table:execute
Decode: aarch64/instrs/vector/transfer/vector/table:decode@aarch64/instrs/vector/transfer/vector/table:diagram
TAG:BRKN-P.P.PP-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[dm];
bits(PL) result;

if LastActive(mask, operand1, 8) == '1' then
    result = operand2;
else
    result = Zeros();

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(Ones(PL), result, 8);
P[dm] = result;
TAG:BRKN-P.P.PP-_:diagram
A64
31:23 _ 001001010
22:22 _ 0
21:14 _ 01100001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pdm xxxx
TAG:BRKN-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer dm = UInt(Pdm);
boolean setflags = FALSE;

TAG:BRKNS-P.P.PP-_:diagram
A64
31:23 _ 001001010
22:22 _ 1
21:14 _ 01100001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pdm xxxx
TAG:BRKNS-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer dm = UInt(Pdm);
boolean setflags = TRUE;

TAG:BRKN-P.P.PP-_:index
Execute: BRKN-P.P.PP-_:execute
Decode: BRKN-P.P.PP-_:decode@BRKN-P.P.PP-_:diagram
Decode: BRKNS-P.P.PP-_:decode@BRKNS-P.P.PP-_:diagram
TAG:UDOT-Z.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:UDOT-Z.ZZZ-_:diagram
A64
31:24 _ 01000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:UDOT-Z.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:UDOT-Z.ZZZ-_:index
Execute: UDOT-Z.ZZZ-_:execute
Decode: UDOT-Z.ZZZ-_:decode@UDOT-Z.ZZZ-_:diagram
TAG:ADD-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = element1 + element2;

Z[d] = result;
TAG:ADD-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ADD-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:ADD-Z.ZZ-_:index
Execute: ADD-Z.ZZ-_:execute
Decode: ADD-Z.ZZ-_:decode@ADD-Z.ZZ-_:diagram
TAG:aarch64/integer/pac/pacga/dp_2src:execute
if source_is_sp then
    X[d] = AddPACGA(X[n], SP[]);
else
    X[d] = AddPACGA(X[n], X[m]);
TAG:aarch64/instrs/integer/pac/pacga/dp_2src:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Rm xxxxx
15:10 _ 001100
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/pacga/dp_2src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if !HavePACExt() then
    UNDEFINED;

if m == 31 then source_is_sp = TRUE;

TAG:aarch64/integer/pac/pacga/dp_2src:index
Execute: aarch64/integer/pac/pacga/dp_2src:execute
Decode: aarch64/instrs/integer/pac/pacga/dp_2src:decode@aarch64/instrs/integer/pac/pacga/dp_2src:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/wrapping/pair:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[concat, 2*e, esize];
    element2 = Elem[concat, (2*e)+1, esize];
    Elem[result, e, esize] = element1 + element2;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/add/wrapping/pair:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/wrapping/pair:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/pair:diagram
TAG:FMSB-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMSB-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Za xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMSB-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean op1_neg = TRUE;
boolean op3_neg = FALSE;

TAG:FMSB-Z.P.ZZZ-_:index
Execute: FMSB-Z.P.ZZZ-_:execute
Decode: FMSB-Z.P.ZZZ-_:decode@FMSB-Z.P.ZZZ-_:diagram
TAG:FMAX-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMax(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMAX-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 011
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMAX-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMAX-Z.P.ZZ-_:index
Execute: FMAX-Z.P.ZZ-_:execute
Decode: FMAX-Z.P.ZZ-_:decode@FMAX-Z.P.ZZ-_:diagram
TAG:LDNT1D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LDNT1D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;

TAG:LDNT1D-Z.P.BR-Contiguous:index
Execute: LDNT1D-Z.P.BR-Contiguous:execute
Decode: LDNT1D-Z.P.BR-Contiguous:decode@LDNT1D-Z.P.BR-Contiguous:diagram
TAG:aarch64/integer/tags/mcsettagarray:execute
if PSTATE.EL == EL0 then
    UNDEFINED;

bits(64) data = X[t];
bits(64) address;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

integer size = 4*(2^(UInt(GMID_EL1.BS)));
address = Align(address,size);
integer count = size >> LOG2_TAG_GRANULE;
integer index = UInt(address[LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE]);

for i = 0 to count-1
    bits(4) tag = data[(index*4)+3:index*4];
    AArch64.MemTag[address, AccType_NORMAL] = tag;
    address = address + TAG_GRANULE;
    index = index + 1;
TAG:aarch64/instrs/integer/tags/mcsettagarray:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:19 _ 0
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagarray:decode
integer t = UInt(Xt);
integer n = UInt(Xn);

TAG:aarch64/integer/tags/mcsettagarray:index
Execute: aarch64/integer/tags/mcsettagarray:execute
Decode: aarch64/instrs/integer/tags/mcsettagarray:decode@aarch64/instrs/integer/tags/mcsettagarray:diagram
TAG:FMAXV-V.P.Z-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) identity = FPInfinity('1');

V[d] = ReducePredicated(ReduceOp_FMAX, operand, mask, identity);
TAG:FMAXV-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 11
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:FMAXV-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:FMAXV-V.P.Z-_:index
Execute: FMAXV-V.P.Z-_:execute
Decode: FMAXV-V.P.Z-_:decode@FMAXV-V.P.Z-_:diagram
TAG:aarch64/integer/tags/mcsettagandzeroarray:execute
if PSTATE.EL == EL0 then
    UNDEFINED;

bits(64) data = X[t];
bits(4) tag = data[3:0];
bits(64) address;
if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

integer size = 4*(2^(UInt(DCZID_EL0.BS)));
address = Align(address,size);
integer count = size >> LOG2_TAG_GRANULE;

for i = 0 to count-1
    AArch64.MemTag[address, AccType_NORMAL] = tag;
    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
    address = address + TAG_GRANULE;
TAG:aarch64/instrs/integer/tags/mcsettagandzeroarray:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:19 _ 0
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagandzeroarray:decode
integer t = UInt(Xt);
integer n = UInt(Xn);

TAG:aarch64/integer/tags/mcsettagandzeroarray:index
Execute: aarch64/integer/tags/mcsettagandzeroarray:execute
Decode: aarch64/instrs/integer/tags/mcsettagandzeroarray:decode@aarch64/instrs/integer/tags/mcsettagandzeroarray:diagram
TAG:ST1D-Z.P.BZ-D.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(VL) offset = Z[m];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1D-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 3;

TAG:ST1D-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1D-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 3;

TAG:ST1D-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:ST1D-Z.P.BZ-D.x32.scaled:index
Execute: ST1D-Z.P.BZ-D.x32.scaled:execute
Decode: ST1D-Z.P.BZ-D.x32.scaled:decode@ST1D-Z.P.BZ-D.x32.scaled:diagram
Decode: ST1D-Z.P.BZ-D.x32.unscaled:decode@ST1D-Z.P.BZ-D.x32.unscaled:diagram
Decode: ST1D-Z.P.BZ-D.64.scaled:decode@ST1D-Z.P.BZ-D.64.scaled:diagram
Decode: ST1D-Z.P.BZ-D.64.unscaled:decode@ST1D-Z.P.BZ-D.64.unscaled:diagram
TAG:LD1H-Z.P.BR-U16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1H-Z.P.BR-U16:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BR-U16:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LD1H-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LD1H-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;

TAG:LD1H-Z.P.BR-U16:index
Execute: LD1H-Z.P.BR-U16:execute
Decode: LD1H-Z.P.BR-U16:decode@LD1H-Z.P.BR-U16:diagram
Decode: LD1H-Z.P.BR-U32:decode@LD1H-Z.P.BR-U32:diagram
Decode: LD1H-Z.P.BR-U64:decode@LD1H-Z.P.BR-U64:diagram
TAG:SQINCB-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQINCB-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCB-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQINCB-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCB-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQINCB-R.RS-SX:index
Execute: SQINCB-R.RS-SX:execute
Decode: SQINCB-R.RS-SX:decode@SQINCB-R.RS-SX:diagram
Decode: SQINCB-R.RS-X:decode@SQINCB-R.RS-X:diagram
TAG:aarch64/vector/arithmetic/unary/float/widen:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;

for e = 0 to elements-1
    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/float/widen:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 10111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/widen:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16 << UInt(sz);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/float/widen:index
Execute: aarch64/vector/arithmetic/unary/float/widen:execute
Decode: aarch64/instrs/vector/arithmetic/unary/float/widen:decode@aarch64/instrs/vector/arithmetic/unary/float/widen:diagram
TAG:aarch64/integer/pac/pacia/dp_1src:execute
if HavePACExt() then
    if source_is_sp then
        X[d] = AddPACIA(X[d], SP[]);
    else
        X[d] = AddPACIA(X[d], X[n]);
TAG:aarch64/instrs/integer/pac/pacia/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/pacia/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // PACIA
    if n == 31 then source_is_sp = TRUE;
else // PACIZA
    if n != 31 then UNDEFINED;

TAG:aarch64/instrs/integer/pac/pacia/hint:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/integer/pac/pacia/hint:decode
integer d;
integer n;
boolean source_is_sp = FALSE;

case CRm:op2 of
    when '0011 000' // PACIAZ 
        d = 30;
        n = 31;
    when '0011 001' // PACIASP
        d = 30;
        source_is_sp = TRUE;
        if HaveBTIExt() then
            // Check for branch target compatibility between PSTATE.BTYPE
            // and implicit branch target of PACIASP instruction.
            SetBTypeCompatible(BTypeCompatible_PACIXSP());

    when '0001 000' // PACIA1716
        d = 17;
        n = 16;
    when '0001 010' SEE "PACIB";
    when '0001 100' SEE "AUTIA";
    when '0001 110' SEE "AUTIB";
    when '0011 01x' SEE "PACIB";
    when '0011 10x' SEE "AUTIA";
    when '0011 11x' SEE "AUTIB";
    when '0000 111' SEE "XPACLRI";
    otherwise       SEE "HINT";

TAG:aarch64/integer/pac/pacia/dp_1src:index
Execute: aarch64/integer/pac/pacia/dp_1src:execute
Decode: aarch64/instrs/integer/pac/pacia/dp_1src:decode@aarch64/instrs/integer/pac/pacia/dp_1src:diagram
Decode: aarch64/instrs/integer/pac/pacia/hint:decode@aarch64/instrs/integer/pac/pacia/hint:diagram
TAG:DUPM-Z.I-_:execute
CheckSVEEnabled();
bits(VL) result = Replicate(imm);
Z[d] = result;
TAG:DUPM-Z.I-_:diagram
A64
31:18 _ 00000101110000
17:5 imm13 xxxxxxxxxxxxx
4:0 Zd xxxxx
TAG:DUPM-Z.I-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer d = UInt(Zd);
bits(esize) imm;
(imm, -) = DecodeBitMasks(imm13[12], imm13[5:0], imm13[11:6], TRUE);

TAG:DUPM-Z.I-_:index
Execute: DUPM-Z.I-_:execute
Decode: DUPM-Z.I-_:decode@DUPM-Z.I-_:diagram
TAG:LASTB-V.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer last = LastActiveElement(mask, esize);

if isBefore then
    if last < 0 then last = elements - 1;
else
    last = last + 1;
    if last >= elements then last = 0;
V[d] = Elem[operand, last, esize];
TAG:LASTB-V.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10001
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:LASTB-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean isBefore = TRUE;

TAG:LASTB-V.P.Z-_:index
Execute: LASTB-V.P.Z-_:execute
Decode: LASTB-V.P.Z-_:decode@LASTB-V.P.Z-_:diagram
TAG:ASR-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    Elem[result, e, esize] = ASR(element1, shift);

Z[d] = result;
TAG:ASR-Z.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:21 _ 1
20:19 tszl xx
18:16 imm3 xxx
15:12 _ 1001
11:11 _ 0
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ASR-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer n = UInt(Zn);
integer d = UInt(Zd);
integer shift = (2 * esize) - UInt(tsize:imm3);

TAG:ASR-Z.ZI-_:index
Execute: ASR-Z.ZI-_:execute
Decode: ASR-Z.ZI-_:decode@ASR-Z.ZI-_:diagram
TAG:FADD-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);

Z[d] = result;
TAG:FADD-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FADD-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FADD-Z.ZZ-_:index
Execute: FADD-Z.ZZ-_:execute
Decode: FADD-Z.ZZ-_:decode@FADD-Z.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/unary/diff-neg/int/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;

for e = 0 to elements-1
    element = SInt(Elem[operand, e, esize]);
    if neg then
        element = -element;
    else
        element = Abs(element);
    Elem[result, e, esize] = element[esize-1:0];                

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 01011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean neg = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 01011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

TAG:aarch64/vector/arithmetic/unary/diff-neg/int/sisd:index
Execute: aarch64/vector/arithmetic/unary/diff-neg/int/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/int/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/int/simd:diagram
TAG:BIC-Z.ZZ-_:execute
CheckSVEEnabled();
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];

Z[d] = operand1 AND (NOT operand2);
TAG:BIC-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:BIC-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:BIC-Z.ZZ-_:index
Execute: BIC-Z.ZZ-_:execute
Decode: BIC-Z.ZZ-_:decode@BIC-Z.ZZ-_:diagram
TAG:LD1RQH-Z.P.BI-U16:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(128) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 16;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQH-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQH-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);

TAG:LD1RQH-Z.P.BI-U16:index
Execute: LD1RQH-Z.P.BI-U16:execute
Decode: LD1RQH-Z.P.BI-U16:decode@LD1RQH-Z.P.BI-U16:diagram
TAG:LD3D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 3;

TAG:LD3D-Z.P.BR-Contiguous:index
Execute: LD3D-Z.P.BR-Contiguous:execute
Decode: LD3D-Z.P.BR-Contiguous:decode@LD3D-Z.P.BR-Contiguous:diagram
TAG:FMAXNM-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMaxNum(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMAXNM-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 10
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FMAXNM-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

TAG:FMAXNM-Z.P.ZS-_:index
Execute: FMAXNM-Z.P.ZS-_:execute
Decode: FMAXNM-Z.P.ZS-_:decode@FMAXNM-Z.P.ZS-_:diagram
TAG:FMIN-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMin(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMIN-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 011
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMIN-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMIN-Z.P.ZZ-_:index
Execute: FMIN-Z.P.ZZ-_:execute
Decode: FMIN-Z.P.ZZ-_:decode@FMIN-Z.P.ZZ-_:diagram
TAG:EOR-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV 64;
bits(VL) operand = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(64) element1 = Elem[operand, e, 64];
    Elem[result, e, 64] = element1 EOR imm;

Z[dn] = result;
TAG:EOR-Z.ZI-_:diagram
A64
31:24 _ 00000101
23:23 _ 0
22:22 _ 1
21:18 _ 0000
17:5 imm13 xxxxxxxxxxxxx
4:0 Zdn xxxxx
TAG:EOR-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer dn = UInt(Zdn);
bits(64) imm;
(imm, -) = DecodeBitMasks(imm13[12], imm13[5:0], imm13[11:6], TRUE);

TAG:EOR-Z.ZI-_:index
Execute: EOR-Z.ZI-_:execute
Decode: EOR-Z.ZI-_:decode@EOR-Z.ZI-_:diagram
TAG:ST2W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST2W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:ST2W-Z.P.BI-Contiguous:index
Execute: ST2W-Z.P.BI-Contiguous:execute
Decode: ST2W-Z.P.BI-Contiguous:decode@ST2W-Z.P.BI-Contiguous:diagram
TAG:ZIP2-P.PP-_:execute
CheckSVEEnabled();
integer pairs = VL DIV (esize * 2);
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

integer base = part * pairs;
for p = 0 to pairs-1
    Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, base+p, esize DIV 8];
    Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, base+p, esize DIV 8];

P[d] = result;
TAG:ZIP2-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 0
11:11 _ 0
10:10 _ 1
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:ZIP2-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 1;

TAG:ZIP1-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:ZIP1-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 0;

TAG:ZIP2-P.PP-_:index
Execute: ZIP2-P.PP-_:execute
Decode: ZIP2-P.PP-_:decode@ZIP2-P.PP-_:diagram
Decode: ZIP1-P.PP-_:decode@ZIP1-P.PP-_:diagram
TAG:LD1SB-Z.P.BI-S16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1SB-Z.P.BI-S16:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BI-S16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SB-Z.P.BI-S32:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SB-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LD1SB-Z.P.BI-S16:index
Execute: LD1SB-Z.P.BI-S16:execute
Decode: LD1SB-Z.P.BI-S16:decode@LD1SB-Z.P.BI-S16:diagram
Decode: LD1SB-Z.P.BI-S32:decode@LD1SB-Z.P.BI-S32:diagram
Decode: LD1SB-Z.P.BI-S64:decode@LD1SB-Z.P.BI-S64:diagram
TAG:FSUBR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPSub(element2, element1, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FSUBR-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 001
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FSUBR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FSUBR-Z.P.ZZ-_:index
Execute: FSUBR-Z.P.ZZ-_:execute
Decode: FSUBR-Z.P.ZZ-_:decode@FSUBR-Z.P.ZZ-_:diagram
TAG:LD3B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 3;

TAG:LD3B-Z.P.BR-Contiguous:index
Execute: LD3B-Z.P.BR-Contiguous:execute
Decode: LD3B-Z.P.BR-Contiguous:decode@LD3B-Z.P.BR-Contiguous:diagram
TAG:aarch64/system/exceptions/runtime/smc:execute
AArch64.CheckForSMCUndefOrTrap(imm);

if SCR_EL3.SMD == '1' then
    // SMC disabled
    UNDEFINED;
else
    AArch64.CallSecureMonitor(imm);
TAG:aarch64/instrs/system/exceptions/runtime/smc:diagram
A64
31:24 _ 11010100
23:21 _ 000
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 _ 11
TAG:aarch64/instrs/system/exceptions/runtime/smc:decode
bits(16) imm = imm16;

TAG:aarch64/system/exceptions/runtime/smc:index
Execute: aarch64/system/exceptions/runtime/smc:execute
Decode: aarch64/instrs/system/exceptions/runtime/smc:decode@aarch64/instrs/system/exceptions/runtime/smc:diagram
TAG:SQSUB-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);

Z[d] = result;
TAG:SQSUB-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SQSUB-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
boolean unsigned = FALSE;

TAG:SQSUB-Z.ZZ-_:index
Execute: SQSUB-Z.ZZ-_:execute
Decode: SQSUB-Z.ZZ-_:decode@SQSUB-Z.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul/long:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(idxdsize)   operand2 = V[m];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;

element2 = Int(Elem[operand2, index, esize], unsigned);
for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    product = (element1 * element2)[2*esize-1:0];
    Elem[result, e, 2*esize] = product;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1010
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/long:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul/long:index
Execute: aarch64/vector/arithmetic/binary/element/mul/long:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/long:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/long:diagram
TAG:aarch64/vector/crypto/sha3op/sha1-sched0:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) operand3 = V[m];
bits(128) result;

result = operand2[63:0] : operand1[127:64];
result = result EOR operand1 EOR operand3;
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-sched0:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:12 _ 011
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-sched0:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha3op/sha1-sched0:index
Execute: aarch64/vector/crypto/sha3op/sha1-sched0:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha1-sched0:decode@aarch64/instrs/vector/crypto/sha3op/sha1-sched0:diagram
TAG:SPLICE-Z.P.ZZ-Des:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;
integer x = 0;
boolean active = FALSE;
integer lastnum = LastActiveElement(mask, esize);

if lastnum >= 0 then
    for e = 0 to lastnum
        active = active || ElemP[mask, e, esize] == '1';
        if active then
            Elem[result, x, esize] = Elem[operand1, e, esize];
            x = x + 1;

elements = elements - x - 1;
for e = 0 to elements
    Elem[result, x, esize] = Elem[operand2, e, esize];
    x = x + 1;

Z[dn] = result;
TAG:SPLICE-Z.P.ZZ-Des:diagram
A64
31:24 _ 00000101
23:22 size xx
21:13 _ 101100100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SPLICE-Z.P.ZZ-Des:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:SPLICE-Z.P.ZZ-Des:index
Execute: SPLICE-Z.P.ZZ-Des:execute
Decode: SPLICE-Z.P.ZZ-Des:decode@SPLICE-Z.P.ZZ-Des:diagram
TAG:ST4H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST4H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 4;

TAG:ST4H-Z.P.BR-Contiguous:index
Execute: ST4H-Z.P.BR-Contiguous:execute
Decode: ST4H-Z.P.BR-Contiguous:decode@ST4H-Z.P.BR-Contiguous:diagram
TAG:UQINCW-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQINCW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQINCW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQINCW-Z.ZS-_:index
Execute: UQINCW-Z.ZS-_:execute
Decode: UQINCW-Z.ZS-_:decode@UQINCW-Z.ZS-_:diagram
TAG:ZIP2-Z.ZZ-_:execute
CheckSVEEnabled();
if VL < esize * 2 then UNDEFINED;
integer pairs = VL DIV (esize * 2);
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result = Zeros();

integer base = part * pairs;
for p = 0 to pairs-1
    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];

Z[d] = result;
TAG:ZIP2-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 00
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ZIP2-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:ZIP2-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ZIP2-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:ZIP1-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 00
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ZIP1-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:ZIP1-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ZIP1-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:ZIP2-Z.ZZ-_:index
Execute: ZIP2-Z.ZZ-_:execute
Decode: ZIP2-Z.ZZ-_:decode@ZIP2-Z.ZZ-_:diagram
Decode: ZIP2-Z.ZZ-Q:decode@ZIP2-Z.ZZ-Q:diagram
Decode: ZIP1-Z.ZZ-_:decode@ZIP1-Z.ZZ-_:diagram
Decode: ZIP1-Z.ZZ-Q:decode@ZIP1-Z.ZZ-Q:diagram
TAG:aarch64/integer/pac/pacib/dp_1src:execute
if HavePACExt() then
    if source_is_sp then
        X[d] = AddPACIB(X[d], SP[]);
    else
        X[d] = AddPACIB(X[d], X[n]);
TAG:aarch64/instrs/integer/pac/pacib/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 001
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/pacib/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // PACIB
    if n == 31 then source_is_sp = TRUE;
else // PACIZB
    if n != 31 then UNDEFINED;

TAG:aarch64/instrs/integer/pac/pacib/hint:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/integer/pac/pacib/hint:decode
integer d;
integer n;
boolean source_is_sp = FALSE;

case CRm:op2 of
    when '0011 010' // PACIBZ
        d = 30;
        n = 31;
    when '0011 011' // PACIBSP
        d = 30;
        source_is_sp = TRUE;
        if HaveBTIExt() then
            // Check for branch target compatibility between PSTATE.BTYPE
            // and implicit branch target of PACIBSP instruction.
            SetBTypeCompatible(BTypeCompatible_PACIXSP());
    when '0001 010' // PACIB1716
        d = 17;
        n = 16;
    when '0001 000' SEE "PACIA";
    when '0001 100' SEE "AUTIA";
    when '0001 110' SEE "AUTIB";
    when '0011 00x' SEE "PACIA";
    when '0011 10x' SEE "AUTIA";
    when '0011 11x' SEE "AUTIB";
    when '0000 111' SEE "XPACLRI";
    otherwise       SEE "HINT";

TAG:aarch64/integer/pac/pacib/dp_1src:index
Execute: aarch64/integer/pac/pacib/dp_1src:execute
Decode: aarch64/instrs/integer/pac/pacib/dp_1src:decode@aarch64/instrs/integer/pac/pacib/dp_1src:diagram
Decode: aarch64/instrs/integer/pac/pacib/hint:decode@aarch64/instrs/integer/pac/pacib/hint:diagram
TAG:LD1D-Z.P.BR-U64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1D-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;

TAG:LD1D-Z.P.BR-U64:index
Execute: LD1D-Z.P.BR-U64:execute
Decode: LD1D-Z.P.BR-U64:decode@LD1D-Z.P.BR-U64:diagram
TAG:FMUL-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMul(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMUL-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 001
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMUL-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMUL-Z.P.ZZ-_:index
Execute: FMUL-Z.P.ZZ-_:execute
Decode: FMUL-Z.P.ZZ-_:decode@FMUL-Z.P.ZZ-_:diagram
TAG:aarch64/vector/crypto/aes/round:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
result = operand1 EOR operand2;
if decrypt then
    result = AESInvSubBytes(AESInvShiftRows(result));
else
    result = AESSubBytes(AESShiftRows(result));

V[d] = result;
TAG:aarch64/instrs/vector/crypto/aes/round:diagram
A64
31:24 _ 01001110
23:22 _ 00
21:17 _ 10100
16:13 _ 0010
12:12 D x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/aes/round:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;
boolean decrypt = (D == '1');

TAG:aarch64/vector/crypto/aes/round:index
Execute: aarch64/vector/crypto/aes/round:execute
Decode: aarch64/instrs/vector/crypto/aes/round:decode@aarch64/instrs/vector/crypto/aes/round:diagram
TAG:aarch64/integer/flags/xaflag:execute
bit N = NOT(PSTATE.C) AND NOT(PSTATE.Z);
bit Z = PSTATE.Z AND PSTATE.C;
bit C = PSTATE.C OR PSTATE.Z;
bit V = NOT(PSTATE.C) AND PSTATE.Z;

PSTATE.N = N;
PSTATE.Z = Z;
PSTATE.C = C;
PSTATE.V = V;
TAG:aarch64/instrs/integer/flags/xaflag:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 000
15:12 _ 0100
11:8 CRm xxxx
7:5 _ 001
4:0 _ 11111
TAG:aarch64/instrs/integer/flags/xaflag:decode
if !HaveFlagFormatExt() then UNDEFINED;

TAG:aarch64/integer/flags/xaflag:index
Execute: aarch64/integer/flags/xaflag:execute
Decode: aarch64/instrs/integer/flags/xaflag:decode@aarch64/instrs/integer/flags/xaflag:diagram
TAG:LD1RQD-Z.P.BI-U64:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(128) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 16;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQD-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQD-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);

TAG:LD1RQD-Z.P.BI-U64:index
Execute: LD1RQD-Z.P.BI-U64:execute
Decode: LD1RQD-Z.P.BI-U64:decode@LD1RQD-Z.P.BI-U64:diagram
TAG:UDIV-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer quotient;
        if element2 == 0 then
            quotient = 0;
        else
            quotient = RoundTowardsZero(Real(element1) / Real(element2));
        Elem[result, e, esize] = quotient[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UDIV-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0101
17:17 _ 0
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UDIV-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UDIV-Z.P.ZZ-_:index
Execute: UDIV-Z.P.ZZ-_:execute
Decode: UDIV-Z.P.ZZ-_:decode@UDIV-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/unary/add/pairwise:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

bits(2*esize) sum;
integer op1;
integer op2;

if acc then result = V[d];
for e = 0 to elements-1
    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);
    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);
    sum = (op1 + op2)[2*esize-1:0];
    if acc then
        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;
    else
        Elem[result, e, 2*esize] = sum;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/add/pairwise:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:15 _ 00
14:14 op x
13:12 _ 10
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/add/pairwise:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV (2*esize);
boolean acc = (op == '1');
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/add/pairwise:index
Execute: aarch64/vector/arithmetic/unary/add/pairwise:execute
Decode: aarch64/instrs/vector/arithmetic/unary/add/pairwise:decode@aarch64/instrs/vector/arithmetic/unary/add/pairwise:diagram
TAG:aarch64/vector/crypto/sha3/xar:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) tmp;
tmp = Vn EOR Vm; 
V[d] = ROR(tmp[127:64], UInt(imm6)):ROR(tmp[63:0], UInt(imm6));
TAG:aarch64/instrs/vector/crypto/sha3/xar:diagram
A64
31:21 _ 11001110100
20:16 Rm xxxxx
15:10 imm6 xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3/xar:decode
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sha3/xar:index
Execute: aarch64/vector/crypto/sha3/xar:execute
Decode: aarch64/instrs/vector/crypto/sha3/xar:decode@aarch64/instrs/vector/crypto/sha3/xar:diagram
TAG:aarch64/vector/arithmetic/binary/element/mat-mul/int/dotp:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128)      operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
    bits(32) res = Elem[operand3, e, 32];
    for b = 0 to 3
        integer element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);
        integer element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);
        res = res + element1 * element2;
    Elem[result, e, 32] = res;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mat-mul/int/dotp:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:23 US x
22:22 _ 0
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1111
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mat-mul/int/dotp:decode
if !HaveInt8MatMulExt() then UNDEFINED;
boolean op1_unsigned = (US == '1');
boolean op2_unsigned = (US == '0');
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer d = UInt(Rd);
integer i = UInt(H:L);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

TAG:aarch64/vector/arithmetic/binary/element/mat-mul/int/dotp:index
Execute: aarch64/vector/arithmetic/binary/element/mat-mul/int/dotp:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mat-mul/int/dotp:decode@aarch64/instrs/vector/arithmetic/binary/element/mat-mul/int/dotp:diagram
TAG:FCMLA-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer pairs = VL DIV (2 * esize);
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for p = 0 to pairs-1
    addend_r = Elem[operand3, 2 * p + 0, esize];
    addend_i = Elem[operand3, 2 * p + 1, esize];
    elt1_a   = Elem[operand1, 2 * p + sel_a, esize];
    elt2_a   = Elem[operand2, 2 * p + sel_a, esize];
    elt2_b   = Elem[operand2, 2 * p + sel_b, esize];
    if ElemP[mask, 2 * p + 0, esize] == '1' then
        if neg_r then elt2_a = FPNeg(elt2_a);
        addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR);
    if ElemP[mask, 2 * p + 1, esize] == '1' then
        if neg_i then elt2_b = FPNeg(elt2_b);
        addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR);
    Elem[result, 2 * p + 0, esize] = addend_r;
    Elem[result, 2 * p + 1, esize] = addend_i;

Z[da] = result;
TAG:FCMLA-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:13 rot xx
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FCMLA-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer sel_a = UInt(rot[0]);
integer sel_b = UInt(NOT(rot[0]));
boolean neg_i = (rot[1] == '1');
boolean neg_r = (rot[0] != rot[1]);

TAG:FCMLA-Z.P.ZZZ-_:index
Execute: FCMLA-Z.P.ZZZ-_:execute
Decode: FCMLA-Z.P.ZZZ-_:decode@FCMLA-Z.P.ZZZ-_:diagram
TAG:EXT-Z.ZI-Des:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

if position >= elements then
    position = 0;

position = position << 3;
bits(VL*2) concat = operand2 : operand1;
result = concat[position+VL-1:position];

Z[dn] = result;
TAG:EXT-Z.ZI-Des:diagram
A64
31:21 _ 00000101001
20:16 imm8h xxxxx
15:13 _ 000
12:10 imm8l xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:EXT-Z.ZI-Des:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer position = UInt(imm8h:imm8l);

TAG:EXT-Z.ZI-Des:index
Execute: EXT-Z.ZI-Des:execute
Decode: EXT-Z.ZI-Des:decode@EXT-Z.ZI-Des:diagram
TAG:aarch64/vector/arithmetic/unary/diff-neg/fp16:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    if neg then
        element = FPNeg(element);
    else
        element = FPAbs(element);
    Elem[result, e, esize] = element;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/float:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/diff-neg/float:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean neg = (U == '1');

TAG:aarch64/vector/arithmetic/unary/diff-neg/fp16:index
Execute: aarch64/vector/arithmetic/unary/diff-neg/fp16:execute
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/fp16:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/diff-neg/float:decode@aarch64/instrs/vector/arithmetic/unary/diff-neg/float:diagram
TAG:aarch64/vector/shift/left/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;

for e = 0 to elements-1
    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);

V[d] = result;
TAG:aarch64/instrs/vector/shift/left/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh[3] != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;

integer shift = UInt(immh:immb) - esize;

TAG:aarch64/instrs/vector/shift/left/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/left/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3]:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer shift = UInt(immh:immb) - esize;

TAG:aarch64/vector/shift/left/sisd:index
Execute: aarch64/vector/shift/left/sisd:execute
Decode: aarch64/instrs/vector/shift/left/sisd:decode@aarch64/instrs/vector/shift/left/sisd:diagram
Decode: aarch64/instrs/vector/shift/left/simd:decode@aarch64/instrs/vector/shift/left/simd:diagram
TAG:aarch64/system/register/system:execute
if read then
    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
else
    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);
TAG:aarch64/instrs/system/register/system:diagram
A64
31:22 _ 1101010100
21:21 L x
20:20 _ 1
19:19 o0 x
18:16 op1 xxx
15:12 CRn xxxx
11:8 CRm xxxx
7:5 op2 xxx
4:0 Rt xxxxx
TAG:aarch64/instrs/system/register/system:decode
AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);

integer t = UInt(Rt);

integer sys_op0 = 2 + UInt(o0);
integer sys_op1 = UInt(op1);
integer sys_op2 = UInt(op2);
integer sys_crn = UInt(CRn);
integer sys_crm = UInt(CRm);
boolean read = (L == '1');

TAG:aarch64/system/register/system:index
Execute: aarch64/system/register/system:execute
Decode: aarch64/instrs/system/register/system:decode@aarch64/instrs/system/register/system:diagram
TAG:INDEX-Z.RI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(esize) operand1 = X[n];
integer element1 = SInt(operand1);
bits(VL) result;

for e = 0 to elements-1
    integer index = element1 + e * imm;
    Elem[result, e, esize] = index[esize-1:0];

Z[d] = result;
TAG:INDEX-Z.RI-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 imm5 xxxxx
15:10 _ 010001
9:5 Rn xxxxx
4:0 Zd xxxxx
TAG:INDEX-Z.RI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Rn);
integer d = UInt(Zd);
integer imm = SInt(imm5);

TAG:INDEX-Z.RI-_:index
Execute: INDEX-Z.RI-_:execute
Decode: INDEX-Z.RI-_:decode@INDEX-Z.RI-_:diagram
TAG:LD1RW-Z.P.BI-U32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RW-Z.P.BI-U32:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RW-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RW-Z.P.BI-U64:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RW-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RW-Z.P.BI-U32:index
Execute: LD1RW-Z.P.BI-U32:execute
Decode: LD1RW-Z.P.BI-U32:decode@LD1RW-Z.P.BI-U32:diagram
Decode: LD1RW-Z.P.BI-U64:decode@LD1RW-Z.P.BI-U64:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/product:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPMul(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp16/product:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/fp16/product:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp16/product:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/product:diagram
TAG:SMAX-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    Elem[result, e, esize] = Max(element1, imm)[esize-1:0];

Z[dn] = result;
TAG:SMAX-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 101
18:17 _ 00
16:16 _ 0
15:14 _ 11
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SMAX-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
boolean unsigned = FALSE;
integer imm = Int(imm8, unsigned);

TAG:SMAX-Z.ZI-_:index
Execute: SMAX-Z.ZI-_:execute
Decode: SMAX-Z.ZI-_:decode@SMAX-Z.ZI-_:diagram
TAG:CLASTB-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = X[dn];
bits(VL) operand2 = Z[m];
bits(csize) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = ZeroExtend(operand1);
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    result = ZeroExtend(Elem[operand2, last, esize]);

X[dn] = result;
TAG:CLASTB-R.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 11000
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Rdn xxxxx
TAG:CLASTB-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Rdn);
integer m = UInt(Zm);
integer csize = if esize < 64 then 32 else 64;
boolean isBefore = TRUE;

TAG:CLASTB-R.P.Z-_:index
Execute: CLASTB-R.P.Z-_:execute
Decode: CLASTB-R.P.Z-_:decode@CLASTB-R.P.Z-_:diagram
TAG:LD2D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:LD2D-Z.P.BI-Contiguous:index
Execute: LD2D-Z.P.BI-Contiguous:execute
Decode: LD2D-Z.P.BI-Contiguous:decode@LD2D-Z.P.BI-Contiguous:diagram
TAG:aarch64/memory/single/general/immediate/unsigned:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

bits(64) address;
bits(datasize) data;

boolean wb_unknown = FALSE;
boolean rt_unknown = FALSE;

if memop == MemOp_LOAD && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if memop == MemOp_STORE && wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);
    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_NONE       rt_unknown = FALSE;  // value stored is original value
        when Constraint_UNKNOWN    rt_unknown = TRUE;   // value stored is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    if memop != MemOp_PREFETCH then CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        if rt_unknown then
            data = bits(datasize) UNKNOWN;
        else
            data = X[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        if signed then
            X[t] = SignExtend(data, regsize);
        else
            X[t] = ZeroExtend(data, regsize);

    when MemOp_PREFETCH
        Prefetch(address, t[4:0]);

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    elsif postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/general/immediate/unsigned:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_NORMAL;
MemOp memop;
boolean signed;
integer regsize;

if opc[1] == '0' then
    // store or zero-extending load
    memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
    regsize = if size == '11' then 64 else 32;
    signed = FALSE;
else
    if size == '11' then
        memop = MemOp_PREFETCH;
        if opc[0] == '1' then UNDEFINED;
    else
        // sign-extending load
        memop = MemOp_LOAD;
        if size == '10' && opc[0] == '1' then UNDEFINED;
        regsize = if opc[0] == '1' then 32 else 64;
        signed = TRUE;

integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/memory/single/general/immediate/unsigned:index
Execute: aarch64/memory/single/general/immediate/unsigned:execute
Postdecode: aarch64/memory/single/general/immediate/unsigned:postdecode
Decode: aarch64/instrs/memory/single/general/immediate/unsigned:decode@aarch64/instrs/memory/single/general/immediate/unsigned:diagram
TAG:aarch64/integer/arithmetic/mul/widening/32-64:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(destsize) operand3 = X[a];

integer result;

if sub_op then
    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));
else
    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));

X[d] = result[63:0];
TAG:aarch64/instrs/integer/arithmetic/mul/widening/32-64:diagram
A64
31:31 _ 1
30:29 _ 00
28:24 _ 11011
23:23 U x
22:21 _ 01
20:16 Rm xxxxx
15:15 o0 x
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/mul/widening/32-64:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer a = UInt(Ra);
integer destsize = 64;
integer datasize = 32;
boolean sub_op = (o0 == '1');
boolean unsigned = (U == '1');

TAG:aarch64/integer/arithmetic/mul/widening/32-64:index
Execute: aarch64/integer/arithmetic/mul/widening/32-64:execute
Decode: aarch64/instrs/integer/arithmetic/mul/widening/32-64:decode@aarch64/instrs/integer/arithmetic/mul/widening/32-64:diagram
TAG:LSR-Z.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    Elem[result, e, esize] = LSR(element1, shift);

Z[d] = result;
TAG:LSR-Z.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1000
11:11 _ 0
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:LSR-Z.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:LSR-Z.ZW-_:index
Execute: LSR-Z.ZW-_:execute
Decode: LSR-Z.ZW-_:decode@LSR-Z.ZW-_:diagram
TAG:LD1B-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1B-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1B-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1B-Z.P.AI-S:index
Execute: LD1B-Z.P.AI-S:execute
Decode: LD1B-Z.P.AI-S:decode@LD1B-Z.P.AI-S:diagram
Decode: LD1B-Z.P.AI-D:decode@LD1B-Z.P.AI-D:diagram
TAG:LDNT1B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LDNT1B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:20 _ 000
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);

TAG:LDNT1B-Z.P.BI-Contiguous:index
Execute: LDNT1B-Z.P.BI-Contiguous:execute
Decode: LDNT1B-Z.P.BI-Contiguous:decode@LDNT1B-Z.P.BI-Contiguous:diagram
TAG:SUBR-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    Elem[result, e, esize] = (imm - element1)[esize-1:0];

Z[dn] = result;
TAG:SUBR-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 01
16:16 _ 1
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SUBR-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:SUBR-Z.ZI-_:index
Execute: SUBR-Z.ZI-_:execute
Decode: SUBR-Z.ZI-_:decode@SUBR-Z.ZI-_:diagram
TAG:PRFH-I.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;
bits(VL) offset;

if n == 31 then
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFH-I.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 1;

TAG:PRFH-I.P.BZ-D.x32.scaled:diagram
A64
31:23 _ 110001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 1;

TAG:PRFH-I.P.BZ-D.64.scaled:diagram
A64
31:21 _ 11000100011
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:PRFH-I.P.BZ-S.x32.scaled:index
Execute: PRFH-I.P.BZ-S.x32.scaled:execute
Decode: PRFH-I.P.BZ-S.x32.scaled:decode@PRFH-I.P.BZ-S.x32.scaled:diagram
Decode: PRFH-I.P.BZ-D.x32.scaled:decode@PRFH-I.P.BZ-D.x32.scaled:diagram
Decode: PRFH-I.P.BZ-D.64.scaled:decode@PRFH-I.P.BZ-D.64.scaled:diagram
TAG:LD1ROW-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(64) offset;
bits(256) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROW-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROW-Z.P.BR-Contiguous:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;

TAG:LD1ROW-Z.P.BR-Contiguous:index
Execute: LD1ROW-Z.P.BR-Contiguous:execute
Decode: LD1ROW-Z.P.BR-Contiguous:decode@LD1ROW-Z.P.BR-Contiguous:diagram
TAG:aarch64/memory/single/simdfp/register:execute
bits(64) offset = ExtendReg(m, extend_type, shift);
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        data = V[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        V[t] = data;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/simdfp/register:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer m = UInt(Rm);
AccType acctype = AccType_VEC;
MemOp memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH;

TAG:aarch64/instrs/memory/single/simdfp/register:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 1
25:24 _ 00
23:22 opc xx
21:21 _ 1
20:16 Rm xxxxx
15:13 option xxx
12:12 S x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/simdfp/register:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(opc[1]:size);
if scale > 4 then UNDEFINED;
if option[1] == '0' then UNDEFINED;             // sub-word index
ExtendType extend_type = DecodeRegExtend(option);
integer shift = if S == '1' then scale else 0;

TAG:aarch64/memory/single/simdfp/register:index
Execute: aarch64/memory/single/simdfp/register:execute
Postdecode: aarch64/memory/single/simdfp/register:postdecode
Decode: aarch64/instrs/memory/single/simdfp/register:decode@aarch64/instrs/memory/single/simdfp/register:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp/complex:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) element3;
bits(esize) element4;

for e = 0 to (elements DIV 2) -1 
    case rot of 
        when '00'
            element1 = Elem[operand2, e*2, esize]; 
            element2 = Elem[operand1, e*2, esize];
            element3 = Elem[operand2, e*2+1, esize];
            element4 = Elem[operand1, e*2, esize];
        when '01'
            element1 = FPNeg(Elem[operand2, e*2+1, esize]); 
            element2 = Elem[operand1, e*2+1, esize];
            element3 = Elem[operand2, e*2, esize];
            element4 = Elem[operand1, e*2+1, esize];
        when '10'
            element1 = FPNeg(Elem[operand2, e*2, esize]); 
            element2 = Elem[operand1, e*2, esize];
            element3 = FPNeg(Elem[operand2, e*2+1, esize]);
            element4 = Elem[operand1, e*2, esize];
        when '11'
            element1 = Elem[operand2, e*2+1, esize]; 
            element2 = Elem[operand1, e*2+1, esize];
            element3 = FPNeg(Elem[operand2, e*2, esize]);
            element4 = Elem[operand1, e*2+1, esize];

    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2,   esize], element2, element1, FPCR);
    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:13 _ 10
12:11 rot xx
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex:decode
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '00' then UNDEFINED;
if Q == '0' && size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp/complex:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/fp/complex:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/complex:diagram
TAG:aarch64/vector/crypto/sha512/sha512su1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(64) sig1;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

sig1 = ROR(X[127:64], 19) EOR ROR(X[127:64],61) EOR ('000000':X[127:70]);
Vtmp[127:64] = W[127:64] + sig1 + Y[127:64];
sig1 = ROR(X[63:0], 19) EOR ROR(X[63:0],61) EOR ('000000':X[63:6]);
Vtmp[63:0] = W[63:0] + sig1 + Y[63:0];
V[d] = Vtmp;
TAG:aarch64/instrs/vector/crypto/sha512/sha512su1:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 0
13:12 _ 00
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha512/sha512su1:decode
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sha512/sha512su1:index
Execute: aarch64/vector/crypto/sha512/sha512su1:execute
Decode: aarch64/instrs/vector/crypto/sha512/sha512su1:decode@aarch64/instrs/vector/crypto/sha512/sha512su1:diagram
TAG:aarch64/integer/arithmetic/add-sub/immediate:execute
bits(datasize) result;
bits(datasize) operand1 = if n == 31 then SP[] else X[n];
bits(datasize) operand2 = imm;
bits(4) nzcv;
bit carry_in;

if sub_op then
    operand2 = NOT(operand2);
    carry_in = '1';
else
    carry_in = '0';

(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);

if setflags then 
    PSTATE.[N,Z,C,V] = nzcv;

if d == 31 && !setflags then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/add-sub/immediate:diagram
A64
31:31 sf x
30:30 op x
29:29 S x
28:23 _ 100010
22:22 sh x
21:10 imm12 xxxxxxxxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/arithmetic/add-sub/immediate:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
boolean setflags = (S == '1');
bits(datasize) imm;

case sh of
    when '0' imm = ZeroExtend(imm12, datasize);
    when '1' imm = ZeroExtend(imm12 : Zeros(12), datasize);

TAG:aarch64/integer/arithmetic/add-sub/immediate:index
Execute: aarch64/integer/arithmetic/add-sub/immediate:execute
Decode: aarch64/instrs/integer/arithmetic/add-sub/immediate:decode@aarch64/instrs/integer/arithmetic/add-sub/immediate:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/dotp:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

result = V[d];
for e = 0 to elements-1 
    integer res = 0;
    integer element1, element2;
    for i = 0 to 3 
        if signed then
            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        else 
            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); 
            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        res = res + element1 * element2; 
    Elem[result, e, esize] = Elem[result, e, esize] + res;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 0010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp:decode
if !HaveDOTPExt() then UNDEFINED;
if size!= '10' then UNDEFINED;
boolean signed = (U=='0');
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/dotp:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/dotp:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/dotp:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/halving/truncating:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer sum;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    sum = element1 + element2;
    Elem[result, e, esize] = sum[esize:1];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/add/halving/truncating:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/halving/truncating:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/halving/truncating:diagram
TAG:LD1D-Z.P.AI-D:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1D-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1D-Z.P.AI-D:index
Execute: LD1D-Z.P.AI-D:execute
Decode: LD1D-Z.P.AI-D:decode@LD1D-Z.P.AI-D:diagram
TAG:ST1B-Z.P.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    addr = addr + mbytes;
TAG:ST1B-Z.P.BI-_:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 size xx
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.BI-_:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 8;
integer offset = SInt(imm4);

TAG:ST1B-Z.P.BI-_:index
Execute: ST1B-Z.P.BI-_:execute
Decode: ST1B-Z.P.BI-_:decode@ST1B-Z.P.BI-_:diagram
TAG:aarch64/vector/shift/conv/int/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);

V[d] = result;
TAG:aarch64/instrs/vector/shift/conv/int/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 11100
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/conv/int/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = esize;
integer elements = 1;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

TAG:aarch64/instrs/vector/shift/conv/int/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 11100
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/conv/int/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then UNDEFINED;
if immh[3]:Q == '10' then UNDEFINED;
integer esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer fracbits = (esize * 2) - UInt(immh:immb);
boolean unsigned = (U == '1');
FPRounding rounding = FPRoundingMode(FPCR);

TAG:aarch64/vector/shift/conv/int/sisd:index
Execute: aarch64/vector/shift/conv/int/sisd:execute
Decode: aarch64/instrs/vector/shift/conv/int/sisd:decode@aarch64/instrs/vector/shift/conv/int/sisd:diagram
Decode: aarch64/instrs/vector/shift/conv/int/simd:decode@aarch64/instrs/vector/shift/conv/int/simd:diagram
TAG:INCP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    Elem[result, e, esize] = Elem[operand1, e, esize] + count;

Z[dn] = result;
TAG:INCP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1011
17:17 _ 0
16:16 _ 0
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:INCP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);

TAG:INCP-Z.P.Z-_:index
Execute: INCP-Z.P.Z-_:execute
Decode: INCP-Z.P.Z-_:decode@INCP-Z.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/fp16:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(2*datasize) concat = operand2:operand1;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    if pair then
        element1 = Elem[concat, 2*e, esize];
        element2 = Elem[concat, (2*e)+1, esize];
    else
        element1 = Elem[operand1, e, esize];
        element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean pair = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/add/fp16:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/fp16:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/fp16:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/fp:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/fp:diagram
TAG:ST2H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST2H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:ST2H-Z.P.BI-Contiguous:index
Execute: ST2H-Z.P.BI-Contiguous:execute
Decode: ST2H-Z.P.BI-Contiguous:decode@ST2H-Z.P.BI-Contiguous:diagram
TAG:SCVTF-Z.P.Z-H2FP16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) fpval = FixedToFP(element[s_esize-1:0], 0, unsigned, FPCR, rounding);
        Elem[result, e, esize] = ZeroExtend(fpval);

Z[d] = result;
TAG:SCVTF-Z.P.Z-H2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 0
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-H2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 16;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-W2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-W2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 16;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-W2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-W2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 32;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-W2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-W2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 64;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-X2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-X2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 16;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-X2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-X2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 32;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-X2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SCVTF-Z.P.Z-X2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 64;
boolean unsigned = FALSE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:SCVTF-Z.P.Z-H2FP16:index
Execute: SCVTF-Z.P.Z-H2FP16:execute
Decode: SCVTF-Z.P.Z-H2FP16:decode@SCVTF-Z.P.Z-H2FP16:diagram
Decode: SCVTF-Z.P.Z-W2FP16:decode@SCVTF-Z.P.Z-W2FP16:diagram
Decode: SCVTF-Z.P.Z-W2S:decode@SCVTF-Z.P.Z-W2S:diagram
Decode: SCVTF-Z.P.Z-W2D:decode@SCVTF-Z.P.Z-W2D:diagram
Decode: SCVTF-Z.P.Z-X2FP16:decode@SCVTF-Z.P.Z-X2FP16:diagram
Decode: SCVTF-Z.P.Z-X2S:decode@SCVTF-Z.P.Z-X2S:diagram
Decode: SCVTF-Z.P.Z-X2D:decode@SCVTF-Z.P.Z-X2D:diagram
TAG:aarch64/integer/tags/mcinserttagmask:execute
bits(64) address = if n == 31 then SP[] else X[n];
bits(64) mask = X[m];
bits(4) tag = AArch64.AllocationTagFromAddress(address);

mask[UInt(tag)] = '1';
X[d] = mask;
TAG:aarch64/instrs/integer/tags/mcinserttagmask:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Xm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 1
11:11 _ 0
10:10 _ 1
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/tags/mcinserttagmask:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

TAG:aarch64/integer/tags/mcinserttagmask:index
Execute: aarch64/integer/tags/mcinserttagmask:execute
Decode: aarch64/instrs/integer/tags/mcinserttagmask:decode@aarch64/instrs/integer/tags/mcinserttagmask:diagram
TAG:BIC-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 AND (NOT element2);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:BIC-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:BIC-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:BIC-Z.P.ZZ-_:index
Execute: BIC-Z.P.ZZ-_:execute
Decode: BIC-Z.P.ZZ-_:decode@BIC-Z.P.ZZ-_:diagram
TAG:LDFF1SB-Z.P.BR-S16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1SB-Z.P.BR-S16:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BR-S16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LDFF1SB-Z.P.BR-S32:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BR-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LDFF1SB-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;

TAG:LDFF1SB-Z.P.BR-S16:index
Execute: LDFF1SB-Z.P.BR-S16:execute
Decode: LDFF1SB-Z.P.BR-S16:decode@LDFF1SB-Z.P.BR-S16:diagram
Decode: LDFF1SB-Z.P.BR-S32:decode@LDFF1SB-Z.P.BR-S32:diagram
Decode: LDFF1SB-Z.P.BR-S64:decode@LDFF1SB-Z.P.BR-S64:diagram
TAG:UZP1-Z.ZZ-_:execute
CheckSVEEnabled();
if VL < esize * 2 then UNDEFINED;
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result = Zeros();

bits(VL*2) zipped = operand2:operand1;
for e = 0 to elements-1
    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];

Z[d] = result;
TAG:UZP1-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 01
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UZP1-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:UZP1-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 01
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UZP1-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:UZP2-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 01
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UZP2-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:UZP2-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 01
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UZP2-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:UZP1-Z.ZZ-_:index
Execute: UZP1-Z.ZZ-_:execute
Decode: UZP1-Z.ZZ-_:decode@UZP1-Z.ZZ-_:diagram
Decode: UZP1-Z.ZZ-Q:decode@UZP1-Z.ZZ-Q:diagram
Decode: UZP2-Z.ZZ-_:decode@UZP2-Z.ZZ-_:diagram
Decode: UZP2-Z.ZZ-Q:decode@UZP2-Z.ZZ-Q:diagram
TAG:aarch64/vector/crypto/sha512/sha512su0:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(64) sig0;
bits(128) Vtmp;
bits(128) X = V[n];
bits(128) W = V[d]; 
sig0 = ROR(W[127:64], 1) EOR ROR(W[127:64], 8) EOR ('0000000':W[127:71]);
Vtmp[63:0] = W[63:0] + sig0;
sig0 = ROR(X[63:0], 1) EOR ROR(X[63:0], 8) EOR ('0000000':X[63:7]);
Vtmp[127:64] = W[127:64] + sig0;
V[d] = Vtmp;
TAG:aarch64/instrs/vector/crypto/sha512/sha512su0:diagram
A64
31:12 _ 11001110110000001000
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha512/sha512su0:decode
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

TAG:aarch64/vector/crypto/sha512/sha512su0:index
Execute: aarch64/vector/crypto/sha512/sha512su0:execute
Decode: aarch64/instrs/vector/crypto/sha512/sha512su0:decode@aarch64/instrs/vector/crypto/sha512/sha512su0:diagram
TAG:INDEX-Z.II-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) result;

for e = 0 to elements-1
    integer index = imm1 + e * imm2;
    Elem[result, e, esize] = index[esize-1:0];

Z[d] = result;
TAG:INDEX-Z.II-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 imm5b xxxxx
15:10 _ 010000
9:5 imm5 xxxxx
4:0 Zd xxxxx
TAG:INDEX-Z.II-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer d = UInt(Zd);
integer imm1 = SInt(imm5);
integer imm2 = SInt(imm5b);

TAG:INDEX-Z.II-_:index
Execute: INDEX-Z.II-_:execute
Decode: INDEX-Z.II-_:decode@INDEX-Z.II-_:diagram
TAG:aarch64/vector/crypto/aes/mix:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand = V[n];
bits(128) result;
if decrypt then
    result = AESInvMixColumns(operand);
else
    result = AESMixColumns(operand);
V[d] = result;
TAG:aarch64/instrs/vector/crypto/aes/mix:diagram
A64
31:24 _ 01001110
23:22 _ 00
21:17 _ 10100
16:13 _ 0011
12:12 D x
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/aes/mix:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveAESExt() then UNDEFINED;
boolean decrypt = (D == '1');

TAG:aarch64/vector/crypto/aes/mix:index
Execute: aarch64/vector/crypto/aes/mix:execute
Decode: aarch64/instrs/vector/crypto/aes/mix:decode@aarch64/instrs/vector/crypto/aes/mix:diagram
TAG:UQINCH-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQINCH-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCH-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQINCH-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCH-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQINCH-R.RS-UW:index
Execute: UQINCH-R.RS-UW:execute
Decode: UQINCH-R.RS-UW:decode@UQINCH-R.RS-UW:diagram
Decode: UQINCH-R.RS-X:decode@UQINCH-R.RS-X:diagram
TAG:LD1ROB-Z.P.BI-U8:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(256) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 32;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROB-Z.P.BI-U8:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROB-Z.P.BI-U8:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);

TAG:LD1ROB-Z.P.BI-U8:index
Execute: LD1ROB-Z.P.BI-U8:execute
Decode: LD1ROB-Z.P.BI-U8:decode@LD1ROB-Z.P.BI-U8:diagram
TAG:AND-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 AND element2;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:AND-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:AND-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:AND-Z.P.ZZ-_:index
Execute: AND-Z.P.ZZ-_:execute
Decode: AND-Z.P.ZZ-_:decode@AND-Z.P.ZZ-_:diagram
TAG:ST1W-Z.P.BR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    offset = offset + 1;
TAG:ST1W-Z.P.BR-_:diagram
A64
31:25 _ 1110010
24:23 _ 10
22:21 size xx
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BR-_:decode
if !HaveSVE() then UNDEFINED;
if size != '1x' then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 32;

TAG:ST1W-Z.P.BR-_:index
Execute: ST1W-Z.P.BR-_:execute
Decode: ST1W-Z.P.BR-_:decode@ST1W-Z.P.BR-_:diagram
TAG:LDNT1D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LDNT1D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:20 _ 000
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);

TAG:LDNT1D-Z.P.BI-Contiguous:index
Execute: LDNT1D-Z.P.BI-Contiguous:execute
Decode: LDNT1D-Z.P.BI-Contiguous:decode@LDNT1D-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/sub/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) diff;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    diff = FPSub(element1, element2, FPCR);
    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;
boolean abs = TRUE;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
boolean abs = TRUE;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean abs = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11010
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean abs = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/sub/fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/sub/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:diagram
TAG:LD1RSW-Z.P.BI-S64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RSW-Z.P.BI-S64:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSW-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSW-Z.P.BI-S64:index
Execute: LD1RSW-Z.P.BI-S64:execute
Decode: LD1RSW-Z.P.BI-S64:decode@LD1RSW-Z.P.BI-S64:diagram
TAG:aarch64/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 0
22:17 _ 111100
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:17 _ 111100
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

FPRounding rounding = FPRounding_TIEAWAY;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:index
Execute: aarch64/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/float/tieaway/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/float/tieaway/simd:diagram
TAG:LD1W-Z.P.BI-U32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1W-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1W-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1W-Z.P.BI-U32:index
Execute: LD1W-Z.P.BI-U32:execute
Decode: LD1W-Z.P.BI-U32:decode@LD1W-Z.P.BI-U32:diagram
Decode: LD1W-Z.P.BI-U64:decode@LD1W-Z.P.BI-U64:diagram
TAG:aarch64/vector/reduce/add-long:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
integer sum;

sum = Int(Elem[operand, 0, esize], unsigned);
for e = 1 to elements-1
    sum = sum + Int(Elem[operand, e, esize], unsigned);

V[d] = sum[2*esize-1:0];
TAG:aarch64/instrs/vector/reduce/add-long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 11000
16:12 _ 00011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/add-long:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '100' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');

TAG:aarch64/vector/reduce/add-long:index
Execute: aarch64/vector/reduce/add-long:execute
Decode: aarch64/instrs/vector/reduce/add-long:decode@aarch64/instrs/vector/reduce/add-long:diagram
TAG:SQINCH-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQINCH-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCH-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQINCH-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCH-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQINCH-R.RS-SX:index
Execute: SQINCH-R.RS-SX:execute
Decode: SQINCH-R.RS-SX:decode@SQINCH-R.RS-SX:diagram
Decode: SQINCH-R.RS-X:decode@SQINCH-R.RS-X:diagram
TAG:SQINCD-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQINCD-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCD-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQINCD-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCD-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQINCD-R.RS-SX:index
Execute: SQINCD-R.RS-SX:execute
Decode: SQINCD-R.RS-SX:decode@SQINCD-R.RS-SX:diagram
Decode: SQINCD-R.RS-X:decode@SQINCD-R.RS-X:diagram
TAG:NEG-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    integer element = SInt(Elem[operand, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        element = -element;
        Elem[result, e, esize] = element[esize-1:0];

Z[d] = result;
TAG:NEG-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 11
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:NEG-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:NEG-Z.P.Z-_:index
Execute: NEG-Z.P.Z-_:execute
Decode: NEG-Z.P.Z-_:decode@NEG-Z.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/unary/special/recip/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/special/recip/fp16/sisd:index
Execute: aarch64/vector/arithmetic/unary/special/recip/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd:decode@aarch64/instrs/vector/arithmetic/unary/special/recip/float/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd:decode@aarch64/instrs/vector/arithmetic/unary/special/recip/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd:decode@aarch64/instrs/vector/arithmetic/unary/special/recip/float/simd:diagram
TAG:FSUB-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPSub(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FSUB-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FSUB-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

TAG:FSUB-Z.P.ZS-_:index
Execute: FSUB-Z.P.ZS-_:execute
Decode: FSUB-Z.P.ZS-_:decode@FSUB-Z.P.ZS-_:diagram
TAG:LDFF1SW-Z.P.BZ-D.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SW-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LDFF1SW-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1SW-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:LDFF1SW-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1SW-Z.P.BZ-D.x32.scaled:index
Execute: LDFF1SW-Z.P.BZ-D.x32.scaled:execute
Decode: LDFF1SW-Z.P.BZ-D.x32.scaled:decode@LDFF1SW-Z.P.BZ-D.x32.scaled:diagram
Decode: LDFF1SW-Z.P.BZ-D.x32.unscaled:decode@LDFF1SW-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1SW-Z.P.BZ-D.64.scaled:decode@LDFF1SW-Z.P.BZ-D.64.scaled:diagram
Decode: LDFF1SW-Z.P.BZ-D.64.unscaled:decode@LDFF1SW-Z.P.BZ-D.64.unscaled:diagram
TAG:SQINCD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:SQINCD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:SQINCD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;

TAG:SQINCD-Z.ZS-_:index
Execute: SQINCD-Z.ZS-_:execute
Decode: SQINCD-Z.ZS-_:decode@SQINCD-Z.ZS-_:diagram
TAG:LDNF1W-Z.P.BI-U32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1W-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1W-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1W-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1W-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1W-Z.P.BI-U32:index
Execute: LDNF1W-Z.P.BI-U32:execute
Decode: LDNF1W-Z.P.BI-U32:decode@LDNF1W-Z.P.BI-U32:diagram
Decode: LDNF1W-Z.P.BI-U64:decode@LDNF1W-Z.P.BI-U64:diagram
TAG:FABS-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPAbs(element);

Z[d] = result;
TAG:FABS-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 10
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FABS-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FABS-Z.P.Z-_:index
Execute: FABS-Z.P.Z-_:execute
Decode: FABS-Z.P.Z-_:decode@FABS-Z.P.Z-_:diagram
TAG:LSRR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element1), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSR(element2, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSRR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSRR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSRR-Z.P.ZZ-_:index
Execute: LSRR-Z.P.ZZ-_:execute
Decode: LSRR-Z.P.ZZ-_:decode@LSRR-Z.P.ZZ-_:diagram
TAG:aarch64/float/convert/fix:execute
CheckFPAdvSIMDEnabled64();

bits(fltsize) fltval;
bits(intsize) intval;

case op of
    when FPConvOp_CVT_FtoI
        fltval = V[n];
        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);
        X[d] = intval;
    when FPConvOp_CVT_ItoF
        intval = X[n];
        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);
        V[d] = fltval;
TAG:aarch64/instrs/float/convert/fix:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 0
20:19 rmode xx
18:16 opcode xxx
15:10 scale xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/convert/fix:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer intsize = if sf == '1' then 64 else 32;
integer fltsize;
FPConvOp op;
FPRounding rounding;
boolean unsigned;

case ftype of
    when '00' fltsize = 32;
    when '01' fltsize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            fltsize = 16;
        else
            UNDEFINED;

if sf == '0' && scale[5] == '0' then UNDEFINED;
integer fracbits = 64 - UInt(scale);

case opcode[2:1]:rmode of
    when '00 11'        // FCVTZ
        rounding = FPRounding_ZERO;
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_FtoI;
    when '01 00'        // [US]CVTF
        rounding = FPRoundingMode(FPCR);
        unsigned = (opcode[0] == '1');
        op = FPConvOp_CVT_ItoF;
    otherwise
        UNDEFINED;

TAG:aarch64/float/convert/fix:index
Execute: aarch64/float/convert/fix:execute
Decode: aarch64/instrs/float/convert/fix:decode@aarch64/instrs/float/convert/fix:diagram
TAG:aarch64/integer/pac/autib/dp_1src:execute
auth_then_branch = FALSE;

if HavePACExt() then
    if source_is_sp then
        X[d] = AuthIB(X[d], SP[], auth_then_branch);
    else
        X[d] = AuthIB(X[d], X[n], auth_then_branch);
TAG:aarch64/instrs/integer/pac/autib/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 101
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/autib/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // AUTIB
    if n == 31 then source_is_sp = TRUE;
else // AUTIZB
    if n != 31 then UNDEFINED;

TAG:aarch64/instrs/integer/pac/autib/hint:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/integer/pac/autib/hint:decode
integer d;
integer n;
boolean source_is_sp = FALSE;

case CRm:op2 of
    when '0011 110' // AUTIBZ
        d = 30;
        n = 31;
    when '0011 111' // AUTIBSP
        d = 30;
        source_is_sp = TRUE;
    when '0001 110' // AUTIB1716
        d = 17;
        n = 16;
    when '0001 000' SEE "PACIA";
    when '0001 010' SEE "PACIB";
    when '0001 100' SEE "AUTIA";
    when '0011 00x' SEE "PACIA";
    when '0011 01x' SEE "PACIB";
    when '0011 10x' SEE "AUTIA";
    when '0000 111' SEE "XPACLRI";
    otherwise       SEE "HINT";

TAG:aarch64/integer/pac/autib/dp_1src:index
Execute: aarch64/integer/pac/autib/dp_1src:execute
Decode: aarch64/instrs/integer/pac/autib/dp_1src:decode@aarch64/instrs/integer/pac/autib/dp_1src:diagram
Decode: aarch64/instrs/integer/pac/autib/hint:decode@aarch64/instrs/integer/pac/autib/hint:diagram
TAG:aarch64/float/arithmetic/unary:execute
CheckFPAdvSIMDEnabled64();

bits(datasize) result;
bits(datasize) operand = V[n];

case fpop of
    when FPUnaryOp_MOV  result = operand;
    when FPUnaryOp_ABS  result = FPAbs(operand);
    when FPUnaryOp_NEG  result = FPNeg(operand);
    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/unary:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:17 _ 0000
16:15 opc xx
14:10 _ 10000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/unary:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

FPUnaryOp fpop;
case opc of
    when '00' fpop = FPUnaryOp_MOV;
    when '01' fpop = FPUnaryOp_ABS;
    when '10' fpop = FPUnaryOp_NEG;
    when '11' fpop = FPUnaryOp_SQRT;

TAG:aarch64/float/arithmetic/unary:index
Execute: aarch64/float/arithmetic/unary:execute
Decode: aarch64/instrs/float/arithmetic/unary:decode@aarch64/instrs/float/arithmetic/unary:diagram
TAG:aarch64/memory/ordered-rcpc:execute
bits(64) address;
bits(datasize) data;
constant integer dbytes = datasize DIV 8;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

data = Mem[address, dbytes, acctype];
X[t] = ZeroExtend(data, regsize);
TAG:aarch64/instrs/memory/ordered-rcpc:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:16 Rs xxxxx
15:15 _ 1
14:12 _ 100
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/ordered-rcpc:decode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);   // ignored by all loads and store-release

AccType acctype = AccType_ORDERED;
integer elsize = 8 << UInt(size);
integer regsize = if elsize == 64 then 64 else 32;
integer datasize = elsize;
boolean tag_checked = n != 31;

TAG:aarch64/memory/ordered-rcpc:index
Execute: aarch64/memory/ordered-rcpc:execute
Decode: aarch64/instrs/memory/ordered-rcpc:decode@aarch64/instrs/memory/ordered-rcpc:diagram
TAG:aarch64/system/sysops:execute
if has_result then
    // No architecturally defined instructions here.
    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);
else
    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);
TAG:aarch64/instrs/system/sysops:diagram
A64
31:22 _ 1101010100
21:21 L x
20:19 _ 01
18:16 op1 xxx
15:12 CRn xxxx
11:8 CRm xxxx
7:5 op2 xxx
4:0 Rt xxxxx
TAG:aarch64/instrs/system/sysops:decode
AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);

integer t = UInt(Rt);

integer sys_op0 = 1;
integer sys_op1 = UInt(op1);
integer sys_op2 = UInt(op2);
integer sys_crn = UInt(CRn);
integer sys_crm = UInt(CRm);
boolean has_result = (L == '1');

TAG:aarch64/system/sysops:index
Execute: aarch64/system/sysops:execute
Decode: aarch64/instrs/system/sysops:decode@aarch64/instrs/system/sysops:diagram
TAG:LD4H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:LD4H-Z.P.BI-Contiguous:index
Execute: LD4H-Z.P.BI-Contiguous:execute
Decode: LD4H-Z.P.BI-Contiguous:decode@LD4H-Z.P.BI-Contiguous:diagram
TAG:aarch64/integer/flags/axflag:execute
bit N = '0';
bit Z = PSTATE.Z OR PSTATE.V;
bit C = PSTATE.C AND NOT(PSTATE.V);
bit V = '0';

PSTATE.N = N;
PSTATE.Z = Z;
PSTATE.C = C;
PSTATE.V = V;
TAG:aarch64/instrs/integer/flags/axflag:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 000
15:12 _ 0100
11:8 CRm xxxx
7:5 _ 010
4:0 _ 11111
TAG:aarch64/instrs/integer/flags/axflag:decode
if !HaveFlagFormatExt() then UNDEFINED;

TAG:aarch64/integer/flags/axflag:index
Execute: aarch64/integer/flags/axflag:execute
Decode: aarch64/instrs/integer/flags/axflag:decode@aarch64/instrs/integer/flags/axflag:diagram
TAG:ST3W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST3W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:ST3W-Z.P.BI-Contiguous:index
Execute: ST3W-Z.P.BI-Contiguous:execute
Decode: ST3W-Z.P.BI-Contiguous:decode@ST3W-Z.P.BI-Contiguous:diagram
TAG:aarch64/integer/crc:execute
bits(32)      acc     = X[n];   // accumulator
bits(size)    val     = X[m];   // input value
bits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)[31:0];

bits(32+size) tempacc = BitReverse(acc) : Zeros(size);
bits(size+32) tempval = BitReverse(val) : Zeros(32);

// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation
X[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));
TAG:aarch64/instrs/integer/crc:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Rm xxxxx
15:13 _ 010
12:12 C x
11:10 sz xx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/crc:decode
if !HaveCRCExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sf == '1' && sz != '11' then UNDEFINED;
if sf == '0' && sz == '11' then UNDEFINED;
integer size = 8 << UInt(sz);   // 2-bit size field -> 8, 16, 32, 64
boolean crc32c = (C == '1');

TAG:aarch64/integer/crc:index
Execute: aarch64/integer/crc:execute
Decode: aarch64/instrs/integer/crc:decode@aarch64/instrs/integer/crc:diagram
TAG:ADDVL-R.RI-_:execute
CheckSVEEnabled();
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(64) result = operand1 + (imm * (VL DIV 8));

if d == 31 then
    SP[] = result;
else
    X[d] = result;
TAG:ADDVL-R.RI-_:diagram
A64
31:23 _ 000001000
22:22 _ 0
21:21 _ 1
20:16 Rn xxxxx
15:11 _ 01010
10:5 imm6 xxxxxx
4:0 Rd xxxxx
TAG:ADDVL-R.RI-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);
integer imm = SInt(imm6);

TAG:ADDVL-R.RI-_:index
Execute: ADDVL-R.RI-_:execute
Decode: ADDVL-R.RI-_:decode@ADDVL-R.RI-_:diagram
TAG:CLASTB-V.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = V[dn];
bits(VL) operand2 = Z[m];
bits(esize) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = ZeroExtend(operand1);
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    result = Elem[operand2, last, esize];

V[dn] = result;
TAG:CLASTB-V.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10101
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Vdn xxxxx
TAG:CLASTB-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Vdn);
integer m = UInt(Zm);
boolean isBefore = TRUE;

TAG:CLASTB-V.P.Z-_:index
Execute: CLASTB-V.P.Z-_:execute
Decode: CLASTB-V.P.Z-_:decode@CLASTB-V.P.Z-_:diagram
TAG:aarch64/system/exceptions/debug/breakpoint:execute
AArch64.SoftwareBreakpoint(comment);
TAG:aarch64/instrs/system/exceptions/debug/breakpoint:diagram
A64
31:24 _ 11010100
23:21 _ 001
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 _ 00
TAG:aarch64/instrs/system/exceptions/debug/breakpoint:decode
bits(16) comment = imm16;
if HaveBTIExt() then
    SetBTypeCompatible(TRUE);

TAG:aarch64/system/exceptions/debug/breakpoint:index
Execute: aarch64/system/exceptions/debug/breakpoint:execute
Decode: aarch64/instrs/system/exceptions/debug/breakpoint:decode@aarch64/instrs/system/exceptions/debug/breakpoint:diagram
TAG:aarch64/integer/tags/mcgettag:execute
bits(64) address;
bits(4) tag;

if n == 31 then
    CheckSPAlignment(); 
    address = SP[];
else
    address = X[n];

address = address + offset;
address = Align(address, TAG_GRANULE);

tag = AArch64.MemTag[address, AccType_NORMAL];
X[t] = AArch64.AddressWithAllocationTag(X[t], tag);
TAG:aarch64/instrs/integer/tags/mcgettag:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcgettag:decode
integer t = UInt(Xt);
integer n = UInt(Xn);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);

TAG:aarch64/integer/tags/mcgettag:index
Execute: aarch64/integer/tags/mcgettag:execute
Decode: aarch64/instrs/integer/tags/mcgettag:decode@aarch64/instrs/integer/tags/mcgettag:diagram
TAG:ST1H-Z.P.BR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    offset = offset + 1;
TAG:ST1H-Z.P.BR-_:diagram
A64
31:25 _ 1110010
24:23 _ 01
22:21 size xx
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BR-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 16;

TAG:ST1H-Z.P.BR-_:index
Execute: ST1H-Z.P.BR-_:execute
Decode: ST1H-Z.P.BR-_:decode@ST1H-Z.P.BR-_:diagram
TAG:aarch64/vector/arithmetic/unary/add/saturating/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

bits(datasize) operand2 = V[d];
integer op1;
integer op2;
boolean sat;

for e = 0 to elements-1
    op1 = Int(Elem[operand, e, esize], !unsigned);
    op2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);
    if sat then FPSR.QC = '1';
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 00011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;

boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/add/saturating/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 00011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/add/saturating/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/add/saturating/sisd:index
Execute: aarch64/vector/arithmetic/unary/add/saturating/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd:decode@aarch64/instrs/vector/arithmetic/unary/add/saturating/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/add/saturating/simd:decode@aarch64/instrs/vector/arithmetic/unary/add/saturating/simd:diagram
TAG:LD3W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 3;

TAG:LD3W-Z.P.BR-Contiguous:index
Execute: LD3W-Z.P.BR-Contiguous:execute
Decode: LD3W-Z.P.BR-Contiguous:decode@LD3W-Z.P.BR-Contiguous:diagram
TAG:LDFF1W-Z.P.BR-U32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1W-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;

TAG:LDFF1W-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 101
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;

TAG:LDFF1W-Z.P.BR-U32:index
Execute: LDFF1W-Z.P.BR-U32:execute
Decode: LDFF1W-Z.P.BR-U32:decode@LDFF1W-Z.P.BR-U32:diagram
Decode: LDFF1W-Z.P.BR-U64:decode@LDFF1W-Z.P.BR-U64:diagram
TAG:ST3B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST3B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 3;

TAG:ST3B-Z.P.BR-Contiguous:index
Execute: ST3B-Z.P.BR-Contiguous:execute
Decode: ST3B-Z.P.BR-Contiguous:decode@ST3B-Z.P.BR-Contiguous:diagram
TAG:ASR-Z.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    Elem[result, e, esize] = ASR(element1, shift);

Z[d] = result;
TAG:ASR-Z.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1000
11:11 _ 0
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ASR-Z.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:ASR-Z.ZW-_:index
Execute: ASR-Z.ZW-_:execute
Decode: ASR-Z.ZW-_:decode@ASR-Z.ZW-_:diagram
TAG:REV-P.P-_:execute
CheckSVEEnabled();
bits(PL) operand = P[n];
bits(PL) result = Reverse(operand, esize DIV 8);
P[d] = result;
TAG:REV-P.P-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:10 _ 110100010000
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:REV-P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer d = UInt(Pd);

TAG:REV-P.P-_:index
Execute: REV-P.P-_:execute
Decode: REV-P.P-_:decode@REV-P.P-_:diagram
TAG:STR-Z.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV 8;
bits(VL) src;
bits(64) base;
integer offset = imm * elements;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

src = Z[t];
boolean aligned = AArch64.CheckAlignment(base + offset, 16, AccType_NORMAL, TRUE);
for e = 0 to elements-1
    AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned] = Elem[src, e, 8];
    offset = offset + 1;
TAG:STR-Z.BI-_:diagram
A64
31:22 _ 1110010110
21:16 imm9h xxxxxx
15:13 _ 010
12:10 imm9l xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STR-Z.BI-_:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer imm = SInt(imm9h:imm9l);

TAG:STR-Z.BI-_:index
Execute: STR-Z.BI-_:execute
Decode: STR-Z.BI-_:decode@STR-Z.BI-_:diagram
TAG:USDOT-Z.ZZZ-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:USDOT-Z.ZZZ-S:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 0
21:21 _ 0
20:16 Zm xxxxx
15:10 _ 011110
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:USDOT-Z.ZZZ-S:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer esize = 32;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:USDOT-Z.ZZZ-S:index
Execute: USDOT-Z.ZZZ-S:execute
Decode: USDOT-Z.ZZZ-S:decode@USDOT-Z.ZZZ-S:diagram
TAG:LD1W-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1W-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1W-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1W-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1W-Z.P.AI-S:index
Execute: LD1W-Z.P.AI-S:execute
Decode: LD1W-Z.P.AI-S:decode@LD1W-Z.P.AI-S:diagram
Decode: LD1W-Z.P.AI-D:decode@LD1W-Z.P.AI-D:diagram
TAG:aarch64/vector/cvt_bf16/scalar:execute
CheckFPAdvSIMDEnabled64();
bits(32) operand = V[n];
bits(16) result;

result = FPConvertBF(operand, FPCR);
V[d] = result;
TAG:aarch64/instrs/vector/cvt_bf16/scalar:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 _ 01
21:21 _ 1
20:15 _ 000110
14:10 _ 10000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/cvt_bf16/scalar:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);

TAG:aarch64/vector/cvt_bf16/scalar:index
Execute: aarch64/vector/cvt_bf16/scalar:execute
Decode: aarch64/instrs/vector/cvt_bf16/scalar:decode@aarch64/instrs/vector/cvt_bf16/scalar:diagram
TAG:FDIVR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPDiv(element2, element1, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FDIVR-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 110
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FDIVR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FDIVR-Z.P.ZZ-_:index
Execute: FDIVR-Z.P.ZZ-_:execute
Decode: FDIVR-Z.P.ZZ-_:decode@FDIVR-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul/double/sisd:execute
CheckFPAdvSIMDEnabled64();

bits(datasize)   operand1 = Vpart[n, part];
bits(idxdsize)   operand2 = V[m];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
boolean sat;

element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
    Elem[result, e, 2*esize] = product;
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1011
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
integer part = 0;

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1011
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/element/mul/double/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul/double/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/double/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/double/simd:diagram
TAG:INSR-Z.R-_:execute
CheckSVEEnabled();
bits(VL) dest = Z[dn];
bits(esize) src = X[m];
Z[dn] = dest[VL-esize-1:0] : src;
TAG:INSR-Z.R-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:10 _ 100100001110
9:5 Rm xxxxx
4:0 Zdn xxxxx
TAG:INSR-Z.R-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer m = UInt(Rm);

TAG:INSR-Z.R-_:index
Execute: INSR-Z.R-_:execute
Decode: INSR-Z.R-_:decode@INSR-Z.R-_:diagram
TAG:FCVTZU-Z.P.Z-FP162H:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) res = FPToFixed(element[s_esize-1:0], 0, unsigned, FPCR, rounding);
        Elem[result, e, esize] = Extend(res, unsigned);

Z[d] = result;
TAG:FCVTZU-Z.P.Z-FP162H:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-FP162H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 16;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-FP162W:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-FP162W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 32;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-FP162X:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-FP162X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 64;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-S2W:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-S2W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 32;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-S2X:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-S2X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 64;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-D2W:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-D2W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 32;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-D2X:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZU-Z.P.Z-D2X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 64;
boolean unsigned = TRUE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZU-Z.P.Z-FP162H:index
Execute: FCVTZU-Z.P.Z-FP162H:execute
Decode: FCVTZU-Z.P.Z-FP162H:decode@FCVTZU-Z.P.Z-FP162H:diagram
Decode: FCVTZU-Z.P.Z-FP162W:decode@FCVTZU-Z.P.Z-FP162W:diagram
Decode: FCVTZU-Z.P.Z-FP162X:decode@FCVTZU-Z.P.Z-FP162X:diagram
Decode: FCVTZU-Z.P.Z-S2W:decode@FCVTZU-Z.P.Z-S2W:diagram
Decode: FCVTZU-Z.P.Z-S2X:decode@FCVTZU-Z.P.Z-S2X:diagram
Decode: FCVTZU-Z.P.Z-D2W:decode@FCVTZU-Z.P.Z-D2W:diagram
Decode: FCVTZU-Z.P.Z-D2X:decode@FCVTZU-Z.P.Z-D2X:diagram
TAG:PRFB-I.P.BR-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) offset = X[m];
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + (UInt(offset) << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
    offset = offset + 1;
TAG:PRFB-I.P.BR-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.BR-S:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 0;

TAG:PRFB-I.P.BR-S:index
Execute: PRFB-I.P.BR-S:execute
Decode: PRFB-I.P.BR-S:decode@PRFB-I.P.BR-S:diagram
TAG:FCVTZS-Z.P.Z-FP162H:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) res = FPToFixed(element[s_esize-1:0], 0, unsigned, FPCR, rounding);
        Elem[result, e, esize] = Extend(res, unsigned);

Z[d] = result;
TAG:FCVTZS-Z.P.Z-FP162H:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 0
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-FP162H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 16;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-FP162W:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-FP162W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 32;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-FP162X:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-FP162X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 64;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-S2W:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-S2W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 32;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-S2X:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-S2X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 64;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-D2W:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-D2W:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 32;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-D2X:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 011
18:18 _ 1
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVTZS-Z.P.Z-D2X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 64;
boolean unsigned = FALSE;
FPRounding rounding = FPRounding_ZERO;

TAG:FCVTZS-Z.P.Z-FP162H:index
Execute: FCVTZS-Z.P.Z-FP162H:execute
Decode: FCVTZS-Z.P.Z-FP162H:decode@FCVTZS-Z.P.Z-FP162H:diagram
Decode: FCVTZS-Z.P.Z-FP162W:decode@FCVTZS-Z.P.Z-FP162W:diagram
Decode: FCVTZS-Z.P.Z-FP162X:decode@FCVTZS-Z.P.Z-FP162X:diagram
Decode: FCVTZS-Z.P.Z-S2W:decode@FCVTZS-Z.P.Z-S2W:diagram
Decode: FCVTZS-Z.P.Z-S2X:decode@FCVTZS-Z.P.Z-S2X:diagram
Decode: FCVTZS-Z.P.Z-D2W:decode@FCVTZS-Z.P.Z-D2W:diagram
Decode: FCVTZS-Z.P.Z-D2X:decode@FCVTZS-Z.P.Z-D2X:diagram
TAG:UQINCP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    integer element = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);

Z[dn] = result;
TAG:UQINCP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 1
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:UQINCP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);
boolean unsigned = TRUE;

TAG:UQINCP-Z.P.Z-_:index
Execute: UQINCP-Z.P.Z-_:execute
Decode: UQINCP-Z.P.Z-_:decode@UQINCP-Z.P.Z-_:diagram
TAG:LSL-Z.P.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) mask = P[g];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSL(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSL-Z.P.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:20 _ 00
19:19 _ 0
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:8 tszl xx
7:5 imm3 xxx
4:0 Zdn xxxxx
TAG:LSL-Z.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer shift = UInt(tsize:imm3) - esize;

TAG:LSL-Z.P.ZI-_:index
Execute: LSL-Z.P.ZI-_:execute
Decode: LSL-Z.P.ZI-_:decode@LSL-Z.P.ZI-_:diagram
TAG:ST2B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST2B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 2;

TAG:ST2B-Z.P.BI-Contiguous:index
Execute: ST2B-Z.P.BI-Contiguous:execute
Decode: ST2B-Z.P.BI-Contiguous:decode@ST2B-Z.P.BI-Contiguous:diagram
TAG:ST4W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST4W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:ST4W-Z.P.BI-Contiguous:index
Execute: ST4W-Z.P.BI-Contiguous:execute
Decode: ST4W-Z.P.BI-Contiguous:decode@ST4W-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/arithmetic/unary/extract/sat/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;

for e = 0 to elements-1
    element = Elem[operand, e, 2*esize];
    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);
    if sat then FPSR.QC = '1';

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 10100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer part = 0;
integer elements = 1;

boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/extract/sat/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 10100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sat/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/extract/sat/sisd:index
Execute: aarch64/vector/arithmetic/unary/extract/sat/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd:decode@aarch64/instrs/vector/arithmetic/unary/extract/sat/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/extract/sat/simd:decode@aarch64/instrs/vector/arithmetic/unary/extract/sat/simd:diagram
TAG:LDFF1SB-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SB-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LDFF1SB-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LDFF1SB-Z.P.AI-S:index
Execute: LDFF1SB-Z.P.AI-S:execute
Decode: LDFF1SB-Z.P.AI-S:decode@LDFF1SB-Z.P.AI-S:diagram
Decode: LDFF1SB-Z.P.AI-D:decode@LDFF1SB-Z.P.AI-D:diagram
TAG:SUB-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = element1 - element2;

Z[d] = result;
TAG:SUB-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SUB-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:SUB-Z.ZZ-_:index
Execute: SUB-Z.ZZ-_:execute
Decode: SUB-Z.ZZ-_:decode@SUB-Z.ZZ-_:diagram
TAG:ANDV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) result = Ones(esize);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        result = result AND Elem[operand, e, esize];

V[d] = result;
TAG:ANDV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:ANDV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:ANDV-R.P.Z-_:index
Execute: ANDV-R.P.Z-_:execute
Decode: ANDV-R.P.Z-_:decode@ANDV-R.P.Z-_:diagram
TAG:LD1ROW-Z.P.BI-U32:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(256) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 32;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROW-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROW-Z.P.BI-U32:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);

TAG:LD1ROW-Z.P.BI-U32:index
Execute: LD1ROW-Z.P.BI-U32:execute
Decode: LD1ROW-Z.P.BI-U32:decode@LD1ROW-Z.P.BI-U32:diagram
TAG:SABD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer absdiff = Abs(element1 - element2);
        Elem[result, e, esize] = absdiff[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SABD-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 1
17:17 _ 0
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SABD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SABD-Z.P.ZZ-_:index
Execute: SABD-Z.P.ZZ-_:execute
Decode: SABD-Z.P.ZZ-_:decode@SABD-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/unary/fp16/conv/int/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
FPRounding rounding = FPRoundingMode(FPCR);
bits(esize) element;
for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 0
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/unary/fp16/conv/int/sisd:index
Execute: aarch64/vector/arithmetic/unary/fp16/conv/int/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/int/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd:decode@aarch64/instrs/vector/arithmetic/unary/fp16/conv/int/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd:decode@aarch64/instrs/vector/arithmetic/unary/float/conv/int/simd:diagram
TAG:aarch64/vector/crypto/sha2op/sha256-sched0:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) result;
bits(128) T = operand2[31:0] : operand1[127:32];
bits(32) elt;

for e = 0 to 3
    elt = Elem[T, e, 32];
    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);
    Elem[result, e, 32] = elt + Elem[operand1, e, 32];
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sha2op/sha256-sched0:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:17 _ 10100
16:12 _ 00010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha2op/sha256-sched0:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
if !HaveSHA256Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha2op/sha256-sched0:index
Execute: aarch64/vector/crypto/sha2op/sha256-sched0:execute
Decode: aarch64/instrs/vector/crypto/sha2op/sha256-sched0:decode@aarch64/instrs/vector/crypto/sha2op/sha256-sched0:diagram
TAG:LDNT1W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LDNT1W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;

TAG:LDNT1W-Z.P.BR-Contiguous:index
Execute: LDNT1W-Z.P.BR-Contiguous:execute
Decode: LDNT1W-Z.P.BR-Contiguous:decode@LDNT1W-Z.P.BR-Contiguous:diagram
TAG:UXTB-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(element[s_esize-1:0], esize, unsigned);

Z[d] = result;
TAG:UXTB-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 00
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UXTB-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 8;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = TRUE;

TAG:UXTH-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 01
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UXTH-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '1x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = TRUE;

TAG:UXTW-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 10
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UXTW-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = TRUE;

TAG:UXTB-Z.P.Z-_:index
Execute: UXTB-Z.P.Z-_:execute
Decode: UXTB-Z.P.Z-_:decode@UXTB-Z.P.Z-_:diagram
Decode: UXTH-Z.P.Z-_:decode@UXTH-Z.P.Z-_:diagram
Decode: UXTW-Z.P.Z-_:decode@UXTW-Z.P.Z-_:diagram
TAG:UADDV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer sum = 0;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = UInt(Elem[operand, e, esize]);
        sum = sum + element;

V[d] = sum[63:0];
TAG:UADDV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 000
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:UADDV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:UADDV-R.P.Z-_:index
Execute: UADDV-R.P.Z-_:execute
Decode: UADDV-R.P.Z-_:decode@UADDV-R.P.Z-_:diagram
TAG:FMIN-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMin(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMIN-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 11
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FMIN-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

TAG:FMIN-Z.P.ZS-_:index
Execute: FMIN-Z.P.ZS-_:execute
Decode: FMIN-Z.P.ZS-_:decode@FMIN-Z.P.ZS-_:diagram
TAG:LD1ROH-Z.P.BI-U16:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(256) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 32;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROH-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROH-Z.P.BI-U16:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);

TAG:LD1ROH-Z.P.BI-U16:index
Execute: LD1ROH-Z.P.BI-U16:execute
Decode: LD1ROH-Z.P.BI-U16:decode@LD1ROH-Z.P.BI-U16:diagram
TAG:LDR-P.BI-_:execute
CheckSVEEnabled();
integer elements = PL DIV 8;
bits(64) base;
integer offset = imm * elements;
bits(PL) result;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

boolean aligned = AArch64.CheckAlignment(base + offset, 2, AccType_NORMAL, FALSE);
for e = 0 to elements-1
    Elem[result, e, 8] = AArch64.MemSingle[base + offset, 1, AccType_NORMAL, aligned];
    offset = offset + 1;

P[t] = result;
TAG:LDR-P.BI-_:diagram
A64
31:22 _ 1000010110
21:16 imm9h xxxxxx
15:13 _ 000
12:10 imm9l xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 Pt xxxx
TAG:LDR-P.BI-_:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Pt);
integer n = UInt(Rn);
integer imm = SInt(imm9h:imm9l);

TAG:LDR-P.BI-_:index
Execute: LDR-P.BI-_:execute
Decode: LDR-P.BI-_:decode@LDR-P.BI-_:diagram
TAG:DUP-Z.R-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) operand;
if n == 31 then
    operand = SP[];
else
    operand = X[n];
bits(VL) result;

for e = 0 to elements-1
    Elem[result, e, esize] = operand[esize-1:0];

Z[d] = result;
TAG:DUP-Z.R-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:10 _ 100000001110
9:5 Rn xxxxx
4:0 Zd xxxxx
TAG:DUP-Z.R-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Rn);
integer d = UInt(Zd);

TAG:DUP-Z.R-_:index
Execute: DUP-Z.R-_:execute
Decode: DUP-Z.R-_:decode@DUP-Z.R-_:diagram
TAG:SEL-P.P.PP-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1;
    else
        ElemP[result, e, esize] = element2;

P[d] = result;
TAG:SEL-P.P.PP-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:SEL-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);

TAG:SEL-P.P.PP-_:index
Execute: SEL-P.P.PP-_:execute
Decode: SEL-P.P.PP-_:decode@SEL-P.P.PP-_:diagram
TAG:CMPEQ-P.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(PL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        boolean cond;
        case op of
            when Cmp_EQ cond = element1 == element2;
            when Cmp_NE cond = element1 != element2;
            when Cmp_GE cond = element1 >= element2;
            when Cmp_LT cond = element1 <  element2;
            when Cmp_GT cond = element1 >  element2;
            when Cmp_LE cond = element1 <= element2;
        ElemP[result, e, esize] = if cond then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:CMPEQ-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPEQ-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_EQ;
boolean unsigned = FALSE;

TAG:CMPGT-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPGT-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
boolean unsigned = FALSE;

TAG:CMPGE-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPGE-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
boolean unsigned = FALSE;

TAG:CMPHI-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPHI-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
boolean unsigned = TRUE;

TAG:CMPHS-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPHS-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
boolean unsigned = TRUE;

TAG:CMPNE-P.P.ZZ-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPNE-P.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Pd);
SVECmp op = Cmp_NE;
boolean unsigned = FALSE;

TAG:CMPEQ-P.P.ZZ-_:index
Execute: CMPEQ-P.P.ZZ-_:execute
Decode: CMPEQ-P.P.ZZ-_:decode@CMPEQ-P.P.ZZ-_:diagram
Decode: CMPGT-P.P.ZZ-_:decode@CMPGT-P.P.ZZ-_:diagram
Decode: CMPGE-P.P.ZZ-_:decode@CMPGE-P.P.ZZ-_:diagram
Decode: CMPHI-P.P.ZZ-_:decode@CMPHI-P.P.ZZ-_:diagram
Decode: CMPHS-P.P.ZZ-_:decode@CMPHS-P.P.ZZ-_:diagram
Decode: CMPNE-P.P.ZZ-_:decode@CMPNE-P.P.ZZ-_:diagram
TAG:aarch64/integer/tags/mcinsertrandomtag:execute
bits(64) operand = if n == 31 then SP[] else X[n];
bits(64) exclude_reg = X[m];
bits(16) exclude = exclude_reg[15:0] OR GCR_EL1.Exclude;

if AArch64.AllocationTagAccessIsEnabled() then
    if GCR_EL1.RRND == '1' then
        RGSR_EL1 = bits(32) UNKNOWN;
        rtag = _ChooseRandomNonExcludedTag(exclude);
    else
        bits(4) start = RGSR_EL1.TAG;
        bits(4) offset = AArch64.RandomTag();

        rtag = AArch64.ChooseNonExcludedTag(start, offset, exclude);

        RGSR_EL1.TAG = rtag;
else
    rtag = '0000';

bits(64) result = AArch64.AddressWithAllocationTag(operand, rtag);

if d == 31 then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/tags/mcinsertrandomtag:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Xm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 1
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/tags/mcinsertrandomtag:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);

TAG:aarch64/integer/tags/mcinsertrandomtag:index
Execute: aarch64/integer/tags/mcinsertrandomtag:execute
Decode: aarch64/instrs/integer/tags/mcinsertrandomtag:decode@aarch64/instrs/integer/tags/mcinsertrandomtag:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul-acc/bf16/long:execute
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) operand3 = V[d];
bits(128) result;

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);
    bits(32) addend = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul-acc/bf16/long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 _ 11
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:13 _ 11
12:12 _ 1
11:11 _ 1
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul-acc/bf16/long:decode
if !HaveBF16Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch64/vector/arithmetic/binary/uniform/mul-acc/bf16/long:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul-acc/bf16/long:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul-acc/bf16/long:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul-acc/bf16/long:diagram
TAG:LD1RH-Z.P.BI-U16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RH-Z.P.BI-U16:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RH-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RH-Z.P.BI-U32:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RH-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RH-Z.P.BI-U64:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RH-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RH-Z.P.BI-U16:index
Execute: LD1RH-Z.P.BI-U16:execute
Decode: LD1RH-Z.P.BI-U16:decode@LD1RH-Z.P.BI-U16:diagram
Decode: LD1RH-Z.P.BI-U32:decode@LD1RH-Z.P.BI-U32:diagram
Decode: LD1RH-Z.P.BI-U64:decode@LD1RH-Z.P.BI-U64:diagram
TAG:ST3D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST3D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 3;

TAG:ST3D-Z.P.BR-Contiguous:index
Execute: ST3D-Z.P.BR-Contiguous:execute
Decode: ST3D-Z.P.BR-Contiguous:decode@ST3D-Z.P.BR-Contiguous:diagram
TAG:LDFF1SH-Z.P.BR-S32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1SH-Z.P.BR-S32:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BR-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;

TAG:LDFF1SH-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;

TAG:LDFF1SH-Z.P.BR-S32:index
Execute: LDFF1SH-Z.P.BR-S32:execute
Decode: LDFF1SH-Z.P.BR-S32:decode@LDFF1SH-Z.P.BR-S32:diagram
Decode: LDFF1SH-Z.P.BR-S64:decode@LDFF1SH-Z.P.BR-S64:diagram
TAG:aarch64/vector/transfer/vector/cpy-dup/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(idxdsize) operand = V[n];
bits(datasize) result;
bits(esize) element;

element = Elem[operand, index, esize];
for e = 0 to elements-1
    Elem[result, e, esize] = element;
V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/cpy-dup/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:21 _ 11110000
20:16 imm5 xxxxx
15:15 _ 0
14:11 _ 0000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/cpy-dup/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;

integer index = UInt(imm5[4:size+1]);
integer idxdsize = if imm5[4] == '1' then 128 else 64; 

integer esize = 8 << size;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/transfer/vector/cpy-dup/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:11 _ 0000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/cpy-dup/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;

integer index = UInt(imm5[4:size+1]);
integer idxdsize = if imm5[4] == '1' then 128 else 64; 

if size == 3 && Q == '0' then UNDEFINED;
integer esize = 8 << size;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/transfer/vector/cpy-dup/sisd:index
Execute: aarch64/vector/transfer/vector/cpy-dup/sisd:execute
Decode: aarch64/instrs/vector/transfer/vector/cpy-dup/sisd:decode@aarch64/instrs/vector/transfer/vector/cpy-dup/sisd:diagram
Decode: aarch64/instrs/vector/transfer/vector/cpy-dup/simd:decode@aarch64/instrs/vector/transfer/vector/cpy-dup/simd:diagram
TAG:LD4B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 11
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:LD4B-Z.P.BI-Contiguous:index
Execute: LD4B-Z.P.BI-Contiguous:execute
Decode: LD4B-Z.P.BI-Contiguous:decode@LD4B-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/transfer/vector/permute/zip:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;

integer base = part * pairs;

for p = 0 to pairs-1
    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];

V[d] = result;
TAG:aarch64/instrs/vector/transfer/vector/permute/zip:diagram
A64
31:31 _ 0
30:30 Q x
29:24 _ 001110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:14 op x
13:12 _ 11
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/permute/zip:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
integer part = UInt(op);
integer pairs = elements DIV 2;

TAG:aarch64/vector/transfer/vector/permute/zip:index
Execute: aarch64/vector/transfer/vector/permute/zip:execute
Decode: aarch64/instrs/vector/transfer/vector/permute/zip:decode@aarch64/instrs/vector/transfer/vector/permute/zip:diagram
TAG:LDFF1SB-Z.P.BZ-D.x32.unscaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SB-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1SB-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1SB-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SB-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1SB-Z.P.BZ-D.x32.unscaled:index
Execute: LDFF1SB-Z.P.BZ-D.x32.unscaled:execute
Decode: LDFF1SB-Z.P.BZ-D.x32.unscaled:decode@LDFF1SB-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1SB-Z.P.BZ-S.x32.unscaled:decode@LDFF1SB-Z.P.BZ-S.x32.unscaled:diagram
Decode: LDFF1SB-Z.P.BZ-D.64.unscaled:decode@LDFF1SB-Z.P.BZ-D.64.unscaled:diagram
TAG:SETFFR-F-_:execute
CheckSVEEnabled();
FFR[] = Ones(PL);
TAG:SETFFR-F-_:diagram
A64
31:30 _ 00
29:24 _ 100101
23:23 _ 0
22:22 _ 0
21:20 _ 10
19:10 _ 1100100100
9:4 _ 000000
3:3 _ 0
2:2 _ 0
1:0 _ 00
TAG:SETFFR-F-_:decode
if !HaveSVE() then UNDEFINED;

TAG:SETFFR-F-_:index
Execute: SETFFR-F-_:execute
Decode: SETFFR-F-_:decode@SETFFR-F-_:diagram
TAG:UQDECD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQDECD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQDECD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQDECD-Z.ZS-_:index
Execute: UQDECD-Z.ZS-_:execute
Decode: UQDECD-Z.ZS-_:decode@UQDECD-Z.ZS-_:diagram
TAG:LD1H-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1H-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001001
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LD1H-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LD1H-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1H-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1H-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:LD1H-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1H-Z.P.BZ-S.x32.scaled:index
Execute: LD1H-Z.P.BZ-S.x32.scaled:execute
Decode: LD1H-Z.P.BZ-S.x32.scaled:decode@LD1H-Z.P.BZ-S.x32.scaled:diagram
Decode: LD1H-Z.P.BZ-D.x32.scaled:decode@LD1H-Z.P.BZ-D.x32.scaled:diagram
Decode: LD1H-Z.P.BZ-D.x32.unscaled:decode@LD1H-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1H-Z.P.BZ-S.x32.unscaled:decode@LD1H-Z.P.BZ-S.x32.unscaled:diagram
Decode: LD1H-Z.P.BZ-D.64.scaled:decode@LD1H-Z.P.BZ-D.64.scaled:diagram
Decode: LD1H-Z.P.BZ-D.64.unscaled:decode@LD1H-Z.P.BZ-D.64.unscaled:diagram
TAG:UQDECP-R.P.R-UW:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(ssize) operand1 = X[dn];
bits(PL) operand2 = P[m];
bits(ssize) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

integer element = Int(operand1, unsigned);
(result, -) = SatQ(element - count, ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQDECP-R.P.R-UW:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 1
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:UQDECP-R.P.R-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQDECP-R.P.R-X:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 1
15:11 _ 10001
10:10 _ 1
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:UQDECP-R.P.R-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQDECP-R.P.R-UW:index
Execute: UQDECP-R.P.R-UW:execute
Decode: UQDECP-R.P.R-UW:decode@UQDECP-R.P.R-UW:diagram
Decode: UQDECP-R.P.R-X:decode@UQDECP-R.P.R-X:diagram
TAG:aarch64/vector/crypto/sm4/sm4enc:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vn = V[n];
bits(32) intval; 
bits(8) sboxout;
bits(128) roundresult;
bits(32) roundkey;

roundresult=V[d];
for index = 0 to 3
    roundkey = Elem[Vn,index,32];

    intval = roundresult[127:96] EOR roundresult[95:64] EOR roundresult[63:32] EOR roundkey; 

    for i = 0 to 3  
        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); 

    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);
    intval = intval EOR roundresult[31:0]; 

    roundresult[31:0] = roundresult[63:32];
    roundresult[63:32] = roundresult[95:64];
    roundresult[95:64] = roundresult[127:96];
    roundresult[127:96] = intval; 
V[d] = roundresult;
TAG:aarch64/instrs/vector/crypto/sm4/sm4enc:diagram
A64
31:12 _ 11001110110000001000
11:10 _ 01
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm4/sm4enc:decode
if !HaveSM4Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);

TAG:aarch64/vector/crypto/sm4/sm4enc:index
Execute: aarch64/vector/crypto/sm4/sm4enc:execute
Decode: aarch64/instrs/vector/crypto/sm4/sm4enc:decode@aarch64/instrs/vector/crypto/sm4/sm4enc:diagram
TAG:DECD-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    Elem[result, e, esize] = Elem[operand1, e, esize] - (count * imm);

Z[dn] = result;
TAG:DECD-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:DECD-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:DECH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11000
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:DECW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECD-Z.ZS-_:index
Execute: DECD-Z.ZS-_:execute
Decode: DECD-Z.ZS-_:decode@DECD-Z.ZS-_:diagram
Decode: DECH-Z.ZS-_:decode@DECH-Z.ZS-_:diagram
Decode: DECW-Z.ZS-_:decode@DECW-Z.ZS-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul/int:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) product;

element2 = UInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = UInt(Elem[operand1, e, esize]);
    product = (element1 * element2)[esize-1:0];
    Elem[result, e, esize] = product;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/int:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1000
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/int:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/element/mul/int:index
Execute: aarch64/vector/arithmetic/binary/element/mul/int:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/int:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/int:diagram
TAG:DECP-R.P.R-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) operand1 = X[dn];
bits(PL) operand2 = P[m];
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

X[dn] = operand1 - count;
TAG:DECP-R.P.R-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1011
17:17 _ 0
16:16 _ 1
15:11 _ 10001
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Rdn xxxxx
TAG:DECP-R.P.R-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Rdn);

TAG:DECP-R.P.R-_:index
Execute: DECP-R.P.R-_:execute
Decode: DECP-R.P.R-_:decode@DECP-R.P.R-_:diagram
TAG:EOR-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1 EOR element2;
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:EOR-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:EOR-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:EORS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 1
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:EORS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:EOR-P.P.PP-Z:index
Execute: EOR-P.P.PP-Z:execute
Decode: EOR-P.P.PP-Z:decode@EOR-P.P.PP-Z:diagram
Decode: EORS-P.P.PP-Z:decode@EORS-P.P.PP-Z:diagram
TAG:LD1RQB-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(64) offset;
bits(128) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQB-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQB-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;

TAG:LD1RQB-Z.P.BR-Contiguous:index
Execute: LD1RQB-Z.P.BR-Contiguous:execute
Decode: LD1RQB-Z.P.BR-Contiguous:decode@LD1RQB-Z.P.BR-Contiguous:diagram
TAG:BRKPB-P.P.PP-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;
boolean last = (LastActive(mask, operand1, 8) == '1');

for e = 0 to elements-1
    if ElemP[mask, e, 8] == '1' then
        last = last && (ElemP[operand2, e, 8] == '0');
        ElemP[result, e, 8] = if last then '1' else '0';
    else
        ElemP[result, e, 8] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:BRKPB-P.P.PP-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 11
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:BRKPB-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:BRKPBS-P.P.PP-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 11
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 1
3:0 Pd xxxx
TAG:BRKPBS-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:BRKPB-P.P.PP-_:index
Execute: BRKPB-P.P.PP-_:execute
Decode: BRKPB-P.P.PP-_:decode@BRKPB-P.P.PP-_:diagram
Decode: BRKPBS-P.P.PP-_:decode@BRKPBS-P.P.PP-_:diagram
TAG:UQINCH-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQINCH-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQINCH-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQINCH-Z.ZS-_:index
Execute: UQINCH-Z.ZS-_:execute
Decode: UQINCH-Z.ZS-_:decode@UQINCH-Z.ZS-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/mul/double/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize)   operand1 = Vpart[n, part];
bits(datasize)   operand2 = Vpart[m, part];
bits(2*datasize) result;
integer element1;
integer element2;
bits(2*esize) product;
boolean sat;

for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    element2 = SInt(Elem[operand2, e, esize]);
    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);
    Elem[result, e, 2*esize] = product;
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1101
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '00' || size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
integer part = 0;

TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 1101
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '00' || size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/disparate/mul/double/sisd:index
Execute: aarch64/vector/arithmetic/binary/disparate/mul/double/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd:decode@aarch64/instrs/vector/arithmetic/binary/disparate/mul/double/simd:diagram
TAG:FMAXNMV-V.P.Z-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) identity = FPDefaultNaN();

V[d] = ReducePredicated(ReduceOp_FMAXNUM, operand, mask, identity);
TAG:FMAXNMV-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 10
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:FMAXNMV-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:FMAXNMV-V.P.Z-_:index
Execute: FMAXNMV-V.P.Z-_:execute
Decode: FMAXNMV-V.P.Z-_:decode@FMAXNMV-V.P.Z-_:diagram
TAG:UMAX-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer maximum = Max(element1, element2);
        Elem[result, e, esize] = maximum[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UMAX-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UMAX-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UMAX-Z.P.ZZ-_:index
Execute: UMAX-Z.P.ZZ-_:execute
Decode: UMAX-Z.P.ZZ-_:decode@UMAX-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/unary/special/sqrt-fp16:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPSqrt(element, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:12 _ 11111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/special/sqrt-fp16:index
Execute: aarch64/vector/arithmetic/unary/special/sqrt-fp16:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-fp16:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt:diagram
TAG:aarch64/float/move/fp/imm:execute
CheckFPAdvSIMDEnabled64();

V[d] = imm;
TAG:aarch64/instrs/float/move/fp/imm:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:13 imm8 xxxxxxxx
12:10 _ 100
9:5 _ 00000
4:0 Rd xxxxx
TAG:aarch64/instrs/float/move/fp/imm:decode
integer d = UInt(Rd);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

bits(datasize) imm = VFPExpandImm(imm8);

TAG:aarch64/float/move/fp/imm:index
Execute: aarch64/float/move/fp/imm:execute
Decode: aarch64/instrs/float/move/fp/imm:decode@aarch64/instrs/float/move/fp/imm:diagram
TAG:UMINV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = Int(Elem[operand, e, esize], unsigned);
        minimum = Min(minimum, element);

V[d] = minimum[esize-1:0];
TAG:UMINV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:UMINV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean unsigned = TRUE;

TAG:UMINV-R.P.Z-_:index
Execute: UMINV-R.P.Z-_:execute
Decode: UMINV-R.P.Z-_:decode@UMINV-R.P.Z-_:diagram
TAG:UMIN-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer minimum = Min(element1, element2);
        Elem[result, e, esize] = minimum[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:UMIN-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:UMIN-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = TRUE;

TAG:UMIN-Z.P.ZZ-_:index
Execute: UMIN-Z.P.ZZ-_:execute
Decode: UMIN-Z.P.ZZ-_:decode@UMIN-Z.P.ZZ-_:diagram
TAG:aarch64/vector/crypto/sm3/sm3tt2b:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result; 
bits(32) TT2;

Wj = Elem[Vm,i,32];
TT2 = (Vd[127:96] AND Vd[95:64]) OR (NOT(Vd[127:96]) AND Vd[63:32]); 
TT2 = (TT2 + Vd[31:0] + Vn[127:96] + Wj)[31:0];

result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],19); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt2b:diagram
A64
31:21 _ 11001110010
20:16 Rm xxxxx
15:14 _ 10
13:12 imm2 xx
11:10 _ 11
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt2b:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer i = UInt(imm2);

TAG:aarch64/vector/crypto/sm3/sm3tt2b:index
Execute: aarch64/vector/crypto/sm3/sm3tt2b:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3tt2b:decode@aarch64/instrs/vector/crypto/sm3/sm3tt2b:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/int:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
integer element1;
integer element2;
bits(esize) product;

element2 = UInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = UInt(Elem[operand1, e, esize]);
    product = (element1 * element2)[esize-1:0];
    if sub_op then
        Elem[result, e, esize] = Elem[operand3, e, esize] - product;
    else
        Elem[result, e, esize] = Elem[operand3, e, esize] + product;
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 o2 x
13:12 _ 00
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (o2 == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/int:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/int:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/int:diagram
TAG:aarch64/vector/crypto/sm3/sm3tt1b:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) WjPrime;
bits(128) result; 
bits(32) TT1;
bits(32) SS2;

WjPrime = Elem[Vm,i,32];
SS2 = Vn[127:96] EOR ROL(Vd[127:96],12); 
TT1 = (Vd[127:96] AND Vd[63:32]) OR (Vd[127:96] AND Vd[95:64]) OR (Vd[63:32] AND Vd[95:64]); 
TT1 = (TT1 + Vd[31:0] + SS2 + WjPrime)[31:0];
result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],9); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT1; 
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt1b:diagram
A64
31:21 _ 11001110010
20:16 Rm xxxxx
15:14 _ 10
13:12 imm2 xx
11:10 _ 01
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt1b:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer i = UInt(imm2);

TAG:aarch64/vector/crypto/sm3/sm3tt1b:index
Execute: aarch64/vector/crypto/sm3/sm3tt1b:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3tt1b:decode@aarch64/instrs/vector/crypto/sm3/sm3tt1b:diagram
TAG:CLZ-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = CountLeadingZeroBits(element)[esize-1:0];

Z[d] = result;
TAG:CLZ-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:CLZ-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:CLZ-Z.P.Z-_:index
Execute: CLZ-Z.P.Z-_:execute
Decode: CLZ-Z.P.Z-_:decode@CLZ-Z.P.Z-_:diagram
TAG:USDOT-Z.ZZZi-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = SInt(Elem[operand2, 4 * s + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:USDOT-Z.ZZZi-S:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00011
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:USDOT-Z.ZZZi-S:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:USDOT-Z.ZZZi-S:index
Execute: USDOT-Z.ZZZi-S:execute
Decode: USDOT-Z.ZZZi-S:decode@USDOT-Z.ZZZi-S:diagram
TAG:UQSUB-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - element2, esize, unsigned);

Z[d] = result;
TAG:UQSUB-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UQSUB-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
boolean unsigned = TRUE;

TAG:UQSUB-Z.ZZ-_:index
Execute: UQSUB-Z.ZZ-_:execute
Decode: UQSUB-Z.ZZ-_:decode@UQSUB-Z.ZZ-_:diagram
TAG:PTEST-.P.P-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(PL) result = P[n];

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
TAG:PTEST-.P.P-_:diagram
A64
31:30 _ 00
29:24 _ 100101
23:23 _ 0
22:22 _ 1
21:20 _ 01
19:14 _ 000011
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:3 _ 0
2:2 _ 0
1:1 _ 0
0:0 _ 0
TAG:PTEST-.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);

TAG:PTEST-.P.P-_:index
Execute: PTEST-.P.P-_:execute
Decode: PTEST-.P.P-_:decode@PTEST-.P.P-_:diagram
TAG:FRECPS-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRecipStepFused(element1, element2);

Z[d] = result;
TAG:FRECPS-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRECPS-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FRECPS-Z.ZZ-_:index
Execute: FRECPS-Z.ZZ-_:execute
Decode: FRECPS-Z.ZZ-_:decode@FRECPS-Z.ZZ-_:diagram
TAG:UQINCD-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQINCD-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCD-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQINCD-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCD-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQINCD-R.RS-UW:index
Execute: UQINCD-R.RS-UW:execute
Decode: UQINCD-R.RS-UW:decode@UQINCD-R.RS-UW:diagram
Decode: UQINCD-R.RS-X:decode@UQINCD-R.RS-X:diagram
TAG:FCVT-Z.P.Z-H2S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) res = FPConvertSVE(element[s_esize-1:0], FPCR);
        Elem[result, e, esize] = ZeroExtend(res);

Z[d] = result;
TAG:FCVT-Z.P.Z-H2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:18 _ 0010
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-H2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 32;

TAG:FCVT-Z.P.Z-H2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:18 _ 0010
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-H2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 64;

TAG:FCVT-Z.P.Z-S2H:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:18 _ 0010
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-S2H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 16;

TAG:FCVT-Z.P.Z-S2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:18 _ 0010
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-S2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 64;

TAG:FCVT-Z.P.Z-D2H:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:18 _ 0010
17:17 _ 0
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-D2H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 16;

TAG:FCVT-Z.P.Z-D2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:18 _ 0010
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FCVT-Z.P.Z-D2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 32;

TAG:FCVT-Z.P.Z-H2S:index
Execute: FCVT-Z.P.Z-H2S:execute
Decode: FCVT-Z.P.Z-H2S:decode@FCVT-Z.P.Z-H2S:diagram
Decode: FCVT-Z.P.Z-H2D:decode@FCVT-Z.P.Z-H2D:diagram
Decode: FCVT-Z.P.Z-S2H:decode@FCVT-Z.P.Z-S2H:diagram
Decode: FCVT-Z.P.Z-S2D:decode@FCVT-Z.P.Z-S2D:diagram
Decode: FCVT-Z.P.Z-D2H:decode@FCVT-Z.P.Z-D2H:diagram
Decode: FCVT-Z.P.Z-D2S:decode@FCVT-Z.P.Z-D2S:diagram
TAG:aarch64/memory/single/general/immediate/signed/pac:execute
bits(64) address;
bits(64) data;
boolean wb_unknown = FALSE;
boolean auth_then_branch = TRUE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if wback && n == t && n != 31 then
    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);
    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_WBSUPPRESS wback = FALSE;       // writeback is suppressed
        when Constraint_UNKNOWN    wb_unknown = TRUE;   // writeback is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    address = SP[];
else
    address = X[n];

if use_key_a then
    address = AuthDA(address, X[31], auth_then_branch);
else
    address = AuthDB(address, X[31], auth_then_branch);

if n == 31 then
    CheckSPAlignment();

address = address + offset;
data = Mem[address, 8, AccType_NORMAL];
X[t] = data;

if wback then
    if wb_unknown then
        address = bits(64) UNKNOWN;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/memory/single/general/immediate/signed/pac:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 0
25:24 _ 00
23:23 M x
22:22 S x
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 W x
10:10 _ 1
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/general/immediate/signed/pac:decode
if !HavePACExt() || size != '11' then UNDEFINED;
integer t = UInt(Rt);
integer n = UInt(Rn);
boolean wback = (W == '1');
boolean use_key_a = (M == '0');
bits(10) S10 = S:imm9;
integer scale = 3;
bits(64) offset = LSL(SignExtend(S10, 64), scale);
boolean tag_checked = wback || n != 31;

TAG:aarch64/memory/single/general/immediate/signed/pac:index
Execute: aarch64/memory/single/general/immediate/signed/pac:execute
Decode: aarch64/instrs/memory/single/general/immediate/signed/pac:decode@aarch64/instrs/memory/single/general/immediate/signed/pac:diagram
TAG:aarch64/integer/tags/mcsettagandzerodatapost:execute
bits(64) address;

SetTagCheckedInstruction(FALSE);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if !postindex then
    address = address + offset;

if zero_data then
    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);

bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
AArch64.MemTag[address, AccType_NORMAL] = tag;

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/integer/tags/mcsettagandzerodatapost:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 0
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagandzerodatapost:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;
boolean zero_data = TRUE;

TAG:aarch64/instrs/integer/tags/mcsettagandzerodatapre:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagandzerodatapre:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;
boolean zero_data = TRUE;

TAG:aarch64/instrs/integer/tags/mcsettagandzerodata:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagandzerodata:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;
boolean zero_data = TRUE;

TAG:aarch64/integer/tags/mcsettagandzerodatapost:index
Execute: aarch64/integer/tags/mcsettagandzerodatapost:execute
Decode: aarch64/instrs/integer/tags/mcsettagandzerodatapost:decode@aarch64/instrs/integer/tags/mcsettagandzerodatapost:diagram
Decode: aarch64/instrs/integer/tags/mcsettagandzerodatapre:decode@aarch64/instrs/integer/tags/mcsettagandzerodatapre:diagram
Decode: aarch64/instrs/integer/tags/mcsettagandzerodata:decode@aarch64/instrs/integer/tags/mcsettagandzerodata:diagram
TAG:ST2D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST2D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 2;

TAG:ST2D-Z.P.BR-Contiguous:index
Execute: ST2D-Z.P.BR-Contiguous:execute
Decode: ST2D-Z.P.BR-Contiguous:decode@ST2D-Z.P.BR-Contiguous:diagram
TAG:ST1W-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1W-Z.P.AI-S:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offset = UInt(imm5);

TAG:ST1W-Z.P.AI-D:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offset = UInt(imm5);

TAG:ST1W-Z.P.AI-S:index
Execute: ST1W-Z.P.AI-S:execute
Decode: ST1W-Z.P.AI-S:decode@ST1W-Z.P.AI-S:diagram
Decode: ST1W-Z.P.AI-D:decode@ST1W-Z.P.AI-D:diagram
TAG:aarch64/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) zero = FPZero('0');
bits(esize) element;
boolean test_passed;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    case comparison of
        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);
        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);
        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);
        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);
        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:17 _ 111100
16:12 _ 01110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 01110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:12 _ 01110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 01110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:index
Execute: aarch64/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/fp16/lessthan/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/float/lessthan/simd:diagram
TAG:CPY-Z.P.I-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) dest = Z[d];
bits(VL) result;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = imm[esize-1:0];
    elsif merging then
        Elem[result, e, esize] = Elem[dest, e, esize];
    else
        Elem[result, e, esize] = Zeros();

Z[d] = result;
TAG:CPY-Z.P.I-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 01
19:16 Pg xxxx
15:15 _ 0
14:14 _ 1
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zd xxxxx
TAG:CPY-Z.P.I-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer d = UInt(Zd);
boolean merging = TRUE;
integer imm = SInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:CPY-Z.P.I-_:index
Execute: CPY-Z.P.I-_:execute
Decode: CPY-Z.P.I-_:decode@CPY-Z.P.I-_:diagram
TAG:LD1RQH-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(64) offset;
bits(128) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQH-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQH-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;

TAG:LD1RQH-Z.P.BR-Contiguous:index
Execute: LD1RQH-Z.P.BR-Contiguous:execute
Decode: LD1RQH-Z.P.BR-Contiguous:decode@LD1RQH-Z.P.BR-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/product:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) product;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if poly then
        product = PolynomialMult(element1, element2)[esize-1:0];
    else
        product = (UInt(element1) * UInt(element2))[esize-1:0];
    Elem[result, e, esize] = product;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if U == '1' && size != '00' then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean poly = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/product:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/product:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/product:diagram
TAG:FMUL-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPMul(element1, element2, FPCR);

Z[d] = result;
TAG:FMUL-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 01
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FMUL-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FMUL-Z.ZZ-_:index
Execute: FMUL-Z.ZZ-_:execute
Decode: FMUL-Z.ZZ-_:decode@FMUL-Z.ZZ-_:diagram
TAG:LD1RSH-Z.P.BI-S32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RSH-Z.P.BI-S32:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSH-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSH-Z.P.BI-S64:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSH-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSH-Z.P.BI-S32:index
Execute: LD1RSH-Z.P.BI-S32:execute
Decode: LD1RSH-Z.P.BI-S32:decode@LD1RSH-Z.P.BI-S32:diagram
Decode: LD1RSH-Z.P.BI-S64:decode@LD1RSH-Z.P.BI-S64:diagram
TAG:LD1RQB-Z.P.BI-U8:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(128) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 16;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQB-Z.P.BI-U8:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQB-Z.P.BI-U8:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);

TAG:LD1RQB-Z.P.BI-U8:index
Execute: LD1RQB-Z.P.BI-U8:execute
Decode: LD1RQB-Z.P.BI-U8:decode@LD1RQB-Z.P.BI-U8:diagram
TAG:LD1SB-Z.P.BZ-D.x32.unscaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset = Z[m];
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SB-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1SB-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LD1SB-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LD1SB-Z.P.BZ-D.x32.unscaled:index
Execute: LD1SB-Z.P.BZ-D.x32.unscaled:execute
Decode: LD1SB-Z.P.BZ-D.x32.unscaled:decode@LD1SB-Z.P.BZ-D.x32.unscaled:diagram
Decode: LD1SB-Z.P.BZ-S.x32.unscaled:decode@LD1SB-Z.P.BZ-S.x32.unscaled:diagram
Decode: LD1SB-Z.P.BZ-D.64.unscaled:decode@LD1SB-Z.P.BZ-D.64.unscaled:diagram
TAG:FMINNM-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMINNM-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 010
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMINNM-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMINNM-Z.P.ZZ-_:index
Execute: FMINNM-Z.P.ZZ-_:execute
Decode: FMINNM-Z.P.ZZ-_:decode@FMINNM-Z.P.ZZ-_:diagram
TAG:FABD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPAbs(FPSub(element1, element2, FPCR));
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FABD-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 100
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FABD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FABD-Z.P.ZZ-_:index
Execute: FABD-Z.P.ZZ-_:execute
Decode: FABD-Z.P.ZZ-_:decode@FABD-Z.P.ZZ-_:diagram
TAG:LD1H-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1H-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1H-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LD1H-Z.P.AI-S:index
Execute: LD1H-Z.P.AI-S:execute
Decode: LD1H-Z.P.AI-S:decode@LD1H-Z.P.AI-S:diagram
Decode: LD1H-Z.P.AI-D:decode@LD1H-Z.P.AI-D:diagram
TAG:aarch64/vector/crypto/sm3/sm3tt2a:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(32) Wj;
bits(128) result; 
bits(32) TT2;

Wj = Elem[Vm,i,32];
TT2 = Vd[63:32] EOR (Vd[127:96] EOR Vd[95:64]);
TT2 = (TT2 + Vd[31:0] + Vn[127:96] + Wj)[31:0];

result[31:0] = Vd[63:32];
result[63:32] = ROL(Vd[95:64],19); 
result[95:64] = Vd[127:96]; 
result[127:96] = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); 
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt2a:diagram
A64
31:21 _ 11001110010
20:16 Rm xxxxx
15:14 _ 10
13:12 imm2 xx
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3tt2a:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer i = UInt(imm2);

TAG:aarch64/vector/crypto/sm3/sm3tt2a:index
Execute: aarch64/vector/crypto/sm3/sm3tt2a:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3tt2a:decode@aarch64/instrs/vector/crypto/sm3/sm3tt2a:diagram
TAG:LDNT1H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LDNT1H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:20 _ 000
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);

TAG:LDNT1H-Z.P.BI-Contiguous:index
Execute: LDNT1H-Z.P.BI-Contiguous:execute
Decode: LDNT1H-Z.P.BI-Contiguous:decode@LDNT1H-Z.P.BI-Contiguous:diagram
TAG:PRFW-I.P.BR-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) offset = X[m];
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + (UInt(offset) << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
    offset = offset + 1;
TAG:PRFW-I.P.BR-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.BR-S:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 2;

TAG:PRFW-I.P.BR-S:index
Execute: PRFW-I.P.BR-S:execute
Decode: PRFW-I.P.BR-S:decode@PRFW-I.P.BR-S:diagram
TAG:ST1B-Z.P.BR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    offset = offset + 1;
TAG:ST1B-Z.P.BR-_:diagram
A64
31:25 _ 1110010
24:23 _ 00
22:21 size xx
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.BR-_:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 8;

TAG:ST1B-Z.P.BR-_:index
Execute: ST1B-Z.P.BR-_:execute
Decode: ST1B-Z.P.BR-_:decode@ST1B-Z.P.BR-_:diagram
TAG:MOVPRFX-Z.Z-_:execute
CheckSVEEnabled();
bits(VL) result = Z[n];
Z[d] = result;
TAG:MOVPRFX-Z.Z-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:17 _ 0000
16:16 _ 0
15:10 _ 101111
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:MOVPRFX-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:MOVPRFX-Z.Z-_:index
Execute: MOVPRFX-Z.Z-_:execute
Decode: MOVPRFX-Z.Z-_:decode@MOVPRFX-Z.Z-_:diagram
TAG:ST1D-Z.P.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    addr = addr + mbytes;
TAG:ST1D-Z.P.BI-_:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 size xx
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.BI-_:decode
if !HaveSVE() then UNDEFINED;
if size != '11' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 64;
integer offset = SInt(imm4);

TAG:ST1D-Z.P.BI-_:index
Execute: ST1D-Z.P.BI-_:execute
Decode: ST1D-Z.P.BI-_:decode@ST1D-Z.P.BI-_:diagram
TAG:SMAXV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer maximum = if unsigned then 0 else -(2^(esize-1));

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = Int(Elem[operand, e, esize], unsigned);
        maximum = Max(maximum, element);

V[d] = maximum[esize-1:0];
TAG:SMAXV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:SMAXV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean unsigned = FALSE;

TAG:SMAXV-R.P.Z-_:index
Execute: SMAXV-R.P.Z-_:execute
Decode: SMAXV-R.P.Z-_:decode@SMAXV-R.P.Z-_:diagram
TAG:ORR-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1 OR element2;
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:ORR-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 S 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:ORR-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:ORRS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 S 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:ORRS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:ORR-P.P.PP-Z:index
Execute: ORR-P.P.PP-Z:execute
Decode: ORR-P.P.PP-Z:decode@ORR-P.P.PP-Z:diagram
Decode: ORRS-P.P.PP-Z:decode@ORRS-P.P.PP-Z:diagram
TAG:STNT1W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
constant integer mbytes = esize DIV 8;
bits(VL) src;
bits(PL) mask = P[g];

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];
src = Z[t];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    addr = addr + mbytes;
TAG:STNT1W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:20 _ 001
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);

TAG:STNT1W-Z.P.BI-Contiguous:index
Execute: STNT1W-Z.P.BI-Contiguous:execute
Decode: STNT1W-Z.P.BI-Contiguous:decode@STNT1W-Z.P.BI-Contiguous:diagram
TAG:LDFF1SH-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SH-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LDFF1SH-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LDFF1SH-Z.P.AI-S:index
Execute: LDFF1SH-Z.P.AI-S:execute
Decode: LDFF1SH-Z.P.AI-S:decode@LDFF1SH-Z.P.AI-S:diagram
Decode: LDFF1SH-Z.P.AI-D:decode@LDFF1SH-Z.P.AI-D:diagram
TAG:FRSQRTE-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);

Z[d] = result;
TAG:FRSQRTE-Z.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 001
18:17 _ 11
16:16 _ 1
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRSQRTE-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FRSQRTE-Z.Z-_:index
Execute: FRSQRTE-Z.Z-_:execute
Decode: FRSQRTE-Z.Z-_:decode@FRSQRTE-Z.Z-_:diagram
TAG:RDFFR-P.P.F-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(PL) ffr = FFR[];
bits(PL) result = ffr AND mask;

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, 8);
P[d] = result;
TAG:RDFFR-P.P.F-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:10 _ 011000111100
9:9 _ 0
8:5 Pg xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:RDFFR-P.P.F-_:decode
if !HaveSVE() then UNDEFINED;
integer g = UInt(Pg);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:RDFFRS-P.P.F-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:10 _ 011000111100
9:9 _ 0
8:5 Pg xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:RDFFRS-P.P.F-_:decode
if !HaveSVE() then UNDEFINED;
integer g = UInt(Pg);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:RDFFR-P.P.F-_:index
Execute: RDFFR-P.P.F-_:execute
Decode: RDFFR-P.P.F-_:decode@RDFFR-P.P.F-_:diagram
Decode: RDFFRS-P.P.F-_:decode@RDFFRS-P.P.F-_:diagram
TAG:FNMAD-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FNMAD-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Za xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FNMAD-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean op1_neg = TRUE;
boolean op3_neg = TRUE;

TAG:FNMAD-Z.P.ZZZ-_:index
Execute: FNMAD-Z.P.ZZZ-_:execute
Decode: FNMAD-Z.P.ZZZ-_:decode@FNMAD-Z.P.ZZZ-_:diagram
TAG:ST4D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST4D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer nreg = 4;

TAG:ST4D-Z.P.BR-Contiguous:index
Execute: ST4D-Z.P.BR-Contiguous:execute
Decode: ST4D-Z.P.BR-Contiguous:decode@ST4D-Z.P.BR-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul/high/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(idxdsize) operand2 = V[m];
bits(datasize) result;
integer round_const = if round then 1 << (esize - 1) else 0;
integer element1;
integer element2;
integer product;
boolean sat;

element2 = SInt(Elem[operand2, index, esize]);
for e = 0 to elements-1
    element1 = SInt(Elem[operand1, e, esize]);
    product = (2 * element1 * element2) + round_const;
    // The following only saturates if element1 and element2 equal -(2^(esize-1))
    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);
    if sat then FPSR.QC = '1';

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:13 _ 110
12:12 op x
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;

boolean round = (op == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:13 _ 110
12:12 op x
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd:decode
integer idxdsize = if H == '1' then 128 else 64; 
integer index;
bit Rmhi;
case size of
    when '01' index = UInt(H:L:M); Rmhi = '0';
    when '10' index = UInt(H:L);   Rmhi = M;
    otherwise UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rmhi:Rm);

integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

boolean round = (op == '1');

TAG:aarch64/vector/arithmetic/binary/element/mul/high/sisd:index
Execute: aarch64/vector/arithmetic/binary/element/mul/high/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/high/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd:decode@aarch64/instrs/vector/arithmetic/binary/element/mul/high/simd:diagram
TAG:LD1B-Z.P.BR-U8:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1B-Z.P.BR-U8:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BR-U8:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LD1B-Z.P.BR-U16:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BR-U16:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LD1B-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LD1B-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1B-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LD1B-Z.P.BR-U8:index
Execute: LD1B-Z.P.BR-U8:execute
Decode: LD1B-Z.P.BR-U8:decode@LD1B-Z.P.BR-U8:diagram
Decode: LD1B-Z.P.BR-U16:decode@LD1B-Z.P.BR-U16:diagram
Decode: LD1B-Z.P.BR-U32:decode@LD1B-Z.P.BR-U32:diagram
Decode: LD1B-Z.P.BR-U64:decode@LD1B-Z.P.BR-U64:diagram
TAG:AND-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV 64;
bits(VL) operand = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(64) element1 = Elem[operand, e, 64];
    Elem[result, e, 64] = element1 AND imm;

Z[dn] = result;
TAG:AND-Z.ZI-_:diagram
A64
31:24 _ 00000101
23:23 _ 1
22:22 _ 0
21:18 _ 0000
17:5 imm13 xxxxxxxxxxxxx
4:0 Zdn xxxxx
TAG:AND-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer dn = UInt(Zdn);
bits(64) imm;
(imm, -) = DecodeBitMasks(imm13[12], imm13[5:0], imm13[11:6], TRUE);

TAG:AND-Z.ZI-_:index
Execute: AND-Z.ZI-_:execute
Decode: AND-Z.ZI-_:decode@AND-Z.ZI-_:diagram
TAG:aarch64/memory/single/simdfp/immediate/signed/offset/normal:execute
if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

CheckFPAdvSIMDEnabled64();
bits(64) address;
bits(datasize) data;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        data = V[t];
        Mem[address, datasize DIV 8, acctype] = data;

    when MemOp_LOAD
        data = Mem[address, datasize DIV 8, acctype];
        V[t] = data;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/single/simdfp/immediate/signed/offset/normal:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
AccType acctype = AccType_VEC;
MemOp memop = if opc[0] == '1' then MemOp_LOAD else MemOp_STORE;
integer datasize = 8 << scale;
boolean tag_checked = memop != MemOp_PREFETCH && (wback || n != 31);

TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal:diagram
A64
31:30 size xx
29:27 _ 111
26:26 _ 1
25:24 _ 00
23:22 opc xx
21:21 _ 0
20:12 imm9 xxxxxxxxx
11:10 _ 00
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal:decode
boolean wback = FALSE;
boolean postindex = FALSE;
integer scale = UInt(opc[1]:size);
if scale > 4 then UNDEFINED;
bits(64) offset = SignExtend(imm9, 64);

TAG:aarch64/memory/single/simdfp/immediate/signed/offset/normal:index
Execute: aarch64/memory/single/simdfp/immediate/signed/offset/normal:execute
Postdecode: aarch64/memory/single/simdfp/immediate/signed/offset/normal:postdecode
Decode: aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal:decode@aarch64/instrs/memory/single/simdfp/immediate/signed/offset/normal:diagram
TAG:FMAX-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMax(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMAX-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 11
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FMAX-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

TAG:FMAX-Z.P.ZS-_:index
Execute: FMAX-Z.P.ZS-_:execute
Decode: FMAX-Z.P.ZS-_:decode@FMAX-Z.P.ZS-_:diagram
TAG:REVB-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        bits(esize) element = Elem[operand, e, esize];
        Elem[result, e, esize] = Reverse(element, swsize);

Z[d] = result;
TAG:REVB-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1001
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:REVB-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer swsize = 8;

TAG:REVH-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1001
17:17 _ 0
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:REVH-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '1x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer swsize = 16;

TAG:REVW-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:18 _ 1001
17:17 _ 1
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:REVW-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer swsize = 32;

TAG:REVB-Z.Z-_:index
Execute: REVB-Z.Z-_:execute
Decode: REVB-Z.Z-_:decode@REVB-Z.Z-_:diagram
Decode: REVH-Z.Z-_:decode@REVH-Z.Z-_:diagram
Decode: REVW-Z.Z-_:decode@REVW-Z.Z-_:diagram
TAG:aarch64/system/barriers/sb:execute
SpeculationBarrier();
TAG:aarch64/instrs/system/barriers/sb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/sb:decode
if !HaveSBExt() then UNDEFINED;

TAG:aarch64/system/barriers/sb:index
Execute: aarch64/system/barriers/sb:execute
Decode: aarch64/instrs/system/barriers/sb:decode@aarch64/instrs/system/barriers/sb:diagram
TAG:FMLS-Z.ZZZi-H:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result = Z[da];

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, s, esize];
    bits(esize) element3 = Elem[result, e, esize];
    if op1_neg then element1 = FPNeg(element1);
    if op3_neg then element3 = FPNeg(element3);
    Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:FMLS-Z.ZZZi-H:diagram
A64
31:24 _ 01100100
23:23 _ 0
22:22 i3h x
21:21 _ 1
20:19 i3l xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLS-Z.ZZZi-H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer index = UInt(i3h:i3l);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = TRUE;
boolean op3_neg = FALSE;

TAG:FMLS-Z.ZZZi-S:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLS-Z.ZZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = TRUE;
boolean op3_neg = FALSE;

TAG:FMLS-Z.ZZZi-D:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:11 _ 00000
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLS-Z.ZZZi-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = TRUE;
boolean op3_neg = FALSE;

TAG:FMLS-Z.ZZZi-H:index
Execute: FMLS-Z.ZZZi-H:execute
Decode: FMLS-Z.ZZZi-H:decode@FMLS-Z.ZZZi-H:diagram
Decode: FMLS-Z.ZZZi-S:decode@FMLS-Z.ZZZi-S:diagram
Decode: FMLS-Z.ZZZi-D:decode@FMLS-Z.ZZZi-D:diagram
TAG:PRFD-I.P.BI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

addr = base + ((offset * elements) << scale);
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Hint_Prefetch(addr, pref_hint, level, stream);
    addr = addr + (1 << scale);
TAG:PRFD-I.P.BI-S:diagram
A64
31:22 _ 1000010111
21:16 imm6 xxxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.BI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 3;
integer offset = SInt(imm6);

TAG:PRFD-I.P.BI-S:index
Execute: PRFD-I.P.BI-S:execute
Decode: PRFD-I.P.BI-S:decode@PRFD-I.P.BI-S:diagram
TAG:aarch64/vector/arithmetic/unary/float/xtn/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;

for e = 0 to elements-1
    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 10110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz == '0' then UNDEFINED;
integer esize = 32;
integer datasize = esize;
integer elements = 1;
integer part = 0;

TAG:aarch64/instrs/vector/arithmetic/unary/float/xtn/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 0
22:22 sz x
21:17 _ 10000
16:12 _ 10110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/float/xtn/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz == '0' then UNDEFINED;
integer esize = 32;
integer datasize = 64;
integer elements = 2;
integer part = UInt(Q);

TAG:aarch64/vector/arithmetic/unary/float/xtn/sisd:index
Execute: aarch64/vector/arithmetic/unary/float/xtn/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd:decode@aarch64/instrs/vector/arithmetic/unary/float/xtn/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/float/xtn/simd:decode@aarch64/instrs/vector/arithmetic/unary/float/xtn/simd:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    if sub_op then
        Elem[result, e, esize] = element1 - element2;
    else
        Elem[result, e, esize] = element1 + element2;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:diagram
A64
31:30 _ 01
29:29 U x
28:24 _ 11110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;
boolean sub_op = (U == '1');

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 10000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/wrapping/single/simd:diagram
TAG:aarch64/vector/arithmetic/unary/shift:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = Vpart[n, part];
bits(2*datasize) result;
integer element;

for e = 0 to elements-1
    element = Int(Elem[operand, e, esize], unsigned) << shift;
    Elem[result, e, 2*esize] = element[2*esize-1:0];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/shift:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 10011
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/shift:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

integer shift = esize;
boolean unsigned = FALSE; // Or TRUE without change of functionality

TAG:aarch64/vector/arithmetic/unary/shift:index
Execute: aarch64/vector/arithmetic/unary/shift:execute
Decode: aarch64/instrs/vector/arithmetic/unary/shift:decode@aarch64/instrs/vector/arithmetic/unary/shift:diagram
TAG:SXTB-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(element[s_esize-1:0], esize, unsigned);

Z[d] = result;
TAG:SXTB-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 00
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SXTB-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 8;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = FALSE;

TAG:SXTH-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 01
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SXTH-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '1x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = FALSE;

TAG:SXTW-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 10
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SXTW-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer s_esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean unsigned = FALSE;

TAG:SXTB-Z.P.Z-_:index
Execute: SXTB-Z.P.Z-_:execute
Decode: SXTB-Z.P.Z-_:decode@SXTB-Z.P.Z-_:diagram
Decode: SXTH-Z.P.Z-_:decode@SXTH-Z.P.Z-_:diagram
Decode: SXTW-Z.P.Z-_:decode@SXTW-Z.P.Z-_:diagram
TAG:LDNF1B-Z.P.BI-U8:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1B-Z.P.BI-U8:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1B-Z.P.BI-U8:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1B-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1B-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1B-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1B-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1B-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1B-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1B-Z.P.BI-U8:index
Execute: LDNF1B-Z.P.BI-U8:execute
Decode: LDNF1B-Z.P.BI-U8:decode@LDNF1B-Z.P.BI-U8:diagram
Decode: LDNF1B-Z.P.BI-U16:decode@LDNF1B-Z.P.BI-U16:diagram
Decode: LDNF1B-Z.P.BI-U32:decode@LDNF1B-Z.P.BI-U32:diagram
Decode: LDNF1B-Z.P.BI-U64:decode@LDNF1B-Z.P.BI-U64:diagram
TAG:aarch64/system/exceptions/runtime/hvc:execute
if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && (!IsSecureEL2Enabled() && IsSecure())) then
    UNDEFINED;

hvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);

if hvc_enable == '0' then
    UNDEFINED;
else
    AArch64.CallHypervisor(imm);
TAG:aarch64/instrs/system/exceptions/runtime/hvc:diagram
A64
31:24 _ 11010100
23:21 _ 000
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 _ 10
TAG:aarch64/instrs/system/exceptions/runtime/hvc:decode
bits(16) imm = imm16;

TAG:aarch64/system/exceptions/runtime/hvc:index
Execute: aarch64/system/exceptions/runtime/hvc:execute
Decode: aarch64/instrs/system/exceptions/runtime/hvc:decode@aarch64/instrs/system/exceptions/runtime/hvc:diagram
TAG:LDFF1W-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1W-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1W-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1W-Z.P.AI-S:index
Execute: LDFF1W-Z.P.AI-S:execute
Decode: LDFF1W-Z.P.AI-S:decode@LDFF1W-Z.P.AI-S:diagram
Decode: LDFF1W-Z.P.AI-D:decode@LDFF1W-Z.P.AI-D:diagram
TAG:LDNF1H-Z.P.BI-U16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1H-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1H-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1H-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1H-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1H-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1H-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1H-Z.P.BI-U16:index
Execute: LDNF1H-Z.P.BI-U16:execute
Decode: LDNF1H-Z.P.BI-U16:decode@LDNF1H-Z.P.BI-U16:diagram
Decode: LDNF1H-Z.P.BI-U32:decode@LDNF1H-Z.P.BI-U32:diagram
Decode: LDNF1H-Z.P.BI-U64:decode@LDNF1H-Z.P.BI-U64:diagram
TAG:CLASTB-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = operand1;
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    for e = 0 to elements-1
        Elem[result, e, esize] = Elem[operand2, last, esize];

Z[dn] = result;
TAG:CLASTB-Z.P.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10100
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:CLASTB-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean isBefore = TRUE;

TAG:CLASTB-Z.P.ZZ-_:index
Execute: CLASTB-Z.P.ZZ-_:execute
Decode: CLASTB-Z.P.ZZ-_:decode@CLASTB-Z.P.ZZ-_:diagram
TAG:FMINNM-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMinNum(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMINNM-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 10
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FMINNM-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then Zeros() else FPOne('0');

TAG:FMINNM-Z.P.ZS-_:index
Execute: FMINNM-Z.P.ZS-_:execute
Decode: FMINNM-Z.P.ZS-_:decode@FMINNM-Z.P.ZS-_:diagram
TAG:aarch64/branch/conditional/test:execute
bits(datasize) operand = X[t];

if operand[bit_pos] == bit_val then
    BranchTo(PC[] + offset, BranchType_DIR);
TAG:aarch64/instrs/branch/conditional/test:diagram
A64
31:31 b5 x
30:25 _ 011011
24:24 op x
23:19 b40 xxxxx
18:5 imm14 xxxxxxxxxxxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/branch/conditional/test:decode
integer t = UInt(Rt);

integer datasize = if b5 == '1' then 64 else 32;
integer bit_pos = UInt(b5:b40);
bit bit_val = op;
bits(64) offset = SignExtend(imm14:'00', 64);

TAG:aarch64/branch/conditional/test:index
Execute: aarch64/branch/conditional/test:execute
Decode: aarch64/instrs/branch/conditional/test:decode@aarch64/instrs/branch/conditional/test:diagram
TAG:BFMLALT-Z.ZZZi-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
integer eltspersegment = 128 DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = 2 * segmentbase + index;
    bits(32) element1 = Elem[operand1, 2 * e + 1, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, s, 16] : Zeros(16);
    bits(32) element3 = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:BFMLALT-Z.ZZZi-_:diagram
A64
31:23 _ 011001001
22:22 _ 1
21:21 _ 1
20:19 i3h xx
18:16 Zm xxx
15:14 _ 01
13:13 _ 0
12:12 _ 0
11:11 i3l x
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFMLALT-Z.ZZZi-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer index = UInt(i3h:i3l);

TAG:BFMLALT-Z.ZZZi-_:index
Execute: BFMLALT-Z.ZZZi-_:execute
Decode: BFMLALT-Z.ZZZi-_:decode@BFMLALT-Z.ZZZi-_:diagram
TAG:MAD-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    integer element2 = UInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        integer product = element1 * element2;
        if sub_op then
            Elem[result, e, esize] = Elem[operand3, e, esize] - product;
        else
            Elem[result, e, esize] = Elem[operand3, e, esize] + product;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:MAD-Z.P.ZZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:14 _ 11
13:13 _ 0
12:10 Pg xxx
9:5 Za xxxxx
4:0 Zdn xxxxx
TAG:MAD-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean sub_op = FALSE;

TAG:MAD-Z.P.ZZZ-_:index
Execute: MAD-Z.P.ZZZ-_:execute
Decode: MAD-Z.P.ZZZ-_:decode@MAD-Z.P.ZZZ-_:diagram
TAG:WRFFR-F.P-_:execute
CheckSVEEnabled();
bits(PL) operand = P[n];

hsb = HighestSetBit(operand);
if hsb < 0 || IsOnes(operand[hsb:0]) then  
    FFR[] = operand;
else // not a monotonic predicate
    FFR[] = bits(PL) UNKNOWN;
TAG:WRFFR-F.P-_:diagram
A64
31:30 _ 00
29:24 _ 100101
23:23 _ 0
22:22 _ 0
21:20 _ 10
19:10 _ 1000100100
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:3 _ 0
2:2 _ 0
1:0 _ 00
TAG:WRFFR-F.P-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Pn);

TAG:WRFFR-F.P-_:index
Execute: WRFFR-F.P-_:execute
Decode: WRFFR-F.P-_:decode@WRFFR-F.P-_:diagram
TAG:aarch64/integer/shift/variable:execute
bits(datasize) result;
bits(datasize) operand2 = X[m];

result = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);
X[d] = result;
TAG:aarch64/instrs/integer/shift/variable:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Rm xxxxx
15:12 _ 0010
11:10 op2 xx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/shift/variable:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
ShiftType shift_type = DecodeShift(op2);

TAG:aarch64/integer/shift/variable:index
Execute: aarch64/integer/shift/variable:execute
Decode: aarch64/instrs/integer/shift/variable:decode@aarch64/instrs/integer/shift/variable:diagram
TAG:ASR-Z.P.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) mask = P[g];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = ASR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ASR-Z.P.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:20 _ 00
19:19 _ 0
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:8 tszl xx
7:5 imm3 xxx
4:0 Zdn xxxxx
TAG:ASR-Z.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer shift = (2 * esize) - UInt(tsize:imm3);

TAG:ASR-Z.P.ZI-_:index
Execute: ASR-Z.P.ZI-_:execute
Decode: ASR-Z.P.ZI-_:decode@ASR-Z.P.ZI-_:diagram
TAG:UQDECH-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQDECH-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECH-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQDECH-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECH-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQDECH-R.RS-UW:index
Execute: UQDECH-R.RS-UW:execute
Decode: UQDECH-R.RS-UW:decode@UQDECH-R.RS-UW:diagram
Decode: UQDECH-R.RS-X:decode@UQDECH-R.RS-X:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/complex:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to (elements DIV 2) -1 
    case rot of 
        when '00'
            element1 = Elem[operand2, index*2, esize]; 
            element2 = Elem[operand1, e*2, esize];
            element3 = Elem[operand2, index*2+1, esize];
            element4 = Elem[operand1, e*2, esize];
        when '01'
            element1 = FPNeg(Elem[operand2, index*2+1, esize]); 
            element2 = Elem[operand1, e*2+1, esize];
            element3 = Elem[operand2, index*2, esize];
            element4 = Elem[operand1, e*2+1, esize];
        when '10'
            element1 = FPNeg(Elem[operand2, index*2,esize]); 
            element2 = Elem[operand1, e*2, esize];
            element3 = FPNeg(Elem[operand2, index*2+1, esize]);
            element4 = Elem[operand1, e*2, esize];
        when '11'
            element1 = Elem[operand2, index*2+1, esize]; 
            element2 = Elem[operand1, e*2+1, esize];
            element3 = FPNeg(Elem[operand2, index*2, esize]);
            element4 = Elem[operand1, e*2+1, esize];

    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);
    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01111
23:22 size xx
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:13 rot xx
12:12 _ 1
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex:decode
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(M:Rm);
if size == '00' || size == '11' then UNDEFINED;
if size == '01' then index = UInt(H:L);
if size == '10' then index = UInt(H);
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
if size == '10' && (L == '1' || Q == '0') then UNDEFINED; 
if size == '01' && H == '1' && Q=='0' then UNDEFINED;

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/complex:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/complex:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/complex:diagram
TAG:FMAXNM-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMAXNM-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 010
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMAXNM-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMAXNM-Z.P.ZZ-_:index
Execute: FMAXNM-Z.P.ZZ-_:execute
Decode: FMAXNM-Z.P.ZZ-_:decode@FMAXNM-Z.P.ZZ-_:diagram
TAG:SQDECH-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQDECH-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECH-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQDECH-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECH-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQDECH-R.RS-SX:index
Execute: SQDECH-R.RS-SX:execute
Decode: SQDECH-R.RS-SX:decode@SQDECH-R.RS-SX:diagram
Decode: SQDECH-R.RS-X:decode@SQDECH-R.RS-X:diagram
TAG:aarch64/float/move/fp/select:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;

result = if ConditionHolds(condition) then V[n] else V[m];

V[d] = result;
TAG:aarch64/instrs/float/move/fp/select:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:12 cond xxxx
11:10 _ 11
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/move/fp/select:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

bits(4) condition = cond;

TAG:aarch64/float/move/fp/select:index
Execute: aarch64/float/move/fp/select:execute
Decode: aarch64/instrs/float/move/fp/select:decode@aarch64/instrs/float/move/fp/select:diagram
TAG:aarch64/system/barriers/pssbb:execute
SpeculativeStoreBypassBarrierToPA();
TAG:aarch64/instrs/system/barriers/pssbb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/pssbb:decode
// No additional decoding required

TAG:aarch64/system/barriers/pssbb:index
Execute: aarch64/system/barriers/pssbb:execute
Decode: aarch64/instrs/system/barriers/pssbb:decode@aarch64/instrs/system/barriers/pssbb:diagram
TAG:UQDECD-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQDECD-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECD-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQDECD-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQDECD-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQDECD-R.RS-UW:index
Execute: UQDECD-R.RS-UW:execute
Decode: UQDECD-R.RS-UW:decode@UQDECD-R.RS-UW:diagram
Decode: UQDECD-R.RS-X:decode@UQDECD-R.RS-X:diagram
TAG:CNOT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = ZeroExtend(IsZeroBit(element), esize);

Z[d] = result;
TAG:CNOT-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:CNOT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:CNOT-Z.P.Z-_:index
Execute: CNOT-Z.P.Z-_:execute
Decode: CNOT-Z.P.Z-_:decode@CNOT-Z.P.Z-_:diagram
TAG:TRN1-P.PP-_:execute
CheckSVEEnabled();
integer pairs = VL DIV (esize * 2);
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for p = 0 to pairs-1
    Elem[result, 2*p+0, esize DIV 8] = Elem[operand1, 2*p+part, esize DIV 8];
    Elem[result, 2*p+1, esize DIV 8] = Elem[operand2, 2*p+part, esize DIV 8];

P[d] = result;
TAG:TRN1-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 1
11:11 _ 0
10:10 _ 0
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:TRN1-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 0;

TAG:TRN2-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 1
11:11 _ 0
10:10 _ 1
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:TRN2-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 1;

TAG:TRN1-P.PP-_:index
Execute: TRN1-P.PP-_:execute
Decode: TRN1-P.PP-_:decode@TRN1-P.PP-_:diagram
Decode: TRN2-P.PP-_:decode@TRN2-P.PP-_:diagram
TAG:BFCVT-Z.P.Z-S2BF:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(32) element = Elem[operand, e, 32];
    if ElemP[mask, e, 32] == '1' then
        Elem[result, 2*e, 16] = FPConvertBF(element, FPCR);
        Elem[result, 2*e+1, 16] = Zeros();

Z[d] = result;
TAG:BFCVT-Z.P.Z-S2BF:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:18 _ 0010
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:BFCVT-Z.P.Z-S2BF:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:BFCVT-Z.P.Z-S2BF:index
Execute: BFCVT-Z.P.Z-S2BF:execute
Decode: BFCVT-Z.P.Z-S2BF:decode@BFCVT-Z.P.Z-S2BF:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/bf16/long:execute
CheckFPAdvSIMDEnabled64();
bits(128) operand1 = V[n];
bits(128) operand2 = V[m];
bits(128) operand3 = V[d];
bits(128) result;

bits(32) element2 = Elem[operand2, index, 16] : Zeros(16);

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);
    bits(32) addend = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(addend, element1, element2, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/bf16/long:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 _ 11
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 1
14:14 _ 1
13:12 _ 11
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/bf16/long:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt('0':Rm);
integer d = UInt(Rd);
integer index = UInt(H:L:M);

integer elements = 128 DIV 32;
integer sel = UInt(Q);

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/bf16/long:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/bf16/long:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/bf16/long:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/bf16/long:diagram
TAG:LD4W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 4;

TAG:LD4W-Z.P.BR-Contiguous:index
Execute: LD4W-Z.P.BR-Contiguous:execute
Decode: LD4W-Z.P.BR-Contiguous:decode@LD4W-Z.P.BR-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:execute
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n,part];
bits(128) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2 = Elem[operand2, index, esize DIV 2];

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize DIV 2];
    if sub_op then element1 = FPNeg(element1);
    Elem[result, e, esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 0
14:14 S x
13:12 _ 00
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M); 

integer esize = 32;
integer datasize = if Q=='1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (S == '1');
integer part = 0;

TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/upper:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01111
23:23 _ 1
22:22 sz x
21:21 L x
20:20 M x
19:16 Rm xxxx
15:15 _ 1
14:14 S x
13:12 _ 00
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/upper:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt('0':Rm);    // Vm can only be in bottom 16 registers.
if sz == '1' then UNDEFINED;
integer index = UInt(H:L:M); 

integer esize = 32;
integer datasize = if Q=='1' then 128 else 64;
integer elements = datasize DIV esize;

boolean sub_op = (S == '1');
integer part = 1;

TAG:aarch64/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:index
Execute: aarch64/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/lower:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/upper:decode@aarch64/instrs/vector/arithmetic/binary/element/mul-acc/mul_norounding_i/upper:diagram
TAG:LD1SW-Z.P.BR-S64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1SW-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;

TAG:LD1SW-Z.P.BR-S64:index
Execute: LD1SW-Z.P.BR-S64:execute
Decode: LD1SW-Z.P.BR-S64:decode@LD1SW-Z.P.BR-S64:diagram
TAG:LDFF1W-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1W-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001010
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LDFF1W-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:LDFF1W-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1W-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 0
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1W-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:LDFF1W-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1W-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1W-Z.P.BZ-S.x32.scaled:index
Execute: LDFF1W-Z.P.BZ-S.x32.scaled:execute
Decode: LDFF1W-Z.P.BZ-S.x32.scaled:decode@LDFF1W-Z.P.BZ-S.x32.scaled:diagram
Decode: LDFF1W-Z.P.BZ-D.x32.scaled:decode@LDFF1W-Z.P.BZ-D.x32.scaled:diagram
Decode: LDFF1W-Z.P.BZ-D.x32.unscaled:decode@LDFF1W-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1W-Z.P.BZ-S.x32.unscaled:decode@LDFF1W-Z.P.BZ-S.x32.unscaled:diagram
Decode: LDFF1W-Z.P.BZ-D.64.scaled:decode@LDFF1W-Z.P.BZ-D.64.scaled:diagram
Decode: LDFF1W-Z.P.BZ-D.64.unscaled:decode@LDFF1W-Z.P.BZ-D.64.unscaled:diagram
TAG:CNTB-R.S-_:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);

X[d] = (count * imm)[63:0];
TAG:CNTB-R.S-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rd xxxxx
TAG:CNTB-R.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer d = UInt(Rd);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:CNTD-R.S-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rd xxxxx
TAG:CNTD-R.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer d = UInt(Rd);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:CNTH-R.S-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 10
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rd xxxxx
TAG:CNTH-R.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer d = UInt(Rd);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:CNTW-R.S-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rd xxxxx
TAG:CNTW-R.S-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer d = UInt(Rd);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:CNTB-R.S-_:index
Execute: CNTB-R.S-_:execute
Decode: CNTB-R.S-_:decode@CNTB-R.S-_:diagram
Decode: CNTD-R.S-_:decode@CNTD-R.S-_:diagram
Decode: CNTH-R.S-_:decode@CNTH-R.S-_:diagram
Decode: CNTW-R.S-_:decode@CNTW-R.S-_:diagram
TAG:aarch64/integer/tags/mcgettagarray:execute
if PSTATE.EL == EL0 then
    UNDEFINED;

bits(64) data = Zeros(64);
bits(64) address;

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

integer size = 4*(2^(UInt(GMID_EL1.BS)));
address = Align(address,size);
integer count = size >> LOG2_TAG_GRANULE;
integer index = UInt(address[LOG2_TAG_GRANULE+3:LOG2_TAG_GRANULE]);

for i = 0 to count-1
    bits(4) tag = AArch64.MemTag[address, AccType_NORMAL];
    data[(index*4)+3:index*4] = tag;
    address = address + TAG_GRANULE;
    index = index + 1;

X[t] = data;
TAG:aarch64/instrs/integer/tags/mcgettagarray:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 _ 0
19:19 _ 0
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcgettagarray:decode
integer t = UInt(Xt);
integer n = UInt(Xn);

TAG:aarch64/integer/tags/mcgettagarray:index
Execute: aarch64/integer/tags/mcgettagarray:execute
Decode: aarch64/instrs/integer/tags/mcgettagarray:decode@aarch64/instrs/integer/tags/mcgettagarray:diagram
TAG:ADD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 + element2;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ADD-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 000
18:17 _ 00
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:ADD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:ADD-Z.P.ZZ-_:index
Execute: ADD-Z.P.ZZ-_:execute
Decode: ADD-Z.P.ZZ-_:decode@ADD-Z.P.ZZ-_:diagram
TAG:WHILELE-P.P.RR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = Ones(PL);
bits(rsize) operand1 = X[n];
bits(rsize) operand2 = X[m];
bits(PL) result;
boolean last = TRUE;

for e = 0 to elements-1
    boolean cond;
    case op of
        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));

    last = last && cond;
    ElemP[result, e, esize] = if last then '1' else '0';
    operand1 = operand1 + 1;

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:WHILELE-P.P.RR-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 000
12:12 sf x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:WHILELE-P.P.RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = 32 << UInt(sf);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Pd);
boolean unsigned = FALSE;
SVECmp op = Cmp_LE;

TAG:WHILELE-P.P.RR-_:index
Execute: WHILELE-P.P.RR-_:execute
Decode: WHILELE-P.P.RR-_:decode@WHILELE-P.P.RR-_:diagram
TAG:aarch64/vector/arithmetic/unary/cmp/int/lessthan/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
integer element;
boolean test_passed;

for e = 0 to elements-1
    element = SInt(Elem[operand, e, esize]);
    case comparison of
        when CompareOp_GT test_passed = element > 0;
        when CompareOp_GE test_passed = element >= 0;
        when CompareOp_EQ test_passed = element == 0;
        when CompareOp_LE test_passed = element <= 0;
        when CompareOp_LT test_passed = element < 0;
    Elem[result, e, esize] = if test_passed then Ones() else Zeros();

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 01010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size != '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer elements = 1;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 01010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size:Q == '110' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

CompareOp comparison = CompareOp_LT;

TAG:aarch64/vector/arithmetic/unary/cmp/int/lessthan/sisd:index
Execute: aarch64/vector/arithmetic/unary/cmp/int/lessthan/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd:decode@aarch64/instrs/vector/arithmetic/unary/cmp/int/lessthan/simd:diagram
TAG:UQDECW-Z.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer count = DecodePredCount(pat, esize);
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - (count * imm), esize, unsigned);

Z[dn] = result;
TAG:UQDECW-Z.ZS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 10
19:16 imm4 xxxx
15:12 _ 1100
11:11 _ 1
10:10 _ 1
9:5 pattern xxxxx
4:0 Zdn xxxxx
TAG:UQDECW-Z.ZS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Zdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;

TAG:UQDECW-Z.ZS-_:index
Execute: UQDECW-Z.ZS-_:execute
Decode: UQDECW-Z.ZS-_:decode@UQDECW-Z.ZS-_:diagram
TAG:aarch64/vector/transfer/vector/extract:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) hi = V[m];
bits(datasize) lo = V[n];
bits(datasize*2) concat = hi : lo;

V[d] = concat[position+datasize-1:position];
TAG:aarch64/instrs/vector/transfer/vector/extract:diagram
A64
31:31 _ 0
30:30 Q x
29:24 _ 101110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:11 imm4 xxxx
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/vector/extract:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if Q == '0' && imm4[3] == '1' then UNDEFINED;

integer datasize = if Q == '1' then 128 else 64;
integer position = UInt(imm4) << 3;

TAG:aarch64/vector/transfer/vector/extract:index
Execute: aarch64/vector/transfer/vector/extract:execute
Decode: aarch64/instrs/vector/transfer/vector/extract:decode@aarch64/instrs/vector/transfer/vector/extract:diagram
TAG:ORR-Z.ZZ-_:execute
CheckSVEEnabled();
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];

Z[d] = operand1 OR operand2;
TAG:ORR-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ORR-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:ORR-Z.ZZ-_:index
Execute: ORR-Z.ZZ-_:execute
Decode: ORR-Z.ZZ-_:decode@ORR-Z.ZZ-_:diagram
TAG:BFCVTNT-Z.P.Z-S2BF:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(32) element = Elem[operand, e, 32];
    if ElemP[mask, e, 32] == '1' then
        Elem[result, 2*e+1, 16] = FPConvertBF(element, FPCR);

Z[d] = result;
TAG:BFCVTNT-Z.P.Z-S2BF:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:18 _ 0010
17:17 _ 1
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:BFCVTNT-Z.P.Z-S2BF:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:BFCVTNT-Z.P.Z-S2BF:index
Execute: BFCVTNT-Z.P.Z-S2BF:execute
Decode: BFCVTNT-Z.P.Z-S2BF:decode@BFCVTNT-Z.P.Z-S2BF:diagram
TAG:LD4D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:LD4D-Z.P.BI-Contiguous:index
Execute: LD4D-Z.P.BI-Contiguous:execute
Decode: LD4D-Z.P.BI-Contiguous:decode@LD4D-Z.P.BI-Contiguous:diagram
TAG:aarch64/system/barriers/ssbb:execute
SpeculativeStoreBypassBarrierToVA();
TAG:aarch64/instrs/system/barriers/ssbb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/ssbb:decode
// No additional decoding required

TAG:aarch64/system/barriers/ssbb:index
Execute: aarch64/system/barriers/ssbb:execute
Decode: aarch64/instrs/system/barriers/ssbb:decode@aarch64/instrs/system/barriers/ssbb:diagram
TAG:aarch64/float/arithmetic/div:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) result;
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];

result = FPDiv(operand1, operand2, FPCR);

V[d] = result;
TAG:aarch64/instrs/float/arithmetic/div:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:16 Rm xxxxx
15:12 _ 0001
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/arithmetic/div:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer datasize;
case ftype of
    when '00' datasize = 32;
    when '01' datasize = 64;
    when '10' UNDEFINED;
    when '11'
        if HaveFP16Ext() then
            datasize = 16;
        else
            UNDEFINED;

TAG:aarch64/float/arithmetic/div:index
Execute: aarch64/float/arithmetic/div:execute
Decode: aarch64/instrs/float/arithmetic/div:decode@aarch64/instrs/float/arithmetic/div:diagram
TAG:aarch64/system/exceptions/runtime/svc:execute
AArch64.CheckForSVCTrap(imm);
AArch64.CallSupervisor(imm);
TAG:aarch64/instrs/system/exceptions/runtime/svc:diagram
A64
31:24 _ 11010100
23:21 _ 000
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 _ 01
TAG:aarch64/instrs/system/exceptions/runtime/svc:decode
bits(16) imm = imm16;

TAG:aarch64/system/exceptions/runtime/svc:index
Execute: aarch64/system/exceptions/runtime/svc:execute
Decode: aarch64/instrs/system/exceptions/runtime/svc:decode@aarch64/instrs/system/exceptions/runtime/svc:diagram
TAG:LSR-Z.P.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) mask = P[g];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSR-Z.P.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:20 _ 00
19:19 _ 0
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:8 tszl xx
7:5 imm3 xxx
4:0 Zdn xxxxx
TAG:LSR-Z.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer shift = (2 * esize) - UInt(tsize:imm3);

TAG:LSR-Z.P.ZI-_:index
Execute: LSR-Z.P.ZI-_:execute
Decode: LSR-Z.P.ZI-_:decode@LSR-Z.P.ZI-_:diagram
TAG:SQSUB-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 - imm, esize, unsigned);

Z[dn] = result;
TAG:SQSUB-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 11
16:16 _ 0
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SQSUB-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;
boolean unsigned = FALSE;

TAG:SQSUB-Z.ZI-_:index
Execute: SQSUB-Z.ZI-_:execute
Decode: SQSUB-Z.ZI-_:decode@SQSUB-Z.ZI-_:diagram
TAG:aarch64/system/monitors:execute
ClearExclusiveLocal(ProcessorID());
TAG:aarch64/instrs/system/monitors:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:5 _ 010
4:0 _ 11111
TAG:aarch64/instrs/system/monitors:decode
// CRm field is ignored

TAG:aarch64/system/monitors:index
Execute: aarch64/system/monitors:execute
Decode: aarch64/instrs/system/monitors:decode@aarch64/instrs/system/monitors:diagram
TAG:UZP1-P.PP-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

bits(PL*2) zipped = operand2:operand1;
for e = 0 to elements-1
    Elem[result, e, esize DIV 8] = Elem[zipped, 2*e+part, esize DIV 8];

P[d] = result;
TAG:UZP1-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 0
11:11 _ 1
10:10 _ 0
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:UZP1-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 0;

TAG:UZP2-P.PP-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 10
19:16 Pm xxxx
15:13 _ 010
12:12 _ 0
11:11 _ 1
10:10 _ 1
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:UZP2-P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
integer part = 1;

TAG:UZP1-P.PP-_:index
Execute: UZP1-P.PP-_:execute
Decode: UZP1-P.PP-_:decode@UZP1-P.PP-_:diagram
Decode: UZP2-P.PP-_:decode@UZP2-P.PP-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mat-mul/int/usdot:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
    bits(32) res = Elem[operand3, e, 32];
    for b = 0 to 3
        integer element1 = UInt(Elem[operand1, 4 * e + b, 8]);
        integer element2 = SInt(Elem[operand2, 4 * e + b, 8]);
        res = res + element1 * element2;
    Elem[result, e, 32] = res;

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/usdot:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 _ 10
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 0011
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/usdot:decode
if !HaveInt8MatMulExt() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

TAG:aarch64/vector/arithmetic/binary/uniform/mat-mul/int/usdot:index
Execute: aarch64/vector/arithmetic/binary/uniform/mat-mul/int/usdot:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/usdot:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mat-mul/int/usdot:diagram
TAG:DECB-R.RS-_:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(64) operand1 = X[dn];

X[dn] = operand1 - (count * imm);
TAG:DECB-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:DECB-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECD-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:DECD-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECH-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:DECH-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECW-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:DECW-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:DECB-R.RS-_:index
Execute: DECB-R.RS-_:execute
Decode: DECB-R.RS-_:decode@DECB-R.RS-_:diagram
Decode: DECD-R.RS-_:decode@DECD-R.RS-_:diagram
Decode: DECH-R.RS-_:decode@DECH-R.RS-_:diagram
Decode: DECW-R.RS-_:decode@DECW-R.RS-_:diagram
TAG:ASR-Z.P.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = ASR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ASR-Z.P.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:ASR-Z.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:ASR-Z.P.ZW-_:index
Execute: ASR-Z.P.ZW-_:execute
Decode: ASR-Z.P.ZW-_:decode@ASR-Z.P.ZW-_:diagram
TAG:SQADD-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);

Z[d] = result;
TAG:SQADD-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 10
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:SQADD-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
boolean unsigned = FALSE;

TAG:SQADD-Z.ZZ-_:index
Execute: SQADD-Z.ZZ-_:execute
Decode: SQADD-Z.ZZ-_:decode@SQADD-Z.ZZ-_:diagram
TAG:BFMLALB-Z.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + 0, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, 2 * e + 0, 16] : Zeros(16);
    bits(32) element3 = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:BFMLALB-Z.ZZZ-_:diagram
A64
31:23 _ 011001001
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:14 _ 10
13:13 _ 0
12:11 _ 00
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFMLALB-Z.ZZZ-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:BFMLALB-Z.ZZZ-_:index
Execute: BFMLALB-Z.ZZZ-_:execute
Decode: BFMLALB-Z.ZZZ-_:decode@BFMLALB-Z.ZZZ-_:diagram
TAG:aarch64/vector/crypto/sm3/sm3ss1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) Va = V[a];
Vd[127:96] = ROL((ROL(Vn[127:96],12) + Vm[127:96] + Va[127:96]) , 7);
Vd[95:0] = Zeros();
V[d] = Vd;
TAG:aarch64/instrs/vector/crypto/sm3/sm3ss1:diagram
A64
31:23 _ 110011100
22:21 _ 10
20:16 Rm xxxxx
15:15 _ 0
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3ss1:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer a = UInt(Ra);

TAG:aarch64/vector/crypto/sm3/sm3ss1:index
Execute: aarch64/vector/crypto/sm3/sm3ss1:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3ss1:decode@aarch64/instrs/vector/crypto/sm3/sm3ss1:diagram
TAG:aarch64/system/barriers/isb:execute
InstructionSynchronizationBarrier();
TAG:aarch64/instrs/system/barriers/isb:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0011
11:8 CRm xxxx
7:7 _ 1
6:5 opc xx
4:0 _ 11111
TAG:aarch64/instrs/system/barriers/isb:decode
// No additional decoding required

TAG:aarch64/system/barriers/isb:index
Execute: aarch64/system/barriers/isb:execute
Decode: aarch64/instrs/system/barriers/isb:decode@aarch64/instrs/system/barriers/isb:diagram
TAG:SDOT-Z.ZZZi-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = SInt(Elem[operand2, 4 * s + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:SDOT-Z.ZZZi-S:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:SDOT-Z.ZZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:SDOT-Z.ZZZi-D:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:11 _ 00000
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:SDOT-Z.ZZZi-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:SDOT-Z.ZZZi-S:index
Execute: SDOT-Z.ZZZi-S:execute
Decode: SDOT-Z.ZZZi-S:decode@SDOT-Z.ZZZi-S:diagram
Decode: SDOT-Z.ZZZi-D:decode@SDOT-Z.ZZZi-D:diagram
TAG:FADDA-V.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = V[dn];
bits(VL) operand2 = Z[m];
bits(esize) result = operand1;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        bits(esize) element = Elem[operand2, e, esize];
        result = FPAdd(result, element, FPCR);

V[dn] = result;
TAG:FADDA-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Vdn xxxxx
TAG:FADDA-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Vdn);
integer m = UInt(Zm);

TAG:FADDA-V.P.Z-_:index
Execute: FADDA-V.P.Z-_:execute
Decode: FADDA-V.P.Z-_:decode@FADDA-V.P.Z-_:diagram
TAG:BFMLALB-Z.ZZZi-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
integer eltspersegment = 128 DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = 2 * segmentbase + index;
    bits(32) element1 = Elem[operand1, 2 * e + 0, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, s, 16] : Zeros(16);
    bits(32) element3 = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:BFMLALB-Z.ZZZi-_:diagram
A64
31:23 _ 011001001
22:22 _ 1
21:21 _ 1
20:19 i3h xx
18:16 Zm xxx
15:14 _ 01
13:13 _ 0
12:12 _ 0
11:11 i3l x
10:10 _ 0
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFMLALB-Z.ZZZi-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer index = UInt(i3h:i3l);

TAG:BFMLALB-Z.ZZZi-_:index
Execute: BFMLALB-Z.ZZZi-_:execute
Decode: BFMLALB-Z.ZZZi-_:decode@BFMLALB-Z.ZZZi-_:diagram
TAG:LDFF1B-Z.P.BR-U8:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1B-Z.P.BR-U8:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BR-U8:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LDFF1B-Z.P.BR-U16:diagram
A64
31:25 _ 1010010
24:22 _ 000
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BR-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LDFF1B-Z.P.BR-U32:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BR-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LDFF1B-Z.P.BR-U64:diagram
A64
31:25 _ 1010010
24:22 _ 001
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1B-Z.P.BR-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;

TAG:LDFF1B-Z.P.BR-U8:index
Execute: LDFF1B-Z.P.BR-U8:execute
Decode: LDFF1B-Z.P.BR-U8:decode@LDFF1B-Z.P.BR-U8:diagram
Decode: LDFF1B-Z.P.BR-U16:decode@LDFF1B-Z.P.BR-U16:diagram
Decode: LDFF1B-Z.P.BR-U32:decode@LDFF1B-Z.P.BR-U32:diagram
Decode: LDFF1B-Z.P.BR-U64:decode@LDFF1B-Z.P.BR-U64:diagram
TAG:aarch64/integer/flags/rmif:execute
bits(4) tmp;
bits(64) tmpreg = X[n];
tmp = (tmpreg:tmpreg)[lsb+3:lsb];
if mask[3] == '1' then PSTATE.N = tmp[3];
if mask[2] == '1' then PSTATE.Z = tmp[2];
if mask[1] == '1' then PSTATE.C = tmp[1];
if mask[0] == '1' then PSTATE.V = tmp[0];
TAG:aarch64/instrs/integer/flags/rmif:diagram
A64
31:31 sf x
30:30 _ 0
29:29 _ 1
28:21 _ 11010000
20:15 imm6 xxxxxx
14:10 _ 00001
9:5 Rn xxxxx
4:4 _ 0
3:0 mask xxxx
TAG:aarch64/instrs/integer/flags/rmif:decode
if !HaveFlagManipulateExt() || sf != '1' then UNDEFINED;
integer lsb = UInt(imm6);
integer n = UInt(Rn);

TAG:aarch64/integer/flags/rmif:index
Execute: aarch64/integer/flags/rmif:execute
Decode: aarch64/instrs/integer/flags/rmif:decode@aarch64/instrs/integer/flags/rmif:diagram
TAG:ORR-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV 64;
bits(VL) operand = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(64) element1 = Elem[operand, e, 64];
    Elem[result, e, 64] = element1 OR imm;

Z[dn] = result;
TAG:ORR-Z.ZI-_:diagram
A64
31:24 _ 00000101
23:23 _ 0
22:22 _ 0
21:18 _ 0000
17:5 imm13 xxxxxxxxxxxxx
4:0 Zdn xxxxx
TAG:ORR-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer dn = UInt(Zdn);
bits(64) imm;
(imm, -) = DecodeBitMasks(imm13[12], imm13[5:0], imm13[11:6], TRUE);

TAG:ORR-Z.ZI-_:index
Execute: ORR-Z.ZI-_:execute
Decode: ORR-Z.ZI-_:decode@ORR-Z.ZI-_:diagram
TAG:ST2H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST2H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 2;

TAG:ST2H-Z.P.BR-Contiguous:index
Execute: ST2H-Z.P.BR-Contiguous:execute
Decode: ST2H-Z.P.BR-Contiguous:decode@ST2H-Z.P.BR-Contiguous:diagram
TAG:FCADD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer pairs = VL DIV (2 * esize);
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for p = 0 to pairs-1
    acc_r  = Elem[operand1, 2 * p + 0, esize];
    acc_i  = Elem[operand1, 2 * p + 1, esize];
    elt2_r = Elem[operand2, 2 * p + 0, esize];
    elt2_i = Elem[operand2, 2 * p + 1, esize];
    if ElemP[mask, 2 * p + 0, esize] == '1' then
        if sub_i then elt2_i = FPNeg(elt2_i);
        acc_r = FPAdd(acc_r, elt2_i, FPCR);
    if ElemP[mask, 2 * p + 1, esize] == '1' then
        if sub_r then elt2_r = FPNeg(elt2_r);
        acc_i = FPAdd(acc_i, elt2_r, FPCR);
    Elem[result, 2 * p + 0, esize] = acc_r;
    Elem[result, 2 * p + 1, esize] = acc_i;

Z[dn] = result;
TAG:FCADD-Z.P.ZZ-_:diagram
A64
31:24 _ 01100100
23:22 size xx
21:17 _ 00000
16:16 rot x
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FCADD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean sub_i = (rot == '0');
boolean sub_r = (rot == '1');

TAG:FCADD-Z.P.ZZ-_:index
Execute: FCADD-Z.P.ZZ-_:execute
Decode: FCADD-Z.P.ZZ-_:decode@FCADD-Z.P.ZZ-_:diagram
TAG:ST1W-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(VL) offset = Z[m];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1W-Z.P.BZ-S.x32.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:ST1W-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 2;

TAG:ST1W-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1W-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 xs x
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 32;
integer offs_size = 32;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:ST1W-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 2;

TAG:ST1W-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Zm xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:ST1W-Z.P.BZ-S.x32.scaled:index
Execute: ST1W-Z.P.BZ-S.x32.scaled:execute
Decode: ST1W-Z.P.BZ-S.x32.scaled:decode@ST1W-Z.P.BZ-S.x32.scaled:diagram
Decode: ST1W-Z.P.BZ-D.x32.scaled:decode@ST1W-Z.P.BZ-D.x32.scaled:diagram
Decode: ST1W-Z.P.BZ-D.x32.unscaled:decode@ST1W-Z.P.BZ-D.x32.unscaled:diagram
Decode: ST1W-Z.P.BZ-S.x32.unscaled:decode@ST1W-Z.P.BZ-S.x32.unscaled:diagram
Decode: ST1W-Z.P.BZ-D.64.scaled:decode@ST1W-Z.P.BZ-D.64.scaled:diagram
Decode: ST1W-Z.P.BZ-D.64.unscaled:decode@ST1W-Z.P.BZ-D.64.unscaled:diagram
TAG:SADDV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer sum = 0;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = SInt(Elem[operand, e, esize]);
        sum = sum + element;

V[d] = sum[63:0];
TAG:SADDV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 000
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:SADDV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:SADDV-R.P.Z-_:index
Execute: SADDV-R.P.Z-_:execute
Decode: SADDV-R.P.Z-_:decode@SADDV-R.P.Z-_:diagram
TAG:LD1SH-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SH-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LD1SH-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LD1SH-Z.P.AI-S:index
Execute: LD1SH-Z.P.AI-S:execute
Decode: LD1SH-Z.P.AI-S:decode@LD1SH-Z.P.AI-S:diagram
Decode: LD1SH-Z.P.AI-D:decode@LD1SH-Z.P.AI-D:diagram
TAG:AND-P.P.PP-Z:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;

for e = 0 to elements-1
    bit element1 = ElemP[operand1, e, esize];
    bit element2 = ElemP[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = element1 AND element2;
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:AND-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 S 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:AND-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:ANDS-P.P.PP-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 S 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 01
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:ANDS-P.P.PP-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:AND-P.P.PP-Z:index
Execute: AND-P.P.PP-Z:execute
Decode: AND-P.P.PP-Z:decode@AND-P.P.PP-Z:diagram
Decode: ANDS-P.P.PP-Z:decode@ANDS-P.P.PP-Z:diagram
TAG:LD1D-Z.P.BI-U64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1D-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1D-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1D-Z.P.BI-U64:index
Execute: LD1D-Z.P.BI-U64:execute
Decode: LD1D-Z.P.BI-U64:decode@LD1D-Z.P.BI-U64:diagram
TAG:aarch64/integer/conditional/compare/register:execute
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bit carry_in = '0';

if ConditionHolds(condition) then
    if sub_op then
        operand2 = NOT(operand2);
        carry_in = '1';
    (-, flags) = AddWithCarry(operand1, operand2, carry_in);
PSTATE.[N,Z,C,V] = flags;
TAG:aarch64/instrs/integer/conditional/compare/register:diagram
A64
31:31 sf x
30:30 op x
29:29 _ 1
28:21 _ 11010010
20:16 Rm xxxxx
15:12 cond xxxx
11:11 _ 0
10:10 _ 0
9:5 Rn xxxxx
4:4 _ 0
3:0 nzcv xxxx
TAG:aarch64/instrs/integer/conditional/compare/register:decode
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
boolean sub_op = (op == '1');
bits(4) condition = cond;
bits(4) flags = nzcv;

TAG:aarch64/integer/conditional/compare/register:index
Execute: aarch64/integer/conditional/compare/register:execute
Decode: aarch64/instrs/integer/conditional/compare/register:decode@aarch64/instrs/integer/conditional/compare/register:diagram
TAG:aarch64/branch/unconditional/immediate:execute
if branch_type == BranchType_DIRCALL then X[30] = PC[] + 4;

BranchTo(PC[] + offset, branch_type);
TAG:aarch64/instrs/branch/unconditional/immediate:diagram
A64
31:31 op x
30:26 _ 00101
25:0 imm26 xxxxxxxxxxxxxxxxxxxxxxxxxx
TAG:aarch64/instrs/branch/unconditional/immediate:decode
BranchType branch_type = if op == '1' then BranchType_DIRCALL else BranchType_DIR;
bits(64) offset = SignExtend(imm26:'00', 64);

TAG:aarch64/branch/unconditional/immediate:index
Execute: aarch64/branch/unconditional/immediate:execute
Decode: aarch64/instrs/branch/unconditional/immediate:decode@aarch64/instrs/branch/unconditional/immediate:diagram
TAG:LD3H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 3;

TAG:LD3H-Z.P.BR-Contiguous:index
Execute: LD3H-Z.P.BR-Contiguous:execute
Decode: LD3H-Z.P.BR-Contiguous:decode@LD3H-Z.P.BR-Contiguous:diagram
TAG:INDEX-Z.RR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(esize) operand1 = X[n];
integer element1 = SInt(operand1);
bits(esize) operand2 = X[m];
integer element2 = SInt(operand2);
bits(VL) result;

for e = 0 to elements-1
    integer index = element1 + e * element2;
    Elem[result, e, esize] = index[esize-1:0];

Z[d] = result;
TAG:INDEX-Z.RR-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:10 _ 010011
9:5 Rn xxxxx
4:0 Zd xxxxx
TAG:INDEX-Z.RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Zd);

TAG:INDEX-Z.RR-_:index
Execute: INDEX-Z.RR-_:execute
Decode: INDEX-Z.RR-_:decode@INDEX-Z.RR-_:diagram
TAG:aarch64/vector/fp16_movi:execute
CheckFPAdvSIMDEnabled64();

V[rd] = imm;
TAG:aarch64/instrs/vector/fp16_movi:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:19 _ 0111100000
18:18 a x
17:17 b x
16:16 c x
15:12 _ 1111
11:11 _ 1
10:10 _ 1
9:9 d x
8:8 e x
7:7 f x
6:6 g x
5:5 h x
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/fp16_movi:decode
if !HaveFP16Ext() then UNDEFINED;

integer rd = UInt(Rd);

integer datasize = if Q == '1' then 128 else 64;
bits(datasize) imm;

imm8 = a:b:c:d:e:f:g:h;
imm16 = imm8[7]:NOT(imm8[6]):Replicate(imm8[6],2):imm8[5:0]:Zeros(6);

imm = Replicate(imm16, datasize DIV 16);

TAG:aarch64/vector/fp16_movi:index
Execute: aarch64/vector/fp16_movi:execute
Decode: aarch64/instrs/vector/fp16_movi:decode@aarch64/instrs/vector/fp16_movi:diagram
Decode: aarch64/instrs/vector/logical:decode@aarch64/instrs/vector/logical:diagram
TAG:UMIN-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    Elem[result, e, esize] = Min(element1, imm)[esize-1:0];

Z[dn] = result;
TAG:UMIN-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 101
18:17 _ 01
16:16 _ 1
15:14 _ 11
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:UMIN-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
boolean unsigned = TRUE;
integer imm = Int(imm8, unsigned);

TAG:UMIN-Z.ZI-_:index
Execute: UMIN-Z.ZI-_:execute
Decode: UMIN-Z.ZI-_:decode@UMIN-Z.ZI-_:diagram
TAG:aarch64/vector/cvt_bf16/vector:execute
CheckFPAdvSIMDEnabled64();
bits(128) operand = V[n];
bits(64) result;

for e = 0 to elements-1
    Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR);

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/cvt_bf16/vector:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 _ 10
21:17 _ 10000
16:12 _ 10110
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/cvt_bf16/vector:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer d = UInt(Rd);
integer part = UInt(Q);
integer elements = 64 DIV 16;

TAG:aarch64/vector/cvt_bf16/vector:index
Execute: aarch64/vector/cvt_bf16/vector:execute
Decode: aarch64/instrs/vector/cvt_bf16/vector:decode@aarch64/instrs/vector/cvt_bf16/vector:diagram
TAG:LSL-Z.P.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSL(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSL-Z.P.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSL-Z.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSL-Z.P.ZW-_:index
Execute: LSL-Z.P.ZW-_:execute
Decode: LSL-Z.P.ZW-_:decode@LSL-Z.P.ZW-_:diagram
TAG:ST1D-Z.P.AI-D:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1D-Z.P.AI-D:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1D-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offset = UInt(imm5);

TAG:ST1D-Z.P.AI-D:index
Execute: ST1D-Z.P.AI-D:execute
Decode: ST1D-Z.P.AI-D:decode@ST1D-Z.P.AI-D:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/sub/fp16/simd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;
bits(esize) diff;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    diff = FPSub(element1, element2, FPCR);
    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;

V[d] = result;
TAG:aarch64/vector/arithmetic/binary/uniform/sub/fp16/simd:index
Execute: aarch64/vector/arithmetic/binary/uniform/sub/fp16/simd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/fp/simd:diagram
TAG:LDFF1H-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1H-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1H-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1H-Z.P.AI-S:index
Execute: LDFF1H-Z.P.AI-S:execute
Decode: LDFF1H-Z.P.AI-S:decode@LDFF1H-Z.P.AI-S:diagram
Decode: LDFF1H-Z.P.AI-D:decode@LDFF1H-Z.P.AI-D:diagram
TAG:MUL-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = SInt(Elem[operand1, e, esize]);
    Elem[result, e, esize] = (element1 * imm)[esize-1:0];

Z[dn] = result;
TAG:MUL-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 110
18:17 _ 00
16:16 _ 0
15:14 _ 11
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:MUL-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = SInt(imm8);

TAG:MUL-Z.ZI-_:index
Execute: MUL-Z.ZI-_:execute
Decode: MUL-Z.ZI-_:decode@MUL-Z.ZI-_:diagram
TAG:CLASTA-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(esize) operand1 = X[dn];
bits(VL) operand2 = Z[m];
bits(csize) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = ZeroExtend(operand1);
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    result = ZeroExtend(Elem[operand2, last, esize]);

X[dn] = result;
TAG:CLASTA-R.P.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 11000
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Rdn xxxxx
TAG:CLASTA-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Rdn);
integer m = UInt(Zm);
integer csize = if esize < 64 then 32 else 64;
boolean isBefore = FALSE;

TAG:CLASTA-R.P.Z-_:index
Execute: CLASTA-R.P.Z-_:execute
Decode: CLASTA-R.P.Z-_:decode@CLASTA-R.P.Z-_:diagram
TAG:LDNF1D-Z.P.BI-U64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1D-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1D-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LDNF1D-Z.P.BI-U64:index
Execute: LDNF1D-Z.P.BI-U64:execute
Decode: LDNF1D-Z.P.BI-U64:decode@LDNF1D-Z.P.BI-U64:diagram
TAG:FTMAD-Z.ZZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPTrigMAdd(imm, element1, element2, FPCR);

Z[dn] = result;
TAG:FTMAD-Z.ZZI-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 010
18:16 imm3 xxx
15:10 _ 100000
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FTMAD-Z.ZZI-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer imm = UInt(imm3);

TAG:FTMAD-Z.ZZI-_:index
Execute: FTMAD-Z.ZZI-_:execute
Decode: FTMAD-Z.ZZI-_:decode@FTMAD-Z.ZZI-_:diagram
TAG:LDFF1D-Z.P.BZ-D.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1D-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 3;

TAG:LDFF1D-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1D-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 3;

TAG:LDFF1D-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1D-Z.P.BZ-D.x32.scaled:index
Execute: LDFF1D-Z.P.BZ-D.x32.scaled:execute
Decode: LDFF1D-Z.P.BZ-D.x32.scaled:decode@LDFF1D-Z.P.BZ-D.x32.scaled:diagram
Decode: LDFF1D-Z.P.BZ-D.x32.unscaled:decode@LDFF1D-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1D-Z.P.BZ-D.64.scaled:decode@LDFF1D-Z.P.BZ-D.64.scaled:diagram
Decode: LDFF1D-Z.P.BZ-D.64.unscaled:decode@LDFF1D-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/vector/arithmetic/unary/special/recip/int:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;

for e = 0 to elements-1
    element = Elem[operand, e, 32];
    Elem[result, e, 32] = UnsignedRecipEstimate(element);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/int:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/recip/int:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/special/recip/int:index
Execute: aarch64/vector/arithmetic/unary/special/recip/int:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/recip/int:decode@aarch64/instrs/vector/arithmetic/unary/special/recip/int:diagram
TAG:ST1H-Z.P.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    addr = addr + mbytes;
TAG:ST1H-Z.P.BI-_:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 size xx
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.BI-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 16;
integer offset = SInt(imm4);

TAG:ST1H-Z.P.BI-_:index
Execute: ST1H-Z.P.BI-_:execute
Decode: ST1H-Z.P.BI-_:decode@ST1H-Z.P.BI-_:diagram
TAG:aarch64/vector/crypto/sm3/sm3partw2:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Vd = V[d];
bits(128) result; 
bits(128) tmp;
bits(32) tmp2;
tmp[127:0] = Vn EOR (ROL(Vm[127:96],7):ROL(Vm[95:64],7):ROL(Vm[63:32],7):ROL(Vm[31:0],7)); 
result[127:0] = Vd[127:0] EOR tmp[127:0];
tmp2 = ROL(tmp[31:0],15);
tmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);
result[127:96] = result[127:96] EOR tmp2;
V[d]= result;
TAG:aarch64/instrs/vector/crypto/sm3/sm3partw2:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 1
13:12 _ 00
11:10 _ 01
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sm3/sm3partw2:decode
if !HaveSM3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sm3/sm3partw2:index
Execute: aarch64/vector/crypto/sm3/sm3partw2:execute
Decode: aarch64/instrs/vector/crypto/sm3/sm3partw2:decode@aarch64/instrs/vector/crypto/sm3/sm3partw2:diagram
TAG:PRFH-I.P.BI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

addr = base + ((offset * elements) << scale);
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Hint_Prefetch(addr, pref_hint, level, stream);
    addr = addr + (1 << scale);
TAG:PRFH-I.P.BI-S:diagram
A64
31:22 _ 1000010111
21:16 imm6 xxxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.BI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 1;
integer offset = SInt(imm6);

TAG:PRFH-I.P.BI-S:index
Execute: PRFH-I.P.BI-S:execute
Decode: PRFH-I.P.BI-S:decode@PRFH-I.P.BI-S:diagram
TAG:aarch64/memory/literal/simdfp:execute
bits(64) address = PC[] + offset;
bits(size*8) data;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

CheckFPAdvSIMDEnabled64();

data = Mem[address, size, AccType_VEC];
V[t] = data;
TAG:aarch64/instrs/memory/literal/simdfp:diagram
A64
31:30 opc xx
29:27 _ 011
26:26 _ 1
25:24 _ 00
23:5 imm19 xxxxxxxxxxxxxxxxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/literal/simdfp:decode
integer t = UInt(Rt);
integer size;
bits(64) offset;

case opc of
    when '00'
        size = 4;
    when '01'
        size = 8;
    when '10'
        size = 16;
    when '11'
        UNDEFINED;

offset = SignExtend(imm19:'00', 64);
boolean tag_checked = FALSE;

TAG:aarch64/memory/literal/simdfp:index
Execute: aarch64/memory/literal/simdfp:execute
Decode: aarch64/instrs/memory/literal/simdfp:decode@aarch64/instrs/memory/literal/simdfp:diagram
TAG:SMULH-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer product = (element1 * element2) >> esize;
        Elem[result, e, esize] = product[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SMULH-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0100
17:17 _ 1
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SMULH-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SMULH-Z.P.ZZ-_:index
Execute: SMULH-Z.P.ZZ-_:execute
Decode: SMULH-Z.P.ZZ-_:decode@SMULH-Z.P.ZZ-_:diagram
TAG:LDNF1SH-Z.P.BI-S32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1SH-Z.P.BI-S32:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SH-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SH-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SH-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SH-Z.P.BI-S32:index
Execute: LDNF1SH-Z.P.BI-S32:execute
Decode: LDNF1SH-Z.P.BI-S32:decode@LDNF1SH-Z.P.BI-S32:diagram
Decode: LDNF1SH-Z.P.BI-S64:decode@LDNF1SH-Z.P.BI-S64:diagram
TAG:SDIVR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer quotient;
        if element1 == 0 then
            quotient = 0;
        else
            quotient = RoundTowardsZero(Real(element2) / Real(element1));
        Elem[result, e, esize] = quotient[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SDIVR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0101
17:17 _ 1
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SDIVR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SDIVR-Z.P.ZZ-_:index
Execute: SDIVR-Z.P.ZZ-_:execute
Decode: SDIVR-Z.P.ZZ-_:decode@SDIVR-Z.P.ZZ-_:diagram
TAG:ABS-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    integer element = SInt(Elem[operand, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        element = Abs(element);
        Elem[result, e, esize] = element[esize-1:0];

Z[d] = result;
TAG:ABS-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:17 _ 11
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ABS-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:ABS-Z.P.Z-_:index
Execute: ABS-Z.P.Z-_:execute
Decode: ABS-Z.P.Z-_:decode@ABS-Z.P.Z-_:diagram
TAG:CLASTA-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;
integer last = LastActiveElement(mask, esize);

if last < 0 then
    result = operand1;
else
    if !isBefore then
        last = last + 1;
        if last >= elements then last = 0;
    for e = 0 to elements-1
        Elem[result, e, esize] = Elem[operand2, last, esize];

Z[dn] = result;
TAG:CLASTA-Z.P.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:17 _ 10100
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:CLASTA-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean isBefore = FALSE;

TAG:CLASTA-Z.P.ZZ-_:index
Execute: CLASTA-Z.P.ZZ-_:execute
Decode: CLASTA-Z.P.ZZ-_:decode@CLASTA-Z.P.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/narrow:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand1 = V[n];
bits(2*datasize) operand2 = V[m];
bits(datasize)   result;
integer round_const = if round then 1 << (esize - 1) else 0;
bits(2*esize) element1;
bits(2*esize) element2;
bits(2*esize) sum;

for e = 0 to elements-1
    element1 = Elem[operand1, e, 2*esize];
    element2 = Elem[operand2, e, 2*esize];
    if sub_op then
        sum = element1 - element2;
    else
        sum = element1 + element2;
    sum = sum + round_const;
    Elem[result, e, esize] = sum[2*esize-1:esize];

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:14 _ 01
13:13 o1 x
12:12 _ 0
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

boolean sub_op = (o1 == '1');
boolean round = (U == '1');

TAG:aarch64/vector/arithmetic/binary/disparate/add-sub/narrow:index
Execute: aarch64/vector/arithmetic/binary/disparate/add-sub/narrow:execute
Decode: aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow:decode@aarch64/instrs/vector/arithmetic/binary/disparate/add-sub/narrow:diagram
TAG:LD1RQW-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(64) offset;
bits(128) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQW-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQW-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;

TAG:LD1RQW-Z.P.BR-Contiguous:index
Execute: LD1RQW-Z.P.BR-Contiguous:execute
Decode: LD1RQW-Z.P.BR-Contiguous:decode@LD1RQW-Z.P.BR-Contiguous:diagram
TAG:STNT1H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
constant integer mbytes = esize DIV 8;
bits(VL) src;
bits(PL) mask = P[g];

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];
src = Z[t];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    addr = addr + mbytes;
TAG:STNT1H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:20 _ 001
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);

TAG:STNT1H-Z.P.BI-Contiguous:index
Execute: STNT1H-Z.P.BI-Contiguous:execute
Decode: STNT1H-Z.P.BI-Contiguous:decode@STNT1H-Z.P.BI-Contiguous:diagram
TAG:LD2W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD2W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD2W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 2;

TAG:LD2W-Z.P.BR-Contiguous:index
Execute: LD2W-Z.P.BR-Contiguous:execute
Decode: LD2W-Z.P.BR-Contiguous:decode@LD2W-Z.P.BR-Contiguous:diagram
TAG:LD1RB-Z.P.BI-U8:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RB-Z.P.BI-U8:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RB-Z.P.BI-U8:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RB-Z.P.BI-U16:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RB-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RB-Z.P.BI-U32:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RB-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RB-Z.P.BI-U64:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RB-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RB-Z.P.BI-U8:index
Execute: LD1RB-Z.P.BI-U8:execute
Decode: LD1RB-Z.P.BI-U8:decode@LD1RB-Z.P.BI-U8:diagram
Decode: LD1RB-Z.P.BI-U16:decode@LD1RB-Z.P.BI-U16:diagram
Decode: LD1RB-Z.P.BI-U32:decode@LD1RB-Z.P.BI-U32:diagram
Decode: LD1RB-Z.P.BI-U64:decode@LD1RB-Z.P.BI-U64:diagram
TAG:aarch64/memory/atomicops/cas/pair:execute
bits(64) address;
bits(2*datasize) comparevalue;
bits(2*datasize) newvalue;
bits(2*datasize) data;

bits(datasize) s1 = X[s];
bits(datasize) s2 = X[s+1];
bits(datasize) t1 = X[t];
bits(datasize) t2 = X[t+1];
comparevalue = if BigEndian() then s1:s2 else s2:s1;
newvalue     = if BigEndian() then t1:t2 else t2:t1;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

data = MemAtomicCompareAndSwap(address, comparevalue, newvalue, ldacctype, stacctype);

if BigEndian() then
    X[s]   = ZeroExtend(data[2*datasize-1:datasize], regsize);
    X[s+1] = ZeroExtend(data[datasize-1:0], regsize);
else
    X[s]   = ZeroExtend(data[datasize-1:0], regsize);
    X[s+1] = ZeroExtend(data[2*datasize-1:datasize], regsize);
TAG:aarch64/instrs/memory/atomicops/cas/pair:diagram
A64
31:31 _ 0
30:30 sz x
29:24 _ 001000
23:23 _ 0
22:22 L x
21:21 _ 1
20:16 Rs xxxxx
15:15 o0 x
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/atomicops/cas/pair:decode
if !HaveAtomicExt() then UNDEFINED;
if Rs[0] == '1' then UNDEFINED;
if Rt[0] == '1' then UNDEFINED;

integer n = UInt(Rn);
integer t = UInt(Rt);
integer s = UInt(Rs);

integer datasize = 32 << UInt(sz);
integer regsize = datasize;
AccType ldacctype = if L == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
AccType stacctype = if o0 == '1' then AccType_ORDEREDATOMICRW else AccType_ATOMICRW;
boolean tag_checked = n != 31;

TAG:aarch64/memory/atomicops/cas/pair:index
Execute: aarch64/memory/atomicops/cas/pair:execute
Decode: aarch64/instrs/memory/atomicops/cas/pair:decode@aarch64/instrs/memory/atomicops/cas/pair:diagram
TAG:UQINCB-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQINCB-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCB-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQINCB-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCB-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQINCB-R.RS-UW:index
Execute: UQINCB-R.RS-UW:execute
Decode: UQINCB-R.RS-UW:decode@UQINCB-R.RS-UW:diagram
Decode: UQINCB-R.RS-X:decode@UQINCB-R.RS-X:diagram
TAG:aarch64/vector/arithmetic/unary/special/frecpx-fp16:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRecpX(element, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:17 _ 111100
16:12 _ 11111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16:decode
if !HaveFP16Ext() then UNDEFINED;           

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/special/frecpx:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/frecpx:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/vector/arithmetic/unary/special/frecpx-fp16:index
Execute: aarch64/vector/arithmetic/unary/special/frecpx-fp16:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16:decode@aarch64/instrs/vector/arithmetic/unary/special/frecpx-fp16:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/frecpx:decode@aarch64/instrs/vector/arithmetic/unary/special/frecpx:diagram
TAG:INSR-Z.V-_:execute
CheckSVEEnabled();
bits(VL) dest = Z[dn];
bits(esize) src = V[m];
Z[dn] = dest[VL-esize-1:0] : src;
TAG:INSR-Z.V-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:10 _ 110100001110
9:5 Vm xxxxx
4:0 Zdn xxxxx
TAG:INSR-Z.V-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer m = UInt(Vm);

TAG:INSR-Z.V-_:index
Execute: INSR-Z.V-_:execute
Decode: INSR-Z.V-_:decode@INSR-Z.V-_:diagram
TAG:LD1ROH-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(64) offset;
bits(256) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROH-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROH-Z.P.BR-Contiguous:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;

TAG:LD1ROH-Z.P.BR-Contiguous:index
Execute: LD1ROH-Z.P.BR-Contiguous:execute
Decode: LD1ROH-Z.P.BR-Contiguous:decode@LD1ROH-Z.P.BR-Contiguous:diagram
TAG:aarch64/integer/tags/mcsettagpairandzerodatapost:execute
bits(64) address;
bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);

SetTagCheckedInstruction(FALSE);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if !postindex then
    address = address + offset;

if zero_data then
    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);
    Mem[address+TAG_GRANULE, TAG_GRANULE, AccType_NORMAL] = Zeros(8*TAG_GRANULE);

AArch64.MemTag[address, AccType_NORMAL] = tag;
AArch64.MemTag[address+TAG_GRANULE, AccType_NORMAL] = tag;

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodatapost:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 0
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodatapost:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;
boolean zero_data = TRUE;

TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodatapre:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodatapre:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;
boolean zero_data = TRUE;

TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodata:diagram
A64
31:24 _ 11011001
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpairandzerodata:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;
boolean zero_data = TRUE;

TAG:aarch64/integer/tags/mcsettagpairandzerodatapost:index
Execute: aarch64/integer/tags/mcsettagpairandzerodatapost:execute
Decode: aarch64/instrs/integer/tags/mcsettagpairandzerodatapost:decode@aarch64/instrs/integer/tags/mcsettagpairandzerodatapost:diagram
Decode: aarch64/instrs/integer/tags/mcsettagpairandzerodatapre:decode@aarch64/instrs/integer/tags/mcsettagpairandzerodatapre:diagram
Decode: aarch64/instrs/integer/tags/mcsettagpairandzerodata:decode@aarch64/instrs/integer/tags/mcsettagpairandzerodata:diagram
TAG:BRKB-P.P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand  = P[n];
bits(PL) operand2 = P[d];
boolean break = FALSE;
bits(PL) result;

for e = 0 to elements-1
    boolean element = ElemP[operand, e, esize] == '1';
    if ElemP[mask, e, esize] == '1' then
        break = break || element;
        ElemP[result, e, esize] = if !break then '1' else '0';
    elsif merging then
        ElemP[result, e, esize] = ElemP[operand2, e, esize];
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:BRKB-P.P.P-_:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 0
21:14 _ 01000001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 M x
3:0 Pd xxxx
TAG:BRKB-P.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean merging = (M == '1');
boolean setflags = FALSE;

TAG:BRKBS-P.P.P-Z:diagram
A64
31:24 _ 00100101
23:23 _ 1
22:22 _ 1
21:14 _ 01000001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:BRKBS-P.P.P-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean merging = FALSE;
boolean setflags = TRUE;

TAG:BRKB-P.P.P-_:index
Execute: BRKB-P.P.P-_:execute
Decode: BRKB-P.P.P-_:decode@BRKB-P.P.P-_:diagram
Decode: BRKBS-P.P.P-Z:decode@BRKBS-P.P.P-Z:diagram
TAG:FMAD-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMAD-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Za xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMAD-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean op1_neg = FALSE;
boolean op3_neg = FALSE;

TAG:FMAD-Z.P.ZZZ-_:index
Execute: FMAD-Z.P.ZZZ-_:execute
Decode: FMAD-Z.P.ZZZ-_:decode@FMAD-Z.P.ZZZ-_:diagram
TAG:LDFF1SW-Z.P.BR-S64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + UInt(offset) * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_CNOTFIRST];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    offset = offset + 1;

Z[t] = result;
TAG:LDFF1SW-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;

TAG:LDFF1SW-Z.P.BR-S64:index
Execute: LDFF1SW-Z.P.BR-S64:execute
Decode: LDFF1SW-Z.P.BR-S64:decode@LDFF1SW-Z.P.BR-S64:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:execute
CheckFPAdvSIMDEnabled64();
bits(datasize DIV 2) operand1 = Vpart[n,part];
bits(datasize DIV 2) operand2 = Vpart[m,part];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize DIV 2) element1;
bits(esize DIV 2) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize DIV 2];
    element2 = Elem[operand2, e, esize DIV 2];
    if sub_op then element1 = FPNeg(element1);
    Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR);
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 S x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 1101
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 0;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/upper:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 S x
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 1001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/upper:decode
if !HaveFP16MulNoRoundingToFP32Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean sub_op = (S == '1');
integer part = 1;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/lower:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/upper:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/fp/mul_norounding/upper:diagram
TAG:LD1ROD-Z.P.BI-U64:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(256) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 32;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROD-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROD-Z.P.BI-U64:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);

TAG:LD1ROD-Z.P.BI-U64:index
Execute: LD1ROD-Z.P.BI-U64:execute
Decode: LD1ROD-Z.P.BI-U64:decode@LD1ROD-Z.P.BI-U64:diagram
TAG:FSQRT-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPSqrt(element, FPCR);

Z[d] = result;
TAG:FSQRT-Z.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:18 _ 0011
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FSQRT-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FSQRT-Z.P.Z-_:index
Execute: FSQRT-Z.P.Z-_:execute
Decode: FSQRT-Z.P.Z-_:decode@FSQRT-Z.P.Z-_:diagram
TAG:ST4H-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST4H-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4H-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:ST4H-Z.P.BI-Contiguous:index
Execute: ST4H-Z.P.BI-Contiguous:execute
Decode: ST4H-Z.P.BI-Contiguous:decode@ST4H-Z.P.BI-Contiguous:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/sub/int:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
integer element1;
integer element2;
integer diff;

for e = 0 to elements-1
    element1 = Int(Elem[operand1, e, esize], unsigned);
    element2 = Int(Elem[operand2, e, esize], unsigned);
    diff = element1 - element2;
    Elem[result, e, esize] = diff[esize:1];

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/int:diagram
A64
31:31 _ 0
30:30 Q x
29:29 U x
28:24 _ 01110
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 00100
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/sub/int:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;
boolean unsigned = (U == '1');

TAG:aarch64/vector/arithmetic/binary/uniform/sub/int:index
Execute: aarch64/vector/arithmetic/binary/uniform/sub/int:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/sub/int:decode@aarch64/instrs/vector/arithmetic/binary/uniform/sub/int:diagram
TAG:SMIN-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    Elem[result, e, esize] = Min(element1, imm)[esize-1:0];

Z[dn] = result;
TAG:SMIN-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 101
18:17 _ 01
16:16 _ 0
15:14 _ 11
13:13 _ 0
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SMIN-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
boolean unsigned = FALSE;
integer imm = Int(imm8, unsigned);

TAG:SMIN-Z.ZI-_:index
Execute: SMIN-Z.ZI-_:execute
Decode: SMIN-Z.ZI-_:decode@SMIN-Z.ZI-_:diagram
TAG:SQINCW-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQINCW-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCW-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQINCW-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQINCW-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQINCW-R.RS-SX:index
Execute: SQINCW-R.RS-SX:execute
Decode: SQINCW-R.RS-SX:decode@SQINCW-R.RS-SX:diagram
Decode: SQINCW-R.RS-X:decode@SQINCW-R.RS-X:diagram
TAG:PRFD-I.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;
bits(VL) offset;

if n == 31 then
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFD-I.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 3;

TAG:PRFD-I.P.BZ-D.x32.scaled:diagram
A64
31:23 _ 110001000
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 32;
boolean offs_unsigned = (xs == '0');
integer scale = 3;

TAG:PRFD-I.P.BZ-D.64.scaled:diagram
A64
31:21 _ 11000100011
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFD-I.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer offs_size = 64;
boolean offs_unsigned = TRUE;
integer scale = 3;

TAG:PRFD-I.P.BZ-S.x32.scaled:index
Execute: PRFD-I.P.BZ-S.x32.scaled:execute
Decode: PRFD-I.P.BZ-S.x32.scaled:decode@PRFD-I.P.BZ-S.x32.scaled:diagram
Decode: PRFD-I.P.BZ-D.x32.scaled:decode@PRFD-I.P.BZ-D.x32.scaled:diagram
Decode: PRFD-I.P.BZ-D.64.scaled:decode@PRFD-I.P.BZ-D.64.scaled:diagram
TAG:LD1SB-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SB-Z.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LD1SB-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1SB-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LD1SB-Z.P.AI-S:index
Execute: LD1SB-Z.P.AI-S:execute
Decode: LD1SB-Z.P.AI-S:decode@LD1SB-Z.P.AI-S:diagram
Decode: LD1SB-Z.P.AI-D:decode@LD1SB-Z.P.AI-D:diagram
TAG:aarch64/vector/crypto/sha3op/sha1-hash/majority:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
    t = SHAmajority(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
V[d] = X;
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:12 _ 010
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha3op/sha1-hash/majority:index
Execute: aarch64/vector/crypto/sha3op/sha1-hash/majority:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority:decode@aarch64/instrs/vector/crypto/sha3op/sha1-hash/majority:diagram
TAG:aarch64/vector/arithmetic/unary/not:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = NOT(element);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/not:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 _ 00
21:17 _ 10000
16:12 _ 00101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/not:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;

TAG:aarch64/vector/arithmetic/unary/not:index
Execute: aarch64/vector/arithmetic/unary/not:execute
Decode: aarch64/instrs/vector/arithmetic/unary/not:decode@aarch64/instrs/vector/arithmetic/unary/not:diagram
TAG:aarch64/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 1
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 1
22:17 _ 111100
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:index
Execute: aarch64/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/float/simd:diagram
TAG:FSUB-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPSub(element1, element2, FPCR);

Z[d] = result;
TAG:FSUB-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 00
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FSUB-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FSUB-Z.ZZ-_:index
Execute: FSUB-Z.ZZ-_:execute
Decode: FSUB-Z.ZZ-_:decode@FSUB-Z.ZZ-_:diagram
TAG:STNT1B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
constant integer mbytes = esize DIV 8;
bits(VL) src;
bits(PL) mask = P[g];

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];
src = Z[t];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    addr = addr + mbytes;
TAG:STNT1B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:20 _ 001
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);

TAG:STNT1B-Z.P.BI-Contiguous:index
Execute: STNT1B-Z.P.BI-Contiguous:execute
Decode: STNT1B-Z.P.BI-Contiguous:decode@STNT1B-Z.P.BI-Contiguous:diagram
TAG:AND-Z.ZZ-_:execute
CheckSVEEnabled();
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];

Z[d] = operand1 AND operand2;
TAG:AND-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:AND-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:AND-Z.ZZ-_:index
Execute: AND-Z.ZZ-_:execute
Decode: AND-Z.ZZ-_:decode@AND-Z.ZZ-_:diagram
TAG:aarch64/vector/crypto/sha512/sha512h:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vtmp;  
bits(64)  MSigma1;
bits(64)  tmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

MSigma1 =  ROR(Y[127:64], 14) EOR ROR(Y[127:64],18) EOR ROR(Y[127:64],41);
Vtmp[127:64] =  (Y[127:64] AND X[63:0]) EOR (NOT(Y[127:64]) AND X[127:64]);
Vtmp[127:64] = (Vtmp[127:64] + MSigma1 +  W[127:64]);
tmp = Vtmp[127:64] + Y[63:0];
MSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);
Vtmp[63:0] = (tmp AND Y[127:64]) EOR (NOT(tmp) AND X[63:0]);
Vtmp[63:0] = (Vtmp[63:0] + MSigma1 + W[63:0]);
V[d] =  Vtmp;
TAG:aarch64/instrs/vector/crypto/sha512/sha512h:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 0
13:12 _ 00
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha512/sha512h:decode
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sha512/sha512h:index
Execute: aarch64/vector/crypto/sha512/sha512h:execute
Decode: aarch64/instrs/vector/crypto/sha512/sha512h:decode@aarch64/instrs/vector/crypto/sha512/sha512h:diagram
TAG:FTSMUL-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPTrigSMul(element1, element2, FPCR);

Z[d] = result;
TAG:FTSMUL-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 01
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FTSMUL-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FTSMUL-Z.ZZ-_:index
Execute: FTSMUL-Z.ZZ-_:execute
Decode: FTSMUL-Z.ZZ-_:decode@FTSMUL-Z.ZZ-_:diagram
TAG:aarch64/vector/arithmetic/binary/element/bfdot:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(128)      operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
    bits(16) elt2_a = Elem[operand2, 2 * i + 0, 16];
    bits(16) elt2_b = Elem[operand2, 2 * i + 1, 16];

    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/element/bfdot:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01111
23:22 _ 01
21:21 L x
20:20 M x
19:16 Rm xxxx
15:12 _ 1111
11:11 H x
10:10 _ 0
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/element/bfdot:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(M:Rm);
integer d = UInt(Rd);
integer i = UInt(H:L);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

TAG:aarch64/vector/arithmetic/binary/element/bfdot:index
Execute: aarch64/vector/arithmetic/binary/element/bfdot:execute
Decode: aarch64/instrs/vector/arithmetic/binary/element/bfdot:decode@aarch64/instrs/vector/arithmetic/binary/element/bfdot:diagram
TAG:aarch64/vector/arithmetic/unary/special/sqrt-est/int:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;
bits(32) element;

for e = 0 to elements-1
    element = Elem[operand, e, 32];
    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:17 _ 10000
16:12 _ 11100
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if sz == '1' then UNDEFINED;
integer esize = 32;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/special/sqrt-est/int:index
Execute: aarch64/vector/arithmetic/unary/special/sqrt-est/int:execute
Decode: aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int:decode@aarch64/instrs/vector/arithmetic/unary/special/sqrt-est/int:diagram
TAG:CMPEQ-P.P.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(PL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        boolean cond;
        case op of
            when Cmp_EQ cond = element1 == imm;
            when Cmp_NE cond = element1 != imm;
            when Cmp_GE cond = element1 >= imm;
            when Cmp_LT cond = element1 <  imm;
            when Cmp_GT cond = element1 >  imm;
            when Cmp_LE cond = element1 <= imm;
        ElemP[result, e, esize] = if cond then '1' else '0';
    else
        ElemP[result, e, esize] = '0';

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:CMPEQ-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPEQ-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_EQ;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPGT-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPGT-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPGE-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPGE-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPHI-P.P.ZI-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 1
20:14 imm7 xxxxxxx
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPHI-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GT;
integer imm = UInt(imm7);
boolean unsigned = TRUE;

TAG:CMPHS-P.P.ZI-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 1
20:14 imm7 xxxxxxx
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPHS-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_GE;
integer imm = UInt(imm7);
boolean unsigned = TRUE;

TAG:CMPLT-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPLT-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LT;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPLE-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPLE-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LE;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPLO-P.P.ZI-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 1
20:14 imm7 xxxxxxx
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:CMPLO-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LT;
integer imm = UInt(imm7);
boolean unsigned = TRUE;

TAG:CMPLS-P.P.ZI-_:diagram
A64
31:24 _ 00100100
23:22 size xx
21:21 _ 1
20:14 imm7 xxxxxxx
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPLS-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_LE;
integer imm = UInt(imm7);
boolean unsigned = TRUE;

TAG:CMPNE-P.P.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 0
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 1
3:0 Pd xxxx
TAG:CMPNE-P.P.ZI-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Pd);
SVECmp op = Cmp_NE;
integer imm = SInt(imm5);
boolean unsigned = FALSE;

TAG:CMPEQ-P.P.ZI-_:index
Execute: CMPEQ-P.P.ZI-_:execute
Decode: CMPEQ-P.P.ZI-_:decode@CMPEQ-P.P.ZI-_:diagram
Decode: CMPGT-P.P.ZI-_:decode@CMPGT-P.P.ZI-_:diagram
Decode: CMPGE-P.P.ZI-_:decode@CMPGE-P.P.ZI-_:diagram
Decode: CMPHI-P.P.ZI-_:decode@CMPHI-P.P.ZI-_:diagram
Decode: CMPHS-P.P.ZI-_:decode@CMPHS-P.P.ZI-_:diagram
Decode: CMPLT-P.P.ZI-_:decode@CMPLT-P.P.ZI-_:diagram
Decode: CMPLE-P.P.ZI-_:decode@CMPLE-P.P.ZI-_:diagram
Decode: CMPLO-P.P.ZI-_:decode@CMPLO-P.P.ZI-_:diagram
Decode: CMPLS-P.P.ZI-_:decode@CMPLS-P.P.ZI-_:diagram
Decode: CMPNE-P.P.ZI-_:decode@CMPNE-P.P.ZI-_:diagram
TAG:UQADD-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + element2, esize, unsigned);

Z[d] = result;
TAG:UQADD-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 10
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UQADD-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
boolean unsigned = TRUE;

TAG:UQADD-Z.ZZ-_:index
Execute: UQADD-Z.ZZ-_:execute
Decode: UQADD-Z.ZZ-_:decode@UQADD-Z.ZZ-_:diagram
TAG:STNT1D-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset = X[m];
bits(VL) src;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

src = Z[t];
for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    offset = offset + 1;
TAG:STNT1D-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1D-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;

TAG:STNT1D-Z.P.BR-Contiguous:index
Execute: STNT1D-Z.P.BR-Contiguous:execute
Decode: STNT1D-Z.P.BR-Contiguous:decode@STNT1D-Z.P.BR-Contiguous:diagram
TAG:ST2W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..1] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST2W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST2W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 2;

TAG:ST2W-Z.P.BR-Contiguous:index
Execute: ST2W-Z.P.BR-Contiguous:execute
Decode: ST2W-Z.P.BR-Contiguous:decode@ST2W-Z.P.BR-Contiguous:diagram
TAG:SQINCP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    integer element = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element + count, esize, unsigned);

Z[dn] = result;
TAG:SQINCP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 0
16:16 _ 0
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:SQINCP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);
boolean unsigned = FALSE;

TAG:SQINCP-Z.P.Z-_:index
Execute: SQINCP-Z.P.Z-_:execute
Decode: SQINCP-Z.P.Z-_:decode@SQINCP-Z.P.Z-_:diagram
TAG:MLS-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = UInt(Elem[operand1, e, esize]);
    integer element2 = UInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        integer product = element1 * element2;
        if sub_op then
            Elem[result, e, esize] = Elem[operand3, e, esize] - product;
        else
            Elem[result, e, esize] = Elem[operand3, e, esize] + product;
    else
        Elem[result, e, esize] = Elem[operand3, e, esize];

Z[da] = result;
TAG:MLS-Z.P.ZZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:14 _ 01
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:MLS-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean sub_op = TRUE;

TAG:MLS-Z.P.ZZZ-_:index
Execute: MLS-Z.P.ZZZ-_:execute
Decode: MLS-Z.P.ZZZ-_:decode@MLS-Z.P.ZZZ-_:diagram
TAG:LSR-Z.P.ZW-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(64) element2 = Elem[operand2, (e * esize) DIV 64, 64];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSR-Z.P.ZW-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSR-Z.P.ZW-_:decode
if !HaveSVE() then UNDEFINED;
if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSR-Z.P.ZW-_:index
Execute: LSR-Z.P.ZW-_:execute
Decode: LSR-Z.P.ZW-_:decode@LSR-Z.P.ZW-_:diagram
TAG:LSL-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    Elem[result, e, esize] = LSL(element1, shift);

Z[d] = result;
TAG:LSL-Z.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:21 _ 1
20:19 tszl xx
18:16 imm3 xxx
15:12 _ 1001
11:11 _ 1
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:LSL-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer n = UInt(Zn);
integer d = UInt(Zd);
integer shift = UInt(tsize:imm3) - esize;

TAG:LSL-Z.ZI-_:index
Execute: LSL-Z.ZI-_:execute
Decode: LSL-Z.ZI-_:decode@LSL-Z.ZI-_:diagram
TAG:SUB-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    Elem[result, e, esize] = element1 - imm;

Z[dn] = result;
TAG:SUB-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 00
16:16 _ 1
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SUB-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:SUB-Z.ZI-_:index
Execute: SUB-Z.ZI-_:execute
Decode: SUB-Z.ZI-_:decode@SUB-Z.ZI-_:diagram
TAG:ST3H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST3H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;
integer nreg = 3;

TAG:ST3H-Z.P.BR-Contiguous:index
Execute: ST3H-Z.P.BR-Contiguous:execute
Decode: ST3H-Z.P.BR-Contiguous:decode@ST3H-Z.P.BR-Contiguous:diagram
TAG:EOR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element1 EOR element2;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:EOR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:EOR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:EOR-Z.P.ZZ-_:index
Execute: EOR-Z.P.ZZ-_:execute
Decode: EOR-Z.P.ZZ-_:decode@EOR-Z.P.ZZ-_:diagram
TAG:RDFFR-P.F-_:execute
CheckSVEEnabled();
bits(PL) ffr = FFR[];
P[d] = ffr;
TAG:RDFFR-P.F-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:10 _ 011001111100
9:4 _ 000000
3:0 Pd xxxx
TAG:RDFFR-P.F-_:decode
if !HaveSVE() then UNDEFINED;
integer d = UInt(Pd);

TAG:RDFFR-P.F-_:index
Execute: RDFFR-P.F-_:execute
Decode: RDFFR-P.F-_:decode@RDFFR-P.F-_:diagram
TAG:LDFF1D-Z.P.AI-D:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1D-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1D-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;
integer offset = UInt(imm5);

TAG:LDFF1D-Z.P.AI-D:index
Execute: LDFF1D-Z.P.AI-D:execute
Decode: LDFF1D-Z.P.AI-D:decode@LDFF1D-Z.P.AI-D:diagram
TAG:aarch64/vector/crypto/sha3op/sha1-hash/parity:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) X = V[d];
bits(32)  Y = V[n];     // Note: 32 not 128 bits wide
bits(128) W = V[m];
bits(32)  t;

for e = 0 to 3
    t = SHAparity(X[63:32], X[95:64], X[127:96]);
    Y = Y + ROL(X[31:0], 5) + t + Elem[W, e, 32];
    X[63:32] = ROL(X[63:32], 30);
    [Y, X] = ROL(Y : X, 32);
V[d] = X;
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:12 _ 001
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA1Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha3op/sha1-hash/parity:index
Execute: aarch64/vector/crypto/sha3op/sha1-hash/parity:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity:decode@aarch64/instrs/vector/crypto/sha3op/sha1-hash/parity:diagram
TAG:aarch64/integer/tags/mcsettagpost:execute
bits(64) address;

SetTagCheckedInstruction(FALSE);

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if !postindex then
    address = address + offset;

if zero_data then
    Mem[address, TAG_GRANULE, AccType_NORMAL] = Zeros(TAG_GRANULE * 8);

bits(64) data = if t == 31 then SP[] else X[t];
bits(4) tag = AArch64.AllocationTagFromAddress(data);
AArch64.MemTag[address, AccType_NORMAL] = tag;

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/instrs/integer/tags/mcsettagpost:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 0
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpost:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = TRUE;
boolean zero_data = FALSE;

TAG:aarch64/instrs/integer/tags/mcsettagpre:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 1
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettagpre:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = TRUE;
boolean postindex = FALSE;
boolean zero_data = FALSE;

TAG:aarch64/instrs/integer/tags/mcsettag:diagram
A64
31:24 _ 11011001
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:12 imm9 xxxxxxxxx
11:11 _ 1
10:10 _ 0
9:5 Xn xxxxx
4:0 Xt xxxxx
TAG:aarch64/instrs/integer/tags/mcsettag:decode
integer n = UInt(Xn);
integer t = UInt(Xt);
bits(64) offset = LSL(SignExtend(imm9, 64), LOG2_TAG_GRANULE);
boolean writeback = FALSE;
boolean postindex = FALSE;
boolean zero_data = FALSE;

TAG:aarch64/integer/tags/mcsettagpost:index
Execute: aarch64/integer/tags/mcsettagpost:execute
Decode: aarch64/instrs/integer/tags/mcsettagpost:decode@aarch64/instrs/integer/tags/mcsettagpost:diagram
Decode: aarch64/instrs/integer/tags/mcsettagpre:decode@aarch64/instrs/integer/tags/mcsettagpre:diagram
Decode: aarch64/instrs/integer/tags/mcsettag:decode@aarch64/instrs/integer/tags/mcsettag:diagram
TAG:LDNT1H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = X[m];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LDNT1H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;

TAG:LDNT1H-Z.P.BR-Contiguous:index
Execute: LDNT1H-Z.P.BR-Contiguous:execute
Decode: LDNT1H-Z.P.BR-Contiguous:decode@LDNT1H-Z.P.BR-Contiguous:diagram
TAG:FRSQRTS-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);

Z[d] = result;
TAG:FRSQRTS-Z.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 0
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FRSQRTS-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FRSQRTS-Z.ZZ-_:index
Execute: FRSQRTS-Z.ZZ-_:execute
Decode: FRSQRTS-Z.ZZ-_:decode@FRSQRTS-Z.ZZ-_:diagram
TAG:aarch64/vector/crypto/sha3op/sha256-hash:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) result;
if part1 then
    result = SHA256hash(V[d], V[n], V[m], TRUE);
else
    result = SHA256hash(V[n], V[d], V[m], FALSE);
V[d] = result;
TAG:aarch64/instrs/vector/crypto/sha3op/sha256-hash:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:13 _ 10
12:12 P x
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha256-hash:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA256Ext() then UNDEFINED;
boolean part1 = (P == '0');

TAG:aarch64/vector/crypto/sha3op/sha256-hash:index
Execute: aarch64/vector/crypto/sha3op/sha256-hash:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha256-hash:decode@aarch64/instrs/vector/crypto/sha3op/sha256-hash:diagram
TAG:FMINNMV-V.P.Z-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) identity = FPDefaultNaN();

V[d] = ReducePredicated(ReduceOp_FMINNUM, operand, mask, identity);
TAG:FMINNMV-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 10
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:FMINNMV-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:FMINNMV-V.P.Z-_:index
Execute: FMINNMV-V.P.Z-_:execute
Decode: FMINNMV-V.P.Z-_:decode@FMINNMV-V.P.Z-_:diagram
TAG:aarch64/integer/pac/autda/dp_1src:execute
auth_then_branch = FALSE;

if HavePACExt() then
    if source_is_sp then
        X[d] = AuthDA(X[d], SP[], auth_then_branch);
    else
        X[d] = AuthDA(X[d], X[n], auth_then_branch);
TAG:aarch64/instrs/integer/pac/autda/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 110
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/autda/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // AUTDA
    if n == 31 then source_is_sp = TRUE;
else // AUTDZA
    if n != 31 then UNDEFINED;

TAG:aarch64/integer/pac/autda/dp_1src:index
Execute: aarch64/integer/pac/autda/dp_1src:execute
Decode: aarch64/instrs/integer/pac/autda/dp_1src:decode@aarch64/instrs/integer/pac/autda/dp_1src:diagram
TAG:aarch64/integer/ins-ext/extract/immediate:execute
bits(datasize) result;
bits(datasize) operand1 = X[n];
bits(datasize) operand2 = X[m];
bits(2*datasize) concat = operand1:operand2;

result = concat[lsb+datasize-1:lsb];

X[d] = result;
TAG:aarch64/instrs/integer/ins-ext/extract/immediate:diagram
A64
31:31 sf x
30:29 _ 00
28:23 _ 100111
22:22 N x
21:21 _ 0
20:16 Rm xxxxx
15:10 imms xxxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/ins-ext/extract/immediate:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer datasize = if sf == '1' then 64 else 32;
integer lsb;

if N != sf then UNDEFINED;
if sf == '0' && imms[5] == '1' then UNDEFINED;
lsb = UInt(imms);

TAG:aarch64/integer/ins-ext/extract/immediate:index
Execute: aarch64/integer/ins-ext/extract/immediate:execute
Decode: aarch64/instrs/integer/ins-ext/extract/immediate:decode@aarch64/instrs/integer/ins-ext/extract/immediate:diagram
TAG:UMAXV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer maximum = if unsigned then 0 else -(2^(esize-1));

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = Int(Elem[operand, e, esize], unsigned);
        maximum = Max(maximum, element);

V[d] = maximum[esize-1:0];
TAG:UMAXV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:UMAXV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean unsigned = TRUE;

TAG:UMAXV-R.P.Z-_:index
Execute: UMAXV-R.P.Z-_:execute
Decode: UMAXV-R.P.Z-_:decode@UMAXV-R.P.Z-_:diagram
TAG:PRFB-I.P.BI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

addr = base + ((offset * elements) << scale);
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Hint_Prefetch(addr, pref_hint, level, stream);
    addr = addr + (1 << scale);
TAG:PRFB-I.P.BI-S:diagram
A64
31:22 _ 1000010111
21:16 imm6 xxxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.BI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 0;
integer offset = SInt(imm6);

TAG:PRFB-I.P.BI-S:index
Execute: PRFB-I.P.BI-S:execute
Decode: PRFB-I.P.BI-S:decode@PRFB-I.P.BI-S:diagram
TAG:EOR-Z.ZZ-_:execute
CheckSVEEnabled();
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];

Z[d] = operand1 EOR operand2;
TAG:EOR-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 001100
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:EOR-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:EOR-Z.ZZ-_:index
Execute: EOR-Z.ZZ-_:execute
Decode: EOR-Z.ZZ-_:decode@EOR-Z.ZZ-_:diagram
TAG:PRFH-I.P.BR-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) offset = X[m];
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = base + (UInt(offset) << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
    offset = offset + 1;
TAG:PRFH-I.P.BR-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 110
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFH-I.P.BR-S:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 1;

TAG:PRFH-I.P.BR-S:index
Execute: PRFH-I.P.BR-S:execute
Decode: PRFH-I.P.BR-S:decode@PRFH-I.P.BR-S:diagram
TAG:MOVPRFX-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) dest = Z[d];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element;
    elsif merging then
        Elem[result, e, esize] = Elem[dest, e, esize];
    else
        Elem[result, e, esize] = Zeros();

Z[d] = result;
TAG:MOVPRFX-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 0
17:17 _ 0
16:16 M x
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:MOVPRFX-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
boolean merging = (M == '1');

TAG:MOVPRFX-Z.P.Z-_:index
Execute: MOVPRFX-Z.P.Z-_:execute
Decode: MOVPRFX-Z.P.Z-_:decode@MOVPRFX-Z.P.Z-_:diagram
TAG:INDEX-Z.IR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(esize) operand2 = X[m];
integer element2 = SInt(operand2);
bits(VL) result;

for e = 0 to elements-1
    integer index = imm + e * element2;
    Elem[result, e, esize] = index[esize-1:0];

Z[d] = result;
TAG:INDEX-Z.IR-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:10 _ 010010
9:5 imm5 xxxxx
4:0 Zd xxxxx
TAG:INDEX-Z.IR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Rm);
integer d = UInt(Zd);
integer imm = SInt(imm5);

TAG:INDEX-Z.IR-_:index
Execute: INDEX-Z.IR-_:execute
Decode: INDEX-Z.IR-_:decode@INDEX-Z.IR-_:diagram
TAG:FADDV-V.P.Z-_:execute
CheckSVEEnabled();
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) identity = FPZero('0');

V[d] = ReducePredicated(ReduceOp_FADD, operand, mask, identity);
TAG:FADDV-V.P.Z-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 000
18:17 _ 00
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:FADDV-V.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:FADDV-V.P.Z-_:index
Execute: FADDV-V.P.Z-_:execute
Decode: FADDV-V.P.Z-_:decode@FADDV-V.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/unary/extract/sqxtun/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;
boolean sat;

for e = 0 to elements-1
    element = Elem[operand, e, 2*esize];
    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);
    if sat then FPSR.QC = '1';

Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:22 size xx
21:17 _ 10000
16:12 _ 10010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = esize;
integer part = 0;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 10010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/extract/sqxtun/sisd:index
Execute: aarch64/vector/arithmetic/unary/extract/sqxtun/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd:decode@aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd:decode@aarch64/instrs/vector/arithmetic/unary/extract/sqxtun/simd:diagram
TAG:EORV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) result = Zeros(esize);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        result = result EOR Elem[operand, e, esize];

V[d] = result;
TAG:EORV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 1
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:EORV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:EORV-R.P.Z-_:index
Execute: EORV-R.P.Z-_:execute
Decode: EORV-R.P.Z-_:decode@EORV-R.P.Z-_:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) result;
bits(esize) element1;
bits(esize) element2;

for e = 0 to elements-1
    element1 = Elem[operand1, e, esize];
    element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 32 << UInt(sz);
integer datasize = esize;
integer elements = 1;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:21 _ 10
20:16 Rm xxxxx
15:14 _ 00
13:11 _ 111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer esize = 16;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Rm xxxxx
15:11 _ 11111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if sz:Q == '10' then UNDEFINED;
integer esize = 32 << UInt(sz);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:index
Execute: aarch64/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/sisd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts-fp16/simd:diagram
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd:decode@aarch64/instrs/vector/arithmetic/binary/uniform/rsqrts/simd:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/bfdot:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;

for e = 0 to elements-1
    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];
    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];

    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/bfdot:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 _ 01
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 1111
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/bfdot:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 32;

TAG:aarch64/vector/arithmetic/binary/uniform/mul/int/bfdot:index
Execute: aarch64/vector/arithmetic/binary/uniform/mul/int/bfdot:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/bfdot:decode@aarch64/instrs/vector/arithmetic/binary/uniform/mul/int/bfdot:diagram
TAG:aarch64/integer/pac/pacda/dp_1src:execute
if source_is_sp then
    X[d] = AddPACDA(X[d], SP[]);
else
    X[d] = AddPACDA(X[d], X[n]);
TAG:aarch64/instrs/integer/pac/pacda/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 010
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/pacda/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // PACDA
    if n == 31 then source_is_sp = TRUE;
else // PACDZA
    if n != 31 then UNDEFINED;

TAG:aarch64/integer/pac/pacda/dp_1src:index
Execute: aarch64/integer/pac/pacda/dp_1src:execute
Decode: aarch64/instrs/integer/pac/pacda/dp_1src:decode@aarch64/instrs/integer/pac/pacda/dp_1src:diagram
TAG:LD1RD-Z.P.BI-U64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RD-Z.P.BI-U64:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RD-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 64;
boolean unsigned = TRUE;
integer offset = UInt(imm6);

TAG:LD1RD-Z.P.BI-U64:index
Execute: LD1RD-Z.P.BI-U64:execute
Decode: LD1RD-Z.P.BI-U64:decode@LD1RD-Z.P.BI-U64:diagram
TAG:CPY-Z.P.R-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) operand1;
if n == 31 then
    operand1 = SP[];
else
    operand1 = X[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = operand1[esize-1:0];

Z[d] = result;
TAG:CPY-Z.P.R-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:13 _ 101000101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zd xxxxx
TAG:CPY-Z.P.R-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Rn);
integer d = UInt(Zd);

TAG:CPY-Z.P.R-_:index
Execute: CPY-Z.P.R-_:execute
Decode: CPY-Z.P.R-_:decode@CPY-Z.P.R-_:diagram
TAG:aarch64/vector/arithmetic/unary/cnt:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
bits(datasize) result;

integer count;
for e = 0 to elements-1
    count = BitCount(Elem[operand, e, esize]);
    Elem[result, e, esize] = count[esize-1:0];
V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/cnt:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 00101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/cnt:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size != '00' then UNDEFINED;
integer esize = 8;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV 8;

TAG:aarch64/vector/arithmetic/unary/cnt:index
Execute: aarch64/vector/arithmetic/unary/cnt:execute
Decode: aarch64/instrs/vector/arithmetic/unary/cnt:decode@aarch64/instrs/vector/arithmetic/unary/cnt:diagram
TAG:aarch64/system/exceptions/debug/halt:execute
Halt(DebugHalt_HaltInstruction);
TAG:aarch64/instrs/system/exceptions/debug/halt:diagram
A64
31:24 _ 11010100
23:21 _ 010
20:5 imm16 xxxxxxxxxxxxxxxx
4:2 _ 000
1:0 _ 00
TAG:aarch64/instrs/system/exceptions/debug/halt:decode
if EDSCR.HDE == '0' || !HaltingAllowed() then UNDEFINED;
if HaveBTIExt() then
    SetBTypeCompatible(TRUE);

TAG:aarch64/system/exceptions/debug/halt:index
Execute: aarch64/system/exceptions/debug/halt:execute
Decode: aarch64/instrs/system/exceptions/debug/halt:decode@aarch64/instrs/system/exceptions/debug/halt:diagram
TAG:LD3D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD3D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD3D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:LD3D-Z.P.BI-Contiguous:index
Execute: LD3D-Z.P.BI-Contiguous:execute
Decode: LD3D-Z.P.BI-Contiguous:decode@LD3D-Z.P.BI-Contiguous:diagram
TAG:ASR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = ASR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:ASR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 0
17:17 _ 0
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:ASR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:ASR-Z.P.ZZ-_:index
Execute: ASR-Z.P.ZZ-_:execute
Decode: ASR-Z.P.ZZ-_:decode@ASR-Z.P.ZZ-_:diagram
TAG:UQDECP-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(PL) operand2 = P[m];
bits(VL) result;
integer count = 0;

for e = 0 to elements-1
    if ElemP[operand2, e, esize] == '1' then
        count = count + 1;

for e = 0 to elements-1
    integer element = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element - count, esize, unsigned);

Z[dn] = result;
TAG:UQDECP-Z.P.Z-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:18 _ 1010
17:17 _ 1
16:16 _ 1
15:11 _ 10000
10:10 _ 0
9:9 _ 0
8:5 Pm xxxx
4:0 Zdn xxxxx
TAG:UQDECP-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer m = UInt(Pm);
integer dn = UInt(Zdn);
boolean unsigned = TRUE;

TAG:UQDECP-Z.P.Z-_:index
Execute: UQDECP-Z.P.Z-_:execute
Decode: UQDECP-Z.P.Z-_:decode@UQDECP-Z.P.Z-_:diagram
TAG:BFMLALT-Z.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(32) element1 = Elem[operand1, 2 * e + 1, 16] : Zeros(16);
    bits(32) element2 = Elem[operand2, 2 * e + 1, 16] : Zeros(16);
    bits(32) element3 = Elem[operand3, e, 32];
    Elem[result, e, 32] = FPMulAdd(element3, element1, element2, FPCR);

Z[da] = result;
TAG:BFMLALT-Z.ZZZ-_:diagram
A64
31:23 _ 011001001
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:14 _ 10
13:13 _ 0
12:11 _ 00
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFMLALT-Z.ZZZ-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:BFMLALT-Z.ZZZ-_:index
Execute: BFMLALT-Z.ZZZ-_:execute
Decode: BFMLALT-Z.ZZZ-_:decode@BFMLALT-Z.ZZZ-_:diagram
TAG:aarch64/integer/pac/autia/dp_1src:execute
auth_then_branch = FALSE;

if HavePACExt() then
    if source_is_sp then
        X[d] = AuthIA(X[d], SP[], auth_then_branch);
    else
        X[d] = AuthIA(X[d], X[n], auth_then_branch);
TAG:aarch64/instrs/integer/pac/autia/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 100
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/autia/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // AUTIA
    if n == 31 then source_is_sp = TRUE;
else // AUTIZA
    if n != 31 then UNDEFINED;

TAG:aarch64/instrs/integer/pac/autia/hint:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 _ 011
15:12 _ 0010
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/integer/pac/autia/hint:decode
integer d;
integer n;
boolean source_is_sp = FALSE;

case CRm:op2 of
    when '0011 100' // AUTIAZ
        d = 30;
        n = 31;
    when '0011 101' // AUTIASP
        d = 30;
        source_is_sp = TRUE;
    when '0001 100' // AUTIA1716
        d = 17;
        n = 16;
    when '0001 000' SEE "PACIA";
    when '0001 010' SEE "PACIB";
    when '0001 110' SEE "AUTIB";
    when '0011 00x' SEE "PACIA";
    when '0011 01x' SEE "PACIB";
    when '0011 11x' SEE "AUTIB";
    when '0000 111' SEE "XPACLRI";
    otherwise       SEE "HINT";

TAG:aarch64/integer/pac/autia/dp_1src:index
Execute: aarch64/integer/pac/autia/dp_1src:execute
Decode: aarch64/instrs/integer/pac/autia/dp_1src:decode@aarch64/instrs/integer/pac/autia/dp_1src:diagram
Decode: aarch64/instrs/integer/pac/autia/hint:decode@aarch64/instrs/integer/pac/autia/hint:diagram
TAG:aarch64/vector/reduce/fp16-max/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/fp16-max/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp16-max/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 16;
if sz == '1' then UNDEFINED;
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

TAG:aarch64/instrs/vector/reduce/fp-max/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 o1 x
22:22 sz x
21:17 _ 11000
16:12 _ 01111
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp-max/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;

TAG:aarch64/vector/reduce/fp16-max/sisd:index
Execute: aarch64/vector/reduce/fp16-max/sisd:execute
Decode: aarch64/instrs/vector/reduce/fp16-max/sisd:decode@aarch64/instrs/vector/reduce/fp16-max/sisd:diagram
Decode: aarch64/instrs/vector/reduce/fp-max/sisd:decode@aarch64/instrs/vector/reduce/fp-max/sisd:diagram
TAG:LSR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSR(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSR-Z.P.ZZ-_:index
Execute: LSR-Z.P.ZZ-_:execute
Decode: LSR-Z.P.ZZ-_:decode@LSR-Z.P.ZZ-_:diagram
TAG:UQINCW-R.RS-UW:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 + (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:UQINCW-R.RS-UW:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCW-R.RS-UW:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 32;

TAG:UQINCW-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 0
10:10 _ 1
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:UQINCW-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = TRUE;
integer ssize = 64;

TAG:UQINCW-R.RS-UW:index
Execute: UQINCW-R.RS-UW:execute
Decode: UQINCW-R.RS-UW:decode@UQINCW-R.RS-UW:diagram
Decode: UQINCW-R.RS-X:decode@UQINCW-R.RS-X:diagram
TAG:SQDECW-R.RS-SX:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(ssize) operand1 = X[dn];
bits(ssize) result;

integer element1 = Int(operand1, unsigned);
(result, -) = SatQ(element1 - (count * imm), ssize, unsigned);
X[dn] = Extend(result, 64, unsigned);
TAG:SQDECW-R.RS-SX:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECW-R.RS-SX:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 32;

TAG:SQDECW-R.RS-X:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:12 _ 1111
11:11 _ 1
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:SQDECW-R.RS-X:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;
boolean unsigned = FALSE;
integer ssize = 64;

TAG:SQDECW-R.RS-SX:index
Execute: SQDECW-R.RS-SX:execute
Decode: SQDECW-R.RS-SX:decode@SQDECW-R.RS-SX:diagram
Decode: SQDECW-R.RS-X:decode@SQDECW-R.RS-X:diagram
TAG:aarch64/vector/crypto/sha3op/sha256-sched1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) operand1 = V[d];
bits(128) operand2 = V[n];
bits(128) operand3 = V[m];
bits(128) result;
bits(128) T0 = operand3[31:0] : operand2[127:32];
bits(64) T1;
bits(32) elt;

T1 = operand3[127:64];
for e = 0 to 1
    elt = Elem[T1, e, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

T1 = result[63:0];
for e = 2 to 3
    elt = Elem[T1, e - 2, 32];
    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);
    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];
    Elem[result, e, 32] = elt;

V[d] = result;
TAG:aarch64/instrs/vector/crypto/sha3op/sha256-sched1:diagram
A64
31:24 _ 01011110
23:22 _ 00
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 0
14:12 _ 110
11:10 _ 00
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3op/sha256-sched1:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if !HaveSHA256Ext() then UNDEFINED;

TAG:aarch64/vector/crypto/sha3op/sha256-sched1:index
Execute: aarch64/vector/crypto/sha3op/sha256-sched1:execute
Decode: aarch64/instrs/vector/crypto/sha3op/sha256-sched1:decode@aarch64/instrs/vector/crypto/sha3op/sha256-sched1:diagram
TAG:LD1RSB-Z.P.BI-S16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

integer last = LastActiveElement(mask, esize);
if last >= 0 then
    addr = base + offset * mbytes;
    data = Mem[addr, mbytes, AccType_NORMAL];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1RSB-Z.P.BI-S16:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSB-Z.P.BI-S16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSB-Z.P.BI-S32:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSB-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSB-Z.P.BI-S64:diagram
A64
31:25 _ 1000010
24:24 _ 1
23:23 _ 1
22:22 _ 1
21:16 imm6 xxxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RSB-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = UInt(imm6);

TAG:LD1RSB-Z.P.BI-S16:index
Execute: LD1RSB-Z.P.BI-S16:execute
Decode: LD1RSB-Z.P.BI-S16:decode@LD1RSB-Z.P.BI-S16:diagram
Decode: LD1RSB-Z.P.BI-S32:decode@LD1RSB-Z.P.BI-S32:diagram
Decode: LD1RSB-Z.P.BI-S64:decode@LD1RSB-Z.P.BI-S64:diagram
TAG:FMULX-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMULX-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 101
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FMULX-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FMULX-Z.P.ZZ-_:index
Execute: FMULX-Z.P.ZZ-_:execute
Decode: FMULX-Z.P.ZZ-_:decode@FMULX-Z.P.ZZ-_:diagram
TAG:aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:execute
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(64) operand2 = if m == 31 then SP[] else X[m];
operand1 = SignExtend(operand1[55:0], 64);
operand2 = SignExtend(operand2[55:0], 64);

bits(64) result;
bits(4) nzcv;

operand2 = NOT(operand2);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');

if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 1
28:21 _ 11010110
20:16 Xm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);
boolean setflags = TRUE;

TAG:aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:index
Execute: aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:execute
Decode: aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:decode@aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddresssetflags:diagram
TAG:ST1B-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1B-Z.P.AI-S:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 11
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
integer offset = UInt(imm5);

TAG:ST1B-Z.P.AI-D:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 10
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1B-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
integer offset = UInt(imm5);

TAG:ST1B-Z.P.AI-S:index
Execute: ST1B-Z.P.AI-S:execute
Decode: ST1B-Z.P.AI-S:decode@ST1B-Z.P.AI-S:diagram
Decode: ST1B-Z.P.AI-D:decode@ST1B-Z.P.AI-D:diagram
TAG:LSL-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    integer shift = Min(UInt(element2), esize);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = LSL(element1, shift);
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:LSL-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 010
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:LSL-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:LSL-Z.P.ZZ-_:index
Execute: LSL-Z.P.ZZ-_:execute
Decode: LSL-Z.P.ZZ-_:decode@LSL-Z.P.ZZ-_:diagram
TAG:aarch64/integer/flags/cfinv:execute
PSTATE.C = NOT(PSTATE.C);
TAG:aarch64/instrs/integer/flags/cfinv:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:20 _ 0
19:19 _ 0
18:16 _ 000
15:12 _ 0100
11:8 CRm xxxx
7:5 _ 000
4:0 _ 11111
TAG:aarch64/instrs/integer/flags/cfinv:decode
if !HaveFlagManipulateExt() then UNDEFINED;

TAG:aarch64/integer/flags/cfinv:index
Execute: aarch64/integer/flags/cfinv:execute
Decode: aarch64/instrs/integer/flags/cfinv:decode@aarch64/instrs/integer/flags/cfinv:diagram
TAG:FMMLA-Z.ZZZ-S:execute
CheckSVEEnabled();
if VL < esize * 4 then UNDEFINED;
integer segments = VL DIV (4 * esize);
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result = Zeros();
bits(4*esize) op1, op2;
bits(4*esize) res, addend;

for s = 0 to segments-1
    op1    = Elem[operand1, s, 4*esize];
    op2    = Elem[operand2, s, 4*esize];
    addend = Elem[operand3, s, 4*esize];
    res    = FPMatMulAdd(addend, op1, op2, esize, FPCR);
    Elem[result, s, 4*esize] = res;

Z[da] = result;
TAG:FMMLA-Z.ZZZ-S:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 111001
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMMLA-Z.ZZZ-S:decode
if !HaveSVEFP32MatMulExt() then UNDEFINED;
integer esize = 32;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:FMMLA-Z.ZZZ-D:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 111001
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMMLA-Z.ZZZ-D:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 64;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:FMMLA-Z.ZZZ-S:index
Execute: FMMLA-Z.ZZZ-S:execute
Decode: FMMLA-Z.ZZZ-S:decode@FMMLA-Z.ZZZ-S:diagram
Decode: FMMLA-Z.ZZZ-D:decode@FMMLA-Z.ZZZ-D:diagram
TAG:SUBR-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = element2 - element1;
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SUBR-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 000
18:17 _ 01
16:16 _ 1
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SUBR-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:SUBR-Z.P.ZZ-_:index
Execute: SUBR-Z.P.ZZ-_:execute
Decode: SUBR-Z.P.ZZ-_:decode@SUBR-Z.P.ZZ-_:diagram
TAG:aarch64/vector/crypto/sha3/bcax:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Va = V[a];
V[d] = Vn EOR (Vm AND NOT(Va));
TAG:aarch64/instrs/vector/crypto/sha3/bcax:diagram
A64
31:23 _ 110011100
22:21 _ 01
20:16 Rm xxxxx
15:15 _ 0
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3/bcax:decode
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer a = UInt(Ra);

TAG:aarch64/vector/crypto/sha3/bcax:index
Execute: aarch64/vector/crypto/sha3/bcax:execute
Decode: aarch64/instrs/vector/crypto/sha3/bcax:decode@aarch64/instrs/vector/crypto/sha3/bcax:diagram
TAG:LD1RQW-Z.P.BI-U32:execute
CheckSVEEnabled();
integer elements = 128 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low 16 bits only
bits(128) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * 16;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = Replicate(result, VL DIV 128);
TAG:LD1RQW-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 001
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1RQW-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);

TAG:LD1RQW-Z.P.BI-U32:index
Execute: LD1RQW-Z.P.BI-U32:execute
Decode: LD1RQW-Z.P.BI-U32:decode@LD1RQW-Z.P.BI-U32:diagram
TAG:FCMLA-Z.ZZZi-H:execute
CheckSVEEnabled();
integer pairs = VL DIV (2 * esize);
integer pairspersegment = 128 DIV (2 * esize);
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for p = 0 to pairs-1
    segmentbase = p - (p MOD pairspersegment);
    s = segmentbase + index;
    addend_r = Elem[operand3, 2 * p + 0, esize];
    addend_i = Elem[operand3, 2 * p + 1, esize];
    elt1_a   = Elem[operand1, 2 * p + sel_a, esize];
    elt2_a   = Elem[operand2, 2 * s + sel_a, esize];
    elt2_b   = Elem[operand2, 2 * s + sel_b, esize];
    if neg_r then elt2_a = FPNeg(elt2_a);
    if neg_i then elt2_b = FPNeg(elt2_b);
    addend_r = FPMulAdd(addend_r, elt1_a, elt2_a, FPCR);
    addend_i = FPMulAdd(addend_i, elt1_a, elt2_b, FPCR);
    Elem[result, 2 * p + 0, esize] = addend_r;
    Elem[result, 2 * p + 1, esize] = addend_i;

Z[da] = result;
TAG:FCMLA-Z.ZZZi-H:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:12 _ 0001
11:10 rot xx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FCMLA-Z.ZZZi-H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer sel_a = UInt(rot[0]);
integer sel_b = UInt(NOT(rot[0]));
boolean neg_i = (rot[1] == '1');
boolean neg_r = (rot[0] != rot[1]);

TAG:FCMLA-Z.ZZZi-S:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:12 _ 0001
11:10 rot xx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FCMLA-Z.ZZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
integer sel_a = UInt(rot[0]);
integer sel_b = UInt(NOT(rot[0]));
boolean neg_i = (rot[1] == '1');
boolean neg_r = (rot[0] != rot[1]);

TAG:FCMLA-Z.ZZZi-H:index
Execute: FCMLA-Z.ZZZi-H:execute
Decode: FCMLA-Z.ZZZi-H:decode@FCMLA-Z.ZZZi-H:diagram
Decode: FCMLA-Z.ZZZi-S:decode@FCMLA-Z.ZZZi-S:diagram
TAG:FMLS-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element3;

Z[da] = result;
TAG:FMLS-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLS-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = TRUE;
boolean op3_neg = FALSE;

TAG:FMLS-Z.P.ZZZ-_:index
Execute: FMLS-Z.P.ZZZ-_:execute
Decode: FMLS-Z.P.ZZZ-_:decode@FMLS-Z.P.ZZZ-_:diagram
TAG:DUP-Z.I-_:execute
CheckSVEEnabled();
bits(VL) result = Replicate(imm[esize-1:0]);
Z[d] = result;
TAG:DUP-Z.I-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 111
18:18 _ 0
17:17 _ 0
16:14 _ 011
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zd xxxxx
TAG:DUP-Z.I-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer d = UInt(Zd);
integer imm = SInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:DUP-Z.I-_:index
Execute: DUP-Z.I-_:execute
Decode: DUP-Z.I-_:decode@DUP-Z.I-_:diagram
TAG:LD1H-Z.P.BI-U16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LD1H-Z.P.BI-U16:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BI-U16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1H-Z.P.BI-U32:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 0
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BI-U32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1H-Z.P.BI-U64:diagram
A64
31:25 _ 1010010
24:22 _ 011
21:21 _ 1
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1H-Z.P.BI-U64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = TRUE;
integer offset = SInt(imm4);

TAG:LD1H-Z.P.BI-U16:index
Execute: LD1H-Z.P.BI-U16:execute
Decode: LD1H-Z.P.BI-U16:decode@LD1H-Z.P.BI-U16:diagram
Decode: LD1H-Z.P.BI-U32:decode@LD1H-Z.P.BI-U32:diagram
Decode: LD1H-Z.P.BI-U64:decode@LD1H-Z.P.BI-U64:diagram
TAG:ST4W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST4W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 4;

TAG:ST4W-Z.P.BR-Contiguous:index
Execute: ST4W-Z.P.BR-Contiguous:execute
Decode: ST4W-Z.P.BR-Contiguous:decode@ST4W-Z.P.BR-Contiguous:diagram
TAG:FNMSB-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[a];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FNMSB-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Za xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FNMSB-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
integer a = UInt(Za);
boolean op1_neg = FALSE;
boolean op3_neg = TRUE;

TAG:FNMSB-Z.P.ZZZ-_:index
Execute: FNMSB-Z.P.ZZZ-_:execute
Decode: FNMSB-Z.P.ZZZ-_:decode@FNMSB-Z.P.ZZZ-_:diagram
TAG:LD1ROD-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(64) offset;
bits(256) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROD-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 1
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROD-Z.P.BR-Contiguous:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;

TAG:LD1ROD-Z.P.BR-Contiguous:index
Execute: LD1ROD-Z.P.BR-Contiguous:execute
Decode: LD1ROD-Z.P.BR-Contiguous:decode@LD1ROD-Z.P.BR-Contiguous:diagram
TAG:CPY-Z.O.I-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) dest = Z[d];
bits(VL) result;

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = imm[esize-1:0];
    elsif merging then
        Elem[result, e, esize] = Elem[dest, e, esize];
    else
        Elem[result, e, esize] = Zeros();

Z[d] = result;
TAG:CPY-Z.O.I-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 01
19:16 Pg xxxx
15:15 _ 0
14:14 _ 0
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zd xxxxx
TAG:CPY-Z.O.I-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer d = UInt(Zd);
boolean merging = FALSE;
integer imm = SInt(imm8);
if sh == '1' then imm = imm << 8;

TAG:CPY-Z.O.I-_:index
Execute: CPY-Z.O.I-_:execute
Decode: CPY-Z.O.I-_:decode@CPY-Z.O.I-_:diagram
TAG:aarch64/branch/unconditional/dret:execute
DRPSInstruction();
TAG:aarch64/instrs/branch/unconditional/dret:diagram
A64
31:25 _ 1101011
24:21 _ 0101
20:16 _ 11111
15:10 _ 000000
9:5 _ 11111
4:0 _ 00000
TAG:aarch64/instrs/branch/unconditional/dret:decode
if !Halted() || PSTATE.EL == EL0 then UNDEFINED;

TAG:aarch64/branch/unconditional/dret:index
Execute: aarch64/branch/unconditional/dret:execute
Decode: aarch64/instrs/branch/unconditional/dret:decode@aarch64/instrs/branch/unconditional/dret:diagram
TAG:LDNF1SB-Z.P.BI-S16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1SB-Z.P.BI-S16:diagram
A64
31:25 _ 1010010
24:22 _ 111
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SB-Z.P.BI-S16:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 16;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SB-Z.P.BI-S32:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 1
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SB-Z.P.BI-S32:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SB-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 110
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SB-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 8;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SB-Z.P.BI-S16:index
Execute: LDNF1SB-Z.P.BI-S16:execute
Decode: LDNF1SB-Z.P.BI-S16:decode@LDNF1SB-Z.P.BI-S16:diagram
Decode: LDNF1SB-Z.P.BI-S32:decode@LDNF1SB-Z.P.BI-S32:diagram
Decode: LDNF1SB-Z.P.BI-S64:decode@LDNF1SB-Z.P.BI-S64:diagram
TAG:STNT1W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset = X[m];
bits(VL) src;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

src = Z[t];
for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    offset = offset + 1;
TAG:STNT1W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;

TAG:STNT1W-Z.P.BR-Contiguous:index
Execute: STNT1W-Z.P.BR-Contiguous:execute
Decode: STNT1W-Z.P.BR-Contiguous:decode@STNT1W-Z.P.BR-Contiguous:diagram
TAG:ST3W-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST3W-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 _ 10
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3W-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer nreg = 3;

TAG:ST3W-Z.P.BR-Contiguous:index
Execute: ST3W-Z.P.BR-Contiguous:execute
Decode: ST3W-Z.P.BR-Contiguous:decode@ST3W-Z.P.BR-Contiguous:diagram
TAG:PRFB-I.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) base;
bits(64) addr;
base = Z[n];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + (offset << scale);
        Hint_Prefetch(addr, pref_hint, level, stream);
TAG:PRFB-I.P.AI-S:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 0;
integer offset = UInt(imm5);

TAG:PRFB-I.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 0
22:21 _ 00
20:16 imm5 xxxxx
15:13 _ 111
12:10 Pg xxx
9:5 Zn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFB-I.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 0;
integer offset = UInt(imm5);

TAG:PRFB-I.P.AI-S:index
Execute: PRFB-I.P.AI-S:execute
Decode: PRFB-I.P.AI-S:decode@PRFB-I.P.AI-S:diagram
Decode: PRFB-I.P.AI-D:decode@PRFB-I.P.AI-D:diagram
TAG:SUDOT-Z.ZZZi-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) res = Elem[operand3, e, esize];
    for i = 0 to 3
        integer element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]);
        integer element2 = UInt(Elem[operand2, 4 * s + i, esize DIV 4]);
        res = res + element1 * element2;
    Elem[result, e, esize] = res;

Z[da] = result;
TAG:SUDOT-Z.ZZZi-S:diagram
A64
31:24 _ 01000100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:11 _ 00011
10:10 _ 1
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:SUDOT-Z.ZZZi-S:decode
if !HaveSVE() || !HaveInt8MatMulExt() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:SUDOT-Z.ZZZi-S:index
Execute: SUDOT-Z.ZZZi-S:execute
Decode: SUDOT-Z.ZZZi-S:decode@SUDOT-Z.ZZZi-S:diagram
TAG:LD4W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Elem[values[r], e, esize] = Mem[addr, mbytes, AccType_NORMAL];
        else
            Elem[values[r], e, esize] = Zeros();
        addr = addr + mbytes;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];
TAG:LD4W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:21 _ 11
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD4W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:LD4W-Z.P.BI-Contiguous:index
Execute: LD4W-Z.P.BI-Contiguous:execute
Decode: LD4W-Z.P.BI-Contiguous:decode@LD4W-Z.P.BI-Contiguous:diagram
TAG:SMINV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
integer minimum = if unsigned then (2^esize - 1) else (2^(esize-1) - 1);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer element = Int(Elem[operand, e, esize], unsigned);
        minimum = Min(minimum, element);

V[d] = minimum[esize-1:0];
TAG:SMINV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 001
18:18 _ 0
17:17 _ 1
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:SMINV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);
boolean unsigned = FALSE;

TAG:SMINV-R.P.Z-_:index
Execute: SMINV-R.P.Z-_:execute
Decode: SMINV-R.P.Z-_:decode@SMINV-R.P.Z-_:diagram
TAG:FNMLA-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element3;

Z[da] = result;
TAG:FNMLA-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FNMLA-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = TRUE;
boolean op3_neg = TRUE;

TAG:FNMLA-Z.P.ZZZ-_:index
Execute: FNMLA-Z.P.ZZZ-_:execute
Decode: FNMLA-Z.P.ZZZ-_:decode@FNMLA-Z.P.ZZZ-_:diagram
TAG:FCPY-Z.P.I-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) result = Z[d];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = imm;

Z[d] = result;
TAG:FCPY-Z.P.I-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:20 _ 01
19:16 Pg xxxx
15:13 _ 110
12:5 imm8 xxxxxxxx
4:0 Zd xxxxx
TAG:FCPY-Z.P.I-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer d = UInt(Zd);
bits(esize) imm = VFPExpandImm(imm8);

TAG:FCPY-Z.P.I-_:index
Execute: FCPY-Z.P.I-_:execute
Decode: FCPY-Z.P.I-_:decode@FCPY-Z.P.I-_:diagram
TAG:aarch64/memory/pair/simdfp/no-alloc:execute
CheckFPAdvSIMDEnabled64();

bits(64) address;
bits(datasize) data1;
bits(datasize) data2;
constant integer dbytes = datasize DIV 8;
boolean rt_unknown = FALSE;

if HaveMTEExt() then
    SetTagCheckedInstruction(tag_checked);

if memop == MemOp_LOAD && t == t2 then
    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);
    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};
    case c of
        when Constraint_UNKNOWN    rt_unknown = TRUE;    // result is UNKNOWN
        when Constraint_UNDEF      UNDEFINED;
        when Constraint_NOP        EndOfInstruction();

if n == 31 then
    CheckSPAlignment();
    address = SP[];
else
    address = X[n];

if ! postindex then
    address = address + offset;

case memop of
    when MemOp_STORE
        data1 = V[t];
        data2 = V[t2];
        Mem[address + 0     , dbytes, acctype] = data1;
        Mem[address + dbytes, dbytes, acctype] = data2;

    when MemOp_LOAD
        data1 = Mem[address + 0     , dbytes, acctype];
        data2 = Mem[address + dbytes, dbytes, acctype];
        if rt_unknown then
            data1 = bits(datasize) UNKNOWN;
            data2 = bits(datasize) UNKNOWN;
        V[t]  = data1;
        V[t2] = data2;

if wback then
    if postindex then
        address = address + offset;
    if n == 31 then
        SP[] = address;
    else
        X[n] = address;
TAG:aarch64/memory/pair/simdfp/no-alloc:postdecode
integer n = UInt(Rn);
integer t = UInt(Rt);
integer t2 = UInt(Rt2);
AccType acctype = AccType_VECSTREAM;
MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;
if opc == '11' then UNDEFINED;
integer scale = 2 + UInt(opc);
integer datasize = 8 << scale;
bits(64) offset = LSL(SignExtend(imm7, 64), scale);
boolean tag_checked = wback || n != 31;

TAG:aarch64/instrs/memory/pair/simdfp/no-alloc:diagram
A64
31:30 opc xx
29:27 _ 101
26:26 _ 1
25:23 _ 000
22:22 L x
21:15 imm7 xxxxxxx
14:10 Rt2 xxxxx
9:5 Rn xxxxx
4:0 Rt xxxxx
TAG:aarch64/instrs/memory/pair/simdfp/no-alloc:decode
boolean wback  = FALSE;
boolean postindex = FALSE;

TAG:aarch64/memory/pair/simdfp/no-alloc:index
Execute: aarch64/memory/pair/simdfp/no-alloc:execute
Postdecode: aarch64/memory/pair/simdfp/no-alloc:postdecode
Decode: aarch64/instrs/memory/pair/simdfp/no-alloc:decode@aarch64/instrs/memory/pair/simdfp/no-alloc:diagram
TAG:LDFF1H-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1H-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001001
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LDFF1H-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LDFF1H-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1H-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = TRUE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1H-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:LDFF1H-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1H-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = TRUE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1H-Z.P.BZ-S.x32.scaled:index
Execute: LDFF1H-Z.P.BZ-S.x32.scaled:execute
Decode: LDFF1H-Z.P.BZ-S.x32.scaled:decode@LDFF1H-Z.P.BZ-S.x32.scaled:diagram
Decode: LDFF1H-Z.P.BZ-D.x32.scaled:decode@LDFF1H-Z.P.BZ-D.x32.scaled:diagram
Decode: LDFF1H-Z.P.BZ-D.x32.unscaled:decode@LDFF1H-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1H-Z.P.BZ-S.x32.unscaled:decode@LDFF1H-Z.P.BZ-S.x32.unscaled:diagram
Decode: LDFF1H-Z.P.BZ-D.64.scaled:decode@LDFF1H-Z.P.BZ-D.64.scaled:diagram
Decode: LDFF1H-Z.P.BZ-D.64.unscaled:decode@LDFF1H-Z.P.BZ-D.64.unscaled:diagram
TAG:FADD-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPAdd(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FADD-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 000
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FADD-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FADD-Z.P.ZZ-_:index
Execute: FADD-Z.P.ZZ-_:execute
Decode: FADD-Z.P.ZZ-_:decode@FADD-Z.P.ZZ-_:diagram
TAG:BRKPA-P.P.PP-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand1 = P[n];
bits(PL) operand2 = P[m];
bits(PL) result;
boolean last = (LastActive(mask, operand1, 8) == '1');

for e = 0 to elements-1
    if ElemP[mask, e, 8] == '1' then
        ElemP[result, e, 8] = if last then '1' else '0';
        last = last && (ElemP[operand2, e, 8] == '0');
    else
        ElemP[result, e, 8] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:BRKPA-P.P.PP-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:20 _ 00
19:16 Pm xxxx
15:14 _ 11
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:BRKPA-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = FALSE;

TAG:BRKPAS-P.P.PP-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:20 _ 00
19:16 Pm xxxx
15:14 _ 11
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:BRKPAS-P.P.PP-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer m = UInt(Pm);
integer d = UInt(Pd);
boolean setflags = TRUE;

TAG:BRKPA-P.P.PP-_:index
Execute: BRKPA-P.P.PP-_:execute
Decode: BRKPA-P.P.PP-_:decode@BRKPA-P.P.PP-_:diagram
Decode: BRKPAS-P.P.PP-_:decode@BRKPAS-P.P.PP-_:diagram
TAG:FMUL-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPMul(element1, imm, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FMUL-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 0
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FMUL-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPTwo('0');

TAG:FMUL-Z.P.ZS-_:index
Execute: FMUL-Z.P.ZS-_:execute
Decode: FMUL-Z.P.ZS-_:decode@FMUL-Z.P.ZS-_:diagram
TAG:aarch64/vector/crypto/sha512/sha512h2:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vtmp;  
bits(64) NSigma0;
bits(64) tmp;
bits(128) X = V[n];
bits(128) Y = V[m];
bits(128) W = V[d];

NSigma0 =  ROR(Y[63:0], 28) EOR ROR(Y[63:0],34) EOR ROR(Y[63:0],39);
Vtmp[127:64] = (X[63:0] AND Y[127:64]) EOR (X[63:0] AND Y[63:0]) EOR (Y[127:64] AND Y[63:0]);
Vtmp[127:64] = (Vtmp[127:64] + NSigma0 +  W[127:64]);
NSigma0 =  ROR(Vtmp[127:64], 28) EOR ROR(Vtmp[127:64],34) EOR ROR(Vtmp[127:64],39);
Vtmp[63:0] =   (Vtmp[127:64] AND Y[63:0]) EOR (Vtmp[127:64] AND Y[127:64]) EOR (Y[127:64] AND Y[63:0]);
Vtmp[63:0] =   (Vtmp[63:0] + NSigma0 + W[63:0]);

V[d] = Vtmp;
TAG:aarch64/instrs/vector/crypto/sha512/sha512h2:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 0
13:12 _ 00
11:10 _ 01
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha512/sha512h2:decode
if !HaveSHA512Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sha512/sha512h2:index
Execute: aarch64/vector/crypto/sha512/sha512h2:execute
Decode: aarch64/instrs/vector/crypto/sha512/sha512h2:decode@aarch64/instrs/vector/crypto/sha512/sha512h2:diagram
TAG:aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddress:execute
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(64) operand2 = if m == 31 then SP[] else X[m];
operand1 = SignExtend(operand1[55:0], 64);
operand2 = SignExtend(operand2[55:0], 64);

bits(64) result;
bits(4) nzcv;

operand2 = NOT(operand2);
(result, nzcv) = AddWithCarry(operand1, operand2, '1');

if setflags then
    PSTATE.[N,Z,C,V] = nzcv;
X[d] = result;
TAG:aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddress:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 0
28:21 _ 11010110
20:16 Xm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:12 _ 0
11:11 _ 0
10:10 _ 0
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddress:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
integer m = UInt(Xm);
boolean setflags = FALSE;

TAG:aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddress:index
Execute: aarch64/integer/arithmetic/pointer/mcsubtracttaggedaddress:execute
Decode: aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddress:decode@aarch64/instrs/integer/arithmetic/pointer/mcsubtracttaggedaddress:diagram
TAG:aarch64/integer/tags/mcaddtag:execute
bits(64) operand1 = if n == 31 then SP[] else X[n];
bits(4) start_tag = AArch64.AllocationTagFromAddress(operand1);
bits(16) exclude = GCR_EL1.Exclude;
bits(64) result;
bits(4) rtag;

if AArch64.AllocationTagAccessIsEnabled() then
    rtag = AArch64.ChooseNonExcludedTag(start_tag, tag_offset, exclude);
else
    rtag = '0000';

if ADD then
    (result, -) = AddWithCarry(operand1, offset, '0');
else
    (result, -) = AddWithCarry(operand1, NOT(offset), '1');

result = AArch64.AddressWithAllocationTag(result, rtag);

if d == 31 then
    SP[] = result;
else
    X[d] = result;
TAG:aarch64/instrs/integer/tags/mcaddtag:diagram
A64
31:31 _ 1
30:30 _ 0
29:29 _ 0
28:23 _ 100011
22:22 _ 0
21:16 uimm6 xxxxxx
15:14 op3 xx
13:10 uimm4 xxxx
9:5 Xn xxxxx
4:0 Xd xxxxx
TAG:aarch64/instrs/integer/tags/mcaddtag:decode
integer d = UInt(Xd);
integer n = UInt(Xn);
bits(4) tag_offset = uimm4;
bits(64) offset = LSL(ZeroExtend(uimm6, 64), LOG2_TAG_GRANULE);
boolean ADD = TRUE;

TAG:aarch64/integer/tags/mcaddtag:index
Execute: aarch64/integer/tags/mcaddtag:execute
Decode: aarch64/instrs/integer/tags/mcaddtag:decode@aarch64/instrs/integer/tags/mcaddtag:diagram
TAG:LD1ROB-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
if VL < 256 then UNDEFINED;
integer elements = 256 DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g]; // low bits only
bits(64) offset;
bits(256) result;
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

offset = X[m];

addr = base + UInt(offset) * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_NORMAL];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = ZeroExtend(Replicate(result, VL DIV 256), VL);
TAG:LD1ROB-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 0
23:23 _ 0
22:21 _ 01
20:16 Rm xxxxx
15:13 _ 000
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1ROB-Z.P.BR-Contiguous:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;

TAG:LD1ROB-Z.P.BR-Contiguous:index
Execute: LD1ROB-Z.P.BR-Contiguous:execute
Decode: LD1ROB-Z.P.BR-Contiguous:decode@LD1ROB-Z.P.BR-Contiguous:diagram
TAG:LDFF1SH-Z.P.BZ-S.x32.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(VL) offset;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];
offset = Z[m];

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        integer off = Int(Elem[offset, e, esize][offs_size-1:0], offs_unsigned);
        addr = base + (off << scale);
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SH-Z.P.BZ-S.x32.scaled:diagram
A64
31:23 _ 100001001
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-S.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LDFF1SH-Z.P.BZ-D.x32.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-D.x32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 1;

TAG:LDFF1SH-Z.P.BZ-D.x32.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-D.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1SH-Z.P.BZ-S.x32.unscaled:diagram
A64
31:25 _ 1000010
24:24 _ 0
23:23 _ 1
22:22 xs x
21:21 _ 0
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-S.x32.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offs_size = 32;
boolean unsigned = FALSE;
boolean offs_unsigned = xs == '0';
integer scale = 0;

TAG:LDFF1SH-Z.P.BZ-D.64.scaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-D.64.scaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 1;

TAG:LDFF1SH-Z.P.BZ-D.64.unscaled:diagram
A64
31:25 _ 1100010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 Zm xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SH-Z.P.BZ-D.64.unscaled:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Zm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offs_size = 64;
boolean unsigned = FALSE;
boolean offs_unsigned = TRUE;
integer scale = 0;

TAG:LDFF1SH-Z.P.BZ-S.x32.scaled:index
Execute: LDFF1SH-Z.P.BZ-S.x32.scaled:execute
Decode: LDFF1SH-Z.P.BZ-S.x32.scaled:decode@LDFF1SH-Z.P.BZ-S.x32.scaled:diagram
Decode: LDFF1SH-Z.P.BZ-D.x32.scaled:decode@LDFF1SH-Z.P.BZ-D.x32.scaled:diagram
Decode: LDFF1SH-Z.P.BZ-D.x32.unscaled:decode@LDFF1SH-Z.P.BZ-D.x32.unscaled:diagram
Decode: LDFF1SH-Z.P.BZ-S.x32.unscaled:decode@LDFF1SH-Z.P.BZ-S.x32.unscaled:diagram
Decode: LDFF1SH-Z.P.BZ-D.64.scaled:decode@LDFF1SH-Z.P.BZ-D.64.scaled:diagram
Decode: LDFF1SH-Z.P.BZ-D.64.unscaled:decode@LDFF1SH-Z.P.BZ-D.64.unscaled:diagram
TAG:aarch64/vector/crypto/sha3/eor3:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
bits(128) Va = V[a];
V[d] = Vn EOR Vm EOR Va;
TAG:aarch64/instrs/vector/crypto/sha3/eor3:diagram
A64
31:23 _ 110011100
22:21 _ 00
20:16 Rm xxxxx
15:15 _ 0
14:10 Ra xxxxx
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3/eor3:decode
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

integer a = UInt(Ra);

TAG:aarch64/vector/crypto/sha3/eor3:index
Execute: aarch64/vector/crypto/sha3/eor3:execute
Decode: aarch64/instrs/vector/crypto/sha3/eor3:decode@aarch64/instrs/vector/crypto/sha3/eor3:diagram
TAG:aarch64/vector/reduce/fp16-add/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand = V[n];
V[d] = Reduce(op, operand, esize);
TAG:aarch64/instrs/vector/reduce/fp16-add/sisd:diagram
A64
31:30 _ 01
29:29 _ 0
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:17 _ 11000
16:12 _ 01101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp16-add/sisd:decode
if !HaveFP16Ext() then UNDEFINED;

integer d = UInt(Rd);
integer n = UInt(Rn);
integer esize = 16;
if sz == '1' then UNDEFINED;
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = ReduceOp_FADD;

TAG:aarch64/instrs/vector/reduce/fp-add/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:24 _ 11110
23:23 _ 0
22:22 sz x
21:17 _ 11000
16:12 _ 01101
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/reduce/fp-add/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer esize = 32 << UInt(sz);
integer datasize = esize * 2;
integer elements = 2;

ReduceOp op = ReduceOp_FADD;

TAG:aarch64/vector/reduce/fp16-add/sisd:index
Execute: aarch64/vector/reduce/fp16-add/sisd:execute
Decode: aarch64/instrs/vector/reduce/fp16-add/sisd:decode@aarch64/instrs/vector/reduce/fp16-add/sisd:diagram
Decode: aarch64/instrs/vector/reduce/fp-add/sisd:decode@aarch64/instrs/vector/reduce/fp-add/sisd:diagram
TAG:FSCALE-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    integer element2 = SInt(Elem[operand2, e, esize]);
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPScale(element1, element2, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FSCALE-Z.P.ZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:20 _ 00
19:17 _ 100
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:FSCALE-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);

TAG:FSCALE-Z.P.ZZ-_:index
Execute: FSCALE-Z.P.ZZ-_:execute
Decode: FSCALE-Z.P.ZZ-_:decode@FSCALE-Z.P.ZZ-_:diagram
TAG:REV-Z.Z-_:execute
CheckSVEEnabled();
bits(VL) operand = Z[n];
bits(VL) result = Reverse(operand, esize);
Z[d] = result;
TAG:REV-Z.Z-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:10 _ 111000001110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:REV-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:REV-Z.Z-_:index
Execute: REV-Z.Z-_:execute
Decode: REV-Z.Z-_:decode@REV-Z.Z-_:diagram
TAG:aarch64/vector/shift/right-insert/sisd:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand  = V[n];
bits(datasize) operand2 = V[d];
bits(datasize) result;
bits(esize) mask = LSR(Ones(esize), shift);
bits(esize) shifted;

for e = 0 to elements-1
    shifted = LSR(Elem[operand, e, esize], shift);
    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;
V[d] = result;
TAG:aarch64/instrs/vector/shift/right-insert/sisd:diagram
A64
31:30 _ 01
29:29 _ 1
28:23 _ 111110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-insert/sisd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh[3] != '1' then UNDEFINED;
integer esize = 8 << 3;
integer datasize = esize;
integer elements = 1;

integer shift = (esize * 2) - UInt(immh:immb);

TAG:aarch64/instrs/vector/shift/right-insert/simd:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:23 _ 011110
22:19 immh xxxx
18:16 immb xxx
15:11 _ 01000
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/shift/right-insert/simd:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if immh == '0000' then SEE(asimdimm);
if immh[3]:Q == '10' then UNDEFINED;
integer esize = 8 << HighestSetBit(immh);
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

integer shift = (esize * 2) - UInt(immh:immb);

TAG:aarch64/vector/shift/right-insert/sisd:index
Execute: aarch64/vector/shift/right-insert/sisd:execute
Decode: aarch64/instrs/vector/shift/right-insert/sisd:decode@aarch64/instrs/vector/shift/right-insert/sisd:diagram
Decode: aarch64/instrs/vector/shift/right-insert/simd:decode@aarch64/instrs/vector/shift/right-insert/simd:diagram
TAG:ST1H-Z.P.AI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(VL) src = Z[t];
bits(PL) mask = P[g];
bits(64) addr;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
TAG:ST1H-Z.P.AI-S:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 11
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.AI-S:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
integer offset = UInt(imm5);

TAG:ST1H-Z.P.AI-D:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 10
20:16 imm5 xxxxx
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:ST1H-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
integer offset = UInt(imm5);

TAG:ST1H-Z.P.AI-S:index
Execute: ST1H-Z.P.AI-S:execute
Decode: ST1H-Z.P.AI-S:decode@ST1H-Z.P.AI-S:diagram
Decode: ST1H-Z.P.AI-D:decode@ST1H-Z.P.AI-D:diagram
TAG:LD1SH-Z.P.BR-S32:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
bits(64) offset = X[m];
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();
    offset = offset + 1;

Z[t] = result;
TAG:LD1SH-Z.P.BR-S32:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BR-S32:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 32;
integer msize = 16;
boolean unsigned = FALSE;

TAG:LD1SH-Z.P.BR-S64:diagram
A64
31:25 _ 1010010
24:22 _ 100
21:21 _ 0
20:16 Rm xxxxx
15:13 _ 010
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LD1SH-Z.P.BR-S64:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 16;
boolean unsigned = FALSE;

TAG:LD1SH-Z.P.BR-S32:index
Execute: LD1SH-Z.P.BR-S32:execute
Decode: LD1SH-Z.P.BR-S32:decode@LD1SH-Z.P.BR-S32:diagram
Decode: LD1SH-Z.P.BR-S64:decode@LD1SH-Z.P.BR-S64:diagram
TAG:aarch64/vector/transfer/integer/dup:execute
CheckFPAdvSIMDEnabled64();
bits(esize) element = X[n];
bits(datasize) result;

for e = 0 to elements-1
    Elem[result, e, esize] = element;
V[d] = result;
TAG:aarch64/instrs/vector/transfer/integer/dup:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:21 _ 01110000
20:16 imm5 xxxxx
15:15 _ 0
14:11 _ 0001
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/transfer/integer/dup:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

integer size = LowestSetBit(imm5);
if size > 3 then UNDEFINED;

// imm5[4:size+1] is IGNORED

if size == 3 && Q == '0' then UNDEFINED;
integer esize = 8 << size;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/transfer/integer/dup:index
Execute: aarch64/vector/transfer/integer/dup:execute
Decode: aarch64/instrs/vector/transfer/integer/dup:decode@aarch64/instrs/vector/transfer/integer/dup:diagram
TAG:LDNF1SW-Z.P.BI-S64:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        // MemNF[] will return fault=TRUE if access is not performed for any reason
        (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

    addr = addr + mbytes;

Z[t] = result;
TAG:LDNF1SW-Z.P.BI-S64:diagram
A64
31:25 _ 1010010
24:22 _ 010
21:21 _ 0
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 101
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNF1SW-Z.P.BI-S64:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;
integer offset = SInt(imm4);

TAG:LDNF1SW-Z.P.BI-S64:index
Execute: LDNF1SW-Z.P.BI-S64:execute
Decode: LDNF1SW-Z.P.BI-S64:decode@LDNF1SW-Z.P.BI-S64:diagram
TAG:ST4B-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = X[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
    offset = offset + nreg;
TAG:ST4B-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 11
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4B-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 8;
integer nreg = 4;

TAG:ST4B-Z.P.BR-Contiguous:index
Execute: ST4B-Z.P.BR-Contiguous:execute
Decode: ST4B-Z.P.BR-Contiguous:decode@ST4B-Z.P.BR-Contiguous:diagram
TAG:ST1W-Z.P.BI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) src = Z[t];
constant integer mbytes = msize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_NORMAL] = Elem[src, e, esize][msize-1:0];
    addr = addr + mbytes;
TAG:ST1W-Z.P.BI-_:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 0
22:21 size xx
20:20 _ 0
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST1W-Z.P.BI-_:decode
if !HaveSVE() then UNDEFINED;
if size != '1x' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8 << UInt(size);
integer msize = 32;
integer offset = SInt(imm4);

TAG:ST1W-Z.P.BI-_:index
Execute: ST1W-Z.P.BI-_:execute
Decode: ST1W-Z.P.BI-_:decode@ST1W-Z.P.BI-_:diagram
TAG:UQADD-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);

Z[dn] = result;
TAG:UQADD-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 10
16:16 _ 1
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:UQADD-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;
boolean unsigned = TRUE;

TAG:UQADD-Z.ZI-_:index
Execute: UQADD-Z.ZI-_:execute
Decode: UQADD-Z.ZI-_:decode@UQADD-Z.ZI-_:diagram
TAG:ADR-Z.AZ-SD.same.scaled:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(VL) offs = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) addr = Elem[base, e, esize];
    integer offset = Int(Elem[offs, e, esize][osize-1:0], unsigned);
    Elem[result, e, esize] = addr + (offset * mbytes);

Z[d] = result;
TAG:ADR-Z.AZ-SD.same.scaled:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 sz x
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1010
11:10 msz xx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ADR-Z.AZ-SD.same.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32 << UInt(sz);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer osize = esize;
boolean unsigned = TRUE;
integer mbytes = 1 << UInt(msz);

TAG:ADR-Z.AZ-D.s32.scaled:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1010
11:10 msz xx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ADR-Z.AZ-D.s32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer osize = 32;
boolean unsigned = FALSE;
integer mbytes = 1 << UInt(msz);

TAG:ADR-Z.AZ-D.u32.scaled:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:12 _ 1010
11:10 msz xx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:ADR-Z.AZ-D.u32.scaled:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer osize = 32;
boolean unsigned = TRUE;
integer mbytes = 1 << UInt(msz);

TAG:ADR-Z.AZ-SD.same.scaled:index
Execute: ADR-Z.AZ-SD.same.scaled:execute
Decode: ADR-Z.AZ-SD.same.scaled:decode@ADR-Z.AZ-SD.same.scaled:diagram
Decode: ADR-Z.AZ-D.s32.scaled:decode@ADR-Z.AZ-D.s32.scaled:diagram
Decode: ADR-Z.AZ-D.u32.scaled:decode@ADR-Z.AZ-D.u32.scaled:diagram
TAG:aarch64/vector/bfmmla:execute
CheckFPAdvSIMDEnabled64();
bits(128) op1 = V[n];
bits(128) op2 = V[m];
bits(128) acc = V[d];

V[d] = BFMatMulAdd(acc, op1, op2);
TAG:aarch64/instrs/vector/bfmmla:diagram
A64
31:31 _ 0
30:30 _ 1
29:29 _ 1
28:24 _ 01110
23:22 _ 01
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:11 _ 1101
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/bfmmla:decode
if !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Rd);

TAG:aarch64/vector/bfmmla:index
Execute: aarch64/vector/bfmmla:execute
Decode: aarch64/instrs/vector/bfmmla:decode@aarch64/instrs/vector/bfmmla:diagram
TAG:CLS-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = CountLeadingSignBits(element)[esize-1:0];

Z[d] = result;
TAG:CLS-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 0
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:CLS-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:CLS-Z.P.Z-_:index
Execute: CLS-Z.P.Z-_:execute
Decode: CLS-Z.P.Z-_:decode@CLS-Z.P.Z-_:diagram
TAG:PRFW-I.P.BI-S:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(64) base;
bits(64) addr;

if n == 31 then
    base = SP[];
else
    base = X[n];

addr = base + ((offset * elements) << scale);
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Hint_Prefetch(addr, pref_hint, level, stream);
    addr = addr + (1 << scale);
TAG:PRFW-I.P.BI-S:diagram
A64
31:22 _ 1000010111
21:16 imm6 xxxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 0
12:10 Pg xxx
9:5 Rn xxxxx
4:4 _ 0
3:0 prfop xxxx
TAG:PRFW-I.P.BI-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Rn);
integer level = UInt(prfop[2:1]);
boolean stream = (prfop[0] == '1');
pref_hint = if prfop[3] == '0' then Prefetch_READ else Prefetch_WRITE;
integer scale = 2;
integer offset = SInt(imm6);

TAG:PRFW-I.P.BI-S:index
Execute: PRFW-I.P.BI-S:execute
Decode: PRFW-I.P.BI-S:decode@PRFW-I.P.BI-S:diagram
TAG:ST3D-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..2] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST3D-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 1
23:23 _ 1
22:21 _ 10
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST3D-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 64;
integer offset = SInt(imm4);
integer nreg = 3;

TAG:ST3D-Z.P.BI-Contiguous:index
Execute: ST3D-Z.P.BI-Contiguous:execute
Decode: ST3D-Z.P.BI-Contiguous:decode@ST3D-Z.P.BI-Contiguous:diagram
TAG:FNMLS-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element3;

Z[da] = result;
TAG:FNMLS-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 1
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FNMLS-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = FALSE;
boolean op3_neg = TRUE;

TAG:FNMLS-Z.P.ZZZ-_:index
Execute: FNMLS-Z.P.ZZZ-_:execute
Decode: FNMLS-Z.P.ZZZ-_:decode@FNMLS-Z.P.ZZZ-_:diagram
TAG:FSUBR-Z.P.ZS-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPSub(imm, element1, FPCR);
    else
        Elem[result, e, esize] = element1;

Z[dn] = result;
TAG:FSUBR-Z.P.ZS-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:19 _ 011
18:17 _ 01
16:16 _ 1
15:13 _ 100
12:10 Pg xxx
9:6 _ 0000
5:5 i1 x
4:0 Zdn xxxxx
TAG:FSUBR-Z.P.ZS-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
bits(esize) imm = if i1 == '0' then FPPointFive('0') else FPOne('0');

TAG:FSUBR-Z.P.ZS-_:index
Execute: FSUBR-Z.P.ZS-_:execute
Decode: FSUBR-Z.P.ZS-_:decode@FSUBR-Z.P.ZS-_:diagram
TAG:FNEG-Z.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = FPNeg(element);

Z[d] = result;
TAG:FNEG-Z.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 10
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FNEG-Z.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FNEG-Z.P.Z-_:index
Execute: FNEG-Z.P.Z-_:execute
Decode: FNEG-Z.P.Z-_:decode@FNEG-Z.P.Z-_:diagram
TAG:SDIV-Z.P.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[dn];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    integer element2 = Int(Elem[operand2, e, esize], unsigned);
    if ElemP[mask, e, esize] == '1' then
        integer quotient;
        if element2 == 0 then
            quotient = 0;
        else
            quotient = RoundTowardsZero(Real(element1) / Real(element2));
        Elem[result, e, esize] = quotient[esize-1:0];
    else
        Elem[result, e, esize] = Elem[operand1, e, esize];

Z[dn] = result;
TAG:SDIV-Z.P.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:18 _ 0101
17:17 _ 0
16:16 _ 0
15:13 _ 000
12:10 Pg xxx
9:5 Zm xxxxx
4:0 Zdn xxxxx
TAG:SDIV-Z.P.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '0x' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer dn = UInt(Zdn);
integer m = UInt(Zm);
boolean unsigned = FALSE;

TAG:SDIV-Z.P.ZZ-_:index
Execute: SDIV-Z.P.ZZ-_:execute
Decode: SDIV-Z.P.ZZ-_:decode@SDIV-Z.P.ZZ-_:diagram
TAG:LSR-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    Elem[result, e, esize] = LSR(element1, shift);

Z[d] = result;
TAG:LSR-Z.ZI-_:diagram
A64
31:24 _ 00000100
23:22 tszh xx
21:21 _ 1
20:19 tszl xx
18:16 imm3 xxx
15:12 _ 1001
11:11 _ 0
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:LSR-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
bits(4) tsize = tszh:tszl;
case tsize of
    when '0000' UNDEFINED;
    when '0001' esize = 8;
    when '001x' esize = 16;
    when '01xx' esize = 32;
    when '1xxx' esize = 64;
integer n = UInt(Zn);
integer d = UInt(Zd);
integer shift = (2 * esize) - UInt(tsize:imm3);

TAG:LSR-Z.ZI-_:index
Execute: LSR-Z.ZI-_:execute
Decode: LSR-Z.ZI-_:decode@LSR-Z.ZI-_:diagram
TAG:TRN1-Z.ZZ-_:execute
CheckSVEEnabled();
if VL < esize * 2 then UNDEFINED;
integer pairs = VL DIV (esize * 2);
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result = Zeros();

for p = 0 to pairs-1
    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];
    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];

Z[d] = result;
TAG:TRN1-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 10
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:TRN1-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:TRN1-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:TRN1-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 0;

TAG:TRN2-Z.ZZ-_:diagram
A64
31:24 _ 00000101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 011
12:11 _ 10
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:TRN2-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:TRN2-Z.ZZ-Q:diagram
A64
31:23 _ 000001011
22:22 _ 0
21:21 _ 1
20:16 Zm xxxxx
15:13 _ 000
12:11 _ 11
10:10 _ 1
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:TRN2-Z.ZZ-Q:decode
if !HaveSVEFP64MatMulExt() then UNDEFINED;
integer esize = 128;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);
integer part = 1;

TAG:TRN1-Z.ZZ-_:index
Execute: TRN1-Z.ZZ-_:execute
Decode: TRN1-Z.ZZ-_:decode@TRN1-Z.ZZ-_:diagram
Decode: TRN1-Z.ZZ-Q:decode@TRN1-Z.ZZ-Q:diagram
Decode: TRN2-Z.ZZ-_:decode@TRN2-Z.ZZ-_:diagram
Decode: TRN2-Z.ZZ-Q:decode@TRN2-Z.ZZ-Q:diagram
TAG:ST4B-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

for r = 0 to nreg-1
    values[r] = Z[(t+r) MOD 32];

addr = base + offset * elements * nreg * mbytes;
for e = 0 to elements-1
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            Mem[addr, mbytes, AccType_NORMAL] = Elem[values[r], e, esize];
        addr = addr + mbytes;
TAG:ST4B-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 0
22:21 _ 11
20:20 _ 1
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:ST4B-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 8;
integer offset = SInt(imm4);
integer nreg = 4;

TAG:ST4B-Z.P.BI-Contiguous:index
Execute: ST4B-Z.P.BI-Contiguous:execute
Decode: ST4B-Z.P.BI-Contiguous:decode@ST4B-Z.P.BI-Contiguous:diagram
TAG:LDFF1SW-Z.P.AI-D:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(VL) orig = Z[t];
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean first = TRUE;
boolean fault = FALSE;
boolean faulted = FALSE;
boolean unknown = FALSE;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        if first then
            // Mem[] will not return if a fault is detected for the first active element
            data = Mem[addr, mbytes, AccType_NORMAL];
            first = FALSE;
        else
            // MemNF[] will return fault=TRUE if access is not performed for any reason
            (data, fault) = MemNF[addr, mbytes, AccType_NONFAULT];
    else
        (data, fault) = (Zeros(msize), FALSE);

    // FFR elements set to FALSE following a supressed access/fault
    faulted = faulted || fault;
    if faulted then
        ElemFFR[e, esize] = '0';

    // Value becomes CONSTRAINED UNPREDICTABLE after an FFR element is FALSE
    unknown = unknown || ElemFFR[e, esize] == '0';
    if unknown then
        if !fault && ConstrainUnpredictableBool(Unpredictable_SVELDNFDATA) then
            Elem[result, e, esize] = Extend(data, esize, unsigned);
        elsif ConstrainUnpredictableBool(Unpredictable_SVELDNFZERO) then
            Elem[result, e, esize] = Zeros();
        else  // merge
            Elem[result, e, esize] = Elem[orig, e, esize];
    else
        Elem[result, e, esize] = Extend(data, esize, unsigned);

Z[t] = result;
TAG:LDFF1SW-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 1
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LDFF1SW-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LDFF1SW-Z.P.AI-D:index
Execute: LDFF1SW-Z.P.AI-D:execute
Decode: LDFF1SW-Z.P.AI-D:decode@LDFF1SW-Z.P.AI-D:diagram
TAG:FTSSEL-Z.ZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    Elem[result, e, esize] = FPTrigSSel(element1, element2);

Z[d] = result;
TAG:FTSSEL-Z.ZZ-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:11 _ 10110
10:10 _ 0
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FTSSEL-Z.ZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FTSSEL-Z.ZZ-_:index
Execute: FTSSEL-Z.ZZ-_:execute
Decode: FTSSEL-Z.ZZ-_:decode@FTSSEL-Z.ZZ-_:diagram
TAG:BRKA-P.P.P-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(PL) operand  = P[n];
bits(PL) operand2 = P[d];
boolean break = FALSE;
bits(PL) result;

for e = 0 to elements-1
    boolean element = ElemP[operand, e, esize] == '1';
    if ElemP[mask, e, esize] == '1' then
        ElemP[result, e, esize] = if !break then '1' else '0';
        break = break || element;
    elsif merging then
        ElemP[result, e, esize] = ElemP[operand2, e, esize];
    else
        ElemP[result, e, esize] = '0';

if setflags then
    PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:BRKA-P.P.P-_:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 0
21:14 _ 01000001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 M x
3:0 Pd xxxx
TAG:BRKA-P.P.P-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean merging = (M == '1');
boolean setflags = FALSE;

TAG:BRKAS-P.P.P-Z:diagram
A64
31:24 _ 00100101
23:23 _ 0
22:22 _ 1
21:14 _ 01000001
13:10 Pg xxxx
9:9 _ 0
8:5 Pn xxxx
4:4 _ 0
3:0 Pd xxxx
TAG:BRKAS-P.P.P-Z:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer g = UInt(Pg);
integer n = UInt(Pn);
integer d = UInt(Pd);
boolean merging = FALSE;
boolean setflags = TRUE;

TAG:BRKA-P.P.P-_:index
Execute: BRKA-P.P.P-_:execute
Decode: BRKA-P.P.P-_:decode@BRKA-P.P.P-_:diagram
Decode: BRKAS-P.P.P-Z:decode@BRKAS-P.P.P-Z:diagram
TAG:aarch64/vector/arithmetic/unary/extract/nosat:execute
CheckFPAdvSIMDEnabled64();
bits(2*datasize) operand = V[n];
bits(datasize) result;
bits(2*esize) element;

for e = 0 to elements-1
    element = Elem[operand, e, 2*esize];
    Elem[result, e, esize] = element[esize-1:0];
Vpart[d, part] = result;
TAG:aarch64/instrs/vector/arithmetic/unary/extract/nosat:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 0
28:24 _ 01110
23:22 size xx
21:17 _ 10000
16:12 _ 10010
11:10 _ 10
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/unary/extract/nosat:decode
integer d = UInt(Rd);
integer n = UInt(Rn);

if size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
integer datasize = 64;
integer part = UInt(Q);
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/unary/extract/nosat:index
Execute: aarch64/vector/arithmetic/unary/extract/nosat:execute
Decode: aarch64/instrs/vector/arithmetic/unary/extract/nosat:decode@aarch64/instrs/vector/arithmetic/unary/extract/nosat:diagram
TAG:aarch64/vector/crypto/sha3/rax1:execute
AArch64.CheckFPAdvSIMDEnabled();

bits(128) Vm = V[m];
bits(128) Vn = V[n];
V[d] = Vn EOR (ROL(Vm[127:64],1):ROL(Vm[63:0], 1));
TAG:aarch64/instrs/vector/crypto/sha3/rax1:diagram
A64
31:21 _ 11001110011
20:16 Rm xxxxx
15:15 _ 1
14:14 _ 0
13:12 _ 00
11:10 _ 11
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/crypto/sha3/rax1:decode
if !HaveSHA3Ext() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);

TAG:aarch64/vector/crypto/sha3/rax1:index
Execute: aarch64/vector/crypto/sha3/rax1:execute
Decode: aarch64/instrs/vector/crypto/sha3/rax1:decode@aarch64/instrs/vector/crypto/sha3/rax1:diagram
TAG:UCVTF-Z.P.Z-H2FP16:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand  = Z[n];
bits(VL) result = Z[d];

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    if ElemP[mask, e, esize] == '1' then
        bits(d_esize) fpval = FixedToFP(element[s_esize-1:0], 0, unsigned, FPCR, rounding);
        Elem[result, e, esize] = ZeroExtend(fpval);

Z[d] = result;
TAG:UCVTF-Z.P.Z-H2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 0
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-H2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 16;
integer d_esize = 16;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-W2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-W2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 16;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-W2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 0
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-W2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 32;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-W2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 0
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-W2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 32;
integer d_esize = 64;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-X2FP16:diagram
A64
31:24 _ 01100101
23:23 _ 0
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-X2FP16:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 16;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-X2S:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 0
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-X2S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 32;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-X2D:diagram
A64
31:24 _ 01100101
23:23 _ 1
22:22 _ 1
21:19 _ 010
18:18 _ 1
17:17 _ 1
16:16 _ 1
15:13 _ 101
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:UCVTF-Z.P.Z-X2D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Zd);
integer s_esize = 64;
integer d_esize = 64;
boolean unsigned = TRUE;
FPRounding rounding = FPRoundingMode(FPCR);

TAG:UCVTF-Z.P.Z-H2FP16:index
Execute: UCVTF-Z.P.Z-H2FP16:execute
Decode: UCVTF-Z.P.Z-H2FP16:decode@UCVTF-Z.P.Z-H2FP16:diagram
Decode: UCVTF-Z.P.Z-W2FP16:decode@UCVTF-Z.P.Z-W2FP16:diagram
Decode: UCVTF-Z.P.Z-W2S:decode@UCVTF-Z.P.Z-W2S:diagram
Decode: UCVTF-Z.P.Z-W2D:decode@UCVTF-Z.P.Z-W2D:diagram
Decode: UCVTF-Z.P.Z-X2FP16:decode@UCVTF-Z.P.Z-X2FP16:diagram
Decode: UCVTF-Z.P.Z-X2S:decode@UCVTF-Z.P.Z-X2S:diagram
Decode: UCVTF-Z.P.Z-X2D:decode@UCVTF-Z.P.Z-X2D:diagram
TAG:BFDOT-Z.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV 32;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];
    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];
    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];
    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];

    bits(32) sum = BFAdd(BFMul(elt1_a, elt2_a), BFMul(elt1_b, elt2_b));
    Elem[result, e, 32] = BFAdd(Elem[operand3, e, 32], sum);

Z[da] = result;
TAG:BFDOT-Z.ZZZ-_:diagram
A64
31:23 _ 011001000
22:22 _ 1
21:21 _ 1
20:16 Zm xxxxx
15:10 _ 100000
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:BFDOT-Z.ZZZ-_:decode
if !HaveSVE() || !HaveBF16Ext() then UNDEFINED;
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);

TAG:BFDOT-Z.ZZZ-_:index
Execute: BFDOT-Z.ZZZ-_:execute
Decode: BFDOT-Z.ZZZ-_:decode@BFDOT-Z.ZZZ-_:diagram
TAG:LDNT1W-Z.P.BI-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
constant integer mbytes = esize DIV 8;

if n == 31 then
    CheckSPAlignment();
    if HaveMTEExt() then SetTagCheckedInstruction(FALSE);
    base = SP[];
else
    if HaveMTEExt() then SetTagCheckedInstruction(TRUE);
    base = X[n];

addr = base + offset * elements * mbytes;
for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        Elem[result, e, esize] = Mem[addr, mbytes, AccType_STREAM];
    else
        Elem[result, e, esize] = Zeros();
    addr = addr + mbytes;

Z[t] = result;
TAG:LDNT1W-Z.P.BI-Contiguous:diagram
A64
31:25 _ 1010010
24:24 _ 1
23:23 _ 0
22:20 _ 000
19:16 imm4 xxxx
15:13 _ 111
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:LDNT1W-Z.P.BI-Contiguous:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer g = UInt(Pg);
integer esize = 32;
integer offset = SInt(imm4);

TAG:LDNT1W-Z.P.BI-Contiguous:index
Execute: LDNT1W-Z.P.BI-Contiguous:execute
Decode: LDNT1W-Z.P.BI-Contiguous:decode@LDNT1W-Z.P.BI-Contiguous:diagram
TAG:WHILELO-P.P.RR-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = Ones(PL);
bits(rsize) operand1 = X[n];
bits(rsize) operand2 = X[m];
bits(PL) result;
boolean last = TRUE;

for e = 0 to elements-1
    boolean cond;
    case op of
        when Cmp_LT cond = (Int(operand1, unsigned) <  Int(operand2, unsigned));
        when Cmp_LE cond = (Int(operand1, unsigned) <= Int(operand2, unsigned));

    last = last && cond;
    ElemP[result, e, esize] = if last then '1' else '0';
    operand1 = operand1 + 1;

PSTATE.[N,Z,C,V] = PredTest(mask, result, esize);
P[d] = result;
TAG:WHILELO-P.P.RR-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:21 _ 1
20:16 Rm xxxxx
15:13 _ 000
12:12 sf x
11:11 _ 1
10:10 _ 1
9:5 Rn xxxxx
4:4 _ 0
3:0 Pd xxxx
TAG:WHILELO-P.P.RR-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer rsize = 32 << UInt(sf);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer d = UInt(Pd);
boolean unsigned = TRUE;
SVECmp op = Cmp_LT;

TAG:WHILELO-P.P.RR-_:index
Execute: WHILELO-P.P.RR-_:execute
Decode: WHILELO-P.P.RR-_:decode@WHILELO-P.P.RR-_:diagram
TAG:STNT1H-Z.P.BR-Contiguous:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(64) offset = X[m];
bits(VL) src;
bits(PL) mask = P[g];
constant integer mbytes = esize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

if n == 31 then
    CheckSPAlignment();
    base = SP[];
else
    base = X[n];

src = Z[t];
for e = 0 to elements-1
    addr = base + UInt(offset) * mbytes;
    if ElemP[mask, e, esize] == '1' then
        Mem[addr, mbytes, AccType_STREAM] = Elem[src, e, esize];
    offset = offset + 1;
TAG:STNT1H-Z.P.BR-Contiguous:diagram
A64
31:25 _ 1110010
24:24 _ 0
23:23 _ 1
22:21 _ 00
20:16 Rm xxxxx
15:13 _ 011
12:10 Pg xxx
9:5 Rn xxxxx
4:0 Zt xxxxx
TAG:STNT1H-Z.P.BR-Contiguous:decode
if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Rn);
integer m = UInt(Rm);
integer g = UInt(Pg);
integer esize = 16;

TAG:STNT1H-Z.P.BR-Contiguous:index
Execute: STNT1H-Z.P.BR-Contiguous:execute
Decode: STNT1H-Z.P.BR-Contiguous:decode@STNT1H-Z.P.BR-Contiguous:diagram
TAG:SQADD-Z.ZI-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand1 = Z[dn];
bits(VL) result;

for e = 0 to elements-1
    integer element1 = Int(Elem[operand1, e, esize], unsigned);
    (Elem[result, e, esize], -) = SatQ(element1 + imm, esize, unsigned);

Z[dn] = result;
TAG:SQADD-Z.ZI-_:diagram
A64
31:24 _ 00100101
23:22 size xx
21:19 _ 100
18:17 _ 10
16:16 _ 0
15:14 _ 11
13:13 sh x
12:5 imm8 xxxxxxxx
4:0 Zdn xxxxx
TAG:SQADD-Z.ZI-_:decode
if !HaveSVE() then UNDEFINED;
if size:sh == '001' then UNDEFINED;
integer esize = 8 << UInt(size);
integer dn = UInt(Zdn);
integer imm = UInt(imm8);
if sh == '1' then imm = imm << 8;
boolean unsigned = FALSE;

TAG:SQADD-Z.ZI-_:index
Execute: SQADD-Z.ZI-_:execute
Decode: SQADD-Z.ZI-_:decode@SQADD-Z.ZI-_:diagram
TAG:aarch64/system/register/cpsr:execute
case field of
    when PSTATEField_SSBS
        PSTATE.SSBS = operand[0];
    when PSTATEField_SP
        PSTATE.SP = operand[0];
    when PSTATEField_DAIFSet
        PSTATE.D = PSTATE.D OR operand[3];
        PSTATE.A = PSTATE.A OR operand[2];
        PSTATE.I = PSTATE.I OR operand[1];
        PSTATE.F = PSTATE.F OR operand[0];
    when PSTATEField_DAIFClr
        PSTATE.D = PSTATE.D AND NOT(operand[3]);
        PSTATE.A = PSTATE.A AND NOT(operand[2]);
        PSTATE.I = PSTATE.I AND NOT(operand[1]);
        PSTATE.F = PSTATE.F AND NOT(operand[0]);
    when PSTATEField_PAN
        PSTATE.PAN = operand[0];
    when PSTATEField_UAO
        PSTATE.UAO = operand[0];
    when PSTATEField_DIT
        PSTATE.DIT = operand[0];
    when PSTATEField_TCO
        PSTATE.TCO = operand[0];
TAG:aarch64/instrs/system/register/cpsr:diagram
A64
31:22 _ 1101010100
21:21 _ 0
20:19 _ 00
18:16 op1 xxx
15:12 _ 0100
11:8 CRm xxxx
7:5 op2 xxx
4:0 _ 11111
TAG:aarch64/instrs/system/register/cpsr:decode
if op1 == '000' && op2 == '000' then SEE "CFINV";
if op1 == '000' && op2 == '001' then SEE "XAFLAG";
if op1 == '000' && op2 == '010' then SEE "AXFLAG";

AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');
bits(2) min_EL;
boolean need_secure;
(min_EL, need_secure) = AArch64.GetMinELSecurityState(op1);
if UInt(PSTATE.EL) < UInt(min_EL) || (need_secure && !IsSecure()) then
    UNDEFINED;

bits(4) operand = CRm;
PSTATEField field;
case op1:op2 of
    when '000 011'
        if !HaveUAOExt() then
            UNDEFINED;
        field = PSTATEField_UAO;
    when '000 100'
        if !HavePANExt() then
            UNDEFINED;
        field = PSTATEField_PAN;
    when '000 101' field = PSTATEField_SP;
    when '011 010'
        if !HaveDITExt() then
            UNDEFINED;
        field = PSTATEField_DIT;
    when '011 100'
        if !HaveMTEExt() then
            UNDEFINED;
        field = PSTATEField_TCO;
    when '011 110' field = PSTATEField_DAIFSet;
    when '011 111' field = PSTATEField_DAIFClr;
    when '011 001'
        if !HaveSSBSExt() then
            UNDEFINED;
        field = PSTATEField_SSBS;
    otherwise      UNDEFINED;

// Check that an AArch64 MSR/MRS access to the DAIF flags is permitted
if PSTATE.EL == EL0 && field IN {PSTATEField_DAIFSet, PSTATEField_DAIFClr}  then
    if !ELUsingAArch32(EL1) && ((EL2Enabled() && HCR_EL2.[E2H,TGE] == '11') || SCTLR_EL1.UMA == '0') then
        if EL2Enabled() && !ELUsingAArch32(EL2) && HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x18);
        else
            AArch64.SystemAccessTrap(EL1, 0x18);

TAG:aarch64/system/register/cpsr:index
Execute: aarch64/system/register/cpsr:execute
Decode: aarch64/instrs/system/register/cpsr:decode@aarch64/instrs/system/register/cpsr:diagram
TAG:INCB-R.RS-_:execute
CheckSVEEnabled();
integer count = DecodePredCount(pat, esize);
bits(64) operand1 = X[dn];

X[dn] = operand1 + (count * imm);
TAG:INCB-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:INCB-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCD-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:INCD-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCH-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 0
22:22 _ 1
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:INCH-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCW-R.RS-_:diagram
A64
31:24 _ 00000100
23:23 _ 1
22:22 _ 0
21:20 _ 11
19:16 imm4 xxxx
15:11 _ 11100
10:10 _ 0
9:5 pattern xxxxx
4:0 Rdn xxxxx
TAG:INCW-R.RS-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer dn = UInt(Rdn);
bits(5) pat = pattern;
integer imm = UInt(imm4) + 1;

TAG:INCB-R.RS-_:index
Execute: INCB-R.RS-_:execute
Decode: INCB-R.RS-_:decode@INCB-R.RS-_:diagram
Decode: INCD-R.RS-_:decode@INCD-R.RS-_:diagram
Decode: INCH-R.RS-_:decode@INCH-R.RS-_:diagram
Decode: INCW-R.RS-_:decode@INCW-R.RS-_:diagram
TAG:aarch64/integer/pac/autdb/dp_1src:execute
auth_then_branch = FALSE;

if HavePACExt() then
    if source_is_sp then
        X[d] = AuthDB(X[d], SP[], auth_then_branch);
    else
        X[d] = AuthDB(X[d], X[n], auth_then_branch);
TAG:aarch64/instrs/integer/pac/autdb/dp_1src:diagram
A64
31:31 _ 1
30:30 _ 1
29:29 _ 0
28:21 _ 11010110
20:16 _ 00001
15:15 _ 0
14:14 _ 0
13:13 Z x
12:10 _ 111
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/integer/pac/autdb/dp_1src:decode
boolean source_is_sp = FALSE;
integer d = UInt(Rd);
integer n = UInt(Rn);

if !HavePACExt() then
    UNDEFINED;

if Z == '0' then // AUTDB
    if n == 31 then source_is_sp = TRUE;
else // AUTDZB
    if n != 31 then UNDEFINED;

TAG:aarch64/integer/pac/autdb/dp_1src:index
Execute: aarch64/integer/pac/autdb/dp_1src:execute
Decode: aarch64/instrs/integer/pac/autdb/dp_1src:decode@aarch64/instrs/integer/pac/autdb/dp_1src:diagram
TAG:aarch64/vector/arithmetic/binary/uniform/add/fp/complex:execute
CheckFPAdvSIMDEnabled64();
bits(datasize) operand1 = V[n];
bits(datasize) operand2 = V[m];
bits(datasize) operand3 = V[d];
bits(datasize) result;
bits(esize) element1;
bits(esize) element3;

for e = 0 to (elements DIV 2) -1 
    case rot of 
        when '0'
            element1 = FPNeg(Elem[operand2, e*2+1, esize]); 
            element3 = Elem[operand2, e*2, esize];
        when '1'
            element1 = Elem[operand2, e*2+1, esize]; 
            element3 = FPNeg(Elem[operand2, e*2, esize]);   
    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);
    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);

V[d] = result;
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex:diagram
A64
31:31 _ 0
30:30 Q x
29:29 _ 1
28:24 _ 01110
23:22 size xx
21:21 _ 0
20:16 Rm xxxxx
15:15 _ 1
14:13 _ 11
12:12 rot x
11:11 _ 0
10:10 _ 1
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex:decode
if !HaveFCADDExt() then UNDEFINED;
integer d = UInt(Rd);
integer n = UInt(Rn);
integer m = UInt(Rm);
if size == '00' then UNDEFINED;
if Q == '0' && size == '11' then UNDEFINED;
integer esize = 8 << UInt(size);
if !HaveFP16Ext() && esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;

TAG:aarch64/vector/arithmetic/binary/uniform/add/fp/complex:index
Execute: aarch64/vector/arithmetic/binary/uniform/add/fp/complex:execute
Decode: aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex:decode@aarch64/instrs/vector/arithmetic/binary/uniform/add/fp/complex:diagram
TAG:FMUL-Z.ZZi-H:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
integer eltspersegment = 128 DIV esize;
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) result;

for e = 0 to elements-1
    integer segmentbase = e - (e MOD eltspersegment);
    integer s = segmentbase + index;
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, s, esize];
    Elem[result, e, esize] = FPMul(element1, element2, FPCR);

Z[d] = result;
TAG:FMUL-Z.ZZi-H:diagram
A64
31:24 _ 01100100
23:23 _ 0
22:22 i3h x
21:21 _ 1
20:19 i3l xx
18:16 Zm xxx
15:10 _ 001000
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FMUL-Z.ZZi-H:decode
if !HaveSVE() then UNDEFINED;
integer esize = 16;
integer index = UInt(i3h:i3l);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FMUL-Z.ZZi-S:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 0
21:21 _ 1
20:19 i2 xx
18:16 Zm xxx
15:10 _ 001000
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FMUL-Z.ZZi-S:decode
if !HaveSVE() then UNDEFINED;
integer esize = 32;
integer index = UInt(i2);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FMUL-Z.ZZi-D:diagram
A64
31:24 _ 01100100
23:23 _ 1
22:22 _ 1
21:21 _ 1
20:20 i1 x
19:16 Zm xxxx
15:10 _ 001000
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FMUL-Z.ZZi-D:decode
if !HaveSVE() then UNDEFINED;
integer esize = 64;
integer index = UInt(i1);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer d = UInt(Zd);

TAG:FMUL-Z.ZZi-H:index
Execute: FMUL-Z.ZZi-H:execute
Decode: FMUL-Z.ZZi-H:decode@FMUL-Z.ZZi-H:diagram
Decode: FMUL-Z.ZZi-S:decode@FMUL-Z.ZZi-S:diagram
Decode: FMUL-Z.ZZi-D:decode@FMUL-Z.ZZi-D:diagram
TAG:FMLA-Z.P.ZZZ-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand1 = Z[n];
bits(VL) operand2 = Z[m];
bits(VL) operand3 = Z[da];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element1 = Elem[operand1, e, esize];
    bits(esize) element2 = Elem[operand2, e, esize];
    bits(esize) element3 = Elem[operand3, e, esize];
    
    if ElemP[mask, e, esize] == '1' then
        if op1_neg then element1 = FPNeg(element1);
        if op3_neg then element3 = FPNeg(element3);
        Elem[result, e, esize] = FPMulAdd(element3, element1, element2, FPCR);
    else
        Elem[result, e, esize] = element3;

Z[da] = result;
TAG:FMLA-Z.P.ZZZ-_:diagram
A64
31:24 _ 01100101
23:22 size xx
21:21 _ 1
20:16 Zm xxxxx
15:15 _ 0
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zda xxxxx
TAG:FMLA-Z.P.ZZZ-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer m = UInt(Zm);
integer da = UInt(Zda);
boolean op1_neg = FALSE;
boolean op3_neg = FALSE;

TAG:FMLA-Z.P.ZZZ-_:index
Execute: FMLA-Z.P.ZZZ-_:execute
Decode: FMLA-Z.P.ZZZ-_:decode@FMLA-Z.P.ZZZ-_:diagram
TAG:aarch64/float/convert/fp:execute
CheckFPAdvSIMDEnabled64();

bits(dstsize) result;
bits(srcsize) operand = V[n];

result = FPConvert(operand, FPCR);
V[d] = result;
TAG:aarch64/instrs/float/convert/fp:diagram
A64
31:31 _ 0
30:30 _ 0
29:29 _ 0
28:24 _ 11110
23:22 ftype xx
21:21 _ 1
20:17 _ 0001
16:15 opc xx
14:10 _ 10000
9:5 Rn xxxxx
4:0 Rd xxxxx
TAG:aarch64/instrs/float/convert/fp:decode
integer d = UInt(Rd);
integer n = UInt(Rn);
integer srcsize;
integer dstsize;

if ftype == opc then UNDEFINED;

case ftype of
    when '00' srcsize = 32;
    when '01' srcsize = 64;
    when '10' UNDEFINED;
    when '11' srcsize = 16;
case opc of
    when '00' dstsize = 32;
    when '01' dstsize = 64;
    when '10' UNDEFINED;
    when '11' dstsize = 16;

TAG:aarch64/float/convert/fp:index
Execute: aarch64/float/convert/fp:execute
Decode: aarch64/instrs/float/convert/fp:decode@aarch64/instrs/float/convert/fp:diagram
TAG:ORV-R.P.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(PL) mask = P[g];
bits(VL) operand = Z[n];
bits(esize) result = Zeros(esize);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        result = result OR Elem[operand, e, esize];

V[d] = result;
TAG:ORV-R.P.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:19 _ 011
18:17 _ 00
16:16 _ 0
15:13 _ 001
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Vd xxxxx
TAG:ORV-R.P.Z-_:decode
if !HaveSVE() then UNDEFINED;
integer esize = 8 << UInt(size);
integer g = UInt(Pg);
integer n = UInt(Zn);
integer d = UInt(Vd);

TAG:ORV-R.P.Z-_:index
Execute: ORV-R.P.Z-_:execute
Decode: ORV-R.P.Z-_:decode@ORV-R.P.Z-_:diagram
TAG:LD1SW-Z.P.AI-D:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) base = Z[n];
bits(64) addr;
bits(PL) mask = P[g];
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;

if HaveMTEExt() then SetTagCheckedInstruction(TRUE);

for e = 0 to elements-1
    if ElemP[mask, e, esize] == '1' then
        addr = ZeroExtend(Elem[base, e, esize], 64) + offset * mbytes;
        data = Mem[addr, mbytes, AccType_NORMAL];
        Elem[result, e, esize] = Extend(data, esize, unsigned);
    else
        Elem[result, e, esize] = Zeros();

Z[t] = result;
TAG:LD1SW-Z.P.AI-D:diagram
A64
31:25 _ 1100010
24:24 _ 1
23:23 _ 0
22:21 _ 01
20:16 imm5 xxxxx
15:15 _ 1
14:14 _ 0
13:13 _ 0
12:10 Pg xxx
9:5 Zn xxxxx
4:0 Zt xxxxx
TAG:LD1SW-Z.P.AI-D:decode
if !HaveSVE() then UNDEFINED;
integer t = UInt(Zt);
integer n = UInt(Zn);
integer g = UInt(Pg);
integer esize = 64;
integer msize = 32;
boolean unsigned = FALSE;
integer offset = UInt(imm5);

TAG:LD1SW-Z.P.AI-D:index
Execute: LD1SW-Z.P.AI-D:execute
Decode: LD1SW-Z.P.AI-D:decode@LD1SW-Z.P.AI-D:diagram
TAG:FEXPA-Z.Z-_:execute
CheckSVEEnabled();
integer elements = VL DIV esize;
bits(VL) operand  = Z[n];
bits(VL) result;

for e = 0 to elements-1
    bits(esize) element = Elem[operand, e, esize];
    Elem[result, e, esize] = FPExpA(element);

Z[d] = result;
TAG:FEXPA-Z.Z-_:diagram
A64
31:24 _ 00000100
23:22 size xx
21:21 _ 1
20:17 _ 0000
16:16 _ 0
15:10 _ 101110
9:5 Zn xxxxx
4:0 Zd xxxxx
TAG:FEXPA-Z.Z-_:decode
if !HaveSVE() then UNDEFINED;
if size == '00' then UNDEFINED;
integer esize = 8 << UInt(size);
integer n = UInt(Zn);
integer d = UInt(Zd);

TAG:FEXPA-Z.Z-_:index
Execute: FEXPA-Z.Z-_:execute
Decode: FEXPA-Z.Z-_:decode@FEXPA-Z.Z-_:diagram
