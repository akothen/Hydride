{"NeonOperationId_00001": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;", "NeonOperationId_00002": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00003": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00004": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00005": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\n\nV[d] = result;", "NeonOperationId_00006": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\n\nV[d] = result;", "NeonOperationId_00007": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00008": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\n\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nV[d] = result;", "NeonOperationId_00009": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\n\nVpart[d, part] = result;", "NeonOperationId_00010": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    Elem[result, e, esize] = product;\n\nV[d] = result;", "NeonOperationId_00011": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00012": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[n] else Zeros();\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMulX(element1, element2, fpcr);\nV[d] = result;", "NeonOperationId_00013": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPDiv(element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00014": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n\nV[d] = result;", "NeonOperationId_00015": "OperationNo operation information.", "NeonOperationId_00016": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    Elem[result, e, 2*esize] = accum;\n\nV[d] = result;", "NeonOperationId_00017": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00018": "OperationCheckFPAdvSIMDEnabled64();\n\nbits(esize) operanda = V[a];\nbits(esize) operand1 = V[n];\nbits(esize) operand2 = V[m];\n\nFPCRType fpcr = FPCR[];\nboolean merge    = IsMerging(fpcr);\nbits(128) result = if merge then V[a] else Zeros();\n\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nElem[result, 0, esize] = FPMulAdd(operanda, operand1, operand2, fpcr);\n\nV[d] = result;", "NeonOperationId_00019": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00020": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00021": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00022": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);\n\nV[d] = result;", "NeonOperationId_00023": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00024": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\nFPCRType fpcr = FPCR[];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, fpcr);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;", "NeonOperationId_00025": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\n\nV[d] = result;", "NeonOperationId_00026": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00027": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;", "NeonOperationId_00028": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[m] else Zeros();\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, fpcr);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, fpcr);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, fpcr);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;", "NeonOperationId_00029": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;", "NeonOperationId_00030": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR[]);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR[]);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR[]);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR[]);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR[]);\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;", "NeonOperationId_00031": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\n\nV[d] = result;", "NeonOperationId_00032": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nV[d] = result;", "NeonOperationId_00033": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[n] else Zeros();\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, fpcr);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\n\nV[d] = result;", "NeonOperationId_00034": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\n\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nV[d] = result;", "NeonOperationId_00035": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00036": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR[]);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00037": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR[]);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00038": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); // 0 for left shift, 2^(n-1) for right shift \n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00039": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00040": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);\n\nV[d] = result;", "NeonOperationId_00041": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00042": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\n\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\n\nVpart[d, part] = result;", "NeonOperationId_00043": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;", "NeonOperationId_00044": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;", "NeonOperationId_00045": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00046": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSR(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSR(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;", "NeonOperationId_00047": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSL(Ones(esize), shift);\nbits(esize) shifted;\n\nfor e = 0 to elements-1\n    shifted = LSL(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nV[d] = result;", "NeonOperationId_00048": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\n\nbits(esize) element;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, fpcr, rounding);\n\nV[d] = result;", "NeonOperationId_00049": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\n\nbits(esize) element;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, fpcr, rounding);\n\nV[d] = result;", "NeonOperationId_00050": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\n\nbits(esize) element;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, fpcr, rounding);\n\nV[d] = result;", "NeonOperationId_00051": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR[]);\n\nVpart[d, part] = result;", "NeonOperationId_00052": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR[]);\n\nV[d] = result;", "NeonOperationId_00053": "OperationCheckFPAdvSIMDEnabled64();\n\nbits(2*datasize) operand = V[n];\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\n\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], fpcr, FPRounding_ODD);\n\nif merge then\n    V[d] = result;\nelse\n    Vpart[d, part] = Elem[result, 0, datasize];", "NeonOperationId_00054": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR[], rounding, exact);\n\nV[d] = result;", "NeonOperationId_00055": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    Elem[result, e, esize] = element<esize-1:0>;\nVpart[d, part] = result;", "NeonOperationId_00056": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;", "NeonOperationId_00057": "OperationCheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);\n    if sat then FPSR.QC = '1';\n\nVpart[d, part] = result;", "NeonOperationId_00058": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    Elem[result, e, esize] = element<esize-1:0>;                \n\nV[d] = result;", "NeonOperationId_00059": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    Elem[result, e, esize] = element;\n\nV[d] = result;", "NeonOperationId_00060": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\n\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00061": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;", "NeonOperationId_00062": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\ninteger count;\nfor e = 0 to elements-1\n    count = BitCount(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nV[d] = result;", "NeonOperationId_00063": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRecipEstimate(element);\n\nV[d] = result;", "NeonOperationId_00064": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\n\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00065": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[n] else Zeros();\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\n\nV[d] = result;", "NeonOperationId_00066": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPSqrt(element, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00067": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);\n\nV[d] = result;", "NeonOperationId_00068": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\n\nbits(esize) element;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, fpcr);\n\nV[d] = result;", "NeonOperationId_00069": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\n\nbits(esize) element1;\nbits(esize) element2;\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[n] else Zeros();\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\n\nV[d] = result;", "NeonOperationId_00070": "OperationThe description of NOT gives the operational pseudocode for this instruction.", "NeonOperationId_00071": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nif invert then operand2 = NOT(operand2);\n\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\n\nV[d] = result;", "NeonOperationId_00072": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\n\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\n\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);", "NeonOperationId_00073": "OperationCheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(128) result;\n\nresult = V[d];\nElem[result, dst_index, esize] = Elem[operand, src_index, esize];\nV[d] = result;", "NeonOperationId_00074": "OperationCheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nelement = Elem[operand, index, esize];\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nV[d] = result;", "NeonOperationId_00075": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nbits(esize) rev;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    for i = 0 to esize-1\n        rev<esize-1-i> = element<i>;\n    Elem[result, e, esize] = rev;\n\nV[d] = result;", "NeonOperationId_00076": "OperationCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger tt;\nconstant integer ebytes = esize DIV 8;\n\nif HaveMTE2Ext() then\n    SetTagCheckedInstruction(tag_checked);\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else // memop == MemOp_STORE\n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;", "NeonOperationId_00077": "Operationif HaveMTE2Ext() then\n    SetTagCheckedInstruction(tag_checked);\n\nCheckFPAdvSIMDEnabled64();\n\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\nconstant integer ebytes = esize DIV 8;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\noffs = Zeros();\nif replicate then\n    // load and replicate to all elements\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        // replicate to fill 128- or 64-bit register\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    // load/store one element per register\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            // insert into one lane of 128-bit register\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else // memop == MemOp_STORE\n            // extract from one lane of 128-bit register\n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n\nif wback then\n    if m != 31 then\n        offs = X[m];\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;", "NeonOperationId_00078": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[concat, 2*e, esize];\n    element2 = Elem[concat, (2*e)+1, esize];\n    Elem[result, e, esize] = element1 + element2;\n\nV[d] = result;", "NeonOperationId_00079": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\n\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\n\nif acc then result = V[d];\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    if acc then\n        Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\n    else\n        Elem[result, e, 2*esize] = sum;\n\nV[d] = result;", "NeonOperationId_00080": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\n\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00081": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);", "NeonOperationId_00082": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\n\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\n\nV[d] = sum<2*esize-1:0>;", "NeonOperationId_00083": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\n\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\n\nV[d] = maxmin<esize-1:0>;", "NeonOperationId_00084": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\n\nV[d] = Reduce(op, operand, esize);", "NeonOperationId_00085": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nboolean altfp = FALSE;\nV[d] = Reduce(op, operand, esize, altfp);", "NeonOperationId_00086": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) hi = V[m];\nbits(datasize) lo = V[n];\nbits(datasize*2) concat = hi : lo;\n\nV[d] = concat<position+datasize-1:position>;", "NeonOperationId_00087": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n\nV[d] = result;", "NeonOperationId_00088": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\ninteger base = part * pairs;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\n\nV[d] = result;", "NeonOperationId_00089": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\n\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\n\nV[d] = result;", "NeonOperationId_00090": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\n\nV[d] = result;", "NeonOperationId_00091": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\n\n// Create table from registers\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\n\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n\nV[d] = result;", "NeonOperationId_00092": "OperationCheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = ZeroExtend(Elem[operand, index, esize], datasize);", "NeonOperationId_00093": "OperationCheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\n\nX[d] = SignExtend(Elem[operand, index, esize], datasize);", "NeonOperationId_00094": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\n\nFPCRType fpcr    = FPCR[];\nboolean merge    = elements == 1 && IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecpX(element, fpcr);\n\nV[d] = result;", "NeonOperationId_00095": "Operationif HaveMTE2Ext() then\n    SetTagCheckedInstruction(tag_checked);\n\nCheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\n\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\n\nif ! postindex then\n    address = address + offset;\n\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\n\nif wback then\n    if postindex then\n        address = address + offset;\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;", "NeonOperationId_00096": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\n\nV[d] = result;", "NeonOperationId_00097": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nV[d] = result;", "NeonOperationId_00098": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;", "NeonOperationId_00099": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;", "NeonOperationId_00100": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) X = V[d];\nbits(32)  Y = V[n];     // Note: 32 not 128 bits wide\nbits(128) W = V[m];\nbits(32)  t;\n\nfor e = 0 to 3\n    t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nV[d] = X;", "NeonOperationId_00101": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(32) operand = V[n];        // read element [0] only,  [1-3] zeroed\nV[d] = ROL(operand, 30);", "NeonOperationId_00102": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\n\nresult = operand2<63:0> : operand1<127:64>;\nresult = result EOR operand1 EOR operand3;\nV[d] = result;", "NeonOperationId_00103": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand1 EOR LSR(operand2, 32);\nresult<31:0>   = ROL(T<31:0>,   1);\nresult<63:32>  = ROL(T<63:32>,  1);\nresult<95:64>  = ROL(T<95:64>,  1);\nresult<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\nV[d] = result;", "NeonOperationId_00104": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nV[d] = result;", "NeonOperationId_00105": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand2<31:0> : operand1<127:32>;\nbits(32) elt;\n\nfor e = 0 to 3\n    elt = Elem[T, e, 32];\n    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n    Elem[result, e, 32] = elt + Elem[operand1, e, 32];\nV[d] = result;", "NeonOperationId_00106": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nbits(128) T0 = operand3<31:0> : operand2<127:32>;\nbits(64) T1;\nbits(32) elt;\n\nT1 = operand3<127:64>;\nfor e = 0 to 1\n    elt = Elem[T1, e, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nT1 = result<63:0>;\nfor e = 2 to 3\n    elt = Elem[T1, e - 2, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\n\nV[d] = result;", "NeonOperationId_00107": "Operationbits(32)      acc     = X[n];   // accumulator\nbits(size)    val     = X[m];   // input value\nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\n\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\n\n// Poly32Mod2 on a bitstring does a polynomial Modulus over {0,1} operation\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));", "NeonOperationId_00108": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\n\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\n\nV[d] = result;", "NeonOperationId_00109": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\n\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        res = res + element1 * element2; \n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nV[d] = result;", "NeonOperationId_00110": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vtmp;  \nbits(64)  MSigma1;\nbits(64)  tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nMSigma1 =  ROR(Y<127:64>, 14) EOR ROR(Y<127:64>,18) EOR ROR(Y<127:64>,41);\nVtmp<127:64> =  (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);\nVtmp<127:64> = (Vtmp<127:64> + MSigma1 +  W<127:64>);\ntmp = Vtmp<127:64> + Y<63:0>;\nMSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);\nVtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);\nVtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);\nV[d] =  Vtmp;", "NeonOperationId_00111": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vtmp;  \nbits(64) NSigma0;\nbits(64) tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nNSigma0 =  ROR(Y<63:0>, 28) EOR ROR(Y<63:0>,34) EOR ROR(Y<63:0>,39);\nVtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<127:64> = (Vtmp<127:64> + NSigma0 +  W<127:64>);\nNSigma0 =  ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>,34) EOR ROR(Vtmp<127:64>,39);\nVtmp<63:0> =   (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<63:0> =   (Vtmp<63:0> + NSigma0 + W<63:0>);\n\nV[d] = Vtmp;", "NeonOperationId_00112": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(64) sig0;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) W = V[d]; \nsig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR ('0000000':W<127:71>);\nVtmp<63:0> = W<63:0> + sig0;\nsig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR ('0000000':X<63:7>);\nVtmp<127:64> = W<127:64> + sig0;\nV[d] = Vtmp;", "NeonOperationId_00113": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(64) sig1;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\n\nsig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>,61) EOR ('000000':X<127:70>);\nVtmp<127:64> = W<127:64> + sig1 + Y<127:64>;\nsig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>,61) EOR ('000000':X<63:6>);\nVtmp<63:0> = W<63:0> + sig1 + Y<63:0>;\nV[d] = Vtmp;", "NeonOperationId_00114": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR Vm EOR Va;", "NeonOperationId_00115": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nV[d] = Vn EOR (ROL(Vm<127:64>,1):ROL(Vm<63:0>, 1));", "NeonOperationId_00116": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) tmp;\ntmp = Vn EOR Vm; \nV[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));", "NeonOperationId_00117": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR (Vm AND NOT(Va));", "NeonOperationId_00118": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) Va = V[a];\nVd<127:96> = ROL((ROL(Vn<127:96>,12) + Vm<127:96> + Va<127:96>) , 7);\nVd<95:0> = Zeros();\nV[d] = Vd;", "NeonOperationId_00119": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;", "NeonOperationId_00120": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\n\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); \nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;", "NeonOperationId_00121": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\n\nWj = Elem[Vm,i,32];\nTT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;", "NeonOperationId_00122": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\n\nWj = Elem[Vm,i,32];\nTT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); \nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\n\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;", "NeonOperationId_00123": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \n\nresult<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>,15):ROL(Vm<95:64>,15):ROL(Vm<63:32>,15));\n\nfor i = 0 to 3\n    if i == 3 then \n        result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>,15));\n    result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>,15) EOR ROL(result<(32*i)+31:(32*i)>,23);\nV[d] = result;", "NeonOperationId_00124": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \nbits(128) tmp;\nbits(32) tmp2;\ntmp<127:0> = Vn EOR (ROL(Vm<127:96>,7):ROL(Vm<95:64>,7):ROL(Vm<63:32>,7):ROL(Vm<31:0>,7)); \nresult<127:0> = Vd<127:0> EOR tmp<127:0>;\ntmp2 = ROL(tmp<31:0>,15);\ntmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);\nresult<127:96> = result<127:96> EOR tmp2;\nV[d]= result;", "NeonOperationId_00125": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vn = V[n];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) roundresult;\nbits(32) roundkey;\n\nroundresult=V[d];\nfor index = 0 to 3\n    roundkey = Elem[Vn,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; \n\n    for i = 0 to 3  \n        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;", "NeonOperationId_00126": "OperationAArch64.CheckFPAdvSIMDEnabled();\n\nbits(128) Vm = V[m];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) result;\nbits(32) const;\nbits(128) roundresult;\n\nroundresult = V[n];\nfor index = 0 to 3 \n    const = Elem[Vm,index,32];\n\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; \n\n    for i = 0 to 3  \n        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); \n\n    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);\n    intval = intval EOR roundresult<31:0>; \n\n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nV[d] = roundresult;", "NeonOperationId_00127": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize DIV 2) operand1 = Vpart[n,part];\nbits(datasize DIV 2) operand2 = Vpart[m,part];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize DIV 2) element1;\nbits(esize DIV 2) element2;\n\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize DIV 2];\n    element2 = Elem[operand2, e, esize DIV 2];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result,e,esize] = FPMulAddH(Elem[operand3, e, esize], element1, element2, FPCR[]);\nV[d] = result;", "NeonOperationId_00128": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element3;\n\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '0'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element3 = Elem[operand2, e*2, esize];\n        when '1'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element3 = FPNeg(Elem[operand2, e*2, esize]);   \n    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR[]);\n    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR[]);\n\nV[d] = result;", "NeonOperationId_00129": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) element3;\nbits(esize) element4;\nFPCRType fpcr = FPCR[];\n\nfor e = 0 to (elements DIV 2) -1\n    case rot of\n        when '00'\n            element1 = Elem[operand2, e*2, esize];\n            element2 = Elem[operand1, e*2, esize];\n            element3 = Elem[operand2, e*2+1, esize];\n            element4 = Elem[operand1, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]);\n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = Elem[operand2, e*2, esize];\n            element4 = Elem[operand1, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand2, e*2, esize]);\n            element2 = Elem[operand1, e*2, esize];\n            element3 = FPNeg(Elem[operand2, e*2+1, esize]);\n            element4 = Elem[operand1, e*2, esize];\n        when '11'\n            element1 = Elem[operand2, e*2+1, esize];\n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = FPNeg(Elem[operand2, e*2, esize]);\n            element4 = Elem[operand1, e*2+1, esize];\n\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, fpcr);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, fpcr);\n\nV[d] = result;", "NeonOperationId_00130": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\n\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundIntN(element, FPCR[], rounding, intsize);\n\nV[d] = result;", "NeonOperationId_00131": "OperationCheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) addend   = V[d];\n\nV[d] = MatMulAdd(addend, operand1, operand2, op1_unsigned, op2_unsigned);", "NeonOperationId_00132": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(32) res = Elem[operand3, e, 32];\n    for b = 0 to 3\n        integer element1 = UInt(Elem[operand1, 4 * e + b, 8]);\n        integer element2 = SInt(Elem[operand2, 4 * e + b, 8]);\n        res = res + element1 * element2;\n    Elem[result, e, 32] = res;\n\nV[d] = result;", "NeonOperationId_00133": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128)      operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(32) res = Elem[operand3, e, 32];\n    for b = 0 to 3\n        integer element1 = Int(Elem[operand1, 4 * e + b, 8], op1_unsigned);\n        integer element2 = Int(Elem[operand2, 4 * i + b, 8], op2_unsigned);\n        res = res + element1 * element2;\n    Elem[result, e, 32] = res;\nV[d] = result;", "NeonOperationId_00134": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\ninteger element;\n\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\n\nV[d] = result;", "NeonOperationId_00135": "OperationCheckFPAdvSIMDEnabled64();\nbits(128) operand = V[n];\nbits(64) result;\n\nfor e = 0 to elements-1\n    Elem[result, e, 16] = FPConvertBF(Elem[operand, e, 32], FPCR[]);\n\nVpart[d, part] = result;", "NeonOperationId_00136": "OperationCheckFPAdvSIMDEnabled64();\n\nbits(32) operand = V[n];\nFPCRType fpcr    = FPCR[];\nboolean merge    = IsMerging(fpcr);\nbits(128) result = if merge then V[d] else Zeros();\n\nElem[result, 0, 16] = FPConvertBF(operand, fpcr);\n\nV[d] = result;", "NeonOperationId_00137": "OperationCheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\n\nfor e = 0 to elements-1\n    bits(16) elt1_a = Elem[operand1, 2 * e + 0, 16];\n    bits(16) elt1_b = Elem[operand1, 2 * e + 1, 16];\n    bits(16) elt2_a = Elem[operand2, 2 * e + 0, 16];\n    bits(16) elt2_b = Elem[operand2, 2 * e + 1, 16];\n\n    bits(32) sum = Elem[operand3, e, 32];\n    sum = BFDotAdd(sum, elt1_a, elt1_b, elt2_a, elt2_b, FPCR[]);\n    Elem[result, e, 32] = sum;\n\nV[d] = result;", "NeonOperationId_00138": "OperationCheckFPAdvSIMDEnabled64();\nbits(128) op1 = V[n];\nbits(128) op2 = V[m];\nbits(128) acc = V[d];\n\nV[d] = BFMatMulAdd(acc, op1, op2);", "NeonOperationId_00139": "OperationCheckFPAdvSIMDEnabled64();\nbits(128) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(128) operand3 = V[d];\nbits(128) result;\n\nfor e = 0 to elements-1\n    bits(32) element1 = Elem[operand1, 2 * e + sel, 16] : Zeros(16);\n    bits(32) element2 = Elem[operand2, 2 * e + sel, 16] : Zeros(16);\n    bits(32) addend   = Elem[operand3, e, 32];\n    Elem[result, e, 32] = BFMulAdd(addend, element1, element2, FPCR[]);\n\nV[d] = result;"}