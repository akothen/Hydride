<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>ESR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css" />
  </head>
  <body><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h1 class="register-section">ESR_EL2, Exception Syndrome Register (EL2)</h1><p>The ESR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Holds syndrome information for an exception taken to EL2.</p>
      <h2>Configuration</h2><p>AArch64 System register ESR_EL2 bits [31:0]
            
                are architecturally mapped to
              AArch32 System register <a href="AArch32-hsr.html">HSR[31:0]
            </a>.
          </p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>

      
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>
      <h2>Attributes</h2>
            <p>ESR_EL2 is a 64-bit register.</p>
          <h2>Field descriptions</h2><p>The ESR_EL2 bit assignments are:</p><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="6"><a href="#EC_31">EC</a></td><td class="lr" colspan="1"><a href="#IL_25">IL</a></td><td class="lr" colspan="25"><a href="#ISS_24">ISS</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields">
      
  <p>ESR_EL2 is made <span class="arm-defined-word">UNKNOWN</span> as a result of an exception return from EL2.</p>
<p>When an <span class="arm-defined-word">UNPREDICTABLE</span> instruction is treated as <span class="arm-defined-word">UNDEFINED</span>, and the exception is taken to EL2, the value of ESR_EL2 is <span class="arm-defined-word">UNKNOWN</span>. The value written to ESR_EL2 must be consistent with a value that could be created as a result of an exception from the same Exception level that generated the exception as a result of a situation that is not <span class="arm-defined-word">UNPREDICTABLE</span> at that Exception level, in order to avoid the possibility of a privilege violation.</p>

    </div><h4 id="0_63">
                Bits [63:32]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="EC_31">EC, bits [31:26]
                  </h4>
          
  <p>Exception Class. Indicates the reason for the exception that this register holds information about.</p>
<p>For each EC value, the table references a subsection that gives information about:</p>
<ul>
<li>The cause of the exception, for example the configuration required to enable the trap.
</li><li>The encoding of the associated ISS.
</li></ul>
<p>Possible values of the EC field are:</p>

          <table class="valuetable"><tr><th>EC</th><th>Meaning</th><th>ISS</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
  <p>Unknown reason.</p>
</td><td><a href="&#10;                #ISS_exceptionswithanunknownreason">ISS encoding for exceptions with an unknown reason</a></td></tr><tr><td class="bitfield">0b000001</td><td>
  <p>Trapped WFI or WFE instruction execution.</p>
<p>Conditional WFE and WFI instructions that fail their condition code check do not cause an exception.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaWFIorWFEinstruction">ISS encoding for an exception from a WFI or WFE instruction</a></td></tr><tr><td class="bitfield">0b000011</td><td>
  <p>Trapped MCR or MRC access with (coproc==<span class="binarynumber">0b1111</span>) that is not reported using EC <span class="binarynumber">0b000000</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanMCRorMRCaccess">ISS encoding for an exception from an MCR or MRC access</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b000100</td><td>
  <p>Trapped MCRR or MRRC access with (coproc==<span class="binarynumber">0b1111</span>) that is not reported using EC <span class="binarynumber">0b000000</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanMCRRorMRRCaccess">ISS encoding for an exception from an MCRR or MRRC access</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b000101</td><td>
  <p>Trapped MCR or MRC access with (coproc==<span class="binarynumber">0b1110</span>).</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanMCRorMRCaccess">ISS encoding for an exception from an MCR or MRC access</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b000110</td><td>
  <p>Trapped LDC or STC access.</p>
<p>The only architected uses of these instruction are:</p>
<ul>
<li>An STC to write data to memory from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.
</li><li>An LDC to read data from memory to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul>
</td><td><a href="&#10;                #ISS_anexceptionfromanLDCorSTCinstruction">ISS encoding for an exception from an LDC or STC instruction</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b000111</td><td>
  <p>Access to SVE, Advanced SIMD, or floating-point functionality trapped by <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.FPEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP, or <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP control.</p>
<p>Excludes exceptions resulting from <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> when the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, or because SVE or Advanced SIMD and floating-point are not implemented. These are reported with EC value <span class="binarynumber">0b000000</span> as described in <span class="xref">'EC encodings when routing exceptions to EL2' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section D1.10.4</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanaccesstoSVE,AdvancedSIMDorfloating-pointfunctionality,resultingfromCPACR_EL1.FPEN,CPTR_EL2.FPENorCPTR_ELx.TFP">ISS encoding for an exception from an access to SVE, Advanced SIMD or floating-point functionality, resulting from CPACR_EL1.FPEN, CPTR_EL2.FPEN or CPTR_ELx.TFP</a></td></tr><tr><td class="bitfield">0b001000</td><td>
  <p>Trapped VMRS access, from ID group trap, that is not reported using EC <span class="binarynumber">0b000111</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanMCRorMRCaccess">ISS encoding for an exception from an MCR or MRC access</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b001001</td><td>
  <p>Trapped use of a Pointer authentication instruction because HCR_EL2.API == 0 || SCR_EL3.API == 0.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaPointerAuthenticationinstructionwhenHCR_EL2.API0||SCR_EL3.API0">ISS encoding for an exception from a Pointer Authentication instruction when HCR_EL2.API == 0 || SCR_EL3.API == 0</a></td><td>When ARMv8.3-PAuth is implemented</td></tr><tr><td class="bitfield">0b001100</td><td>
  <p>Trapped MRRC access with (coproc==<span class="binarynumber">0b1110</span>).</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanMCRRorMRRCaccess">ISS encoding for an exception from an MCRR or MRRC access</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b001101</td><td>
  <p>Branch Target Exception.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromBranchTargetIdentificationinstruction">ISS encoding for an exception from Branch Target Identification instruction</a></td><td>When ARMv8.5-BTI is implemented</td></tr><tr><td class="bitfield">0b001110</td><td>
  <p>Illegal Execution state.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanIllegalExecutionstate,oraPCorSPalignmentfault">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b010001</td><td>
  <p>SVC instruction execution in AArch32 state.</p>
<p>This is reported in ESR_EL2 only when the exception is generated because the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromHVCorSVCinstructionexecution">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b010010</td><td>
  <p>HVC instruction execution in AArch32 state, when HVC is not disabled.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromHVCorSVCinstructionexecution">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b010011</td><td>
  <p>SMC instruction execution in AArch32 state, when SMC is not disabled.</p>
<p>This is reported in ESR_EL2 only when the exception is generated because the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC is 1.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromSMCinstructionexecutioninAArch32state">ISS encoding for an exception from SMC instruction execution in AArch32 state</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b010101</td><td>
  <p>SVC instruction execution in AArch64 state.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromHVCorSVCinstructionexecution">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch64 is supported at any Exception level</td></tr><tr><td class="bitfield">0b010110</td><td>
  <p>HVC instruction execution in AArch64 state, when HVC is not disabled.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromHVCorSVCinstructionexecution">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch64 is supported at any Exception level</td></tr><tr><td class="bitfield">0b010111</td><td>
  <p>SMC instruction execution in AArch64 state, when SMC is not disabled.</p>
<p>This is reported in ESR_EL2 only when the exception is generated because the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC is 1.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromSMCinstructionexecutioninAArch64state">ISS encoding for an exception from SMC instruction execution in AArch64 state</a></td><td>When AArch64 is supported at any Exception level</td></tr><tr><td class="bitfield">0b011000</td><td>
  <p>Trapped MSR, MRS or System instruction execution in AArch64 state, that is not reported using EC <span class="binarynumber">0b000000</span>, <span class="binarynumber">0b000001</span> or <span class="binarynumber">0b000111</span>.</p>
<p>This includes all instructions that cause exceptions that are part of the encoding space defined in <span class="xref">'System instruction class encoding overview' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section C5.2.2</span>, except for those exceptions reported using EC values <span class="binarynumber">0b000000</span>, <span class="binarynumber">0b000001</span>, or <span class="binarynumber">0b000111</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromMSR,MRS,orSysteminstructionexecutioninAArch64state">ISS encoding for an exception from MSR, MRS, or System instruction execution in AArch64 state</a></td><td>When AArch64 is supported at any Exception level</td></tr><tr><td class="bitfield">0b011001</td><td>
  <p>Access to SVE functionality trapped as a result of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.ZEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TZ, or <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.EZ, that is not reported using EC <span class="binarynumber">0b000000</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanaccesstoSVEfunctionality,resultingfromCPACR_EL1.ZEN,CPTR_EL2.ZEN,CPTR_EL2.TZ,orCPTR_EL3.EZ">ISS encoding for an exception from an access to SVE functionality, resulting from CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ</a></td><td>When SVE is implemented</td></tr><tr><td class="bitfield">0b011010</td><td>
  <p>Trapped ERET, ERETAA, or ERETAB instruction execution.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromERET,ERETAAorERETABinstruction">ISS encoding for an exception from ERET, ERETAA or ERETAB instruction</a></td><td>When ARMv8.3-PAuth is implemented and ARMv8.3-NV is implemented</td></tr><tr><td class="bitfield">0b011100</td><td>
  <p>Exception from a Pointer Authentication instruction authentication failure</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaPointerAuthenticationinstructionauthenticationfailure">ISS encoding for an exception from a Pointer Authentication instruction authentication failure</a></td><td>When ARMv8.3-FPAC is implemented</td></tr><tr><td class="bitfield">0b100000</td><td>
  <p>Instruction Abort from a lower Exception level.</p>
<p>Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanInstructionAbort">ISS encoding for an exception from an Instruction Abort</a></td></tr><tr><td class="bitfield">0b100001</td><td>
  <p>Instruction Abort taken without a change in Exception level.</p>
<p>Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanInstructionAbort">ISS encoding for an exception from an Instruction Abort</a></td></tr><tr><td class="bitfield">0b100010</td><td>
  <p>PC alignment fault exception.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanIllegalExecutionstate,oraPCorSPalignmentfault">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b100100</td><td>
  <p>Data Abort from a lower Exception level, excluding Data Aborts taken to EL2 as a result of accesses generated associated with <a href="AArch64-vncr_el2.html">VNCR_EL2</a> as part of nested virtualization support.</p>
<p>These Data Aborts might be generated from Exception levels in any Execution state.</p>
<p>Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaDataAbort">ISS encoding for an exception from a Data Abort</a></td></tr><tr><td class="bitfield">0b100101</td><td>
  <p>Data Abort without a change in Exception level, or Data Aborts taken to EL2 as a result of accesses generated associated with <a href="AArch64-vncr_el2.html">VNCR_EL2</a> as part of nested virtualization support.</p>
<p>Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug related exceptions.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaDataAbort">ISS encoding for an exception from a Data Abort</a></td></tr><tr><td class="bitfield">0b100110</td><td>
  <p>SP alignment fault exception.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromanIllegalExecutionstate,oraPCorSPalignmentfault">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b101000</td><td>
  <p>Trapped floating-point exception taken from AArch32 state.</p>
<p>This EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromatrappedfloating-pointexception">ISS encoding for an exception from a trapped floating-point exception</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b101100</td><td>
  <p>Trapped floating-point exception taken from AArch64 state.</p>
<p>This EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromatrappedfloating-pointexception">ISS encoding for an exception from a trapped floating-point exception</a></td><td>When AArch64 is supported at any Exception level</td></tr><tr><td class="bitfield">0b101111</td><td>
  <p>SError interrupt.</p>
</td><td><a href="&#10;                #ISS_anSErrorinterrupt">ISS encoding for an SError interrupt</a></td></tr><tr><td class="bitfield">0b110000</td><td>
  <p>Breakpoint exception from a lower Exception level.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaBreakpointorVectorCatchdebugexception">ISS encoding for an exception from a Breakpoint or Vector Catch debug exception</a></td></tr><tr><td class="bitfield">0b110001</td><td>
  <p>Breakpoint exception taken without a change in Exception level.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaBreakpointorVectorCatchdebugexception">ISS encoding for an exception from a Breakpoint or Vector Catch debug exception</a></td></tr><tr><td class="bitfield">0b110010</td><td>
  <p>Software Step exception from a lower Exception level.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaSoftwareStepexception">ISS encoding for an exception from a Software Step exception</a></td></tr><tr><td class="bitfield">0b110011</td><td>
  <p>Software Step exception taken without a change in Exception level.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaSoftwareStepexception">ISS encoding for an exception from a Software Step exception</a></td></tr><tr><td class="bitfield">0b110100</td><td>
  <p>Watchpoint from a lower Exception level, excluding Watchpoint Exceptions taken to EL2 as a result of accesses generated associated with <a href="AArch64-vncr_el2.html">VNCR_EL2</a> as part of nested virtualization support.</p>
<p>These Watchpoint Exceptions might be generated from Exception levels using any Execution state.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaWatchpointexception">ISS encoding for an exception from a Watchpoint exception</a></td></tr><tr><td class="bitfield">0b110101</td><td>
  <p>Watchpoint exceptions without a change in Exception level, or Watchpoint exceptions taken to EL2 as a result of accesses generated associated with <a href="AArch64-vncr_el2.html">VNCR_EL2</a> as part of nested virtualization support.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaWatchpointexception">ISS encoding for an exception from a Watchpoint exception</a></td></tr><tr><td class="bitfield">0b111000</td><td>
  <p>BKPT instruction execution in AArch32 state.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromexecutionofaBreakpointinstruction">ISS encoding for an exception from execution of a Breakpoint instruction</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b111010</td><td>
  <p>Vector Catch exception from AArch32 state.</p>
<p>The only case where a Vector Catch exception is taken to an Exception level that is using AArch64 is when the exception is routed to EL2 and EL2 is using AArch64.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromaBreakpointorVectorCatchdebugexception">ISS encoding for an exception from a Breakpoint or Vector Catch debug exception</a></td><td>When AArch32 is supported at any Exception level</td></tr><tr><td class="bitfield">0b111100</td><td>
  <p>BRK instruction execution in AArch64 state.</p>
<p>This is reported in <a href="AArch64-esr_el3.html">ESR_EL3</a> only if a BRK instruction is executed.</p>
</td><td><a href="&#10;                #ISS_anexceptionfromexecutionofaBreakpointinstruction">ISS encoding for an exception from execution of a Breakpoint instruction</a></td><td>When AArch64 is supported at any Exception level</td></tr></table>
            
  <p>All other EC values are reserved by Arm, and:</p>
<ul>
<li>Unused values in the range <span class="binarynumber">0b000000</span> - <span class="binarynumber">0b101100</span> (<span class="hexnumber">0x00</span> - <span class="hexnumber">0x2C</span>) are reserved for future use for synchronous exceptions.
</li><li>Unused values in the range <span class="binarynumber">0b101101</span> - <span class="binarynumber">0b111111</span> (<span class="hexnumber">0x2D</span> - <span class="hexnumber">0x3F</span>) are reserved for future use, and might be used for synchronous or asynchronous exceptions.
</li></ul>
<p>The effect of programming this field to a reserved value is that behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, as described in <span class="xref">'Reserved values in System and memory-mapped registers and translation table entries' in the Arm® Architecture Reference Manual, Armv8, for Armv8-A architecture profile, section K1.1.11</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IL_25">IL, bit [25]
              </h4>
          
  <p>Instruction Length for synchronous exceptions. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>IL</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>16-bit instruction trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>32-bit instruction trapped. This value is also used when the exception is one of the following:</p>
<ul>
<li>
<p>An SError interrupt.</p>

</li><li>
<p>An Instruction Abort exception.</p>

</li><li>
<p>A PC alignment fault exception.</p>

</li><li>
<p>An SP alignment fault exception.</p>

</li><li>
<p>A Data Abort exception for which the value of the ISV bit is 0.</p>

</li><li>
<p>An Illegal Execution state exception.</p>

</li><li>
<p>Any debug exception except for Breakpoint instruction exceptions. For Breakpoint instruction exceptions, this bit has its standard meaning:</p>
<ul>
<li>
<p><span class="binarynumber">0b0</span>: 16-bit T32 BKPT instruction.</p>

</li><li>
<p><span class="binarynumber">0b1</span>: 32-bit A32 BKPT instruction or A64 BRK instruction.</p>

</li></ul>

</li><li>
<p>An exception reported using EC value <span class="binarynumber">0b000000</span>.</p>

</li></ul>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="ISS_24">ISS, bits [24:0]
                  </h4>
          
  <p>Instruction Specific Syndrome. Architecturally, this field can be defined independently for each defined Exception class. However, in practice, some ISS encodings are used for more than one Exception class.</p>
<p>Typically, an ISS encoding has a number of subfields. When an ISS subfield holds a register number, the value returned in that field is the AArch64 view of the register number.</p>
<p>For an exception taken from AArch32 state, <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>
<p>If the AArch32 register descriptor is <span class="binarynumber">0b1111</span>, then:</p>
<ul>
<li>If the instruction that generated the exception was not <span class="arm-defined-word">UNPREDICTABLE</span>, the field takes the value <span class="binarynumber">0b11111</span>.
</li><li>If the instruction that generated the exception was <span class="arm-defined-word">UNPREDICTABLE</span>, the field takes an <span class="arm-defined-word">UNKNOWN</span> value that must be either:<ul>
<li>The AArch64 view of the register number of a register that might have been used at the Exception level from which the exception was taken.
</li><li>The value <span class="binarynumber">0b11111</span>.
</li></ul>

</li></ul>
<p>When the EC field is <span class="binarynumber">0b000000</span>, indicating an exception with an unknown reason, the ISS field is not valid, <span class="arm-defined-word">RES0</span>.</p>

          
            
  

          <div class="partial_fieldset"><h3 id="ISS_exceptionswithanunknownreason">ISS encoding for exceptions with an unknown reason</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#0_24">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>When an exception is reported using this EC code the IL field is set to 1.</p>
<p>This EC code is used for all exceptions that are not covered by any other EC value. This includes exceptions that are generated in the following situations:</p>
<ul>
<li>The attempted execution of an instruction bit pattern that has no allocated instruction or that is not accessible at the current Exception level and Security state, including:<ul>
<li>A read access using a System register pattern that is not allocated for reads or that does not permit reads at the current Exception level and Security state.
</li><li>A write access using a System register pattern that is not allocated for writes or that does not permit writes at the current Exception level and Security state.
</li><li>Instruction encodings that are unallocated.
</li><li>Instruction encodings for instructions or System registers that are not implemented in the implementation.
</li></ul>

</li><li>In Debug state, the attempted execution of an instruction bit pattern that is not accessible in Debug state.
</li><li>In Non-debug state, the attempted execution of an instruction bit pattern that is not accessible in Non-debug state.
</li><li>In AArch32 state, attempted execution of a short vector floating-point instruction.
</li><li>In an implementation that does not include Advanced SIMD and floating-point functionality, an attempted access to Advanced SIMD or floating-point functionality under conditions where that access would be permitted if that functionality was present. This includes the attempted execution of an Advanced SIMD or floating-point instruction, and attempted accesses to Advanced SIMD and floating-point System registers.
</li><li>An exception generated because of the value of one of the <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.{ITD, SED, CP15BEN} control bits.
</li><li>Attempted execution of:<ul>
<li>An HVC instruction when disabled by <a href="AArch64-hcr_el2.html">HCR_EL2</a>.HCD or <a href="AArch64-scr_el3.html">SCR_EL3</a>.HCE.
</li><li>An SMC instruction when disabled by <a href="AArch64-scr_el3.html">SCR_EL3</a>.SMD.
</li><li>An HLT instruction when disabled by <a href="ext-edscr.html">EDSCR</a>.HDE.
</li></ul>

</li><li>Attempted execution of an MSR or MRS instruction to access <a href="AArch64-sp_el0.html">SP_EL0</a> when the value of <a href="AArch64-spsel.html">SPSel</a>.SP is 0.
</li><li>Attempted execution, in Debug state, of:<ul>
<li>A DCPS1 instruction when the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1 and EL2 is disabled or not implemented in the current Security state.
</li><li>A DCPS2 instruction from EL1 or EL0 when EL2 is disabled or not implemented in the current Security state.
</li><li>A DCPS3 instruction when the value of <a href="ext-edscr.html">EDSCR</a>.SDD is 1, or when EL3 is not implemented.
</li></ul>

</li><li>When EL3 is using AArch64, attempted execution from Secure EL1 of an SRS instruction using R13_mon. See <span class="xref">'Traps to EL3 of monitor functionality from Secure EL1 using AArch32'</span>.
</li><li>In Debug state when the value of <a href="ext-edscr.html">EDSCR</a>.SDD is 1, the attempted execution at EL2, EL1, or EL0 of an instruction that is configured to trap to EL3.
</li><li>In AArch32 state, the attempted execution of an MRS (banked register) or an MSR (banked register) instruction to SPSR_mon, SP_mon, or LR_mon.
</li><li>An exception that is taken to EL2 because the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1 that, if the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE was 0 would have been reported with an ESR_ELx.EC value of <span class="binarynumber">0b000111</span>.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaWFIorWFEinstruction">ISS encoding for an exception from a WFI or WFE instruction</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="19"><a href="#0_19">RES0</a></td><td class="lr" colspan="1"><a href="#TI_0">TI</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_19">
                Bits [19:1]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="TI_0">TI, bit [0]
              </h4>
          
  <p>Trapped instruction. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>TI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>WFI trapped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>WFE trapped.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The following fields describe configuration settings for generating this exception:</p>
<ul>
<li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.{nTWE, nTWI}.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TWE, TWI}.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.{TWE, TWI}.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanMCRorMRCaccess">ISS encoding for an exception from an MCR or MRC access</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="3"><a href="#Opc2_19">Opc2</a></td><td class="lr" colspan="3"><a href="#Opc1_16">Opc1</a></td><td class="lr" colspan="4"><a href="#CRn_13">CRn</a></td><td class="lr" colspan="5"><a href="#Rt_9">Rt</a></td><td class="lr" colspan="4"><a href="#CRm_4">CRm</a></td><td class="lr" colspan="1"><a href="#Direction_0">Direction</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Opc2_19">Opc2, bits [19:17]
                  </h4>
          
  <p>The Opc2 value from the issued instruction.</p>
<p>For a trapped VMRS access, holds the value <span class="binarynumber">0b000</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Opc1_16">Opc1, bits [16:14]
                  </h4>
          
  <p>The Opc1 value from the issued instruction.</p>
<p>For a trapped VMRS access, holds the value <span class="binarynumber">0b111</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CRn_13">CRn, bits [13:10]
                  </h4>
          
  <p>The CRn value from the issued instruction.</p>
<p>For a trapped VMRS access, holds the reg field from the VMRS instruction encoding.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Rt_9">Rt, bits [9:5]
                  </h4>
          
  <p>The Rt value from the issued instruction, the general-purpose register used for the transfer. The reported value gives the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CRm_4">CRm, bits [4:1]
                  </h4>
          
  <p>The CRm value from the issued instruction.</p>
<p>For a trapped VMRS access, holds the value <span class="binarynumber">0b0000</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Direction_0">Direction, bit [0]
              </h4>
          
  <p>Indicates the direction of the trapped instruction. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Write to System register space. MCR instruction.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Read from System register space. MRC or VMRS instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000011</span>:</p>
<ul>
<li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN}, for accesses to the Generic Timer Registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{ER, CR, SW, EN}, for accesses to Performance Monitor registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.EN, for accesses to Activity Monitors registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers from EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TTLB, for execution of TLB maintenance instructions at EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TSW, TPC, TPU} for execution of cache maintenance instructions at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TACR, for accesses to the Auxiliary Control Register at EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TIDCP, for accesses to lockdown, DMA, and TCM operations at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TID1, TID2, TID3}, for accesses to ID registers at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TCPAC, for accesses to <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> or <a href="AArch32-cpacr.html">CPACR</a> using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T&lt;n&gt;, for accesses to System registers using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.EL1PCEN, for accesses to the Generic Timer registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TCPAC, for accesses to <a href="AArch32-cpacr.html">CPACR</a> from EL1 and EL2, and accesses to <a href="AArch32-hcptr.html">HCPTR</a> from EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers from EL0, EL1 and EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers from EL0, EL1 and EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li>See <span class="xref">'Traps to EL3 of Secure monitor functionality from Secure EL1 using AArch32'</span> for information on other traps using EC value <span class="binarynumber">0b000011</span>.
</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented, MCR or MRC access to some registers at EL0, trapped to EL2.
</li></ul>
<p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000101</span>:</p>
<ul>
<li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA for accesses to trace registers, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug Communications Channel (DCC) registers at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC, for accesses to the DCC registers at EL0 and EL1, trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID0, for accesses to the <a href="AArch32-jidr.html">JIDR</a> register in the ID group 0 at EL0 and EL1 using AArch32, MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to trace registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers <a href="AArch32-dbgdrar.html">DBGDRAR</a> and AArch-DBGDSAR using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA, for accesses to powerdown debug registers, using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses to other debug registers, using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to trace registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDOSA, for accesses to powerdown debug registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to other debug registers, using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li></ul>
<p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b001000</span>:</p>
<ul>
<li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID0, for accesses to the <a href="AArch32-fpsid.html">FPSID</a> register in ID group 0 at EL1 using AArch32 state, VMRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID3, for accesses to registers in ID group 3 including <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a> and <a href="AArch32-mvfr2.html">MVFR2</a>, VMRS access trapped to EL2.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanMCRRorMRRCaccess">ISS encoding for an exception from an MCRR or MRRC access</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="4"><a href="#Opc1_19">Opc1</a></td><td class="lr" colspan="1"><a href="#0_15">RES0</a></td><td class="lr" colspan="5"><a href="#Rt2_14">Rt2</a></td><td class="lr" colspan="5"><a href="#Rt_9">Rt</a></td><td class="lr" colspan="4"><a href="#CRm_4">CRm</a></td><td class="lr" colspan="1"><a href="#Direction_0">Direction</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Opc1_19">Opc1, bits [19:16]
                  </h4>
          
  <p>The Opc1 value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_15">
                Bit [15]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="Rt2_14">Rt2, bits [14:10]
                  </h4>
          
  <p>The Rt2 value from the issued instruction, the second general-purpose register used for the transfer. The reported value gives the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Rt_9">Rt, bits [9:5]
                  </h4>
          
  <p>The Rt value from the issued instruction, the first general-purpose register used for the transfer. The reported value gives the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CRm_4">CRm, bits [4:1]
                  </h4>
          
  <p>The CRm value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Direction_0">Direction, bit [0]
              </h4>
          
  <p>Indicates the direction of the trapped instruction. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Write to System register space. MCRR instruction.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Read from System register space. MRRC instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000100</span>:</p>
<ul>
<li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN}, for accesses to the Generic Timer Registers from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{CR, EN}, for accesses to Performance Monitor registers from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.{EN}, for accesses to Activity Monitors registers AMEVCNTR0&lt;n&gt; and AMEVCNTR1&lt;n&gt; from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers from EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T&lt;n&gt;, for accesses to System registers using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.{EL1PCEN, EL1PCTEN}, for accesses to the Generic Timer registers from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers registers AMEVCNTR0&lt;n&gt; and AMEVCNTR1&lt;n&gt; from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers from EL0, EL1 and EL2 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers from EL0, EL1 and EL2 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>.PMCCNTR_EL0 for MRRC access and <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>.PMCCNTR_EL0 for MCRR access to <a href="AArch32-pmccntr.html">PMCCNTR</a> at EL0, trapped to EL2.
</li></ul>
<p>The following sections describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b001100</span>:</p>
<ul>
<li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA for accesses to trace registers using MCR or MRC instructions, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug Communications Channel (DCC) registers <a href="AArch32-dbgdsar.html">DBGDSAR</a> and <a href="AArch32-dbgdrar.html">DBGDRAR</a> at EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to trace registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers <a href="AArch32-dbgdrar.html">DBGDRAR</a> and AArch-DBGDSAR using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to trace registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDOSA, for traps to powerdown debug registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to other debug registers, using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanLDCorSTCinstruction">ISS encoding for an exception from an LDC or STC instruction</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="8"><a href="#imm8_19">imm8</a></td><td class="lr" colspan="2"><a href="#0_11">RES0</a></td><td class="lr" colspan="5"><a href="#Rn_9">Rn</a></td><td class="lr" colspan="1"><a href="#Offset_4">Offset</a></td><td class="lr" colspan="3"><a href="#AM_3">AM</a></td><td class="lr" colspan="1"><a href="#Direction_0">Direction</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="imm8_19">imm8, bits [19:12]
                  </h4>
          
  <p>The immediate value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_11">
                Bits [11:10]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="Rn_9">Rn, bits [9:5]
                  </h4>
          
  <p>The Rn value from the issued instruction, the general-purpose register used for the transfer. The reported value gives the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>
<p>This field is valid only when AM[2] is 0, indicating an immediate form of the LDC or STC instruction. When AM[2] is 1, indicating a literal form of the LDC or STC instruction, this field is <span class="arm-defined-word">UNKNOWN</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Offset_4">Offset, bit [4]
              </h4>
          
  <p>Indicates whether the offset is added or subtracted:</p>

          <table class="valuetable"><tr><th>Offset</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Subtract offset.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Add offset.</p>
</td></tr></table>
            
  <p>This bit corresponds to the U bit in the instruction encoding.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="AM_3">AM, bits [3:1]
                  </h4>
          
  <p>Addressing mode. The permitted values of this field are:</p>

          <table class="valuetable"><tr><th>AM</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
  <p>Immediate unindexed.</p>
</td></tr><tr><td class="bitfield">0b001</td><td>
  <p>Immediate post-indexed.</p>
</td></tr><tr><td class="bitfield">0b010</td><td>
  <p>Immediate offset.</p>
</td></tr><tr><td class="bitfield">0b011</td><td>
  <p>Immediate pre-indexed.</p>
</td></tr><tr><td class="bitfield">0b100</td><td>
  <p>For a trapped STC instruction or a trapped T32 LDC instruction this encoding is reserved.</p>
</td></tr><tr><td class="bitfield">0b110</td><td>
  <p>For a trapped STC instruction, this encoding is reserved.</p>
</td></tr></table>
            
  <p>The values <span class="binarynumber">0b101</span> and <span class="binarynumber">0b111</span> are reserved. The effect of programming this field to a reserved value is that behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, as described in <span class="xref">'Reserved values in System and memory-mapped registers and translation table entries'</span>.</p>
<p>Bit [2] in this subfield indicates the instruction form, immediate or literal.</p>
<p>Bits [1:0] in this subfield correspond to the bits {P, W} in the instruction encoding.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Direction_0">Direction, bit [0]
              </h4>
          
  <p>Indicates the direction of the trapped instruction. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Write to memory. STC instruction.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Read from memory. LDC instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The following fields describe the configuration settings for the traps that are reported using EC value <span class="binarynumber">0b000110</span>:</p>
<ul>
<li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> trapped to EL1 or EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> MCR or MRC access trapped to EL2.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> MCR or MRC access trapped to EL3.
</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC, for accesses to the DCC registers at EL0 and EL1, trapped to EL2.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanaccesstoSVE,AdvancedSIMDorfloating-pointfunctionality,resultingfromCPACR_EL1.FPEN,CPTR_EL2.FPENorCPTR_ELx.TFP">ISS encoding for an exception from an access to SVE, Advanced SIMD or floating-point functionality, resulting from CPACR_EL1.FPEN, CPTR_EL2.FPEN or CPTR_ELx.TFP</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="20"><a href="#0_19">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  <p>The accesses covered by this trap include:</p>
<ul>
<li>Execution of SVE or Advanced SIMD and floating-point instructions.
</li><li>Accesses to the Advanced SIMD and floating-point System registers.
</li></ul>
<p>For an implementation that does not include either SVE or support for floating-point and Advanced SIMD, the exception is reported using the EC value <span class="binarynumber">0b000000</span>.</p>

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_19">
                Bits [19:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>The following sections describe the configuration settings for the traps that are reported using EC value <span class="binarynumber">0b000111</span>:</p>
<ul>
<li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN, for accesses to SIMD and floating-point registers trapped to EL1.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP, for accesses to SIMD and floating-point registers trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP, for accesses to SIMD and floating-point registers trapped to EL3.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanaccesstoSVEfunctionality,resultingfromCPACR_EL1.ZEN,CPTR_EL2.ZEN,CPTR_EL2.TZ,orCPTR_EL3.EZ">ISS encoding for an exception from an access to SVE functionality, resulting from CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#0_24">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:0]
              <div style="font-size:smaller;"><br />When SVE is implemented:
                </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="0_24"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>The accesses covered by this trap include:</p>
<ul>
<li>Execution of SVE instructions.
</li><li>Accesses to the SVE system registers, ZCR_ELx and ID_AA64ZFR0_EL1.
</li></ul>
<p>For an implementation that does not include SVE, the exception is reported using the EC value <span class="binarynumber">0b000000</span>.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanIllegalExecutionstate,oraPCorSPalignmentfault">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#0_24">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>There are no configuration settings for generating Illegal Execution state exceptions and PC alignment fault exceptions. For more information about these exceptions see <span class="xref">'The Illegal Execution state exception'</span> and <span class="xref">'PC alignment checking'</span>.</p>
<p><span class="xref">'Stack pointer alignment checking'</span> describes the configuration settings for generating SP alignment fault exceptions.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromHVCorSVCinstructionexecution">ISS encoding for an exception from HVC or SVC instruction execution</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#0_24">RES0</a></td><td class="lr" colspan="16"><a href="#imm16_15">imm16</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:16]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="imm16_15">imm16, bits [15:0]
                  </h4>
          
  <p>The value of the immediate field from the HVC or SVC instruction.</p>
<p>For an HVC instruction, and for an A64 SVC instruction, this is the value of the imm16 field of the issued instruction.</p>
<p>For an A32 or T32 SVC instruction:</p>
<ul>
<li>If the instruction is unconditional, then:<ul>
<li>For the T32 instruction, this field is zero-extended from the imm8 field of the instruction.
</li><li>For the A32 instruction, this field is the bottom 16 bits of the imm24 field of the instruction.
</li></ul>

</li><li>If the instruction is conditional, this field is <span class="arm-defined-word">UNKNOWN</span>.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>In AArch32 state, the HVC instruction is unconditional, and a conditional SVC instruction generates an exception only if it passes its condition code check. Therefore, the syndrome information for these exceptions does not require conditionality information.</p>
<p>For T32 and A32 instructions, see <span class="xref">'SVC'</span> and <span class="xref">'HVC'</span>.</p>
<p>For A64 instructions, see <span class="xref">'SVC'</span> and <span class="xref">'HVC'</span>.</p>
<p>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a>.{SVC_EL1, SVC_EL0} control fine-grained traps on SVC execution.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromSMCinstructionexecutioninAArch32state">ISS encoding for an exception from SMC instruction execution in AArch32 state</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#CV_24">CV</a></td><td class="lr" colspan="4"><a href="#COND_23">COND</a></td><td class="lr" colspan="1"><a href="#CCKNOWNPASS_19">CCKNOWNPASS</a></td><td class="lr" colspan="19"><a href="#0_18">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  <p>For an SMC instruction that completes normally and generates an exception that is taken to EL3, the ISS encoding is <span class="arm-defined-word">RES0</span>.</p>
<p>For an SMC instruction that is trapped to EL2 from EL1 because <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC is 1, the ISS encoding is as shown in the diagram.</p>

    </div><h4 id="CV_24">CV, bit [24]
              </h4>
          
  <p>Condition code valid. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The COND field is not valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The COND field is valid.</p>
</td></tr></table>
            
  <p>For exceptions taken from AArch64, CV is set to 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul>
<p>This field is only valid if CCKNOWNPASS is 1, otherwise it is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="COND_23">COND, bits [23:20]
                  </h4>
          
  <p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p>
<p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p>
<p>For exceptions taken from AArch32:</p>
<ul>
<li>When an A32 instruction is trapped, CV is set to 1 and:<ul>
<li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul>

</li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul>
<li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul>

</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul>
<li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul>

</li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul>
<p>This field is only valid if CCKNOWNPASS is 1, otherwise it is <span class="arm-defined-word">RES0</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CCKNOWNPASS_19">CCKNOWNPASS, bit [19]
              </h4>
          
  <p>Indicates whether the instruction might have failed its condition code check.</p>

          <table class="valuetable"><tr><th>CCKNOWNPASS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The instruction was unconditional, or was conditional and passed its condition code check.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The instruction was conditional, and might have failed its condition code check.</p>
</td></tr></table>
            
  <div class="note"><span class="note-header">Note</span><p>In an implementation in which an SMC instruction that fails it code check is not trapped, this field can always return the value 0.</p></div>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_18">
                Bits [18:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>HCR_EL2.TSC describes the configuration settings for trapping SMC instructions to EL2.</p>
<p>See <span class="xref">'System calls'</span> describes the case where these exceptions are trapped to EL3.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromSMCinstructionexecutioninAArch64state">ISS encoding for an exception from SMC instruction execution in AArch64 state</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#0_24">RES0</a></td><td class="lr" colspan="16"><a href="#imm16_15">imm16</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:16]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="imm16_15">imm16, bits [15:0]
                  </h4>
          
  <p>The value of the immediate field from the issued SMC instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The value of ISS[24:0] described here is used both:</p>
<ul>
<li>When an SMC instruction is trapped from EL1 modes.
</li><li>When an SMC instruction is not trapped, so completes normally and generates an exception that is taken to EL3.
</li></ul>
<p>HCR_EL2.TSC describes the configuration settings for trapping SMC from EL1 modes.</p>
<p><span class="xref">'System calls'</span> describes the case where these exceptions are trapped to EL3.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromMSR,MRS,orSysteminstructionexecutioninAArch64state">ISS encoding for an exception from MSR, MRS, or System instruction execution in AArch64 state</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#0_24">RES0</a></td><td class="lr" colspan="2"><a href="#Op0_21">Op0</a></td><td class="lr" colspan="3"><a href="#Op2_19">Op2</a></td><td class="lr" colspan="3"><a href="#Op1_16">Op1</a></td><td class="lr" colspan="4"><a href="#CRn_13">CRn</a></td><td class="lr" colspan="5"><a href="#Rt_9">Rt</a></td><td class="lr" colspan="4"><a href="#CRm_4">CRm</a></td><td class="lr" colspan="1"><a href="#Direction_0">Direction</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:22]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="Op0_21">Op0, bits [21:20]
                  </h4>
          
  <p>The Op0 value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Op2_19">Op2, bits [19:17]
                  </h4>
          
  <p>The Op2 value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Op1_16">Op1, bits [16:14]
                  </h4>
          
  <p>The Op1 value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CRn_13">CRn, bits [13:10]
                  </h4>
          
  <p>The CRn value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Rt_9">Rt, bits [9:5]
                  </h4>
          
  <p>The Rt value from the issued instruction, the general-purpose register used for the transfer.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CRm_4">CRm, bits [4:1]
                  </h4>
          
  <p>The CRm value from the issued instruction.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Direction_0">Direction, bit [0]
              </h4>
          
  <p>Indicates the direction of the trapped instruction. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Write access, including MSR instructions.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Read access, including MRS instructions.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For exceptions caused by System instructions, see <span class="xref">'System' subsection of 'Branches, exception generating and System instructions'</span> for the encoding values returned by an instruction.</p>
<p>The following fields describe configuration settings for generating the exception that is reported using EC value <span class="binarynumber">0b011000</span>:</p>
<ul>
<li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UCI, for execution of cache maintenance instructions using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UCT, for accesses to <a href="AArch64-ctr_el0.html">CTR_EL0</a> using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.DZE, for execution of DC ZVA instructions using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UMA, for accesses to the PSTATE interrupt masks using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA, for accesses to the trace registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug Communications Channel (DCC) registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC, for accesses to the DCC registers at EL0 and EL1, trapped to EL2.
</li><li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN} accesses to the Generic Timer registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{ER, CR, SW, EN}, for accesses to the Performance Monitor registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.EN, for accesses to Activity Monitors registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TDZ, for execution of DC ZVA instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TTLB, for execution of TLB maintenance instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TSW, TPC, TPU}, for execution of cache maintenance instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TACR, for accesses to the Auxiliary Control Register, <a href="AArch64-actlr_el1.html">ACTLR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TIDCP, for accesses to lockdown, DMA, and TCM operations using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TID1, TID2, TID3}, for accesses to ID group 1, ID group 2 or ID group 3 registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TCPAC, for accesses to <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to the trace registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TTRF, for accesses to the trace filter register, <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA, for accesses to powerdown debug registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.{EL1PCEN, EL1PCTEN}, for accesses to the Generic Timer registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses to debug registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.APK, for accesses to Pointer authentication key registers. using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{NV, NV1}, for Nested virtualization register access, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.AT, for execution of AT S1E* instructions, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TERR, FIEN}, for accesses to RAS registers, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.APK, for accesses to Pointer authentication key registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.ST, for accesses to the Counter-timer Physical Secure timer registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.{TERR, FIEN}, for accesses to RAS registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TCPAC, for accesses to <a href="AArch64-cptr_el2.html">CPTR_EL2</a> and <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to the trace registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TTRF, for accesses to the filter trace control registers, <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> and <a href="AArch64-trfcr_el2.html">TRFCR_EL2</a>, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to debug registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDOSA, for accesses to powerdown debug registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers, using AArch64 state, MSR or MRS access, trapped to EL3.
</li><li>If <span class="xref">ARMv8.2-EVT</span> is implemented the following registers control traps for EL1 and EL0 Cache controls that use this EC value:<ul>
<li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TTLBOS, TTLBIS, TICAB, TOCU, TID4}.
</li><li><a href="AArch32-hcr2.html">HCR2</a>.{TTLBIS, TICAB, TOCU, TID4}.
</li></ul>

</li><li>If <span class="xref">ARMv8.6-FGT</span> is implemented:<ul>
<li><a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn, for accesses to the fine-grained trap registers, MSR or MRS access at EL2 trapped to EL3.
</li><li><a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a> for reads and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> for writes of registers, using AArch64 state, MSR or MRS access at EL0 and EL1 trapped to EL2.
</li><li><a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> for execution of system instructions, MSR or MRS access trapped to EL2
</li><li><a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a> for reads and <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a> for writes of registers, using AArch64 state, MSR or MRS access at EL0 and EL1 state trapped to EL2.
</li><li><a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a> for reads of Activity Monitor counters, using AArch64 state, MRS access at EL0 and EL1 trapped to EL2.
</li></ul>

</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anIMPLEMENTATIONDEFINEDexceptiontoEL3">ISS encoding for an IMPLEMENTATION DEFINED exception to EL3</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#IMPLEMENTATIONDEFINED_24">IMPLEMENTATION DEFINED</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="IMPLEMENTATIONDEFINED_24">IMPLEMENTATION DEFINED, bits [24:0]
                  </h4>
            <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
          
  

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromanInstructionAbort">ISS encoding for an exception from an Instruction Abort</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="12"><a href="#0_24">RES0</a></td><td class="lr" colspan="2"><a href="#SET_12">SET</a></td><td class="lr" colspan="1"><a href="#FnV_10">FnV</a></td><td class="lr" colspan="1"><a href="#EA_9">EA</a></td><td class="lr" colspan="1"><a href="#0_8">RES0</a></td><td class="lr" colspan="1"><a href="#S1PTW_7">S1PTW</a></td><td class="lr" colspan="1"><a href="#0_6">RES0</a></td><td class="lr" colspan="6"><a href="#IFSC_5">IFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:13]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="SET_12">SET, bits [12:11]
                  </h4>
          
  <p>Synchronous Error Type. When the RAS Extension is implemented and IFSC is <span class="binarynumber">0b010000</span>, describes the state of the PE after taking the Instruction Abort exception. The possible values of this field are:</p>

          <table class="valuetable"><tr><th>SET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Recoverable error (UER).</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Uncontainable error (UC).</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Restartable error (UEO) or Corrected error (CE).</p>
</td></tr></table>
            
  <p>All other values are reserved.</p>
<div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. Taking a synchronous External Abort exception might result in an unrecoverable PE state.</p></div><p>This field is <span class="arm-defined-word">RES0</span> if either:</p>
<ul>
<li>The RAS Extension is not implemented.
</li><li>The value returned in the IFSC field is not <span class="binarynumber">0b010000</span>.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="FnV_10">FnV, bit [10]
              </h4>
          
  <p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p>

          <table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>FAR is valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>FAR is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p>
</td></tr></table>
            
  <p>This field is only valid if the IFSC code is <span class="binarynumber">0b010000</span>. It is <span class="arm-defined-word">RES0</span> for all other aborts.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EA_9">EA, bit [9]
              </h4>
          
  <p>External abort type. This bit can provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p>
<p>For any abort other than an External abort this bit returns a value of 0.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_8">
                Bit [8]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="S1PTW_7">S1PTW, bit [7]
              </h4>
          
  <p>For a stage 2 fault, indicates whether the fault was a stage 2 fault on an access made for a stage 1 translation table walk:</p>

          <table class="valuetable"><tr><th>S1PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Fault not on a stage 2 translation for a stage 1 translation table walk.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Fault on the stage 2 translation of an access for a stage 1 translation table walk.</p>
</td></tr></table>
            
  <p>For any abort other than a stage 2 fault this bit is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bit [6]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IFSC_5">IFSC, bits [5:0]
                  </h4>
          
  <p>Instruction Fault Status Code.</p>

          <table class="valuetable"><tr><th>IFSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
  <p>Address size fault, level 0 of translation or translation table base register.</p>
</td></tr><tr><td class="bitfield">0b000001</td><td>
  <p>Address size fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b000010</td><td>
  <p>Address size fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b000011</td><td>
  <p>Address size fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b000100</td><td>
  <p>Translation fault, level 0.</p>
</td></tr><tr><td class="bitfield">0b000101</td><td>
  <p>Translation fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b000110</td><td>
  <p>Translation fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b000111</td><td>
  <p>Translation fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b001001</td><td>
  <p>Access flag fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b001010</td><td>
  <p>Access flag fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b001011</td><td>
  <p>Access flag fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b001101</td><td>
  <p>Permission fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b001110</td><td>
  <p>Permission fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b001111</td><td>
  <p>Permission fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b010000</td><td>
  <p>Synchronous External abort, not on translation table walk or hardware update of translation table.</p>
</td></tr><tr><td class="bitfield">0b010100</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 0.</p>
</td></tr><tr><td class="bitfield">0b010101</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 1.</p>
</td></tr><tr><td class="bitfield">0b010110</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 2.</p>
</td></tr><tr><td class="bitfield">0b010111</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 3.</p>
</td></tr><tr><td class="bitfield">0b011000</td><td>
  <p>Synchronous parity or ECC error on memory access, not on translation table walk.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b110000</td><td>
  <p>TLB conflict abort.</p>
</td></tr><tr><td class="bitfield">0b110001</td><td>
  <p>Unsupported atomic hardware update fault.</p>
</td><td>When ARMv8.1-TTHM is implemented</td></tr></table>
            
  <p>All other values are reserved.</p>
<p>For more information about the lookup level associated with a fault, see <span class="xref">'The level associated with MMU faults'</span>.</p>
<div class="note"><span class="note-header">Note</span><p>Because Access flag faults and Permission faults can only result from a Block or Page translation table descriptor, they cannot occur at level 0.</p></div><p>If the S1PTW bit is set, then the level refers the level of the stage2 translation that is translating a stage 1 translation walk.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaDataAbort">ISS encoding for an exception from a Data Abort</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#ISV_24">ISV</a></td><td class="lr" colspan="2"><a href="#SAS_23">SAS</a></td><td class="lr" colspan="1"><a href="#SSE_21">SSE</a></td><td class="lr" colspan="5"><a href="#SRT_20">SRT</a></td><td class="lr" colspan="1"><a href="#SF_15">SF</a></td><td class="lr" colspan="1"><a href="#AR_14">AR</a></td><td class="lr" colspan="1"><a href="#VNCR_13">VNCR</a></td><td class="lr" colspan="2"><a href="#SET_12">SET</a></td><td class="lr" colspan="1"><a href="#FnV_10">FnV</a></td><td class="lr" colspan="1"><a href="#EA_9">EA</a></td><td class="lr" colspan="1"><a href="#CM_8">CM</a></td><td class="lr" colspan="1"><a href="#S1PTW_7">S1PTW</a></td><td class="lr" colspan="1"><a href="#WnR_6">WnR</a></td><td class="lr" colspan="6"><a href="#DFSC_5">DFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="ISV_24">ISV, bit [24]
              </h4>
          
  <p>Instruction Syndrome Valid. Indicates whether the syndrome information in ISS[23:14] is valid.</p>

          <table class="valuetable"><tr><th>ISV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>No valid instruction syndrome. ISS[23:14] are <span class="arm-defined-word">RES0</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>ISS[23:14] hold a valid instruction syndrome.</p>
</td></tr></table>
            
  <p>This bit is 0 for all faults reported in ESR_EL2 except the following stage 2 aborts:</p>
<ul>
<li>AArch64 loads and stores of a single general-purpose register (including the register specified with <span class="binarynumber">0b11111</span>, including those with Acquire/Release semantics, but excluding Load Exclusive or Store Exclusive and excluding those with writeback.
</li><li>AArch32 instructions where the instruction:<ul>
<li>Is an LDR, LDA, LDRT, LDRSH, LDRSHT, LDRH, LDAH, LDRHT, LDRSB, LDRSBT, LDRB, LDAB, LDRBT, STR, STL, STRT, STRH, STLH, STRHT, STRB, STLB, or STRBT instruction.
</li><li>Is not performing register writeback.
</li><li>Is not using R15 as a source or destination register.
</li></ul>

</li></ul>
<p>For these cases, ISV is <span class="arm-defined-word">UNKNOWN</span> if the exception was generated in Debug state in memory access mode, and otherwise indicates whether ISS[23:14] hold a valid syndrome.</p>
<p>ISV is 0 for all faults reported in ESR_EL1 or ESR_EL3.</p>
<p>When the RAS Extension is implemented, ISV is 0 for any synchronous External abort.</p>
<p>For ISS reporting, a stage 2 abort on a stage 1 translation table walk does not return a valid instruction syndrome, and therefore ISV is 0 for these aborts.</p>
<p>When the RAS Extension is not implemented, the value of ISV on a synchronous External abort on a stage 2 translation table walk is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
<p>When <span class="xref">ARMv8.5-MemTag</span> is implemented, for a synchronous Tag Check Fault abort taken to ELx, ESR_ELx.FNV is 0 and FAR_ELx is valid.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SAS_23">SAS, bits [23:22]
                  </h4>
          
  <p>Syndrome Access Size. When ISV is 1, indicates the size of the access attempted by the faulting operation.</p>

          <table class="valuetable"><tr><th>SAS</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Byte</p>
</td></tr><tr><td class="bitfield">0b01</td><td>
  <p>Halfword</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Word</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Doubleword</p>
</td></tr></table>
            
  <p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>This field is <span class="arm-defined-word">RES0</span> when the value of ISV is 0.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SSE_21">SSE, bit [21]
              </h4>
          
  <p>Syndrome Sign Extend. When ISV is 1, for a byte, halfword, or word load operation, indicates whether the data item must be sign extended. For these cases, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>SSE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Sign-extension not required.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Data item must be sign-extended.</p>
</td></tr></table>
            
  <p>For all other operations this bit is 0.</p>
<p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>This field is <span class="arm-defined-word">RES0</span> when the value of ISV is 0.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SRT_20">SRT, bits [20:16]
                  </h4>
          
  <p>Syndrome Register Transfer. When ISV is 1, the register number of the Rt operand of the faulting instruction.</p>
<p>If the exception was taken from an Exception level that is using AArch32 then this is the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p>
<p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>This field is <span class="arm-defined-word">RES0</span> when the value of ISV is 0.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="SF_15">SF, bit [15]
              </h4>
          
  <p>Width of the register accessed by the instruction is Sixty-Four. When ISV is 1, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>SF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Instruction loads/stores a 32-bit wide register.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Instruction loads/stores a 64-bit wide register.</p>
</td></tr></table>
            
  <div class="note"><span class="note-header">Note</span><p>This field specifies the register width identified by the instruction, not the Execution state.</p></div><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>This field is <span class="arm-defined-word">RES0</span> when the value of ISV is 0.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="AR_14">AR, bit [14]
              </h4>
          
  <p>Acquire/Release. When ISV is 1, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>AR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Instruction did not have acquire/release semantics.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Instruction did have acquire/release semantics.</p>
</td></tr></table>
            
  <p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>This field is <span class="arm-defined-word">RES0</span> when the value of ISV is 0.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="VNCR_13">VNCR, bit [13]
              <div style="font-size:smaller;"><br />When ARMv8.4-NV is implemented:
                </div></h4>
          
  <p>Indicates that the fault came from use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> register by EL1 code.</p>

          <table class="valuetable"><tr><th>VNCR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The fault was not generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a>, by an MRS or MSR instruction executed at EL1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The fault was generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a>, by an MRS or MSR instruction executed at EL1.</p>
</td></tr></table>
            
  <p>This field is 0 in ESR_EL1.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="SET_12">SET, bits [12:11]
                  </h4>
          
  <p>Synchronous Error Type. When the RAS Extension is implemented and DFSC is <span class="binarynumber">0b010000</span>, describes the state of the PE after taking the Data Abort exception. The possible values of this field are:</p>

          <table class="valuetable"><tr><th>SET</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
  <p>Recoverable error (UER).</p>
</td></tr><tr><td class="bitfield">0b10</td><td>
  <p>Uncontainable error (UC).</p>
</td></tr><tr><td class="bitfield">0b11</td><td>
  <p>Restartable error (UEO) or Corrected error (CE).</p>
</td></tr></table>
            
  <p>All other values are reserved.</p>
<div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. Taking a synchronous External Abort exception might result in an unrecoverable PE state.</p></div><p>This field is <span class="arm-defined-word">RES0</span> if either:</p>
<ul>
<li>The RAS Extension is not implemented.
</li><li>The value returned in the DFSC field is not <span class="binarynumber">0b010000</span>.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="FnV_10">FnV, bit [10]
              </h4>
          
  <p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p>

          <table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>FAR is valid.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>FAR is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p>
</td></tr></table>
            
  <p>This field is valid only if the DFSC code is <span class="binarynumber">0b010000</span>. It is <span class="arm-defined-word">RES0</span> for all other aborts.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="EA_9">EA, bit [9]
              </h4>
          
  <p>External abort type. This bit can provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p>
<p>For any abort other than an External abort this bit returns a value of 0.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="CM_8">CM, bit [8]
              </h4>
          
  <p>Cache maintenance. Indicates whether the Data Abort came from a cache maintenance or address translation instruction:</p>

          <table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The Data Abort was not generated by the execution of one of the System instructions identified in the description of value 1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The Data Abort was generated by either the execution of a cache maintenance instruction or by a synchronous fault on the execution of an address translation instruction. The <a href="AArch64-dc-zva.html">DC ZVA</a> instruction is not classified as a cache maintenance instruction, and therefore its execution cannot cause this field to be set to 1.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="S1PTW_7">S1PTW, bit [7]
              </h4>
          
  <p>For a stage 2 fault, indicates whether the fault was a stage 2 fault on an access made for a stage 1 translation table walk:</p>

          <table class="valuetable"><tr><th>S1PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Fault not on a stage 2 translation for a stage 1 translation table walk.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Fault on the stage 2 translation of an access for a stage 1 translation table walk.</p>
</td></tr></table>
            
  <p>For any abort other than a stage 2 fault this bit is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WnR_6">WnR, bit [6]
              </h4>
          
  <p>Write not Read. Indicates whether a synchronous abort was caused by an instruction writing to a memory location, or by an instruction reading from a memory location. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Abort caused by an instruction reading from a memory location.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Abort caused by an instruction writing to a memory location.</p>
</td></tr></table>
            
  <p>For faults on cache maintenance and address translation instructions, this bit always returns a value of 1.</p>
<p>For faults from an atomic instruction that both reads and writes from a memory location, this bit is set to 0 if a read of the address specified by the instruction would have generated the fault which is being reported, otherwise it is set to 1. The architecture permits, but does not require, a relaxation of this requirement such that for all stage 2 aborts on stage 1 translation table walks for atomic instructions, the WnR bit is always 0.</p>
<p>This field is <span class="arm-defined-word">UNKNOWN</span> for:</p>
<ul>
<li>An External abort on an Atomic access.
</li><li>A fault reported using a DFSC value of <span class="binarynumber">0b110101</span> or <span class="binarynumber">0b110001</span>, indicating an unsupported Exclusive or atomic access.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DFSC_5">DFSC, bits [5:0]
                  </h4>
          
  <p>Data Fault Status Code.</p>

          <table class="valuetable"><tr><th>DFSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
  <p>Address size fault, level 0 of translation or translation table base register.</p>
</td></tr><tr><td class="bitfield">0b000001</td><td>
  <p>Address size fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b000010</td><td>
  <p>Address size fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b000011</td><td>
  <p>Address size fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b000100</td><td>
  <p>Translation fault, level 0.</p>
</td></tr><tr><td class="bitfield">0b000101</td><td>
  <p>Translation fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b000110</td><td>
  <p>Translation fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b000111</td><td>
  <p>Translation fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b001001</td><td>
  <p>Access flag fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b001010</td><td>
  <p>Access flag fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b001011</td><td>
  <p>Access flag fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b001101</td><td>
  <p>Permission fault, level 1.</p>
</td></tr><tr><td class="bitfield">0b001110</td><td>
  <p>Permission fault, level 2.</p>
</td></tr><tr><td class="bitfield">0b001111</td><td>
  <p>Permission fault, level 3.</p>
</td></tr><tr><td class="bitfield">0b010000</td><td>
  <p>Synchronous External abort, not on translation table walk or hardware update of translation table.</p>
</td></tr><tr><td class="bitfield">0b010001</td><td>
  <p>Synchronous Tag Check Fault.</p>
</td><td>When ARMv8.5-MemTag is implemented</td></tr><tr><td class="bitfield">0b010100</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 0.</p>
</td></tr><tr><td class="bitfield">0b010101</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 1.</p>
</td></tr><tr><td class="bitfield">0b010110</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 2.</p>
</td></tr><tr><td class="bitfield">0b010111</td><td>
  <p>Synchronous External abort, on translation table walk or hardware update of translation table, level 3.</p>
</td></tr><tr><td class="bitfield">0b011000</td><td>
  <p>Synchronous parity or ECC error on memory access, not on translation table walk.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td>
  <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p>
</td><td>When RAS is not implemented</td></tr><tr><td class="bitfield">0b100001</td><td>
  <p>Alignment fault.</p>
</td></tr><tr><td class="bitfield">0b110000</td><td>
  <p>TLB conflict abort.</p>
</td></tr><tr><td class="bitfield">0b110001</td><td>
  <p>Unsupported atomic hardware update fault.</p>
</td><td>When ARMv8.1-TTHM is implemented</td></tr><tr><td class="bitfield">0b110100</td><td>
  <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Lockdown).</p>
</td></tr><tr><td class="bitfield">0b110101</td><td>
  <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Unsupported Exclusive or Atomic access).</p>
</td></tr></table>
            
  <p>All other values are reserved.</p>
<p>For more information about the lookup level associated with a fault, see <span class="xref">'The level associated with MMU faults'</span>.</p>
<div class="note"><span class="note-header">Note</span><p>Because Access flag faults and Permission faults can only result from a Block or Page translation table descriptor, they cannot occur at level 0.</p></div><p>If the S1PTW bit is set, then the level refers the level of the stage2 translation that is translating a stage 1 translation walk.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromatrappedfloating-pointexception">ISS encoding for an exception from a trapped floating-point exception</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#0_24">RES0</a></td><td class="lr" colspan="1"><a href="#TFV_23">TFV</a></td><td class="lr" colspan="12"><a href="#0_22">RES0</a></td><td class="lr" colspan="3"><a href="#VECITR_10">VECITR</a></td><td class="lr" colspan="1"><a href="#IDF_7">IDF</a></td><td class="lr" colspan="2"><a href="#0_6">RES0</a></td><td class="lr" colspan="1"><a href="#IXF_4">IXF</a></td><td class="lr" colspan="1"><a href="#UFF_3">UFF</a></td><td class="lr" colspan="1"><a href="#OFF_2">OFF</a></td><td class="lr" colspan="1"><a href="#DZF_1">DZF</a></td><td class="lr" colspan="1"><a href="#IOF_0">IOF</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bit [24]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="TFV_23">TFV, bit [23]
              </h4>
          
  <p>Trapped Fault Valid bit. Indicates whether the IDF, IXF, UFF, OFF, DZF, and IOF bits hold valid information about trapped floating-point exceptions. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>TFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The IDF, IXF, UFF, OFF, DZF, and IOF bits do not hold valid information about trapped floating-point exceptions and are <span class="arm-defined-word">UNKNOWN</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>One or more floating-point exceptions occurred during an operation performed while executing the reported instruction. The IDF, IXF, UFF, OFF, DZF, and IOF bits indicate trapped floating-point exceptions that occurred. For more information see <span class="xref">'Floating-point exception traps'</span>.</p>
</td></tr></table>
            
  <p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this field is set to 0 on an exception generated by a trapped floating point exception from a vector instruction.</p>
<div class="note"><span class="note-header">Note</span><p>This is not a requirement. Implementations can set this field to 1 on a trapped floating-point exception from a vector instruction and return valid information in the {IDF, IXF, UFF, OFF, DZF, IOF} fields.</p></div>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_22">
                Bits [22:11]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="VECITR_10">VECITR, bits [10:8]
                  </h4>
          
  <p>For a trapped floating-point exception from an instruction executed in AArch32 state this field is <span class="arm-defined-word">RES1</span>.</p>
<p>For a trapped floating-point exception from an instruction executed in AArch64 state this field is <span class="arm-defined-word">UNKNOWN</span>.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IDF_7">IDF, bit [7]
              </h4>
          
  <p>Input Denormal floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>IDF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Input denormal floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Input denormal floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_6">
                Bits [6:5]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IXF_4">IXF, bit [4]
              </h4>
          
  <p>Inexact floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>IXF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Inexact floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Inexact floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="UFF_3">UFF, bit [3]
              </h4>
          
  <p>Underflow floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>UFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Underflow floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Underflow floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="OFF_2">OFF, bit [2]
              </h4>
          
  <p>Overflow floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>OFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Overflow floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Overflow floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DZF_1">DZF, bit [1]
              </h4>
          
  <p>Divide by Zero floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>DZF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Divide by Zero floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Divide by Zero floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IOF_0">IOF, bit [0]
              </h4>
          
  <p>Invalid Operation floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p>

          <table class="valuetable"><tr><th>IOF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Invalid Operation floating-point exception has not occurred.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Invalid Operation floating-point exception occurred during execution of the reported instruction.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>In an implementation that supports the trapping of floating-point exceptions:</p>
<ul>
<li>From an Exception level using AArch64, the <a href="AArch64-fpcr.html">FPCR</a>.{IDE, IXE, UFE, OFE, DZE, IOE} bits enable each of the floating-point exception traps.
</li><li>From an Exception level using AArch32, the <a href="AArch32-fpscr.html">FPSCR</a>.{IDE, IXE, UFE, OFE, DZE, IOE} bits enable each of the floating-point exception traps.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anSErrorinterrupt">ISS encoding for an SError interrupt</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#IDS_24">IDS</a></td><td class="lr" colspan="10"><a href="#0_23">RES0</a></td><td class="lr" colspan="1"><a href="#IESB_13">IESB</a></td><td class="lr" colspan="3"><a href="#AET_12">AET</a></td><td class="lr" colspan="1"><a href="#EA_9">EA</a></td><td class="lr" colspan="3"><a href="#0_8">RES0</a></td><td class="lr" colspan="6"><a href="#DFSC_5">DFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="IDS_24">IDS, bit [24]
              </h4>
          
  <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome. Possible values of this bit are:</p>

          <table class="valuetable"><tr><th>IDS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Bits[23:0] of the ISS field holds the fields described in this encoding.</p>
<div class="note"><span class="note-header">Note</span><p>If the RAS Extension is not implemented, this means that bits[23:0] of the ISS field are <span class="arm-defined-word">RES0</span>.</p></div>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Bits[23:0] of the ISS field holds <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome information that can be used to provide additional information about the SError interrupt.</p>
</td></tr></table>
            
  <div class="note"><span class="note-header">Note</span><p>This field was previously called ISV.</p></div>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_23">
                Bits [23:14]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IESB_13">IESB, bit [13]
              <div style="font-size:smaller;"><br />When ARMv8.2-IESB is implemented:
                </div></h4>
          
  <p>Implicit error synchronization event.</p>

          <table class="valuetable"><tr><th>IESB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The SError interrupt was either not synchronized by the implicit error synchronization event or not taken immediately.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The SError interrupt was synchronized by the implicit error synchronization event and taken immediately.</p>
</td></tr></table>
            
  <p>This field is <span class="arm-defined-word">RES0</span> if the value returned in the DFSC field is not <span class="binarynumber">0b010001</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="AET_12">AET, bits [12:10]
                  <div style="font-size:smaller;"><br />When RAS is implemented:
                </div></h4>
          
  <p>Asynchronous Error Type.</p>
<p>When the RAS Extension is implemented and DFSC is <span class="binarynumber">0b010001</span>, describes the state of the PE after taking the SError interrupt exception. The possible values of this field are:</p>

          <table class="valuetable"><tr><th>AET</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
  <p>Uncontainable error (UC).</p>
</td></tr><tr><td class="bitfield">0b001</td><td>
  <p>Unrecoverable error (UEU).</p>
</td></tr><tr><td class="bitfield">0b010</td><td>
  <p>Restartable error (UEO).</p>
</td></tr><tr><td class="bitfield">0b011</td><td>
  <p>Recoverable error (UER).</p>
</td></tr><tr><td class="bitfield">0b110</td><td>
  <p>Corrected error (CE).</p>
</td></tr></table>
            
  <p>All other values are reserved.</p>
<p>If multiple errors are taken as a single SError interrupt exception, the overall state of the PE is reported. For example, if both a Recoverable and Unrecoverable error occurred, the state is Unrecoverable.</p>
<div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. The recovery software must also examine any implemented fault records to determine the location and extent of the error.</p></div><p>This field is <span class="arm-defined-word">RES0</span> if either:</p>
<ul>
<li>The RAS Extension is not implemented.
</li><li>The value returned in the DFSC field is not <span class="binarynumber">0b010001</span>.
</li></ul>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_12"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="EA_9">EA, bit [9]
              <div style="font-size:smaller;"><br />When RAS is implemented:
                </div></h4>
          
  <p>External abort type. When the RAS Extension is implemented, this bit can provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p>
<p>For any abort other than an External abort this bit returns a value of 0.</p>
<p>This field is <span class="arm-defined-word">RES0</span> if either:</p>
<ul>
<li>The RAS Extension is not implemented.
</li><li>The value returned in the DFSC field is not <span class="binarynumber">0b010001</span>.
</li></ul>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_9"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="0_8">
                Bits [8:6]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="DFSC_5">DFSC, bits [5:0]
                  <div style="font-size:smaller;"><br />When RAS is implemented:
                </div></h4>
          
  <p>Data Fault Status Code.</p>

          <table class="valuetable"><tr><th>DFSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000000</td><td>
  <p>Uncategorized.</p>
</td></tr><tr><td class="bitfield">0b010001</td><td>
  <p>Asynchronous SError interrupt.</p>
</td></tr></table>
            
  <p>All other values are reserved.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_5"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaBreakpointorVectorCatchdebugexception">ISS encoding for an exception from a Breakpoint or Vector Catch debug exception</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="19"><a href="#0_24">RES0</a></td><td class="lr" colspan="6"><a href="#IFSC_5">IFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:6]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="IFSC_5">IFSC, bits [5:0]
                  </h4>
          
  <p>Instruction Fault Status Code.</p>

          <table class="valuetable"><tr><th>IFSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b100010</td><td>
  <p>Debug exception.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For more information about generating these exceptions:</p>
<ul>
<li>For exceptions from AArch64, see <span class="xref">'Breakpoint exceptions'</span>.
</li><li>For exceptions from AArch32, see <span class="xref">'Breakpoint exceptions'</span> and <span class="xref">'Vector Catch exceptions'</span>.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaSoftwareStepexception">ISS encoding for an exception from a Software Step exception</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#ISV_24">ISV</a></td><td class="lr" colspan="17"><a href="#0_23">RES0</a></td><td class="lr" colspan="1"><a href="#EX_6">EX</a></td><td class="lr" colspan="6"><a href="#IFSC_5">IFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="ISV_24">ISV, bit [24]
              </h4>
          
  <p>Instruction syndrome valid. Indicates whether the EX bit, ISS[6], is valid, as follows:</p>

          <table class="valuetable"><tr><th>ISV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>EX bit is <span class="arm-defined-word">RES0</span>.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>EX bit is valid.</p>
</td></tr></table>
            
  <p>See the EX bit description for more information.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_23">
                Bits [23:7]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="EX_6">EX, bit [6]
              </h4>
          
  <p>Exclusive operation. If the ISV bit is set to 1, this bit indicates whether a Load-Exclusive instruction was stepped.</p>

          <table class="valuetable"><tr><th>EX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>An instruction other than a Load-Exclusive instruction was stepped.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>A Load-Exclusive instruction was stepped.</p>
</td></tr></table>
            
  <p>If the ISV bit is set to 0, this bit is <span class="arm-defined-word">RES0</span>, indicating no syndrome data is available.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="IFSC_5">IFSC, bits [5:0]
                  </h4>
          
  <p>Instruction Fault Status Code.</p>

          <table class="valuetable"><tr><th>IFSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b100010</td><td>
  <p>Debug exception.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see <span class="xref">'Software Step exceptions'</span>.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaWatchpointexception">ISS encoding for an exception from a Watchpoint exception</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="11"><a href="#0_24">RES0</a></td><td class="lr" colspan="1"><a href="#VNCR_13">VNCR</a></td><td class="lr" colspan="4"><a href="#0_12">RES0</a></td><td class="lr" colspan="1"><a href="#CM_8">CM</a></td><td class="lr" colspan="1"><a href="#0_7">RES0</a></td><td class="lr" colspan="1"><a href="#WnR_6">WnR</a></td><td class="lr" colspan="6"><a href="#DFSC_5">DFSC</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:14]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="VNCR_13">VNCR, bit [13]
              <div style="font-size:smaller;"><br />When ARMv8.4-NV is implemented:
                </div></h4>
          
  <p>Indicates that the watchpoint came from use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> register by EL1 code.</p>

          <table class="valuetable"><tr><th>VNCR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The watchpoint was not generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The watchpoint was generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p>
</td></tr></table>
            
  <p>This field is 0 in ESR_EL1.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_13"><div style="font-size:smaller;"><br />
              Otherwise:
            </div></h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="0_12">
                Bits [12:9]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="CM_8">CM, bit [8]
              </h4>
          
  <p>Cache maintenance. Indicates whether the Watchpoint exception came from a cache maintenance or address translation instruction:</p>

          <table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>The Watchpoint exception was not generated by the execution of one of the System instructions identified in the description of value 1.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>The Watchpoint exception was generated by either the execution of a cache maintenance instruction or by a synchronous Watchpoint exception on the execution of an address translation instruction. The <a href="AArch64-dc-zva.html">DC ZVA</a> instruction is not classified as a cache maintenance instruction, and therefore its execution cannot cause this field to be set to 1.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="0_7">
                Bit [7]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="WnR_6">WnR, bit [6]
              </h4>
          
  <p>Write not Read. Indicates whether the Watchpoint exception was caused by an instruction writing to a memory location, or by an instruction reading from a memory location. The possible values of this bit are:</p>

          <table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Watchpoint exception caused by an instruction reading from a memory location.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Watchpoint exception caused by an instruction writing to a memory location.</p>
</td></tr></table>
            
  <p>For Watchpoint exceptions on cache maintenance and address translation instructions, this bit always returns a value of 1.</p>
<p>For Watchpoint exceptions from an atomic instruction, this field is set to 0 if a read of the location would have generated the Watchpoint exception, otherwise it is set to 1.</p>
<p>If multiple watchpoints match on the same access, it is <span class="arm-defined-word">UNPREDICTABLE</span> which watchpoint generates the Watchpoint exception.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="DFSC_5">DFSC, bits [5:0]
                  </h4>
          
  <p>Data Fault Status Code.</p>

          <table class="valuetable"><tr><th>DFSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b100010</td><td>
  <p>Debug exception.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see <span class="xref">'Watchpoint exceptions'</span>.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromexecutionofaBreakpointinstruction">ISS encoding for an exception from execution of a Breakpoint instruction</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#0_24">RES0</a></td><td class="lr" colspan="16"><a href="#Comment_15">Comment</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:16]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="Comment_15">Comment, bits [15:0]
                  </h4>
          
  <p>Set to the instruction comment field value, zero extended as necessary.</p>
<p>For the AArch32 BKPT instructions, the comment field is described as the immediate field.</p>

          
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see <span class="xref">'Breakpoint instruction exceptions'</span>.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromERET,ERETAAorERETABinstruction">ISS encoding for an exception from ERET, ERETAA or ERETAB instruction</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="23"><a href="#WhenARMv8.3-NVisimplemented_0_24">RES0</a></td><td class="lr" colspan="1"><a href="#WhenARMv8.3-NVisimplemented_ERET_1">ERET</a></td><td class="lr" colspan="1"><a href="#WhenARMv8.3-NVisimplemented_ERETA_0">ERETA</a></td></tr></tbody></table><div class="text_before_fields">
      
  <p>This EC value applies when <span class="xref">ARMv8.6-FGT</span> is implemented, or when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.NV is 1.</p>

    </div><h4 id="WhenARMv8.3-NVisimplemented_0_24">
                Bits [24:2]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="WhenARMv8.3-NVisimplemented_ERET_1">ERET, bit [1]
              </h4>
          
  <p>Indicates whether an ERET or ERETA* instruction was trapped to EL2. Possible values are:</p>

          <table class="valuetable"><tr><th>ERET</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>ERET instruction trapped to EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>ERETAA or ERETAB instruction trapped to EL2.</p>
</td></tr></table>
            
  <p>If this bit is 0, the ERETA field is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="WhenARMv8.3-NVisimplemented_ERETA_0">ERETA, bit [0]
              </h4>
          
  <p>Indicates whether an ERETAA or ERETAB instruction was trapped to EL2. Possible values are:</p>

          <table class="valuetable"><tr><th>ERETA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>ERETAA instruction trapped to EL2.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>ERETAB instruction trapped to EL2.</p>
</td></tr></table>
            
  <p>When the ERET field is 0, this bit is <span class="arm-defined-word">RES0</span>.</p>

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see <a href="AArch64-hcr_el2.html">HCR_EL2</a>.NV.</p>
<p>If <span class="xref">ARMv8.6-FGT</span> is implemented, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a>.ERET controls fine-grained trap exceptions from ERET, ERETAA and ERETAB execution.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromBranchTargetIdentificationinstruction">ISS encoding for an exception from Branch Target Identification instruction</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="23"><a href="#WhenARMv8.5-BTIisimplemented_0_24">RES0</a></td><td class="lr" colspan="2"><a href="#WhenARMv8.5-BTIisimplemented_BTYPE_1">BTYPE</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="WhenARMv8.5-BTIisimplemented_0_24">
                Bits [24:2]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="WhenARMv8.5-BTIisimplemented_BTYPE_1">BTYPE, bits [1:0]
                  </h4>
          
  <p>This field is set to the PSTATE.BTYPE value that generated the Branch Target Exception.</p>

          
            
  

          <div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see <span class="xref">'The AArch64 application level programmers model'</span>.</p>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaPointerAuthenticationinstructionwhenHCR_EL2.API0||SCR_EL3.API0">ISS encoding for an exception from a Pointer Authentication instruction when HCR_EL2.API == 0 || SCR_EL3.API == 0</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#0_24">RES0</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:0]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <div class="text_after_fields">
    
  <p>For more information about generating these exceptions, see:</p>
<ul>
<li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.API, for exceptions from Pointer authentication instructions, using AArch64 state, trapped to EL2.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.API, for exceptions from Pointer authentication instructions, using AArch64 state, trapped to EL3.
</li></ul>

    </div></div><div class="partial_fieldset"><h3 id="ISS_anexceptionfromaPointerAuthenticationinstructionauthenticationfailure">ISS encoding for an exception from a Pointer Authentication instruction authentication failure</h3><ul></ul><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="23"><a href="#0_24">RES0</a></td><td class="lr" colspan="1"><a href="#ExceptionasaresultofanInstructionkeyoraDatakey_1">Exception as a result of an Instruction key or a Data key</a></td><td class="lr" colspan="1"><a href="#ExceptionasaresultofanAkeyoraBkey_0">Exception as a result of an A key or a B key</a></td></tr></tbody></table><div class="text_before_fields">
      
  

    </div><h4 id="0_24">
                Bits [24:2]
              </h4>
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          <h4 id="ExceptionasaresultofanInstructionkeyoraDatakey_1">
                Bit [1]
              </h4>
          
  <p>This field indicates whether the exception is as a result of an Instruction key or a Data key.</p>

          <table class="valuetable"><tr><th></th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>Instruction Key.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>Data Key.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="ExceptionasaresultofanAkeyoraBkey_0">
                Bit [0]
              </h4>
          
  <p>This field indicates whether the exception is as a result of an A key or a B key.</p>

          <table class="valuetable"><tr><th></th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
  <p>A key.</p>
</td></tr><tr><td class="bitfield">0b1</td><td>
  <p>B key.</p>
</td></tr></table>
            
  

          <p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields">
    
  <p>The following instructions generate an exception when the Pointer Authentication Code (PAC) is incorrect:</p>
<ul>
<li><span class="instruction">AUTIASP</span>, <span class="instruction">AUTIAZ</span>, <span class="instruction">AUTIA1716</span>.
</li><li><span class="instruction">AUTIBSP</span>, <span class="instruction">AUTIBZ</span>, <span class="instruction">AUTIB1716</span>.
</li><li><span class="instruction">AUTIA</span>, <span class="instruction">AUTDA</span>, <span class="instruction">AUTIB</span>, <span class="instruction">AUTDB</span>.
</li><li><span class="instruction">AUTIZA</span>, <span class="instruction">AUTIZB</span>, <span class="instruction">AUTDZA</span>, <span class="instruction">AUTDZB</span>.
</li></ul>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the following instructions generate an exception directly from the authorization failure, rather than changing the address in a way that will generate a translation fault when the address is accessed:</p>
<ul>
<li><span class="instruction">RETAA</span>, <span class="instruction">RETAB</span>.
</li><li><span class="instruction">BRAA</span>, <span class="instruction">BRAB</span>, <span class="instruction">BLRAA</span>, <span class="instruction">BLRAB</span>.
</li><li><span class="instruction">BRAAZ</span>, <span class="instruction">BRABZ</span>, <span class="instruction">BLRAAZ</span>, <span class="instruction">BLRABZ</span>.
</li><li><span class="instruction">ERETAA</span>, <span class="instruction">ERETAB</span>.
</li><li><span class="instruction">LDRAA</span>, <span class="instruction">LDRAB</span>, whether the authenticated address is written back to the base register or not.
</li></ul>

    </div></div><div class="text_after_fields">
    
  

    </div><div class="access_mechanisms"><h2>Accessing the ESR_EL2</h2>
        <p>When <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H is 1, without explicit synchronization, access from EL2 using the mnemonic ESR_EL2 or ESR_EL1 are not guaranteed to be ordered with respect to accesses using the other mnemonic.</p>
      <p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRS &lt;Xt&gt;, ESR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        return ESR_EL1;
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    return ESR_EL2;
elsif PSTATE.EL == EL3 then
    return ESR_EL2;
              </p><h4 class="assembler">MSR ESR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV&gt; == '11' then
        ESR_EL1 = X[t];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    ESR_EL2 = X[t];
elsif PSTATE.EL == EL3 then
    ESR_EL2 = X[t];
              </p><h4 class="assembler">MRS &lt;Xt&gt;, ESR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.ESR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        return NVMem[0x138];
    else
        return ESR_EL1;
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        return ESR_EL2;
    else
        return ESR_EL1;
elsif PSTATE.EL == EL3 then
    return ESR_EL1;
              </p><h4 class="assembler">MSR ESR_EL1, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.ESR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;NV2,NV1,NV&gt; == '111' then
        NVMem[0x138] = X[t];
    else
        ESR_EL1 = X[t];
elsif PSTATE.EL == EL2 then
    if HCR_EL2.E2H == '1' then
        ESR_EL2 = X[t];
    else
        ESR_EL1 = X[t];
elsif PSTATE.EL == EL3 then
    ESR_EL1 = X[t];
              </p></div><br /><br /><hr /><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">13/12/2019 15:13; 391b5248b29fb2f001ef74792eaacbd6fc72f211</p><p class="copyconf">Copyright © 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
