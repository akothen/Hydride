<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/><title>PAR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PAR, Physical Address Register</h1><p>The PAR characteristics are:</p><h2>Purpose</h2><p>Returns the output address (OA) from an Address translation instruction that executed successfully, or fault information if the instruction did not execute successfully.</p><h2>Configuration</h2><p>AArch32 System register PAR bits [63:0]
            
                are architecturally mapped to
              AArch64 System register <a href="AArch64-par_el1.html">PAR_EL1[63:0]
            </a>.
          </p><p><ins>This register is present only
    when AArch32 is supported at any Exception level.
      
    Otherwise, direct accesses to PAR are </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins>.</ins></p><p>PAR is accessed as a 32-bit value:</p><ul><li>When the PE is not in Hyp mode and is using the Short-descriptor translation table format.
</li><li>When the PE is in Hyp mode and executes an <a href="AArch32-ats12nsopr.html">ATS12NSOPR</a>, <a href="AArch32-ats12nsopw.html">ATS12NSOPW</a>, <a href="AArch32-ats12nsour.html">ATS12NSOUR</a>, or <a href="AArch32-ats12nsouw.html">ATS12NSOUW</a> instruction and the value of <a href="AArch32-hcr.html">HCR</a>.VM is 0 and the value of <a href="AArch32-ttbcr.html">TTBCR</a>.EAE is 0.
</li></ul><p>In these cases, PAR[63:32] is <span class="arm-defined-word">RES0</span>.</p><p>Otherwise, the PAR is accessed as a 64-bit value, if any of the following is true:</p><ul><li>When using the Long-descriptor translation table format.
</li><li>If the stage 1 address translation is disabled and <a href="AArch32-ttbcr.html">TTBCR</a>.EAE is set to 1.
</li><li>In an implementation that includes EL2, for the result of an ATS1Cxx instruction performed from Hyp mode.
</li></ul><p>For PL1&amp;0 stage 1 translations, <a href="AArch32-ttbcr.html">TTBCR</a>.EAE selects the translation table format.</p><p><del class="nocount">
                RW fields in this register reset to architecturally </del><span class="arm-defined-word"><del class="nocount">UNKNOWN</del></span><del class="nocount"> values.
              </del></p><h2>Attributes</h2><p>PAR is a 64-bit register that can also be accessed as a 32-bit value. If it is accessed as a 32-bit register, accesses read and write bits[31:0] and do not modify bits[63:32].</p><p>The Configurations section specifies the cases where each PAR format is used.</p><h2>Field descriptions</h2><p>The PAR bit assignments are:</p><h3>When the instruction returned a 32-bit value to the PAR, PAR.F==0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_PA_31">PA</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_LPAE_11">LPAE</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_NOS_10">NOS</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_NS_9">NS</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_IMPLEMENTATIONDEFINED_8">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_SH_7">SH</a></td><td class="lr" colspan="3"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_Inner2:0_6">Inner[2:0]</a></td><td class="lr" colspan="2"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_Outer1:0_3">Outer[1:0]</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_SS_1">SS</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_F_0">F</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p><p>On a successful conversion, the PAR can return a value that indicates the resulting attributes, rather than the values that appear in the translation table descriptors. More precisely:</p><ul><li>Memory attribute fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the translation table descriptors. This applies to the NOS, SH, Inner, and Outer fields.
</li><li>See the NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_PA_31">PA, bits [31:12]
                  </h4><p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[31:12].</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_LPAE_11">LPAE, bit [11]
              </h4><p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Short-descriptor translation table format used. This means the PAR returned a 32-bit value.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_NOS_10">NOS, bit [10]
              </h4><p>Not Outer Shareable. When the returned value of PAR.SH is 1, indicates the Shareability attribute for the physical memory region:</p><table class="valuetable"><tr><th>NOS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Memory region is Outer Shareable.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Memory region is Inner Shareable.</p></td></tr></table><p>When the returned value of PAR.SH is 0 the value returned to this field is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_NS_9">NS, bit [9]
              </h4><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p><p>For a result from a Secure translation regime, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_IMPLEMENTATIONDEFINED_8">IMPLEMENTATION DEFINED, bit [8]
              </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_SH_7">SH, bit [7]
              </h4><p>Shareability. Indicates whether the physical memory region is Non-shareable:</p><table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Memory is Non-shareable.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Memory is shareable, and PAR.NOS indicates whether the region is Outer Shareable or Inner Shareable.</p></td></tr></table><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_Inner2:0_6">Inner[2:0], bits [6:4]
                  </h4><p>Inner cacheability attribute for the region. Permitted values are:</p><table class="valuetable"><tr><th>Inner[2:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td><p>Non-cacheable.</p></td></tr><tr><td class="bitfield">0b001</td><td><p>Device-nGnRnE.</p></td></tr><tr><td class="bitfield">0b011</td><td><p>Device-nGnRE.</p></td></tr><tr><td class="bitfield">0b101</td><td><p>Write-Back, Write-Allocate.</p></td></tr><tr><td class="bitfield">0b110</td><td><p>Write-Through.</p></td></tr><tr><td class="bitfield">0b111</td><td><p>Write-Back, no Write-Allocate.</p></td></tr></table><p>The values <span class="binarynumber">0b010</span> and <span class="binarynumber">0b100</span> are reserved.</p><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_Outer1:0_3">Outer[1:0], bits [3:2]
                  </h4><p>Outer cacheability attribute for the region. Permitted values are:</p><table class="valuetable"><tr><th>Outer[1:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-cacheable.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Write-Back, Write-Allocate.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Write-Through, no Write-Allocate.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Write-Back, no Write-Allocate.</p></td></tr></table><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_SS_1">SS, bit [1]
              </h4><p>Supersection. Used to indicate if the result is a Supersection:</p><table class="valuetable"><tr><th>SS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Result is not a Supersection. PAR[31:12] contains OA[31:12].</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Result is a Supersection, and:</p><ul><li>PAR[31:24] contains OA[31:24].
</li><li>PAR[23:16] contains OA[39:32].
</li><li>PAR[15:12] contains <span class="binarynumber">0b0000</span>.
</li></ul><p>If an implementation supports less than 40 bits of physical address, the bits in the PAR field that correspond to physical address bits that are not implemented are <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F0_F_0">F, bit [0]
              </h4><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Address translation completed successfully.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><h3>When the instruction returned a 32-bit value to the PAR, PAR.F==1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_63">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="16"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_31">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_15">RES0</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_LPAE_11">LPAE</a></td><td class="lr" colspan="4"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_10">RES0</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_FS5_6"><ins class="nocount">FS[5]</ins></a><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_FS_6"><del class="nocount">FS</del></a></td><td class="lr" colspan="5"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_FS4:0_5"><ins class="nocount">FS[4:0]</ins></a><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_F_0"><del class="nocount">F</del></a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_F_0"><ins class="nocount">F</ins></a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"><p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_63">
                Bits [63:32]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_31">IMPLEMENTATION DEFINED, bits [31:16]
                  </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_15">
                Bits [15:12]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_LPAE_11">LPAE, bit [11]
              </h4><p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Short-descriptor translation table format used. This means the PAR returned a 32-bit value.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_0_10">
                Bits [10:7]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_FS5_6">FS<ins>[5],</ins><del>,</del> <ins>bit</ins><del>bits</del> [6<del>:1</del>]
              </h4><p>Fault status <ins>bits,</ins><del>bits.</del> <ins>external</ins><del>Bits</del> <ins>abort</ins><del>[12,10,3:0]</del> <ins>type.</ins><del>from</del> <ins>Provides an</ins><del>the</del> <span class="arm-defined-word"><ins>IMPLEMENTATION DEFINED</ins></span><ins> classification of an External abort. Values are as in in the </ins><a href="AArch32-dfsr.html">DFSR</a><ins>.ExT</ins><del>,</del> <ins>field</ins><del>indicating</del> <ins>when using </ins>the <ins>Short-descriptor</ins><del>source</del> <ins>translation</ins><del>of</del> <ins>table</ins><del>the</del> <ins>format.</ins><del>abort.</del></p><p><ins>In an implementation that does not provide any classification of External aborts, this bit is </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p><p><ins>For aborts other than External aborts this bit always returns 0.</ins></p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_FS4:0_5"><ins>FS[4:0], bits [5:1]
                  </ins></h4><p><ins>Fault status bits. Values are as in the </ins><a href="AArch32-dfsr.html"><ins>DFSR</ins></a><ins>.FS field when using the Short-descriptor translation table format.</ins></p><table class="valuetable"><tr><th><ins>FS[4:0]</ins></th><th><ins>Meaning</ins></th><th><ins>Applies when</ins></th></tr><tr><td class="bitfield"><ins>0b00001</ins></td><td><p><ins>Alignment fault.</ins></p></td></tr><tr><td class="bitfield"><ins>0b00011</ins></td><td><p><ins>Access flag fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b00100</ins></td><td><p><ins>Fault on instruction cache maintenance.</ins></p></td></tr><tr><td class="bitfield"><ins>0b00101</ins></td><td><p><ins>Translation fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b00110</ins></td><td><p><ins>Access flag fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b00111</ins></td><td><p><ins>Translation fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01001</ins></td><td><p><ins>Domain fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01011</ins></td><td><p><ins>Domain fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01100</ins></td><td><p><ins>Synchronous External abort, on translation table walk, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01101</ins></td><td><p><ins>Permission fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01110</ins></td><td><p><ins>Synchronous External abort, on translation table walk, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b01111</ins></td><td><p><ins>Permission fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b10000</ins></td><td><p><ins>TLB conflict abort.</ins></p></td></tr><tr><td class="bitfield"><ins>0b11001</ins></td><td><p><ins>Synchronous parity or ECC error on memory access, not on translation table walk.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b11100</ins></td><td><p><ins>Synchronous parity or ECC error on translation table walk, level 1.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b11110</ins></td><td><p><ins>Synchronous parity or ECC error on translation table walk, level 2.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr></table><p><ins>This field resets to an </ins><span class="arm-defined-word"><ins>UNKNOWN</ins></span><ins> value.</ins></p><h4 id="Whentheinstructionreturneda32-bitvaluetothePAR,PAR.F1_F_0">F, bit [0]
              </h4><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Address translation aborted.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><h3>When the instruction returned a 64-bit value to the PAR, PAR.F==0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_ATTR_63">ATTR</a></td><td class="lr" colspan="16"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_0_55">RES0</a></td><td class="lr" colspan="8"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_PA_39">PA</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_PA_39">PA</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_LPAE_11">LPAE</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_IMPLEMENTATIONDEFINED_10">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_NS_9">NS</a></td><td class="lr" colspan="2"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_SH_8">SH</a></td><td class="lr" colspan="6"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_0_6">RES0</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_F_0">F</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p><p>On a successful conversion, the PAR can return a value that indicates the resulting attributes, rather than the values that appear in the translation table descriptors. More precisely:</p><ul><li>Memory attribute fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the translation table descriptors. This applies to the ATTR and SH fields.
</li><li>See the NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_ATTR_63">ATTR, bits [63:56]
                  </h4><p>Memory attributes for the returned output address. This field uses the same encoding as the Attr&lt;n> fields in <a href="AArch32-mair0.html">MAIR0</a> and <a href="AArch32-mair1.html">MAIR1</a>.</p><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_0_55">
                Bits [55:40]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_PA_39">PA, bits [39:12]
                  </h4><p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[39:12].</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_LPAE_11">LPAE, bit [11]
              </h4><p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Long-descriptor translation table format used. This means the PAR returned a 64-bit value.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_IMPLEMENTATIONDEFINED_10">IMPLEMENTATION DEFINED, bit [10]
              </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_NS_9">NS, bit [9]
              </h4><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p><p>For a result from a Secure translation regime, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_SH_8">SH, bits [8:7]
                  </h4><p>Shareability attribute, for the returned output address. Permitted values are:</p><table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-shareable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Outer Shareable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Inner Shareable.</p></td></tr></table><p>The value <span class="binarynumber">0b01</span> is reserved.</p><div class="note"><span class="note-header">Note</span><p>This field returns the value <span class="binarynumber">0b10</span> for:</p><ul><li>Any type of Device memory.</li><li>Normal memory with both Inner Non-cacheable and Outer Non-cacheable attributes.</li></ul></div><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_0_6">
                Bits [6:1]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F0_F_0">F, bit [0]
              </h4><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Address translation completed successfully.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><h3>When the instruction returned a 64-bit value to the PAR, PAR.F==1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_63">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_55">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_51">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="16"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_47">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_47">RES0</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_LPAE_11">LPAE</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_10">RES0</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_FSTAGE_9">FSTAGE</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_S2WLK_8">S2WLK</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_7">RES0</a></td><td class="lr" colspan="6"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_FST_6">FST</a></td><td class="lr" colspan="1"><a href="#Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_F_0">F</a></td></tr></tbody><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot></table><div class="text_before_fields"><p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_63">IMPLEMENTATION DEFINED, bits [63:56]
                  </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_55">IMPLEMENTATION DEFINED, bits [55:52]
                  </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_IMPLEMENTATIONDEFINED_51">IMPLEMENTATION DEFINED, bits [51:48]
                  </h4><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_47">
                Bits [47:12]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_LPAE_11">LPAE, bit [11]
              </h4><p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p><table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Long-descriptor translation table format used. This means the PAR returned a 64-bit value.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_10">
                Bit [10]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_FSTAGE_9">FSTAGE, bit [9]
              </h4><p>Indicates the translation stage at which the translation aborted:</p><table class="valuetable"><tr><th>FSTAGE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Translation aborted because of a fault in the stage 1 translation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Translation aborted because of a fault in the stage 2 translation.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_S2WLK_8">S2WLK, bit [8]
              </h4><p>If this bit is set to 1, it indicates the translation aborted because of a stage 2 fault during a stage 1 translation table walk.</p><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_0_7">
                Bit [7]
              </h4><p>Reserved, <span class="arm-defined-word">RES0</span>.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_FST_6">FST, bits [6:1]
                  </h4><p>Fault status field. Values are as in the <a href="AArch32-dfsr.html">DFSR</a>.STATUS and <a href="AArch32-ifsr.html">IFSR</a>.STATUS fields when using the Long-descriptor translation table format.</p><table class="valuetable"><tr><th><ins>FST</ins></th><th><ins>Meaning</ins></th><th><ins>Applies when</ins></th></tr><tr><td class="bitfield"><ins>0b000000</ins></td><td><p><ins>Address size fault in translation table base register.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000001</ins></td><td><p><ins>Address size fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000010</ins></td><td><p><ins>Address size fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000011</ins></td><td><p><ins>Address size fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000101</ins></td><td><p><ins>Translation fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000110</ins></td><td><p><ins>Translation fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b000111</ins></td><td><p><ins>Translation fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001001</ins></td><td><p><ins>Access flag fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001010</ins></td><td><p><ins>Access flag fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001011</ins></td><td><p><ins>Access flag fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001101</ins></td><td><p><ins>Permission fault, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001110</ins></td><td><p><ins>Permission fault, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b001111</ins></td><td><p><ins>Permission fault, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010000</ins></td><td><p><ins>Synchronous External abort, not on translation table walk.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010101</ins></td><td><p><ins>Synchronous External abort, on translation table walk, level 1.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010110</ins></td><td><p><ins>Synchronous External abort, on translation table walk, level 2.</ins></p></td></tr><tr><td class="bitfield"><ins>0b010111</ins></td><td><p><ins>Synchronous External abort, on translation table walk, level 3.</ins></p></td></tr><tr><td class="bitfield"><ins>0b011000</ins></td><td><p><ins>Synchronous parity or ECC error on memory access, not on translation table walk.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b011001</ins></td><td><p><ins>Asynchronous SError interrupt, from a parity or ECC error on memory access.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b011101</ins></td><td><p><ins>Synchronous parity or ECC error on memory access on translation table walk, level 1.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b011110</ins></td><td><p><ins>Synchronous parity or ECC error on memory access on translation table walk, level 2.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b011111</ins></td><td><p><ins>Synchronous parity or ECC error on memory access on translation table walk, level 3.</ins></p></td><td><ins>When RAS is not implemented</ins></td></tr><tr><td class="bitfield"><ins>0b100001</ins></td><td><p><ins>Alignment fault.</ins></p></td></tr><tr><td class="bitfield"><ins>0b110000</ins></td><td><p><ins>TLB conflict abort.</ins></p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><h4 id="Whentheinstructionreturneda64-bitvaluetothePAR,PAR.F1_F_0">F, bit [0]
              </h4><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Address translation aborted.</p></td></tr></table><p>This field resets to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</p><div class="text_after_fields"></div><div class="access_mechanisms"><h2>Accessing the PAR</h2><p>Accesses to this register use the following encodings:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            return PAR_S&lt;31:0>;
        else
            </del>return PAR_NS&lt;31:0>;
    else
        return PAR&lt;31:0>;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return PAR_NS&lt;31:0>;
    else
        return PAR&lt;31:0>;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        return PAR_S&lt;31:0>;
    else
        return PAR_NS&lt;31:0>;
              </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            PAR_S = ZeroExtend(R[t]);
        else
            </del>PAR_NS = ZeroExtend(R[t]);
    else
        PAR = ZeroExtend(R[t]);
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS = ZeroExtend(R[t]);
    else
        PAR = ZeroExtend(R[t]);
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        PAR_S = ZeroExtend(R[t]);
    else
        PAR_NS = ZeroExtend(R[t]);
              </p><h4 class="assembler">MRRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0111</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            return PAR_S;
        else
            </del>return PAR_NS;
    else
        return PAR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        return PAR_NS;
    else
        return PAR;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        return PAR_S;
    else
        return PAR_NS;
              </p><h4 class="assembler">MCRR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0111</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        <del>if SCR.NS == '0' then
            PAR_S = R[t2]:R[t];
        else
            </del>PAR_NS = R[t2]:R[t];
    else
        PAR = R[t2]:R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS = R[t2]:R[t];
    else
        PAR = R[t2]:R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        PAR_S = R[t2]:R[t];
    else
        PAR_NS = R[t2]:R[t];
              </p></div><br/><br/><hr/><table align="center"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>13</ins><del>27</del>/<ins>12</ins><del>09</del>/2019 <ins>15</ins><del>18</del>:<ins>13</ins><del>48</del>; <ins>391b5248b29fb2f001ef74792eaacbd6fc72f211</ins><del>6134483bd14dc8c12a99c984cbfe3431cc1c9707</del></p><p class="copyconf">Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>