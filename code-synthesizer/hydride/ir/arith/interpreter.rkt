#lang rosette
;#lang rosette/safe

(require rosette/lib/synthax)
(require rosette/lib/angelic)
(require rosette/lib/destruct)
(require
  (only-in racket/base error bitwise-and)
  rosette/lib/destruct
  hydride/cpp
  hydride/utils/bvops
  hydride/utils/debug
  hydride/ir/arith/types)

(provide (prefix-out arith: (all-defined-out)))

;; Infer the length of vector generated by the expression
(define (elem-type expr)
  (define intr-expr (interpret expr))
  (cpp:type (intr-expr 0)))



(define (intr-elemT-size elemT) 
(cond
    [(eq? elemT 'int8) 8]
    [(eq? elemT 'int16) 16]
    [(eq? elemT 'int32) 32]
    [(eq? elemT 'int64) 64]
    [(eq? elemT 'uint1) 1]
    [(eq? elemT 'uint8) 8]
    [(eq? elemT 'uint16) 16]
    [(eq? elemT 'uint32) 32]
    [(eq? elemT 'uint64) 64]
    [else (error "arith/ir/interpreter.rkt: Unexpected buffer type in intr-elemT-size" elemT )])
)


(define (create-tensor data shape-vector layout-vector elemT id)
  (define step-size
    (cond
        [(eq? elemT 'int8) 8]
        [(eq? elemT 'int16) 16]
        [(eq? elemT 'int32) 32]
        [(eq? elemT 'int64) 64]
        [(eq? elemT 'uint1) 1]
        [(eq? elemT 'uint8) 8]
        [(eq? elemT 'uint16) 16]
        [(eq? elemT 'uint32) 32]
        [(eq? elemT 'uint64) 64]
        [else (error "arith/ir/interpreter.rkt: Unexpected buffer type in create-buffer" elemT)])
    )
  ;; Create buffer object with
  ;; specified buffer function

  (arith:tensor data shape-vector layout-vector elemT (bvlength data) id)

)


(define (is-signed-expr? e1 e2)
  (define input-shape (tensor-shape e1))
  (define (helper i) 0)
  (define zero-index (build-vector (vector-length input-shape) helper))
  
  (define outT (infer-out-type (interpret e1 zero-index) (interpret e2 zero-index)) )
  (cpp:signed-type? outT)
  )

(define (is-buffer-signed buf)
  (destruct buf

            [(arith:tensor data shape layout elemT buffsize id) 
             (cond
               [(eq? elemT 'int8) #t]
               [(eq? elemT 'int16) #t]
               [(eq? elemT 'int32) #t]
               [(eq? elemT 'int64) #t]
               [(eq? elemT 'uint1) #f]
               [(eq? elemT 'uint8) #f]
               [(eq? elemT 'uint16) #f]
               [(eq? elemT 'uint32) #f]
               [(eq? elemT 'uint64) #f]
               )
             ]

            [(arith:tensor-index index shape layout elemT buffsize id) 
             (cond
               [(eq? elemT 'int8) #t]
               [(eq? elemT 'int16) #t]
               [(eq? elemT 'int32) #t]
               [(eq? elemT 'int64) #t]
               [(eq? elemT 'uint1) #f]
               [(eq? elemT 'uint8) #f]
               [(eq? elemT 'uint16) #f]
               [(eq? elemT 'uint32) #f]
               [(eq? elemT 'uint64) #f]
               )
             ]
            [_ (error "Should have passed in buffer" buf)]
            )
  )


;; Add new shape dimension to the end of the tensor's shape


(define (extend-shape shape1 new-dim)
  (define (helper i)
    (if 
      (< i (vector-length shape1))
       (vector-ref shape1 i)
       new-dim
    )
      )
  (build-vector (+ (vector-length shape1) 1)  helper)
  )





;; Add new layout dimension to the end of the tensor' layout 
(define (extend-layout layout1)
  (define (helper i)
    (if 
      (< i (vector-length layout1))
       (vector-ref layout1 i)
       i
    )
      )
  (build-vector (+ (vector-length layout1) 1)  helper)
  )


(define (get-num-elements shape)
  (define num-elems 1)

  (for/list ([i (range (vector-length shape))])
            (set! num-elems (* num-elems (vector-ref shape i)))
            )

  num-elems
  )




(define (index-tensor bv shape-vec layout-vec prec indices)
  (cond
    [(equal? 0 (vector-length indices ))     
     (error "0 dimensional tensor is illegal")
     ]
    [(equal? 1 (vector-length indices ))
     (define index (vector-ref indices 0))
     (define shape (vector-ref shape-vec 0))
     (define index-from-right (- shape index 1))
     (define low (* prec index-from-right))
     (define high (+ low (- prec 1)))
     (extract high low bv)
     ]
    [else
      (define dim-size (vector-ref shape-vec 0))
      (define index (vector-ref indices 0))
      (define index-from-right (- dim-size index 1))
      (define remaining-shape (vector-take-right shape-vec (- (vector-length shape-vec) 1) ))
      (define remaining-layout (vector-take-right layout-vec (- (vector-length layout-vec) 1) ))
      (define remaining-indices (vector-take-right indices (- (vector-length indices) 1) ))
      (define stride-size (* (get-num-elements remaining-shape) prec) )
      (define low (* stride-size index-from-right))
      (define high (+ low (- stride-size 1)))
      (define bv-slice (extract high low bv))
      (index-tensor bv-slice remaining-shape remaining-layout prec remaining-indices)
      ]
    )
  )

(define (imm-ref data signed?)
  (define size (bvlength data))
  (cond
    [(and (eq? size 8) signed?) (int8_t data)]
    [(and (eq? size 16) signed?) (int16_t data)]
    [(and (eq? size 32) signed?) (int32_t data)]
    [(and (eq? size 64) signed?) (int64_t data)]
    [(and (eq? size 8)) (uint8_t data)]
    [(and (eq? size 16)) (uint16_t data)]
    [(and (eq? size 32)) (uint32_t data)]
    [(and (eq? size 64)) (uint64_t data)]
    [else (error "arith/interpreter.rkt: Unexpected imm-ref buffer type" data)]))


(define (interpret p indices)
  (destruct p


            ;; Constructors

            [(arith:tensor data shape-vector layout-vector elemT buffSize id)

             ;; To account for differing layouts, we can simply sort 
             ;; the indices and the shape vector according to the 
             ;; layout vector. 

             (define (sorted-index-shape i)
               (define layout-index (vector-ref layout-vector i))
               (vector-ref shape-vector layout-index)
               )

             (define (sorted-index-indices i)
               (define layout-index (vector-ref layout-vector i))
               (vector-ref indices layout-index)
               )

             (define sorted-shape  (build-vector (vector-length shape-vector) sorted-index-shape ))
             (define sorted-indices  (build-vector (vector-length indices) sorted-index-indices ))


             (cond
               [(eq? elemT 'int8) (int8_t (index-tensor data sorted-shape layout-vector 8 sorted-indices))]
               [(eq? elemT 'int16) (int16_t (index-tensor data sorted-shape layout-vector 16 sorted-indices))]
               [(eq? elemT 'int32) (int32_t (index-tensor data sorted-shape layout-vector 32 sorted-indices))]
               [(eq? elemT 'int64) (int64_t (index-tensor data sorted-shape layout-vector 64 sorted-indices))]
               [(eq? elemT 'uint1) (uint1_t (index-tensor data sorted-shape layout-vector 1 sorted-indices))]
               [(eq? elemT 'uint8) (uint8_t (index-tensor data sorted-shape layout-vector 8 sorted-indices))]
               [(eq? elemT 'uint16) (uint16_t (index-tensor data sorted-shape layout-vector 16 sorted-indices))]
               [(eq? elemT 'uint32) (uint32_t (index-tensor data sorted-shape layout-vector 32 sorted-indices))]
               [(eq? elemT 'uint64) (uint64_t (index-tensor data sorted-shape layout-vector 64 sorted-indices))]
               [else (error "arith/ir/interpreter.rkt: Unexpected element type type in tensor-ref" p)])
             ]


            [(arith:int-imm data signed?) 
             (imm-ref data signed?)
             ]

            ;; Type Casts

            [(arith:cast-int vec olane oprec) 
              (cpp:cast
                (interpret vec indices)
                (cond
                  [(eq? oprec 8)  'int8]
                  [(eq? oprec 16)  'int16]
                  [(eq? oprec 32)  'int32]
                  [(eq? oprec 64)  'int64]
                  [else (error "arith/interpreter.rkt: Unexpected buffer type in size-to-elemT-signed" oprec )]
                ))]
            [(arith:cast-uint vec olane oprec) 
              (cpp:cast
                (interpret vec indices)
                (cond
                  [(eq? oprec 8)  'uint8]
                  [(eq? oprec 16)  'uint16]
                  [(eq? oprec 32)  'uint32]
                  [(eq? oprec 64)  'uint64]
                  [else (error "arith/interpreter.rkt: Unexpected buffer type in size-to-elemT-signed" oprec )]
                ))]

            ;; Operations

            [(arith:tensor-add v1 v2) (do-add (interpret v1 indices) (interpret v2 indices))]

            [(arith:tensor-sat-add v1 v2) (do-sat-add (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-sub v1 v2) (do-sub (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-sat-sub v1 v2) (do-sat-sub (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-mul v1 v2) (do-mul (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-div v1 v2) (do-div (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-mod v1 v2) (do-mod (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-min v1 v2) (do-min (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-max v1 v2) (do-max (interpret v1 indices) (interpret v2 indices))]

            [(arith:tensor-if v1 v2 v3) (do-if (interpret v1 indices) (interpret v2 indices) (interpret v3 indices))]
            [(arith:tensor-eq v1 v2) (do-eq (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-lt v1 v2) (do-lt (interpret v1 indices) (interpret v2 indices) )]
            [(arith:tensor-le v1 v2) (do-le (interpret v1 indices) (interpret v2 indices) )]

            [(arith:tensor-abs v1) (do-abs (interpret v1 indices))]
            [(arith:tensor-shl v1 v2) (do-shl (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-shr v1 v2) (do-shr (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-absd v1 v2)  (do-absd (interpret v1 indices) (interpret v2 indices))]
            [(arith:tensor-clz v1) (do-clz (interpret v1 indices))]

            [(arith:tensor-bwand v1 v2) (do-bwand (interpret v1 indices) (interpret v2 indices))]

            [(vector:bitcast v1 signed? out-prec)
             (cpp:cast
               (interpret v1 indices)
               (cond
                 [(and (eq? out-prec 8) signed?)  'int8]
                 [(and (eq? out-prec 16) signed?)  'int16]
                 [(and (eq? out-prec 32) signed?)  'int32]
                 [(and (eq? out-prec 64) signed?)  'int64]
                 [(and (eq? out-prec 8) )  'uint8]
                 [(and (eq? out-prec 16) )  'uint16]
                 [(and (eq? out-prec 32) )  'uint32]
                 [(and (eq? out-prec 64) )  'uint64]

                 )
               )
             ]
            [(vector:broadcast v1 output-shape)
             (define input-shape (tensor-shape v1))
             (define num-input-dims (vector-length input-shape))
             (define num-output-dims (vector-length output-shape))

             ;; According to the semantics of the broadcast, the duplication
             ;; happens along the new leading dimensions, hence for the 
             ;; purposes of interpreting the semantics, we can discard
             ;; the leading dimensions

             (define num-new-leading-dims (- num-output-dims num-input-dims))
             (cond
               [(< num-output-dims num-input-dims)
                (error "Illegal broadcast shape for vector:broadcast")
                ]
               [else
                 (define sliced-indices (vector-take-right indices num-input-dims))
                 (interpret v1 sliced-indices)
                 ]
               )
             ]
            [(vector:extract_strided_slice v1 offsets sizes strides)
             (define input-shape (tensor-shape v1))
             (define (generate-strided-indices i)
              ;;; Not sure what's going on here
              ;;;  (if
              ;;;    (< i (vector-length offsets))

              ;;;    ;; Adjusted strided index
                 (+ (vector-ref offsets i) (* (vector-ref strides i) (vector-ref indices i)))

              ;;;    ;; If index along non-strided dimension index regularly
              ;;;    (vector-ref indices i)
              ;;;    )
               )

             (define actual-indices (build-vector (vector-length indices) generate-strided-indices))
             (interpret v1 actual-indices)
             
             ]

            [(vector:extract v1 extract_indices)
             (define input-shape (tensor-shape v1))
             (define (generate-extract-indicies i)
               (if 
                 (< i (vector-length extract_indices))

                 ;; Adjusted strided index
                 (+ (vector-length extract_indices i) (* 1 (vector-ref indices i)))

                 ;; If index along non-strided dimension index regularly
                 (vector-ref indices i)
                 )
               )

             (define actual-indices (build-vector (vector-length indices) generate-extract-indicies))
             (interpret v1 actual-indices)
             ]
            [(vector:matrix_multiply v1 v2 lhs_rows lhs_cols rhs_cols)
             ;; Interprets the underlying flattened vectors as (lhs_rows, lhs_cols)
             ;; and (lhs_cols, rhs_cols) tensors. Note that the rank of the result
             ;; tensor and inputs are 1, they're merely 'interpreted' as 2D according
             ;; to the vector:matrix_multiply semantics.
             (cond
               [(equal? (vector-length indices) 1)
                (define index (vector-ref indices 0))
                (define out-row (quotient index rhs_cols))
                (define out-col (- index (* out-row rhs_cols) 1))

                ;; Need to do a dimension along the lhs-cols elements
                (define partial-products 
                  (for/list ([k (range lhs_cols)])
                            (define e1 (interpret v1 (vector out-row k)))
                            (define e2 (interpret v2 (vector k out-col)))
                            (do-mul e1 e2)
                            )
                  )

                ;; Now accumulate partial-products
                (define acc '())
                (for/list ([p partial-products])
                          (if 
                            (equal? acc '())
                            (set! acc p)
                            (set! acc (do-add p acc))
                            )
                          )
                acc
                ]

               [else
                 (error "arith/interpreter.rkt vector:matrix_multiply can only be interpreted as a 2D operation")
                 ]
               )
             ]
             [(vector:transpose v1 rank_perm)
              (define input-shape (tensor-shape v1))
              (cond 
                [(equal? (vector-length tensor-shape) (vector-length rank_perm))
                 (define (index-helper i)
                   (define current-index-loc (vector-ref rank_perm i))
                   (define adj-index (vector-ref indices current-index-loc))
                   adj-index
                   )
                 (define new-indices (build-vector (vector-length indices) index-helper))
                 (interpret v1 new-indices)
                 ]
                [else
                  (error "arith//interpreter.rkt vector transpose requires rank permutation match input tensors shape")
                  ]

                )
              ]
             [(vector:flat_transpose v1 trows tcols)
              (cond
                [(equal? (vector-length indices) 1)
                 (define index (vector-ref indices 0))
                 (define out-row (quotient index tcols))
                 (define out-col (- index (* out-row tcols) 1))

                 ;; Transpose in 2D simply swaps indexing variable
                 (define input-row out-col)
                 (define input-col out-row)
                 (define num-input-rows tcols)
                 (define num-input-cols trows)

                 (define adjusted_index (+ (* input-row num-input-cols) input-col))

                 (interpret v1 (vector adjusted_index))

                 ]
                [else
                  (error "arith/interpreter.rkt vector:flat_transpose can only be interpreted as a 2D operation")
                  ]
                )
              ]

             [(vector:splat v1 out-shape)
              (cond
                [(and (equal? (tensor-shape v1) 1) (equal? (vector-ref (tensor-shape v1)) 1))
                 (interpret v1 (vector 0))
                 ]
                [else
                  (error "arith/interpreter.rkt vector:splat takes a single element as input")
                  ]
                )
              ]
             [(vector:reduction v1 operation)
              (define input-shape (tensor-shape v1))
              (define reduc-op
                (cond
                  [(equal? operation 'add) do-add]
                  [(equal? operation 'mul) do-mul]
                  [(equal? operation 'min) do-min]
                  [(equal? operation 'max) do-max]
                  [(equal? operation 'and) do-bwand]
                  [else (error "arith/interpreter.rkt Unsupported operation in vector:reduction")]
                  )
                )
              (cond
                [(equal? (vector-length input-shape 1))
                 (define acc '())
                 (for/list ([i (range (vector-ref input-shape 0))])
                           (if (equal? acc '())
                             (set! acc (interpret v1 (vector i)))

                             (set! acc (reduc-op acc (interpret v1 (vector i))))
                             )
                           )
                 acc
                 ]
                [else
                  (error "arith/interpreter.rkt vector:reduction only supports 1D tensors")
                  ]
                )
              ]
             [(vector:outer_product v1 v2)
              (define rows (vector-ref (tensor-shape v1) 0))
              (define cols (vector-ref (tensor-shape v2) 0))
              ;; Interpret outer product as a matrix multiplication
              ;; for a (rows x 1) and (1 x cols) tensor
              (interpret (vector:matrix_multiply v1 v2 rows 1 cols) indices)
              ]
             [(vector:shape_cast v1 input_shape output_shape)
              (displayln "Interpretting shape cast")
              ;; Methodology for interpretting shape_cast:
              ;; For each input index in index, we define a function which maps 
              ;; an input index to a list of indices for the original shape of v1
              ;; We append all these indices together and cast back into a vector
              ;; then we simply interpret v1 with the new indices

              ;; "It is currently assumed that this operation does not require moving data, and that it will be folded away before lowering vector operations." // Layout doesn't change
              (cond
                [(< (vector-length input_shape) (vector-length output_shape)) ; Rank increases

                 (displayln "Increased Dimensionality")
                 ;; Multiple output indices map to single v1 index

                 (define expanded-dims-vec (list))

                 (define starting_index 0)
                 (for/list ([input-dim input_shape])
                           (define prod 1)
                           (for/list ([o-dim-idx (range starting_index (vector-length output_shape))])
                                     (define o-dim (vector-ref output_shape o-dim-idx))
                                     (set! prod (* prod o-dim))

                                     ;; Fold Degenerate dimensions into current output-dim
                                     (define next-term-1? 
                                       (cond
                                         
                                         ;; If current dimension is the last index, not degenerate
                                         [(equal? o-dim-idx (- (vector-length output_shape) 1))
                                          #f
                                          ]
                                         ;; If next dimension exent is 1, fold into current output-dim
                                         [(equal? (vector-ref output_shape (+ 1 o-dim-idx)) 1)
                                          #t
                                          ]
                                         [else
                                           #f
                                           ]
                                         )
                                       
                                       )

                                     (cond
                                       [(and (equal? prod input-dim) (not next-term-1?))
                                        ;; Contigous collapsing dim gives the required output shape

                                        ;; For the given output-dimension output-dim, the 
                                        ;; input-dimension indices from starting_index to i-idx-idx
                                        (define mapping (list starting_index o-dim-idx)) 
                                        (set! expanded-dims-vec (append expanded-dims-vec (list mapping)))
                                        (set! starting_index (+ o-dim-idx 1))
                                        ]
                                       [(equal? prod input-dim)
                                        ;; Proceed as normal
                                        '()
                                        ]
                                       [else
                                         '()
                                         ]
                                       )
                                     )

                           )


                 (define list-of-collapsed-indices
                   ;; Each v1 shape dimension extent maps to potentially multiple output indices after shape cast where rank increases
                   (for/list ( [i (range (vector-length (tensor-shape v1)))])
                             (define collapsed-dims-range (list-ref expanded-dims-vec i))
                             (define dims-start (list-ref collapsed-dims-range 0))
                             (define dims-end (list-ref collapsed-dims-range 1))
                             (define collapsed-dims 
                               (for/list ([k (range dims-start (+ 1 dims-end))])
                                         (vector-ref output_shape k)
                                         )
                               )


                             (define (stride-helper i)
                               (define starting-dim (list-ref collapsed-dims i))
                               (define num-elems 1)
                               (for/list ([si (range (+ 1 i)(length collapsed-dims))])
                                         (set! num-elems (* num-elems (list-ref collapsed-dims si)))
                                         )
                               num-elems
                               )

                             (define dim-strides (build-list (length collapsed-dims) stride-helper))
                             (println dim-strides)
                             ;(define index-val (vector-ref indices i))

                             (define collapsed-index 0)


                              (for/list ([p (range dims-start (+ 1 dims-end))])
                                        (set! collapsed-index (+ collapsed-index (* (vector-ref indices p)   (list-ref dim-strides p))))
                                     )

                              collapsed-index

                             )
                   )


                 (define new-indices (list->vector list-of-collapsed-indices))
                 (interpret v1 new-indices)

                 ]
                [(> (vector-length input_shape) (vector-length output_shape)) ; Rank decreases

                 (displayln "Reduced Dimensionality")
                 ;; Each input index maps to multiple v1 indices

                 (define collapsed-dims-vec (list))

                 (define starting_index 0)
                 (for/list ([output-dim output_shape])
                           (define prod 1)
                           (for/list ([i-dim-idx (range starting_index (vector-length input_shape))])
                                     (define i-dim (vector-ref input_shape i-dim-idx))
                                     (set! prod (* prod i-dim))

                                     ;; Fold Degenerate dimensions into current output-dim
                                     (define next-term-1? 
                                       (cond
                                         
                                         ;; If current dimension is the last index, not degenerate
                                         [(equal? i-dim-idx (- (vector-length input_shape) 1))
                                          #f
                                          ]
                                         ;; If next dimension exent is 1, fold into current output-dim
                                         [(equal? (vector-ref input_shape (+ 1 i-dim-idx)) 1)
                                          #t
                                          ]
                                         [else
                                           #f
                                           ]
                                         )
                                       
                                       )

                                     (cond
                                       [(and (equal? prod output-dim) (not next-term-1?))
                                        ;; Contigous collapsing dim gives the required output shape

                                        ;; For the given output-dimension output-dim, the 
                                        ;; input-dimension indices from starting_index to i-idx-idx
                                        (define mapping (list starting_index i-dim-idx)) 
                                        (set! collapsed-dims-vec (append collapsed-dims-vec (list mapping)))
                                        (set! starting_index (+ i-dim-idx 1))
                                        ]
                                       [(equal? prod output-dim)
                                        ;; Proceed as normal
                                        '()
                                        ]
                                       [else
                                         '()
                                         ]
                                       )
                                     )

                           )

                 ;; collapsed-dims-vec maintains a list of pair of indices for the decreasing rank mapping (start_1, end_1), (end_1+1, end_2), (end_2+1, end_3),...
                 ;; We now need to each index in the indices vectors by identifying the increased rank index corresponding to it.
                 ;; e.g. index 10 of output-shape (20) and input-shape (5 x 4 x 1), would correspond to index (2 , 2, 0)
                 ;; Strides vector : 4, 1, 1

                 (define list-of-expanded-indices
                   (for/list ( [i (range (vector-length indices))])
                             (define expanded-dims-range (list-ref collapsed-dims-vec i))
                             (define dims-start (list-ref expanded-dims-range 0))
                             (define dims-end (list-ref expanded-dims-range 1))
                             (define expanded-dims 
                               (for/list ([k (range dims-start (+ 1 dims-end))])
                                         (vector-ref input_shape k)
                                         )
                               )


                             (define (stride-helper i)
                               (define starting-dim (list-ref expanded-dims i))
                               (define num-elems 1)
                               (for/list ([si (range (+ 1 i)(length expanded-dims))])
                                         (set! num-elems (* num-elems (list-ref expanded-dims si)))
                                         )
                               num-elems
                               )

                             (define dim-strides (build-list (length expanded-dims) stride-helper))
                             (println dim-strides)

                             (define index-val (vector-ref indices i))

                             (define expanded-index 
                               (for/list ([ei dim-strides])
                                         (define new-idx (quotient index-val ei))
                                         (set! index-val (remainder index-val ei))
                                         new-idx
                                         )
                               )



                             expanded-index


                             )
                   )


                 (define new-indices (list->vector (apply append list-of-expanded-indices)))
                 (interpret v1 new-indices)
                 ]
                [else
                  (error "arith/interpreter.rkt vector shape cast without change in rank not supported")
                  
                  ]
                
                )
              ]
            ;; Base case
            [v (error "arith/interpreter.rkt Unsupported data type in interpreter" v)]

            )
  )

(define (interpret-env p indices env)
  (destruct p


            ;; Constructors

            [(arith:tensor data shape-vector layout-vector elemT buffSize id)

             ;; To account for differing layouts, we can simply sort
             ;; the indices and the shape vector according to the
             ;; layout vector.

             (define (sorted-index-shape i)
               (define layout-index (vector-ref layout-vector i))
               (vector-ref shape-vector layout-index)
               )

             (define (sorted-index-indices i)
               (define layout-index (vector-ref layout-vector i))
               (vector-ref indices layout-index)
               )

             (define sorted-shape  (build-vector (vector-length shape-vector) sorted-index-shape ))
             (define sorted-indices  (build-vector (vector-length indices) sorted-index-indices ))


             (cond
               [(eq? elemT 'int8) (int8_t (index-tensor data sorted-shape layout-vector 8 sorted-indices))]
               [(eq? elemT 'int16) (int16_t (index-tensor data sorted-shape layout-vector 16 sorted-indices))]
               [(eq? elemT 'int32) (int32_t (index-tensor data sorted-shape layout-vector 32 sorted-indices))]
               [(eq? elemT 'int64) (int64_t (index-tensor data sorted-shape layout-vector 64 sorted-indices))]
               [(eq? elemT 'uint1) (uint1_t (index-tensor data sorted-shape layout-vector 1 sorted-indices))]
               [(eq? elemT 'uint8) (uint8_t (index-tensor data sorted-shape layout-vector 8 sorted-indices))]
               [(eq? elemT 'uint16) (uint16_t (index-tensor data sorted-shape layout-vector 16 sorted-indices))]
               [(eq? elemT 'uint32) (uint32_t (index-tensor data sorted-shape layout-vector 32 sorted-indices))]
               [(eq? elemT 'uint64) (uint64_t (index-tensor data sorted-shape layout-vector 64 sorted-indices))]
               [else (error "arith/ir/interpret-enver.rkt: Unexpected element type type in tensor-ref" p)])
             ]


            [(arith:int-imm data signed?)
             (imm-ref data signed?)
             ]

            ;; Type Casts
            [(arith:cast-int vec olane oprec)
              (cpp:cast
                (interpret-env vec indices env)
                (cond
                  [(eq? oprec 8)  'int8]
                  [(eq? oprec 16)  'int16]
                  [(eq? oprec 32)  'int32]
                  [(eq? oprec 64)  'int64]
                  [else (error "arith/interpret-enver.rkt: Unexpected buffer type in size-to-elemT-signed" oprec)]
                ))]
            [(arith:cast-uint vec olane oprec) 
              (cpp:cast
                (interpret-env vec indices env)
                (cond
                  [(eq? oprec 8)  'uint8]
                  [(eq? oprec 16)  'uint16]
                  [(eq? oprec 32)  'uint32]
                  [(eq? oprec 64)  'uint64]
                  [else (error "arith/interpret-enver.rkt: Unexpected buffer type in size-to-elemT-signed" oprec )]
                ))]

            ;; Operations

            [(arith:tensor-add v1 v2) (do-add (interpret-env v1 indices env) (interpret-env v2 indices env))]

            [(arith:tensor-sat-add v1 v2) (do-sat-add (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-sub v1 v2) (do-sub (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-sat-sub v1 v2) (do-sat-sub (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-mul v1 v2) (do-mul (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-div v1 v2) (do-div (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-mod v1 v2) (do-mod (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-min v1 v2) (do-min (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-max v1 v2) (do-max (interpret-env v1 indices env) (interpret-env v2 indices env))]

            [(arith:tensor-if v1 v2 v3) (do-if (interpret-env v1 indices env) (interpret-env v2 indices env) (interpret-env v3 indices env))]
            [(arith:tensor-eq v1 v2) (do-eq (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-lt v1 v2) (do-lt (interpret-env v1 indices env) (interpret-env v2 indices env) )]
            [(arith:tensor-le v1 v2) (do-le (interpret-env v1 indices env) (interpret-env v2 indices env ) )]

            [(arith:tensor-abs v1) (do-abs (interpret-env v1 indices env))]
            [(arith:tensor-shl v1 v2) (do-shl (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-shr v1 v2) (do-shr (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-absd v1 v2)  (do-absd (interpret-env v1 indices env) (interpret-env v2 indices env))]
            [(arith:tensor-clz v1) (do-clz (interpret-env v1 indices env))]

            [(arith:tensor-bwand v1 v2) (do-bwand (interpret-env v1 indices env) (interpret-env v2 indices env ))]

            [(vector:bitcast v1 signed? out-prec)
             (cpp:cast
               (interpret-env v1 indices env)
               (cond
                 [(and (eq? out-prec 8) signed?)  'int8]
                 [(and (eq? out-prec 16) signed?)  'int16]
                 [(and (eq? out-prec 32) signed?)  'int32]
                 [(and (eq? out-prec 64) signed?)  'int64]
                 [(and (eq? out-prec 8) )  'uint8]
                 [(and (eq? out-prec 16) )  'uint16]
                 [(and (eq? out-prec 32) )  'uint32]
                 [(and (eq? out-prec 64) )  'uint64]

                 )
               )
             ]
            [(vector:broadcast v1 output-shape)
             (define input-shape (tensor-shape v1))
             (define num-input-dims (vector-length input-shape))
             (define num-output-dims (vector-length output-shape))

             ;; According to the semantics of the broadcast, the duplication
             ;; happens along the new leading dimensions, hence for the
             ;; purposes of interpret-enving the semantics, we can discard
             ;; the leading dimensions

             (define num-new-leading-dims (- num-output-dims num-input-dims))
             (cond
               [(< num-output-dims num-input-dims)
                (error "Illegal broadcast shape for vector:broadcast")
                ]
               [else
                 (define sliced-indices (vector-take-right indices num-input-dims))
                 (interpret-env v1 sliced-indices env)
                 ]
               )
             ]
            [(vector:extract_strided_slice v1 offsets sizes strides)
             (define input-shape (tensor-shape v1))
            ;;;  (debug-log "QWQ")
            ;;;  (debug-log v1);arith:tensor
            ;;;  (debug-log offsets);0
            ;;;  (debug-log sizes);16
            ;;;  (debug-log indices);0
            ;;;  (debug-log strides);1
             (define (generate-strided-indices i)
              ;;; Not sure what's going on here
              ;;;  (if
              ;;;    (< i (vector-length offsets))

              ;;;    ;; Adjusted strided index
                 (+ (vector-ref offsets i) (* (vector-ref strides i) (vector-ref indices i)))

              ;;;    ;; If index along non-strided dimension index regularly
              ;;;    (vector-ref indices i)
              ;;;    )
               )

             (define actual-indices (build-vector (vector-length indices) generate-strided-indices))
             (define res(interpret-env v1 actual-indices env))
            ;;;  (debug-log actual-indices)
            ;;;  (debug-log res)
             res

             ]

            [(vector:extract v1 extract_indices)
             (define input-shape (tensor-shape v1))
             (define (generate-extract-indicies i)
               (if
                 (< i (vector-length extract_indices))

                 ;; Adjusted strided index
                 (+ (vector-length extract_indices i) (* 1 (vector-ref indices i)))

                 ;; If index along non-strided dimension index regularly
                 (vector-ref indices i)
                 )
               )

             (define actual-indices (build-vector (vector-length indices) generate-extract-indicies))
             (interpret-env v1 actual-indices env)
             ]
            [(vector:matrix_multiply v1 v2 lhs_rows lhs_cols rhs_cols)
             ;; interpret-envs the underlying flattened vectors as (lhs_rows, lhs_cols)
             ;; and (lhs_cols, rhs_cols) tensors. Note that the rank of the result
             ;; tensor and inputs are 1, they're merely 'interpret-enved' as 2D according
             ;; to the vector:matrix_multiply semantics.
             (cond
               [(equal? (vector-length indices) 1)
                (define index (vector-ref indices 0))
                (define out-row (quotient index rhs_cols))
                (define out-col (- index (* out-row rhs_cols) 1))

                ;; Need to do a dimension along the lhs-cols elements
                (define partial-products
                  (for/list ([k (range lhs_cols)])
                            (define e1 (interpret-env v1 (vector out-row k) env))
                            (define e2 (interpret-env v2 (vector k out-col) env))
                            (do-mul e1 e2)
                            )
                  )

                ;; Now accumulate partial-products
                (define acc '())
                (for/list ([p partial-products])
                          (if
                            (equal? acc '())
                            (set! acc p)
                            (set! acc (do-add p acc))
                            )
                          )
                acc
                ]

               [else
                 (error "arith/interpret-enver.rkt vector:matrix_multiply can only be interpret-enved as a 2D operation")
                 ]
               )
             ]
             [(vector:transpose v1 rank_perm)
              (define input-shape (tensor-shape v1))
              (cond
                [(equal? (vector-length tensor-shape) (vector-length rank_perm))
                 (define (index-helper i)
                   (define current-index-loc (vector-ref rank_perm i))
                   (define adj-index (vector-ref indices current-index-loc))
                   adj-index
                   )
                 (define new-indices (build-vector (vector-length indices) index-helper))
                 (interpret-env v1 new-indices env)
                 ]
                [else
                  (error "arith//interpret-enver.rkt vector transpose requires rank permutation match input tensors shape")
                  ]

                )
              ]
             [(vector:flat_transpose v1 trows tcols)
              (cond
                [(equal? (vector-length indices) 1)
                 (define index (vector-ref indices 0))
                 (define out-row (quotient index tcols))
                 (define out-col (- index (* out-row tcols) 1))

                 ;; Transpose in 2D simply swaps indexing variable
                 (define input-row out-col)
                 (define input-col out-row)
                 (define num-input-rows tcols)
                 (define num-input-cols trows)

                 (define adjusted_index (+ (* input-row num-input-cols) input-col))

                 (interpret-env v1 (vector adjusted_index) env)

                 ]
                [else
                  (error "arith/interpret-enver.rkt vector:flat_transpose can only be interpret-enved as a 2D operation")
                  ]
                )
              ]

             [(vector:splat v1 out-shape)
              (cond
                [(and (equal? (tensor-shape v1) 1) (equal? (vector-ref (tensor-shape v1)) 1))
                 (interpret-env v1 (vector 0) env)
                 ]
                [else
                  (error "arith/interpret-enver.rkt vector:splat takes a single element as input")
                  ]
                )
              ]
             [(vector:reduction v1 operation)
              (define input-shape (tensor-shape v1))
              (define reduc-op
                (cond
                  [(equal? operation 'add) do-add]
                  [(equal? operation 'mul) do-mul]
                  [(equal? operation 'min) do-min]
                  [(equal? operation 'max) do-max]
                  [(equal? operation 'and) do-bwand]
                  [else (error "arith/interpret-enver.rkt Unsupported operation in vector:reduction")]
                  )
                )
              (cond
                [(equal? (vector-length input-shape 1))
                 (define acc '())
                 (for/list ([i (range (vector-ref input-shape 0))])
                           (if (equal? acc '())
                             (set! acc (interpret-env v1 (vector i) env))

                             (set! acc (reduc-op acc (interpret-env v1 (vector i) env)))
                             )
                           )
                 acc
                 ]
                [else
                  (error "arith/interpret-enver.rkt vector:reduction only supports 1D tensors")
                  ]
                )
              ]
             [(vector:outer_product v1 v2)
              (define rows (vector-ref (tensor-shape v1) 0))
              (define cols (vector-ref (tensor-shape v2) 0))
              ;; interpret-env outer product as a matrix multiplication
              ;; for a (rows x 1) and (1 x cols) tensor
              (interpret-env (vector:matrix_multiply v1 v2 rows 1 cols) indices env)
              ]
             [(vector:shape_cast v1 input_shape output_shape)
              (displayln "interpret-envting shape cast")
              ;; Methodology for interpret-envting shape_cast:
              ;; For each input index in index, we define a function which maps
              ;; an input index to a list of indices for the original shape of v1
              ;; We append all these indices together and cast back into a vector
              ;; then we simply interpret-env v1 with the new indices

              ;; "It is currently assumed that this operation does not require moving data, and that it will be folded away before lowering vector operations." // Layout doesn't change
              (cond
                [(< (vector-length input_shape) (vector-length output_shape)) ; Rank increases

                 (displayln "Increased Dimensionality")
                 ;; Multiple output indices map to single v1 index

                 (define expanded-dims-vec (list))

                 (define starting_index 0)
                 (for/list ([input-dim input_shape])
                           (define prod 1)
                           (for/list ([o-dim-idx (range starting_index (vector-length output_shape))])
                                     (define o-dim (vector-ref output_shape o-dim-idx))
                                     (set! prod (* prod o-dim))

                                     ;; Fold Degenerate dimensions into current output-dim
                                     (define next-term-1?
                                       (cond

                                         ;; If current dimension is the last index, not degenerate
                                         [(equal? o-dim-idx (- (vector-length output_shape) 1))
                                          #f
                                          ]
                                         ;; If next dimension exent is 1, fold into current output-dim
                                         [(equal? (vector-ref output_shape (+ 1 o-dim-idx)) 1)
                                          #t
                                          ]
                                         [else
                                           #f
                                           ]
                                         )

                                       )

                                     (cond
                                       [(and (equal? prod input-dim) (not next-term-1?))
                                        ;; Contigous collapsing dim gives the required output shape

                                        ;; For the given output-dimension output-dim, the
                                        ;; input-dimension indices from starting_index to i-idx-idx
                                        (define mapping (list starting_index o-dim-idx))
                                        (set! expanded-dims-vec (append expanded-dims-vec (list mapping)))
                                        (set! starting_index (+ o-dim-idx 1))
                                        ]
                                       [(equal? prod input-dim)
                                        ;; Proceed as normal
                                        '()
                                        ]
                                       [else
                                         '()
                                         ]
                                       )
                                     )

                           )


                 (define list-of-collapsed-indices
                   ;; Each v1 shape dimension extent maps to potentially multiple output indices after shape cast where rank increases
                   (for/list ( [i (range (vector-length (tensor-shape v1)))])
                             (define collapsed-dims-range (list-ref expanded-dims-vec i))
                             (define dims-start (list-ref collapsed-dims-range 0))
                             (define dims-end (list-ref collapsed-dims-range 1))
                             (define collapsed-dims
                               (for/list ([k (range dims-start (+ 1 dims-end))])
                                         (vector-ref output_shape k)
                                         )
                               )


                             (define (stride-helper i)
                               (define starting-dim (list-ref collapsed-dims i))
                               (define num-elems 1)
                               (for/list ([si (range (+ 1 i)(length collapsed-dims))])
                                         (set! num-elems (* num-elems (list-ref collapsed-dims si)))
                                         )
                               num-elems
                               )

                             (define dim-strides (build-list (length collapsed-dims) stride-helper))
                             (println dim-strides)
                             ;(define index-val (vector-ref indices i))

                             (define collapsed-index 0)


                              (for/list ([p (range dims-start (+ 1 dims-end))])
                                        (set! collapsed-index (+ collapsed-index (* (vector-ref indices p)   (list-ref dim-strides p))))
                                     )

                              collapsed-index

                             )
                   )


                 (define new-indices (list->vector list-of-collapsed-indices))
                 (interpret-env v1 new-indices env)

                 ]
                [(> (vector-length input_shape) (vector-length output_shape)) ; Rank decreases

                 (displayln "Reduced Dimensionality")
                 ;; Each input index maps to multiple v1 indices

                 (define collapsed-dims-vec (list))

                 (define starting_index 0)
                 (for/list ([output-dim output_shape])
                           (define prod 1)
                           (for/list ([i-dim-idx (range starting_index (vector-length input_shape))])
                                     (define i-dim (vector-ref input_shape i-dim-idx))
                                     (set! prod (* prod i-dim))

                                     ;; Fold Degenerate dimensions into current output-dim
                                     (define next-term-1?
                                       (cond

                                         ;; If current dimension is the last index, not degenerate
                                         [(equal? i-dim-idx (- (vector-length input_shape) 1))
                                          #f
                                          ]
                                         ;; If next dimension exent is 1, fold into current output-dim
                                         [(equal? (vector-ref input_shape (+ 1 i-dim-idx)) 1)
                                          #t
                                          ]
                                         [else
                                           #f
                                           ]
                                         )

                                       )

                                     (cond
                                       [(and (equal? prod output-dim) (not next-term-1?))
                                        ;; Contigous collapsing dim gives the required output shape

                                        ;; For the given output-dimension output-dim, the
                                        ;; input-dimension indices from starting_index to i-idx-idx
                                        (define mapping (list starting_index i-dim-idx))
                                        (set! collapsed-dims-vec (append collapsed-dims-vec (list mapping)))
                                        (set! starting_index (+ i-dim-idx 1))
                                        ]
                                       [(equal? prod output-dim)
                                        ;; Proceed as normal
                                        '()
                                        ]
                                       [else
                                         '()
                                         ]
                                       )
                                     )

                           )

                 ;; collapsed-dims-vec maintains a list of pair of indices for the decreasing rank mapping (start_1, end_1), (end_1+1, end_2), (end_2+1, end_3),...
                 ;; We now need to each index in the indices vectors by identifying the increased rank index corresponding to it.
                 ;; e.g. index 10 of output-shape (20) and input-shape (5 x 4 x 1), would correspond to index (2 , 2, 0)
                 ;; Strides vector : 4, 1, 1

                 (define list-of-expanded-indices
                   (for/list ( [i (range (vector-length indices))])
                             (define expanded-dims-range (list-ref collapsed-dims-vec i))
                             (define dims-start (list-ref expanded-dims-range 0))
                             (define dims-end (list-ref expanded-dims-range 1))
                             (define expanded-dims
                               (for/list ([k (range dims-start (+ 1 dims-end))])
                                         (vector-ref input_shape k)
                                         )
                               )


                             (define (stride-helper i)
                               (define starting-dim (list-ref expanded-dims i))
                               (define num-elems 1)
                               (for/list ([si (range (+ 1 i)(length expanded-dims))])
                                         (set! num-elems (* num-elems (list-ref expanded-dims si)))
                                         )
                               num-elems
                               )

                             (define dim-strides (build-list (length expanded-dims) stride-helper))
                             (println dim-strides)

                             (define index-val (vector-ref indices i))

                             (define expanded-index
                               (for/list ([ei dim-strides])
                                         (define new-idx (quotient index-val ei))
                                         (set! index-val (remainder index-val ei))
                                         new-idx
                                         )
                               )



                             expanded-index


                             )
                   )


                 (define new-indices (list->vector (apply append list-of-expanded-indices)))
                 (interpret-env v1 new-indices env)
                 ]
                [else
                  (error "arith/interpret-enver.rkt vector shape cast without change in rank not supported")

                  ]

                )
              ]
            ;; Base case
            [v (error "arith/interpret-enver.rkt Unsupported data type in interpret-enver" v)]

            )
  )


;; Infer the shape of vector generated by the expression
(define (tensor-shape expr)
  (destruct expr
    
    ;; Constructors
    [(arith:int-imm data signed?) (vector 1)]
    [(arith:tensor data shape layout elemT buffsize id) shape]
    [(arith:tensor-index index shape layout elemT buffsize id) shape]

    ;; Type Casts

    [(arith:cast-int vec olane oprec) (tensor-shape vec)]
    [(arith:cast-uint vec olane oprec) (tensor-shape vec)]
    ;; Operations
    [(arith:tensor-add v1 v2) (tensor-shape v1)]
    [(arith:tensor-sat-add v1 v2) (tensor-shape v1)]
    [(arith:tensor-sub v1 v2) (tensor-shape v1)]
    [(arith:tensor-sat-sub v1 v2) (tensor-shape v1)]
    [(arith:tensor-mul v1 v2) (tensor-shape v1)]
    [(arith:tensor-div v1 v2) (tensor-shape v1)]
    [(arith:tensor-mod v1 v2) (tensor-shape v1)]
    [(arith:tensor-min v1 v2) (tensor-shape v1)]
    [(arith:tensor-max v1 v2) (tensor-shape v1)]

    [(arith:tensor-if v1 v2 v3) (tensor-shape v2)]
    [(arith:tensor-eq v1 v2) (tensor-shape v1)]
    [(arith:tensor-lt v1 v2) (tensor-shape v1)]
    [(arith:tensor-le v1 v2) (tensor-shape v1)]

    [(arith:tensor-abs v1) (tensor-shape v1)]
    [(arith:tensor-clz v1) (tensor-shape v1)]

    [(arith:tensor-absd v1 v2) (tensor-shape v1)]
    [(arith:tensor-shl v1 v2) (tensor-shape v1)]
    [(arith:tensor-shr v1 v2) (tensor-shape v1)]

    [(arith:tensor-bwand v1 v2) (tensor-shape v1)]
    [(vector:bitcast v1 signed? out-prec) (tensor-shape v1)]
    [(vector:broadcast v1 output-shape) output-shape]
    [(vector:extract_strided_slice v1 offsets sizes strides)
     (define input-shape (tensor-shape v1))
     (define (extract_strided_slice_helper i)
       (if 
         (< i (vector-length offsets))

         ;; Shape along this axis would be whatever number 
         ;; of elements we want to extract
         (vector-ref sizes i) 

         ;; Non specified dimension -> extract all elements
         (vector-ref input-shape i)
         )
       )

     (build-vector (vector-length input-shape) extract_strided_slice_helper) 
     ]
    [(vector:extract v1 extract_indices)
     (define input-shape (tensor-shape v1))
     (define (extract_slice_helper i)
       (if 
         (< i (vector-length extract_indices))

         ;; Shape along this axis would be whatever number 
         ;; of elements we want to extract
         (- (vector-ref input-shape i) (vector-ref extract_indices i))

         ;; Non specified dimension -> extract all elements
         (vector-ref input-shape i)
         )
       )

     (build-vector (vector-length input-shape) extract_slice_helper) 
     ]
    [(vector:matrix_multiply v1 v2 lhs_rows lhs_cols rhs_cols)
     ;; Flat matrix multiply returns rank 1 tensor
     (vector (* lhs_rows rhs_cols))
     ]

    ;; Flat transpose returns a rank 1 tensor
    [(vector:flat_transpose v1 trows tcols) (tensor-shape v1)]
    [(vector:transpose v1 rank_perm)
     (define input-shape (tensor-shape v1))
     (define (transpose-helper i)
       (vector-ref input-shape (vector-ref rank_perm i))
       )
     (build-vector (vector-length input-shape) transpose-helper)
     ]
    [(vector:splat v1 out-shape) out-shape]
    [(vector:reduction v1 operation) (vector 1)]
    [(vector:outer_product v1 v2)
     (define left-shape (tensor-shape v1))
     (define right-shape (tensor-shape v1))
     (vector (vector-ref left-shape 0) (vector-ref right-shape 0))
     ]
    [(vector:shape_cast v1 input_shape output_shape)
     output_shape
     ]
    ;; Base case
    [_ (error "arith\\interpreter.rkt: Don't know how to infer vector length for arith expression:" expr)]))


;; Infer the layout of vector generated by the expression
(define (tensor-layout expr)
  (destruct expr
    
    ;; Constructors
    [(arith:int-imm data signed?) (vector 0)]
    [(arith:tensor data shape layout elemT buffsize id) layout]
    [(arith:tensor-index index shape layout elemT buffsize id) layout]

    ;; Type Casts

    [(arith:cast-int vec olane oprec) (tensor-layout vec)]
    [(arith:cast-uint vec olane oprec) (tensor-layout vec)]
    ;; Operations
    [(arith:tensor-add v1 v2) (tensor-layout v1)]
    [(arith:tensor-sat-add v1 v2) (tensor-layout v1)]
    [(arith:tensor-sub v1 v2) (tensor-layout v1)]
    [(arith:tensor-sat-sub v1 v2) (tensor-layout v1)]
    [(arith:tensor-mul v1 v2) (tensor-layout v1)]
    [(arith:tensor-div v1 v2) (tensor-layout v1)]
    [(arith:tensor-mod v1 v2) (tensor-layout v1)]
    [(arith:tensor-min v1 v2) (tensor-layout v1)]
    [(arith:tensor-max v1 v2) (tensor-layout v1)]

    [(arith:tensor-if v1 v2 v3) (tensor-layout v2)]
    [(arith:tensor-eq v1 v2) (tensor-layout v1)]
    [(arith:tensor-lt v1 v2) (tensor-layout v1)]
    [(arith:tensor-le v1 v2) (tensor-layout v1)]

    [(arith:tensor-abs v1) (tensor-layout v1)]
    [(arith:tensor-clz v1) (tensor-layout v1)]

    [(arith:tensor-absd v1 v2) (tensor-layout v1)]
    [(arith:tensor-shl v1 v2) (tensor-layout v1)]
    [(arith:tensor-shr v1 v2) (tensor-layout v1)]

    [(arith:tensor-bwand v1 v2) (tensor-layout v1)]
    [(vector:bitcast v1 signed? out-prec) (tensor-layout v1)]
    [(vector:extract v1 extract_indicies) (tensor-layout v1)]
    [(vector:extract_strided_slice v1 offsets sizes strides) (tensor-layout v1)]
    [(vector:matrix_multiply v1 v2 lhs_rows lhs_cols rhs_cols) (tensor-layout v1)]
    [(vector:splat v1 out-shape) 
     (define (id i) i)
     (build-vector (vector-length out-shape) id)
     ]
    [(vector:flat_transpose v1 trows tcols) (tensor-layout v1)]

    [(vector:transpose v1 rank_perm)
     (define input-layout (tensor-layout v1))
     (define (transpose-helper i)
       (vector-ref input-layout (vector-ref rank_perm i))
       )
     (build-vector (vector-length input-layout) transpose-helper)
     ]
    [(vector:shape_cast v1 input_shape output_shape)
     (define (shape_cast-helper i)
       i
       )
     (build-vector (vector-length output_shape) shape_cast-helper)
     ]
    [(vector:reduction v1 operation) (vector 0)]
    [(vector:outer_product v1 v2)
     (vector 0 1)
     ]
    ;; Base case
    [_ (error "arith\\interpreter.rkt: Don't know how to infer vector length for arith expression:" expr)])
  )

(define (get-index-combinations shape-vector)
  (cond
    [(equal? (vector-length shape-vector) 1)
     (define dim (vector-ref shape-vector 0))
     (for/list ([i (range dim)])
               (list i)
               )
     ]
    [else
      (define remaining-shape (vector-take-right shape-vector (- (vector-length shape-vector) 1) ))
      (define remaining-suffix (get-index-combinations remaining-shape))

      (define dim (vector-ref shape-vector 0))

      (define folded-list (list))
      (for/list ([i (range dim)])
                        (define i-combs 
                          (for/list ([shape-comb remaining-suffix])
                           (append (list i) shape-comb)
                            )
                          )

                        (set! folded-list (append folded-list i-combs))
        )
      folded-list
      ]
    )
  )

(define (evaluate-arith-expr prog)
  ;; (debug-log "Entry for evaluation")
  (define result-shape (tensor-shape prog))
  (define combinations (get-index-combinations result-shape))

  (apply concat
         (for/list ([index combinations])
                   (cpp:eval (interpret prog (list->vector index)))
                   )
         )
  )

(define (evaluate-arith-expr-env prog env)
  ;; (debug-log "Entry for evaluation")
  (define result-shape (tensor-shape prog))
  (define combinations (get-index-combinations result-shape))
  ;;; (debug-log "qwq")
  ;;; (debug-log prog)
  ;;; (debug-log env)
  ;;; (debug-log result-shape)
  ;;; (debug-log combinations)
  (apply concat
         (for/list ([index combinations])
                   (cpp:eval (interpret-env prog (list->vector index) env))
                   )
  )
)






(define (sub-exprs expr)
  (destruct expr
            [(arith:tensor data shape layout elemT buffsize id)
             (list expr)
             ]
            [(arith:tensor-index index shape layout elemT buffsize id)
             (list expr)
             ]
            [(arith:int-imm data signed?) (list)]
            [(arith:cast-int vec olane oprec) 
             (list vec)
             ]
            [(arith:cast-uint vec olane oprec) 
             (list vec)
             ]
            [(arith:tensor-add v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-sat-add v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-sub v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-sat-sub v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-mul v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-div v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-mod v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-max v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-min v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-if v1 v2 v3)
             (list v1 v2 v3)
             ]
            [(arith:tensor-lt v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-le v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-eq v1 v2)
             (list v1 v2)
             ]
            [(arith:tensor-abs v1)
             (list v1)
             ]
            [(arith:tensor-clz v1)
             (list v1)
             ]
            [(arith:tensor-absd v1 v2)
             (list v1 v2)
             ]

            [(arith:tensor-shl v1 v2)
             (list v1 v2)
             ]

            [(arith:tensor-shr v1 v2)
             (list v1 v2)
             ]

            [(arith:tensor-bwand v1 v2)
             (list v1 v2)
             ]

            [(vector:bitcast v1 signed? out-prec)
             (list v1)
             ]

            [(vector:broadcast v1 output-shape)
             (list v1)
             ]

            [(vector:extract v1 extract_indices)
             (list v1)
             ]

            [(vector:extract_strided_slice v1 offsets sizes strides)
             (list v1)
             ]

            [(vector:matrix_multiply v1 v2 lhs_rows lhs_cols rhs_cols)
             (list v1 v2)
             ]

            [(vector:flat_transpose v1 trows tcols)
             (list v1)
             ]

            [(vector:transpose v1 rank_perm)
             (list v1)
             ]

            [(vector:reduction v1 operation)
             (list v1)
             ]

            [(vector:splat v1 output-shape)
             (list v1)
             ]

            [(vector:outer_product v1 v2)
             (list v1 v2)
             ]

            [(vector:shape_cast v1 input_shape output_shape)
             (list v1)
             ]

            [v (error "Unrecognized expression in arith sub-exprs" v)]
            )
  )











;; Model basic arithmetic
(define (infer-out-type lhs rhs)
  (define max-bw (if (> (cpp:expr-bw lhs) (cpp:expr-bw rhs)) (cpp:expr-bw lhs) (cpp:expr-bw rhs)))
  (cond
    [(and (cpp:signed-expr? lhs) (cpp:signed-expr? rhs)) (mk-cpp-type max-bw #t)]
    [(and (cpp:unsigned-expr? lhs) (cpp:unsigned-expr? rhs)) (mk-cpp-type max-bw #f)]
    [else (mk-cpp-type max-bw #t)]))

(define (do-add lhs rhs)
  ;(cond
  ;  [(and (integer? lhs) (integer? rhs))
  ;   (+ lhs rhs)]
  ;  [else
     (define outT (infer-out-type lhs rhs))
     (define res (mk-cpp-expr (bvadd (cpp:eval lhs) (cpp:eval rhs)) outT))
       res
   ;    ])
   )


(define (do-sat-add lhs rhs)
  (define outT (infer-out-type lhs rhs))
   (define bitwidth (bvlength (cpp:eval lhs)))
  (cond
    [(cpp:signed-type? outT)
      (mk-cpp-expr (bvaddnsw (cpp:eval lhs) (cpp:eval rhs) bitwidth) outT)
     ]
    [else
      (mk-cpp-expr (bvaddnuw (cpp:eval lhs) (cpp:eval rhs) bitwidth) outT)
      ]
    )
  )


(define (do-sat-sub lhs rhs)
  (define outT (infer-out-type lhs rhs))
   (define bitwidth (bvlength (cpp:eval lhs)))

  (cond
    [(cpp:signed-type? outT)
      (mk-cpp-expr (bvsubnsw (cpp:eval lhs) (cpp:eval rhs) bitwidth) outT)
     ]
    [else
      (mk-cpp-expr (bvsubnuw (cpp:eval lhs) (cpp:eval rhs) bitwidth) outT)
      ]
    )
  )
  

(define (do-sub lhs rhs)
  ;(cond
    ;[(and (integer? lhs) (integer? rhs))
    ; (- lhs rhs)]
    ;[else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvsub (cpp:eval lhs) (cpp:eval rhs)) outT)
     ;])
     )

(define (do-widening-mul a b signed?)

  (define bitwidth (bvlength a))
  (cond 
    [signed?
      (define a-sext (sign-extend a (bitvector (* 2 bitwidth))))
      (define b-sext (sign-extend b (bitvector (* 2 bitwidth))))
      (define result (bvmul a-sext b-sext) )
      (extract  (- bitwidth 1) 0 result)
      ]

    [else
      (define a-zext (zero-extend a (bitvector (* 2 bitwidth))))
      (define b-zext (zero-extend b (bitvector (* 2 bitwidth))))
      (define result (bvmul a-zext b-zext) )
      (extract  (- bitwidth 1) 0 result)
      ]
    
    )
  )

(define (do-mul lhs rhs)
  ;(cond
  ;  [(and (integer? lhs) (integer? rhs))
  ;   (* lhs rhs)]
  ;  [else
     (define outT (infer-out-type lhs rhs))
     (define result  (do-widening-mul (cpp:eval lhs) (cpp:eval rhs) #f) )
     (mk-cpp-expr result outT)
     ;(mk-cpp-expr (bvmul (cpp:eval lhs) (cpp:eval rhs)) outT)
  ;   ])
)

(define (widening-div a b)
  (define bvlen (bvlength a))
  (define a-double (sign-extend a (bitvector (* 2 bvlen))))
  (define b-double (sign-extend b (bitvector (* 2 bvlen))))
  (define widen-div (bvsdiv a-double b-double))
  (extract (- bvlen 1) 0 widen-div)
  )

(define (widening-udiv a b)
  (define bvlen (bvlength a))
  (define a-double (zero-extend a (bitvector (* 2 bvlen))))
  (define b-double (zero-extend b (bitvector (* 2 bvlen))))
  (define widen-div (bvudiv a-double b-double))
  (extract (- bvlen 1) 0 widen-div)
  )

(define (do-div lhs rhs)
  ;(cond
  ;  [(and (integer? lhs) (integer? rhs))
  ;   (quotient lhs rhs)]
  ;  [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)

        ;(assume (not (bvzero? (cpp:eval rhs))))
        ;(cpp:euclidean-div lhs rhs outT)


        (define use-euc-div #f)

        (define bv-result 
          (if use-euc-div
             (cpp:euclidean-div lhs rhs outT)
            (mk-cpp-expr 
              (widening-div (cpp:eval lhs) (cpp:eval rhs))
              outT)
            )
          )

        bv-result

        ]
       [else
        ;(assume (not (bvzero? (cpp:eval rhs))))
        (mk-cpp-expr (widening-udiv (cpp:eval lhs) (cpp:eval rhs)) outT)]
       )
     ;])
)

(define (do-mod lhs rhs)
 ; (cond
 ;   [(and (integer? lhs) (integer? rhs))
 ;    (remainder lhs rhs)]
 ;   [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (mk-cpp-expr (bvsrem (cpp:eval lhs) (cpp:eval rhs)) outT)]
       [else
        (mk-cpp-expr (bvurem (cpp:eval lhs) (cpp:eval rhs)) outT)]
       )
     ;])
)

(define (do-min lhs rhs)
  ;(cond
  ;  [(and (integer? lhs) (integer? rhs))
  ;   (min lhs rhs)]
  ;  [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (define minF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:min8]
            [(eq? (cpp:type-bw outT) 16) cpp:min16]
            [(eq? (cpp:type-bw outT) 32) cpp:min32]
            [(eq? (cpp:type-bw outT) 64) cpp:min64]))
        (minF lhs rhs)]
       [else
        (define minF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:minu8]
            [(eq? (cpp:type-bw outT) 16) cpp:minu16]
            [(eq? (cpp:type-bw outT) 32) cpp:minu32]
            [(eq? (cpp:type-bw outT) 64) cpp:minu64]))

        (minF lhs rhs)])
     ;])
)

(define (do-max lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (max lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (cond
       [(cpp:signed-type? outT)
        (define maxF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:max8]
            [(eq? (cpp:type-bw outT) 16) cpp:max16]
            [(eq? (cpp:type-bw outT) 32) cpp:max32]
            [(eq? (cpp:type-bw outT) 64) cpp:max64]))
        (maxF lhs rhs)]
       [else
        (define maxF
          (cond
            [(eq? (cpp:type-bw outT) 8) cpp:maxu8]
            [(eq? (cpp:type-bw outT) 16) cpp:maxu16]
            [(eq? (cpp:type-bw outT) 32) cpp:maxu32]
            [(eq? (cpp:type-bw outT) 64) cpp:maxu64]))
        (maxF lhs rhs)])]))

(define (do-shr lhs rhs)
  (define outT (cpp:type lhs))
  (cond
    [(cpp:signed-type? outT)
     ;(displayln "ARETHMETIC RIGHT SHIFT")
     (mk-cpp-expr (bvashr (cpp:eval lhs) (cpp:eval rhs)) outT)]
    [else
     ;(displayln "LOGICAL RIGHT SHIFT")
     (mk-cpp-expr (bvlshr (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-shl lhs rhs)
  (define outT (cpp:type lhs))
  (mk-cpp-expr (bvshl (cpp:eval lhs) (cpp:eval rhs)) outT))

(define (do-if condition lhs rhs)
  (cond
    [(and (and (integer? lhs) (integer? rhs) (boolean? condition)))
     (if condition lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (define mask-val (cpp:eval condition))
     (define last-bit (lsb mask-val))
     (define eval-condition (bveq last-bit (bv #b1 1)))
     (mk-cpp-expr (if eval-condition (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-eq lhs rhs)
  ;(printf "do-eq\n")
  (cond
    [(and (integer? lhs) (integer? rhs))
     (eq? lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (if (bveq (cpp:eval lhs) (cpp:eval rhs)) (bv #b1 1) (bv #b0 1)) 'uint1)]
    [else
     (mk-cpp-expr (if (bveq (cpp:eval lhs) (cpp:eval rhs)) (bv #b1 1) (bv #b0 1)) 'uint1)]))

(define (do-lt lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (< lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (bvslt (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvult (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]))

(define (do-le lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (<= lhs rhs)]
    [(cpp:signed-expr? lhs)
     (mk-cpp-expr (bvsle (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]
    [else
     (mk-cpp-expr (bvule (cpp:eval lhs) (cpp:eval rhs)) 'uint1)]))

(define (do-abs lhs)
  (define outT (infer-out-type lhs lhs))
  (define zero (cpp:cast (int8_t (bv 1 8)) (cpp:type-str outT)))
  (define minus1 (cpp:cast (int8_t (bv -1 8)) (cpp:type-str outT)))
  (if (bvsge (cpp:eval lhs) (cpp:eval zero)) lhs (mk-cpp-expr (bvmul (cpp:eval lhs) (cpp:eval minus1)) outT)))

(define (do-absd lhs rhs)
  (define outT (infer-out-type lhs rhs))
  (define prev (cond
    [(cpp:signed-type? outT)
     (mk-cpp-expr (if (bvsle (cpp:eval lhs) (cpp:eval rhs)) (bvsub (cpp:eval rhs) (cpp:eval lhs)) (bvsub (cpp:eval lhs) (cpp:eval rhs))) (mk-cpp-type (cpp:type-bw outT) #f))]
    [else
     (mk-cpp-expr (if (bvule (cpp:eval lhs) (cpp:eval rhs)) (bvsub (cpp:eval rhs) (cpp:eval lhs)) (bvsub (cpp:eval lhs) (cpp:eval rhs))) (mk-cpp-type (cpp:type-bw outT) #f))])
    )
  prev 
  )

(define (do-clz lhs)
  (define outT (infer-out-type lhs lhs))
  (cond
    [(eq? int32_t outT) (cpp:clz32 lhs)]))

(define (do-bwand lhs rhs)
  (cond
    [(and (integer? lhs) (integer? rhs))
     (bitwise-and lhs rhs)]
    [else
     (define outT (infer-out-type lhs rhs))
     (mk-cpp-expr (bvand (cpp:eval lhs) (cpp:eval rhs)) outT)]))

(define (do-reduce vec op base width)
  (define outT (cpp:type (vec 0)))

  (mk-cpp-expr
   (cond
     [(eq? width 2) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))))]
     [(eq? width 3) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))) (cpp:eval (vec (+ base 2))))]
     [(eq? width 4) (op (cpp:eval (vec base)) (cpp:eval (vec (+ base 1))) (cpp:eval (vec (+ base 2))) (cpp:eval (vec (+ base 3))))]
     [else (error "NYI: arith vector_reduce for reduction factor of:" width)])
   outT))
