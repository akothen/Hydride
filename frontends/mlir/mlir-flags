OVERVIEW: MLIR modular optimizer driver

Available Dialects: acc, affine, amdgpu, amx, arith, arm_neon, arm_sve, async, bufferization, builtin, cf, complex, dlti, emitc, func, gpu, linalg, llvm, math, memref, ml_program, nvgpu, nvvm, omp, pdl, pdl_interp, quant, rocdl, scf, shape, sparse_tensor, spv, tensor, test, tosa, transform, vector, x86vector
USAGE: mlir-opt [options] <input file>

OPTIONS:

Color Options:

  --color                                               - Use colors in output (default=autodetect)

General options:

  --abort-on-max-devirt-iterations-reached              - Abort when the max iterations for devirtualization CGSCC repeat pass is reached
  --allow-ginsert-as-artifact                           - Allow G_INSERT to be considered an artifact. Hack around AMDGPU test infinite loops.
  --allow-unregistered-dialect                          - Allow operation with no registered dialects
  --amdgpu-bypass-slow-div                              - Skip 64-bit divide for dynamic 32-bit values
  --amdgpu-disable-loop-alignment                       - Do not align and prefetch loops
  --amdgpu-dpp-combine                                  - Enable DPP combiner
  --amdgpu-dump-hsa-metadata                            - Dump AMDGPU HSA Metadata
  --amdgpu-enable-merge-m0                              - Merge and hoist M0 initializations
  --amdgpu-enable-power-sched                           - Enable scheduling to minimize mAI power bursts
  --amdgpu-igrouplp                                     - Enable construction of Instruction Groups and their ordering for scheduling
  --amdgpu-promote-alloca-to-vector-limit=<uint>        - Maximum byte size to consider promote alloca to vector
  --amdgpu-sdwa-peephole                                - Enable SDWA peepholer
  --amdgpu-use-aa-in-codegen                            - Enable the use of AA during codegen.
  --amdgpu-verify-hsa-metadata                          - Verify AMDGPU HSA Metadata
  --amdgpu-vgpr-index-mode                              - Use GPR indexing mode instead of movrel for vector indexing
  --atomic-counter-update-promoted                      - Do counter update using atomic fetch add  for promoted counters only
  --atomic-first-counter                                - Use atomic fetch add for first counter in a function (usually the entry counter)
  --bounds-checking-single-trap                         - Use one trap block per function
  --cfg-hide-cold-paths=<number>                        - Hide blocks with relative frequency below the given value
  --cfg-hide-deoptimize-paths                           - 
  --cfg-hide-unreachable-paths                          - 
  --cost-kind=<value>                                   - Target cost kind
    =throughput                                         -   Reciprocal throughput
    =latency                                            -   Instruction latency
    =code-size                                          -   Code size
    =size-latency                                       -   Code size and latency
  --debug-info-correlate                                - Use debug info to correlate profiles.
  --debugify-func-limit=<ulong>                         - Set max number of processed functions per pass.
  --debugify-level=<value>                              - Kind of debug info to add
    =locations                                          -   Locations only
    =location+variables                                 -   Locations and Variables
  --debugify-quiet                                      - Suppress verbose debugify output
  --disable-i2p-p2i-opt                                 - Disables inttoptr/ptrtoint roundtrip optimization
  --disable-promote-alloca-to-lds                       - Disable promote alloca to LDS
  --disable-promote-alloca-to-vector                    - Disable promote alloca to vector
  --do-counter-promotion                                - Do counter register promotion
  --dot-cfg-mssa=<file name for generated dot file>     - file name for generated dot file
  --enable-cse-in-irtranslator                          - Should enable CSE in irtranslator
  --enable-cse-in-legalizer                             - Should enable CSE in Legalizer
  --enable-gvn-hoist                                    - Enable the GVN hoisting pass (default = off)
  --enable-gvn-memdep                                   - 
  --enable-gvn-sink                                     - Enable the GVN sinking pass (default = off)
  --enable-load-in-loop-pre                             - 
  --enable-load-pre                                     - 
  --enable-loop-simplifycfg-term-folding                - 
  --enable-name-compression                             - Enable name/filename string compression
  --enable-split-backedge-in-load-pre                   - 
  --experimental-debug-variable-locations               - Use experimental new value-tracking variable locations
  --fs-profile-debug-bw-threshold=<uint>                - Only show debug message if the source branch weight is greater  than this value.
  --fs-profile-debug-prob-diff-threshold=<uint>         - Only show debug message if the branch probility is greater than this value (in percentage).
  --generate-merged-base-profiles                       - When generating nested context-sensitive profiles, always generate extra base profile for function with all its context profiles merged into it.
  --hash-based-counter-split                            - Rename counter variable of a comdat function based on cfg hash
  --hot-cold-split                                      - Enable hot-cold splitting pass
  --import-all-index                                    - Import all external functions in index.
  --instcombine-code-sinking                            - Enable code sinking
  --instcombine-guard-widening-window=<uint>            - How wide an instruction window to bypass looking for another guard
  --instcombine-max-iterations=<uint>                   - Limit the maximum number of instruction combining iterations
  --instcombine-max-num-phis=<uint>                     - Maximum number phis to handle in intptr/ptrint folding
  --instcombine-max-sink-users=<uint>                   - Maximum number of undroppable users for instruction sinking
  --instcombine-maxarray-size=<uint>                    - Maximum array size considered when doing a combine
  --instcombine-negator-enabled                         - Should we attempt to sink negations?
  --instcombine-negator-max-depth=<uint>                - What is the maximal lookup depth when trying to check for viability of negation sinking.
  --instrprof-atomic-counter-update-all                 - Make all profile counter updates atomic (for testing only)
  --internalize-public-api-file=<filename>              - A file containing list of symbol names to preserve
  --internalize-public-api-list=<list>                  - A list of symbol names to preserve
  --iterative-counter-promotion                         - Allow counter promotion across the whole loop nest.
  --matrix-default-layout=<value>                       - Sets the default matrix layout
    =column-major                                       -   Use column-major layout
    =row-major                                          -   Use row-major layout
  --max-counter-promotions=<int>                        - Max number of allowed counter promotions
  --max-counter-promotions-per-loop=<uint>              - Max number counter promotions per loop to avoid increasing register pressure too much
  --mir-strip-debugify-only                             - Should mir-strip-debug only strip debug info from debugified modules by default
  --misexpect-tolerance=<uint>                          - Prevents emiting diagnostics when profile counts are within N% of the threshold..
  --mlir-debug-counter=<string>                         - Comma separated list of debug counter skip and count arguments
  --mlir-disable-threading                              - Disable multi-threading within MLIR, overrides any further call to MLIRContext::enableMultiThreading()
  --mlir-elide-elementsattrs-if-larger=<uint>           - Elide ElementsAttrs with "..." that have more elements than the given upper limit
  --mlir-pass-pipeline-crash-reproducer=<string>        - Generate a .mlir reproducer file at the given output path if the pass manager crashes or fails
  --mlir-pass-pipeline-local-reproducer                 - When generating a crash reproducer, attempt to generated a reproducer with the smallest pipeline.
  --mlir-pass-statistics                                - Display the statistics of each pass
  --mlir-pass-statistics-display=<value>                - Display method for pass statistics
    =list                                               -   display the results in a merged list sorted by pass name
    =pipeline                                           -   display the results with a nested pipeline view
  --mlir-pretty-debuginfo                               - Print pretty debug info in MLIR output
  --mlir-print-debug-counter                            - Print out debug counter information after all counters have been accumulated
  --mlir-print-debuginfo                                - Print debug info in MLIR output
  --mlir-print-elementsattrs-with-hex-if-larger=<long>  - Print DenseElementsAttrs with a hex string that have more elements than the given upper limit (use -1 to disable)
  --mlir-print-ir-after=<pass-arg>                      - Print IR after specified passes
  --mlir-print-ir-after-all                             - Print IR after each pass
  --mlir-print-ir-after-change                          - When printing the IR after a pass, only print if the IR changed
  --mlir-print-ir-after-failure                         - When printing the IR after a pass, only print if the pass failed
  --mlir-print-ir-before=<pass-arg>                     - Print IR before specified passes
  --mlir-print-ir-before-all                            - Print IR before each pass
  --mlir-print-ir-module-scope                          - When printing IR for print-ir-[before|after]{-all} always print the top-level operation
  --mlir-print-local-scope                              - Print with local scope and inline information (eliding aliases for attributes, types, and locations
  --mlir-print-op-on-diagnostic                         - When a diagnostic is emitted on an operation, also print the operation as an attached note
  --mlir-print-stacktrace-on-diagnostic                 - When a diagnostic is emitted, also print the stack trace as an attached note
  --mlir-print-value-users                              - Print users of operation results and block arguments as a comment
  --mlir-timing                                         - Display execution times
  --mlir-timing-display=<value>                         - Display method for timing data
    =list                                               -   display the results in a list sorted by total time
    =tree                                               -   display the results ina with a nested tree view
  --no-discriminators                                   - Disable generation of discriminator information.
  --nvptx-sched4reg                                     - NVPTX Specific: schedule for register pressue
  -o <filename>                                         - Output filename
  --opaque-pointers                                     - Use opaque pointers
  --poison-checking-function-local                      - Check that returns are non-poison (for testing)
  --print-pipeline-passes                               - Print a '-passes' compatible string describing the pipeline (best-effort only).
  --r600-ir-structurize                                 - Use StructurizeCFG IR pass
  --runtime-counter-relocation                          - Enable relocating counters at runtime.
  --safepoint-ir-verifier-print-only                    - 
  --sample-profile-check-record-coverage=<N>            - Emit a warning if less than N% of records in the input profile are matched to the IR.
  --sample-profile-check-sample-coverage=<N>            - Emit a warning if less than N% of samples in the input profile are matched to the IR.
  --sample-profile-max-propagate-iterations=<uint>      - Maximum number of iterations to go through when propagating sample block/edge weights through the CFG.
  Compiler passes to run
    --pass-pipeline                                     -   A textual description of a pass pipeline to run
    Passes:
      --affine-data-copy-generate                       -   Generate explicit copying for affine memory operations
        --fast-mem-capacity=<ulong>                     - Set fast memory space capacity in KiB (default: unlimited)
        --fast-mem-space=<uint>                         - Fast memory space identifier for copy generation (default: 1)
        --generate-dma                                  - Generate DMA instead of point-wise copy
        --min-dma-transfer=<int>                        - Minimum DMA transfer size supported by the target in bytes
        --skip-non-unit-stride-loops                    - Testing purposes: avoid non-unit stride loop choice depths for copy placement
        --slow-mem-space=<uint>                         - Slow memory space identifier for copy generation (default: 0)
        --tag-mem-space=<uint>                          - Tag memory space identifier for copy generation (default: 0)
      --affine-loop-coalescing                          -   Coalesce nested loops with independent bounds into a single loop
      --affine-loop-fusion                              -   Fuse affine loop nests
        --fusion-compute-tolerance=<number>             - Fractional increase in additional computation tolerated while fusing
        --fusion-fast-mem-space=<uint>                  - Faster memory space number to promote fusion buffers to
        --fusion-local-buf-threshold=<ulong>            - Threshold size (KiB) for promoting local buffers to fast memory space
        --fusion-maximal                                - Enables maximal loop fusion
        --mode=<value>                                  - fusion mode to attempt
    =greedy                                       -   Perform greedy (both producer-consumer and sibling)  fusion
    =producer                                     -   Perform only producer-consumer fusion
    =sibling                                      -   Perform only sibling fusion
      --affine-loop-invariant-code-motion               -   Hoist loop invariant instructions outside of affine loops
      --affine-loop-normalize                           -   Apply normalization transformations to affine loop-like ops
      --affine-loop-tile                                -   Tile affine loop nests
        --cache-size=<ulong>                            - Set size of cache to tile for in KiB (default: 512)
        --separate                                      - Separate full and partial tiles (default: false)
        --tile-size=<uint>                              - Use this tile size for all loops
        --tile-sizes=<uint>                             - List of tile sizes for each perfect nest (overridden by -tile-size)
      --affine-loop-unroll                              -   Unroll affine loops
        --unroll-factor=<uint>                          - Use this unroll factor for all loops being unrolled
        --unroll-full                                   - Fully unroll loops
        --unroll-full-threshold=<uint>                  - Unroll all loops with trip count less than or equal to this
        --unroll-num-reps=<uint>                        - Unroll innermost loops repeatedly this many times
        --unroll-up-to-factor                           - Allow unrolling up to the factor specified
      --affine-loop-unroll-jam                          -   Unroll and jam affine loops
        --unroll-jam-factor=<uint>                      - Use this unroll jam factor for all loops (default 4)
      --affine-parallelize                              -   Convert affine.for ops into 1-D affine.parallel
        --max-nested=<uint>                             - Maximum number of nested parallel loops to produce. Defaults to unlimited (UINT_MAX).
        --parallel-reductions                           - Whether to parallelize reduction loops. Defaults to false.
      --affine-pipeline-data-transfer                   -   Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy
      --affine-scalrep                                  -   Replace affine memref acceses by scalars by forwarding stores to loads and eliminating redundant loads
      --affine-simplify-structures                      -   Simplify affine expressions in maps/sets and normalize memrefs
      --affine-super-vectorize                          -   Vectorize to a target independent n-D vector abstraction
        --test-fastest-varying=<long>                   - Specify a 1-D, 2-D or 3-D pattern of fastest varying memory dimensions to match. See defaultPatterns in Vectorize.cpp for a description and examples. This is used for testing purposes
        --vectorize-reductions                          - Vectorize known reductions expressed via iter_args. Switched off by default.
        --virtual-vector-size=<long>                    - Specify an n-D virtual vector size for vectorization
      --affine-super-vectorizer-test                    -   Tests vectorizer standalone functionality.
      --arith-bufferize                                 -   Bufferize Arithmetic dialect ops.
        --alignment=<uint>                              - Create global memrefs with a specified alignment
      --arith-expand                                    -   Legalize Arithmetic ops to be convertible to LLVM.
      --arith-unsigned-when-equivalent                  -   Replace signed ops with unsigned ones where they are proven equivalent
      --arm-neon-2d-to-intr                             -   Convert Arm NEON structured ops to intrinsics
      --async-parallel-for                              -   Convert scf.parallel operations to multiple async compute ops executed concurrently for non-overlapping iteration ranges
        --async-dispatch                                - Dispatch async compute tasks using recursive work splitting. If `false` async compute tasks will be launched using simple for loop in the caller thread.
        --min-task-size=<int>                           - The minimum task size for sharding parallel operation.
        --num-workers=<int>                             - The number of available workers to execute async operations. If `-1` the value will be retrieved from the runtime.
      --async-runtime-policy-based-ref-counting         -   Policy based reference counting for Async runtime operations
      --async-runtime-ref-counting                      -   Automatic reference counting for Async runtime operations
      --async-runtime-ref-counting-opt                  -   Optimize automatic reference counting operations for theAsync runtime by removing redundant operations
      --async-to-async-runtime                          -   Lower high level async operations (e.g. async.execute) to theexplicit async.runtime and async.coro operations
        --eliminate-blocking-await-ops                  - Rewrite functions with blocking async.runtime.await as coroutines with async.runtime.await_and_resume.
      --buffer-deallocation                             -   Adds all required dealloc operations for all allocations in the input program
      --buffer-hoisting                                 -   Optimizes placement of allocation operations by moving them into common dominators and out of nested regions
      --buffer-loop-hoisting                            -   Optimizes placement of allocation operations by moving them out of loop nests
      --buffer-results-to-out-params                    -   Converts memref-typed function results to out-params
      --bufferization-bufferize                         -   Bufferize the `bufferization` dialect
      --canonicalize                                    -   Canonicalize operations
        --disable-patterns=<string>                     - Labels of patterns that should be filtered out during application
        --enable-patterns=<string>                      - Labels of patterns that should be used during application, all other patterns are filtered out
        --max-iterations=<long>                         - Seed the worklist in general top-down order
        --region-simplify                               - Seed the worklist in general top-down order
        --top-down                                      - Seed the worklist in general top-down order
      --control-flow-sink                               -   Sink operations into conditional blocks
      --convert-affine-for-to-gpu                       -   Convert top-level AffineFor Ops to GPU kernels
        --gpu-block-dims=<uint>                         - Number of GPU block dimensions for mapping
        --gpu-thread-dims=<uint>                        - Number of GPU thread dimensions for mapping
      --convert-amdgpu-to-rocdl                         -   Convert AMDGPU dialect to ROCDL dialect
        --chipset=<string>                              - Chipset that these operations will run on
      --convert-arith-to-llvm                           -   Convert Arithmetic dialect to LLVM dialect
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
      --convert-arith-to-spirv                          -   Convert Arithmetic dialect to SPIR-V dialect
        --emulate-non-32-bit-scalar-types               - Emulate non-32-bit scalar types with 32-bit ones if missing native support
      --convert-async-to-llvm                           -   Convert the operations from the async dialect into the LLVM dialect
      --convert-bufferization-to-memref                 -   Convert operations from the Bufferization dialect to the MemRef dialect
      --convert-cf-to-llvm                              -   Convert ControlFlow operations to the LLVM dialect
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
      --convert-cf-to-spirv                             -   Convert ControlFlow dialect to SPIR-V dialect
        --emulate-non-32-bit-scalar-types               - Emulate non-32-bit scalar types with 32-bit ones if missing native support
      --convert-complex-to-libm                         -   Convert Complex dialect to libm calls
      --convert-complex-to-llvm                         -   Convert Complex dialect to LLVM dialect
      --convert-complex-to-standard                     -   Convert Complex dialect to standard dialect
      --convert-elementwise-to-linalg                   -   Convert ElementwiseMappable ops to linalg
      --convert-func-to-llvm                            -   Convert from the Func dialect to the LLVM dialect
        --data-layout=<string>                          - String description (LLVM format) of the data layout that is expected on the produced module
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
        --use-bare-ptr-memref-call-conv                 - Replace FuncOp's MemRef arguments with bare pointers to the MemRef element types
      --convert-func-to-spirv                           -   Convert Func dialect to SPIR-V dialect
        --emulate-non-32-bit-scalar-types               - Emulate non-32-bit scalar types with 32-bit ones if missing native support
      --convert-gpu-launch-to-vulkan-launch             -   Convert gpu.launch_func to vulkanLaunch external call
      --convert-gpu-to-nvvm                             -   Generate NVVM operations for gpu operations
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
      --convert-gpu-to-rocdl                            -   Generate ROCDL operations for gpu operations
        --chipset=<string>                              - Chipset that these operations will run on
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
        --runtime=<value>                               - Runtime code will be run on (default is Unknown, can also use HIP or OpenCl)
    =unknown                                      -   Unknown (default)
    =HIP                                          -   HIP
    =OpenCL                                       -   OpenCL
      --convert-gpu-to-spirv                            -   Convert GPU dialect to SPIR-V dialect
      --convert-linalg-to-affine-loops                  -   Lower the operations from the linalg dialect into affine loops
      --convert-linalg-to-llvm                          -   Convert the operations from the linalg dialect into the LLVM dialect
      --convert-linalg-to-loops                         -   Lower the operations from the linalg dialect into loops
      --convert-linalg-to-parallel-loops                -   Lower the operations from the linalg dialect into parallel loops
      --convert-linalg-to-spirv                         -   Convert Linalg dialect to SPIR-V dialect
      --convert-linalg-to-std                           -   Convert the operations from the linalg dialect into the Standard dialect
      --convert-math-to-libm                            -   Convert Math dialect to libm calls
      --convert-math-to-llvm                            -   Convert Math dialect to LLVM dialect
      --convert-math-to-spirv                           -   Convert Math dialect to SPIR-V dialect
      --convert-memref-to-llvm                          -   Convert operations from the MemRef dialect to the LLVM dialect
        --index-bitwidth=<uint>                         - Bitwidth of the index type, 0 to use size of machine word
        --use-aligned-alloc                             - Use aligned_alloc in place of malloc for heap allocations
        --use-generic-functions                         - Use generic allocation and deallocation functions instead of the classic 'malloc', 'aligned_alloc' and 'free' functions
      --convert-memref-to-spirv                         -   Convert MemRef dialect to SPIR-V dialect
        --bool-num-bits=<int>                           - The number of bits to store a boolean value
      --convert-nvgpu-to-nvvm                           -   Convert NVGPU dialect to NVVM dialect
      --convert-openacc-to-llvm                         -   Convert the OpenACC ops to LLVM dialect
      --convert-openacc-to-scf                          -   Convert the OpenACC ops to OpenACC with SCF dialect
      --convert-openmp-to-llvm                          -   Convert the OpenMP ops to OpenMP ops with LLVM dialect
      --convert-parallel-loops-to-gpu                   -   Convert mapped scf.parallel ops to gpu launch operations
      --convert-pdl-to-pdl-interp                       -   Convert PDL ops to PDL interpreter ops
      --convert-scf-to-cf                               -   Convert SCF dialect to ControlFlow dialect, replacing structured control flow with a CFG
      --convert-scf-to-openmp                           -   Convert SCF parallel loop to OpenMP parallel + workshare constructs.
      --convert-scf-to-spirv                            -   Convert SCF dialect to SPIR-V dialect.
      --convert-shape-constraints                       -   Convert shape constraint operations to the standard dialect
      --convert-shape-to-std                            -   Convert operations from the shape dialect into the standard dialect
      --convert-spirv-to-llvm                           -   Convert SPIR-V dialect to LLVM dialect
      --convert-tensor-to-linalg                        -   Convert some Tensor dialect ops to Linalg dialect
      --convert-tensor-to-spirv                         -   Convert Tensor dialect to SPIR-V dialect
        --emulate-non-32-bit-scalar-types               - Emulate non-32-bit scalar types with 32-bit ones if missing native support
      --convert-vector-to-gpu                           -   Lower the operations from the vector dialect into the GPU dialect
        --use-nvgpu                                     - convert to NvGPU ops instead of GPU dialect ops
      --convert-vector-to-llvm                          -   Lower the operations from the vector dialect into the LLVM dialect
        --enable-amx                                    - Enables the use of AMX dialect while lowering the vector dialect.
        --enable-arm-neon                               - Enables the use of ArmNeon dialect while lowering the vector dialect.
        --enable-arm-sve                                - Enables the use of ArmSVE dialect while lowering the vector dialect.
        --enable-x86vector                              - Enables the use of X86Vector dialect while lowering the vector dialect.
        --force-32bit-vector-indices                    - Allows compiler to assume vector indices fit in 32-bit if that yields faster code
        --reassociate-fp-reductions                     - Allows llvm to reassociate floating-point reductions for speed
      --convert-vector-to-scf                           -   Lower the operations from the vector dialect into the SCF dialect
        --full-unroll                                   - Perform full unrolling when converting vector transfers to SCF
        --lower-permutation-maps                        - Replace permutation maps with vector transposes/broadcasts before lowering transfer ops
        --lower-tensors                                 - Lower transfer ops that operate on tensors
        --target-rank=<uint>                            - Target vector rank to which transfer ops should be lowered
      --convert-vector-to-spirv                         -   Convert Vector dialect to SPIR-V dialect
      --cse                                             -   Eliminate common sub-expressions
      --decorate-spirv-composite-type-layout            -   Decorate SPIR-V composite type with layout info
      --drop-equivalent-buffer-results                  -   Remove MemRef return values that are equivalent to a bbArg
      --eliminate-alloc-tensors                         -   Try to eliminate all alloc_tensor ops.
      --finalizing-bufferize                            -   Finalize a partial bufferization
      --fold-memref-subview-ops                         -   Fold memref.subview ops into consumer load/store ops
      --func-bufferize                                  -   Bufferize func/call/return ops
      --gpu-async-region                                -   Make GPU ops async
      --gpu-kernel-outlining                            -   Outline gpu.launch bodies to kernel functions
        --data-layout-str=<string>                      - String containing the data layout specification to be attached to the GPU kernel module
      --gpu-launch-sink-index-computations              -   Sink index computations into gpu.launch body
      --gpu-map-parallel-loops                          -   Greedily maps loops to GPU hardware dimensions.
      --gpu-to-hsaco                                    -   Lower GPU kernel function to HSACO binary annotations
        --chip=<string>                                 - Target architecture
        --features=<string>                             - Target features
        --gpu-binary-annotation=<string>                - Annotation attribute string for GPU binary
        --opt-level=<int>                               - Optimization level for HSACO compilation
        --rocm-path=<string>                            - Path to ROCm install
        --triple=<string>                               - Target triple
      --gpu-to-llvm                                     -   Convert GPU dialect to LLVM dialect with GPU runtime calls
        --gpu-binary-annotation=<string>                - Annotation attribute string for GPU binary
      --hydride-arith                                   -   Hydride Arith Frontend
      --inline                                          -   Inline function calls
        --default-pipeline=<string>                     - The default optimizer pipeline used for callables
        --max-iterations=<uint>                         - Maximum number of iterations when inlining within an SCC
        --op-pipelines=<pass-manager>                   - Callable operation specific optimizer pipelines (in the form of `dialect.op(pipeline)`)
      --launch-func-to-vulkan                           -   Convert vulkanLaunch external call to Vulkan runtime external calls
      --linalg-bufferize                                -   Bufferize the linalg dialect
      --linalg-detensorize                              -   Detensorize linalg ops
        --aggressive-mode                               - Detensorize all ops that qualify for detensoring along with branch operands and basic-block arguments.
      --linalg-fold-unit-extent-dims                    -   Remove unit-extent dimension in Linalg ops on tensors
        --fold-one-trip-loops-only                      - Only folds the one-trip loops from Linalg ops on tensors (for testing purposes only)
      --linalg-fuse-elementwise-ops                     -   Fuse elementwise operations on tensors
      --linalg-generalize-named-ops                     -   Convert named ops into generic ops
      --linalg-init-tensor-to-alloc-tensor              -   Replace all init_tensor ops by alloc_tensor ops.
      --linalg-inline-scalar-operands                   -   Inline scalar operands into linalg generic ops
      --linalg-named-op-conversion                      -   Convert from one named linalg op to another.
      --linalg-strategy-decompose-pass                  -   Configurable pass to apply pattern-based generalization.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
      --linalg-strategy-enable-pass                     -   Configurable pass to enable the application of other pattern-based linalg passes.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
      --linalg-strategy-generalize-pass                 -   Configurable pass to apply pattern-based generalization.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
      --linalg-strategy-interchange-pass                -   Configurable pass to apply pattern-based iterator interchange.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
      --linalg-strategy-lower-vectors-pass              -   Configurable pass to lower vector operations.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
      --linalg-strategy-pad-pass                        -   Configurable pass to apply padding and hoisting.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
      --linalg-strategy-peel-pass                       -   Configurable pass to apply pattern-based linalg peeling.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
      --linalg-strategy-remove-markers-pass             -   Cleanup pass that drops markers.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
      --linalg-strategy-tile-and-fuse-pass              -   Configurable pass to apply pattern-based tiling and fusion.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
      --linalg-strategy-tile-pass                       -   Configurable pass to apply pattern-based linalg tiling.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
      --linalg-strategy-vectorize-pass                  -   Configurable pass to apply pattern-based linalg vectorization.
        --anchor-func=<string>                          - Which func op is the anchor to latch on.
        --anchor-op=<string>                            - Which linalg op within the func is the anchor to latch on.
        --vectorize-padding                             - Enable vectorization of padding ops.
      --linalg-tile                                     -   Tile operations in the linalg dialect
        --loop-type=<string>                            - Specify the type of loops to generate: for, parallel
        --tile-sizes=<long>                             - Tile sizes
      --llvm-legalize-for-export                        -   Legalize LLVM dialect to be convertible to LLVM IR
      --llvm-optimize-for-nvvm-target                   -   Optimize NVVM IR
      --llvm-request-c-wrappers                         -   Request C wrapper emission for all functions
      --loop-invariant-code-motion                      -   Hoist loop invariant instructions outside of the loop
      --lower-affine                                    -   Lower Affine operations to a combination of Standard and SCF operations
      --lower-host-to-llvm                              -   Lowers the host module code and `gpu.launch_func` to LLVM
      --memref-expand                                   -   Legalize memref operations to be convertible to LLVM.
      --normalize-memrefs                               -   Normalize memrefs
      --nvgpu-optimize-shared-memory                    -   Optimizes accesses to shard memory memrefs in order to reduce bank conflicts.
      --one-shot-bufferize                              -   One-Shot Bufferize
        --allow-return-allocs                           - Allows returning/yielding new allocations from a block.
        --allow-unknown-ops                             - Allows unknown (not bufferizable) ops in the input IR.
        --analysis-fuzzer-seed=<uint>                   - Test only: Analyze ops in random order with a given seed (fuzzer)
        --bufferize-function-boundaries                 - Bufferize function boundaries (experimental).
        --create-deallocs                               - Specify if buffers should be deallocated. For compatibility with core bufferization passes.
        --dialect-filter=<string>                       - Restrict bufferization to ops from these dialects.
        --function-boundary-type-conversion=<string>    - Controls layout maps when bufferizing function signatures.
        --must-infer-memory-space                       - The memory space of an memref types must always be inferred. If unset, a default memory space of 0 is used otherwise.
        --print-conflicts                               - Test only: Annotate IR with RaW conflicts. Requires test-analysis-only.
        --test-analysis-only                            - Test only: Only run inplaceability analysis and annotate IR
        --unknown-type-conversion=<string>              - Controls layout maps for non-inferrable memref types.
      --print-op-stats                                  -   Print statistics of operations
        --json                                          - print the stats as JSON
      --promote-buffers-to-stack                        -   Promotes heap-based allocations to automatically managed stack-based allocations
        --max-alloc-size-in-bytes=<uint>                - Maximal size in bytes to promote allocations to stack.
        --max-rank-of-allocated-memref=<uint>           - Maximal memref rank to promote dynamic buffers.
      --quant-convert-const                             -   Converts constants followed by qbarrier to actual quantized values
      --quant-convert-simulated-quantization            -   Converts training-time simulated quantization ops to corresponding quantize/dequantize casts
      --reconcile-unrealized-casts                      -   Simplify and eliminate unrealized conversion casts
      --remove-shape-constraints                        -   Replace all cstr_ ops with a true witness
      --resolve-ranked-shaped-type-result-dims          -   Resolve memref.dim of result values of ranked shape type
      --resolve-shaped-type-result-dims                 -   Resolve memref.dim of result values
      --sccp                                            -   Sparse Conditional Constant Propagation
      --scf-bufferize                                   -   Bufferize the scf dialect.
      --scf-for-loop-canonicalization                   -   Canonicalize operations within scf.for loop bodies
      --scf-for-loop-peeling                            -   Peel `for` loops at their upper bounds.
        --skip-partial                                  - Do not peel loops inside of the last, partial iteration of another already peeled loop.
      --scf-for-loop-range-folding                      -   Fold add/mul ops into loop range
      --scf-for-loop-specialization                     -   Specialize `for` loops for vectorization
      --scf-for-to-while                                -   Convert SCF for loops to SCF while loops
      --scf-parallel-loop-collapsing                    -   Collapse parallel loops to use less induction variables
        --collapsed-indices-0=<uint>                    - Which loop indices to combine 0th loop index
        --collapsed-indices-1=<uint>                    - Which loop indices to combine into the position 1 loop index
        --collapsed-indices-2=<uint>                    - Which loop indices to combine into the position 2 loop index
      --scf-parallel-loop-fusion                        -   Fuse adjacent parallel loops
      --scf-parallel-loop-specialization                -   Specialize parallel loops for vectorization
      --scf-parallel-loop-tiling                        -   Tile parallel loops
        --no-min-max-bounds                             - Perform tiling with fixed upper bound with inbound check inside the internal loops
        --parallel-loop-tile-sizes=<long>               - Factors to tile parallel loops by
      --shape-bufferize                                 -   Bufferize the shape dialect.
      --shape-to-shape-lowering                         -   Legalize Shape dialect to be convertible to Arithmetic
      --slice-analysis-test                             -   Test Slice analysis functionality.
      --snapshot-op-locations                           -   Generate new locations from the current IR
        --filename=<string>                             - The filename to print the generated IR
        --tag=<string>                                  - A tag to use when fusing the new locations with the original. If unset, the locations are replaced.
      --sparse-tensor-conversion                        -   Apply conversion rules to sparse tensor primitives and types
        --s2s-strategy=<int>                            - Set the strategy for sparse-to-sparse conversion
      --sparsification                                  -   Automatically generate sparse tensor code from sparse tensor types
        --enable-simd-index32                           - Enable i32 indexing into vectors (for efficiency)
        --enable-vla-vectorization                      - Enable vector length agnostic vectorization
        --parallelization-strategy=<int>                - Set the parallelization strategy
        --vectorization-strategy=<int>                  - Set the vectorization strategy
        --vl=<int>                                      - Set the vector length
      --spirv-canonicalize-gl                           -   Run canonicalization involving GLSL ops
      --spirv-lower-abi-attrs                           -   Decorate SPIR-V composite type with layout info
      --spirv-rewrite-inserts                           -   Rewrite sequential chains of spv.CompositeInsert operations into spv.CompositeConstruct operations
      --spirv-unify-aliased-resource                    -   Unify access of multiple aliased resources into access of one single resource
      --spirv-update-vce                                -   Deduce and attach minimal (version, capabilities, extensions) requirements to spv.module ops
      --strip-debuginfo                                 -   Strip debug info from all operations
      --symbol-dce                                      -   Eliminate dead symbols
      --symbol-privatize                                -   Mark symbols private
        --exclude=<string>                              - Comma separated list of symbols that should not be marked private
      --tensor-bufferize                                -   Bufferize the `tensor` dialect
      --tensor-copy-insertion                           -   Make all tensor IR inplaceable by inserting copies
        --allow-return-allocs                           - Allows returning/yielding new allocations from a block.
        --bufferize-function-boundaries                 - Bufferize function boundaries (experimental).
        --create-deallocs                               - Specify if new allocations should be deallocated.
        --must-infer-memory-space                       - The memory space of an memref types must always be inferred. If unset, a default memory space of 0 is used otherwise.
      --test-affine-data-copy                           -   Tests affine data copy utility functions.
        --for-memref-region                             - Test copy generation for a single memref region
        --memref-filter                                 - Enable memref filter testing in affine data copy optimization
      --test-affine-loop-unswitch                       -   Tests affine loop unswitching / if/else hoisting
      --test-affine-parametric-tile                     -   Tile affine loops using SSA values as tile sizes
      --test-alias-analysis                             -   Test alias analysis results.
      --test-alias-analysis-modref                      -   Test alias analysis ModRef results.
      --test-clone                                      -   Test clone of op
      --test-compose-subview                            -   Test combining composed subviews
      --test-constant-fold                              -   Test operation constant folding
      --test-control-flow-sink                          -   Test control-flow sink pass
      --test-convert-call-op                            -   Tests conversion of `func.call` to `llvm.call` in presence of custom types
      --test-data-layout-query                          -   Test data layout queries
      --test-dead-code-analysis                         -   
      --test-decompose-call-graph-types                 -   Decomposes types at call graph boundaries.
      --test-derived-attr                               -   Run test derived attributes
      --test-diagnostic-filter                          -   Test diagnostic filtering support.
        --filters=<string>                              - Specifies the diagnostic file name filters.
      --test-dynamic-pipeline                           -   Tests the dynamic pipeline feature by applying a pipeline on a selected set of functions
        --dynamic-pipeline=<string>                     - The pipeline description that will run on the filtered function.
        --op-name=<string>                              - List of function name to apply the pipeline to
        --run-on-nested-operations                      - This will apply the pipeline on nested operations under the visited operation.
        --run-on-parent                                 - This will apply the pipeline on the parent operation if it exist, this is expected to fail.
      --test-elements-attr-interface                    -   Test ElementsAttr interface support.
      --test-expand-math                                -   Test expanding math
      --test-extract-fixed-outer-loops                  -   test application of parametric tiling to the outer loops so that the ranges of outer loops become static
        --test-outer-loop-sizes=<long>                  - fixed number of iterations that the outer loops should have
      --test-foo-analysis                               -   
      --test-func-erase-arg                             -   Test erasing func args.
      --test-func-erase-result                          -   Test erasing func results.
      --test-func-insert-arg                            -   Test inserting func args.
      --test-func-insert-result                         -   Test inserting func results.
      --test-func-set-type                              -   Test FunctionOpInterface::setType.
      --test-function-pass                              -   Test a function pass in the pass manager
      --test-generic-ir-block-visitors-interrupt        -   Test generic IR visitors with interrupts, starting with Blocks.
      --test-generic-ir-region-visitors-interrupt       -   Test generic IR visitors with interrupts, starting with Regions.
      --test-generic-ir-visitors                        -   Test generic IR visitors.
      --test-generic-ir-visitors-interrupt              -   Test generic IR visitors with interrupts.
      --test-gpu-memory-promotion                       -   Promotes the annotated arguments of gpu.func to workgroup memory.
      --test-gpu-rewrite                                -   Applies all rewrite patterns within the GPU dialect.
      --test-gpu-to-cubin                               -   Lower GPU kernel function to CUBIN binary annotations
        --chip=<string>                                 - Target architecture
        --features=<string>                             - Target features
        --gpu-binary-annotation=<string>                - Annotation attribute string for GPU binary
        --triple=<string>                               - Target triple
      --test-gpu-to-hsaco                               -   Lower GPU kernel function to HSAco binary annotations
        --chip=<string>                                 - Target architecture
        --features=<string>                             - Target features
        --gpu-binary-annotation=<string>                - Annotation attribute string for GPU binary
        --triple=<string>                               - Target triple
      --test-inline                                     -   Test inlining region calls
      --test-int-range-inference                        -   Test integer range inference analysis
      --test-interface-pass                             -   Test an interface pass (running on FunctionOpInterface) in the pass manager
      --test-ir-visitors                                -   Test various visitors.
      --test-last-modified                              -   
      --test-legalize-patterns                          -   Run test dialect legalization patterns
      --test-legalize-type-conversion                   -   Test various type conversion functionalities in DialectConversion
      --test-legalize-unknown-root-patterns             -   Test public remapped value mechanism in ConversionPatternRewriter
      --test-linalg-decompose-ops                       -   Test Linalg decomposition patterns
      --test-linalg-elementwise-fusion-patterns         -   Test Linalg element wise operation fusion patterns
        --control-fusion-by-expansion                   - Test controlling fusion of reshape with generic op by expansion
        --fuse-generic-ops                              - Test fusion of generic operations.
        --fuse-with-reshape-by-collapsing               - Test linalg expand_shape -> generic fusion patterns that collapse the iteration space of the consumer
        --fuse-with-reshape-by-collapsing-control       - Test controlling the linalg expand_shape -> generic fusion patterns that collapse the iteration space of the consumer
        --fuse-with-reshape-by-expansion                - Test fusion of generic operations with reshape by expansion
      --test-linalg-greedy-fusion                       -   Test Linalg fusion by applying a greedy test transformation.
      --test-linalg-hoisting                            -   Test Linalg hoisting functions.
        --test-hoist-redundant-transfers                - Test hoisting transfer_read/transfer_write pairs
      --test-linalg-pad-fusion                          -   Test PadOp fusion
      --test-linalg-transform-patterns                  -   Test Linalg transformation patterns by applying them greedily.
        --loop-type=<string>                            - Specify the type of loops to generate: for, parallel or tiled_loop
        --peeled-loops=<long>                           - Loops to be peeled when test-tile-pattern
        --skip-partial                                  - Skip loops inside partial iterations during peeling
        --test-bubble-up-extract-slice-op-pattern       - Test rewrite of linalgOp + extract_slice into extract_slice + linalgOp
        --test-generalize-pad-tensor                    - Test transform pad tensor by copying with generic ops
        --test-linalg-to-vector-patterns                - Test a set of patterns that rewrite a linalg contraction in vector.contract form
        --test-patterns                                 - Test a mixed set of patterns
        --test-split-reduction                          - Test split reduction transformation
        --test-swap-subtensor-padtensor                 - Test rewrite of subtensor(tensor.pad) into tensor.pad(subtensor)
        --test-tile-and-distribute-options              - Test tile and distribute options
        --test-tile-fuse-and-distribute-options         - Test tile, fuse and distribute options
        --test-tile-pattern                             - Test tile pattern
        --test-tile-scalarize-dynamic-dims              - Test tiling of dynamic dims by 1
        --test-transform-pad-tensor                     - Test transform pad tensor by copying with generic ops
        --test-vector-transfer-forwarding-patterns      - Test a fused pass that forwards memref.copy to vector.transfer
        --tile-sizes=<long>                             - Linalg tile sizes for test-tile-pattern
      --test-loop-fusion                                -   Tests loop fusion utility functions.
      --test-loop-permutation                           -   Tests affine loop permutation utility
        --permutation-map=<uint>                        - Specify the loop permutation
      --test-loop-unrolling                             -   Tests loop unrolling transformation
        --annotate                                      - Annotate unrolled iterations.
        --loop-depth=<uint>                             - Loop depth.
        --unroll-factor=<ulong>                         - Loop unroll factor.
        --unroll-up-to-factor                           - Loop unroll up to factor.
      --test-mapping-to-processing-elements             -   test mapping a single loop on a virtual processor grid
      --test-match-reduction                            -   Test the match reduction utility.
      --test-matchers                                   -   Test C++ pattern matchers.
      --test-math-algebraic-simplification              -   Test math algebraic simplification
      --test-math-polynomial-approximation              -   Test math polynomial approximations
        --enable-avx2                                   - Enable approximations that emit AVX2 intrinsics via the X86Vector dialect
      --test-memref-bound-check                         -   Check memref access bounds
      --test-memref-dependence-check                    -   Checks dependences between all pairs of memref accesses.
      --test-memref-stride-calculation                  -   Test operation constant folding
      --test-merge-blocks                               -   Test Merging operation in ConversionPatternRewriter
      --test-mlir-reducer                               -   Tests MLIR Reduce tool by generating failures
      --test-module-pass                                -   Test a module pass in the pass manager
      --test-multi-buffering                            -   Test multi buffering transformation
        --multiplier=<uint>                             - Decide how many versions of the buffer should be created,
      --test-opaque-loc                                 -   Changes all leaf locations to opaque locations
      --test-operations-equality                        -   Test operations equality.
      --test-options-pass                               -   Test options parsing capabilities
        --list=<int>                                    - Example list option
        --string=<string>                               - Example string option
        --string-list=<string>                          - Example string list option
      --test-pass-crash                                 -   Test a pass in the pass manager that always crashes
      --test-pass-create-invalid-ir                     -   Test pass that adds an invalid operation in a function body
        --emit-invalid-ir                               - Emit invalid IR
        --signal-pass-failure                           - Trigger a pass failure
      --test-pass-failure                               -   Test a pass in the pass manager that always fails
      --test-pass-invalid-parent                        -   Test a pass in the pass manager that makes the parent operation invalid
      --test-pattern-selective-replacement              -   Test selective replacement in the PatternRewriter
      --test-patterns                                   -   Run test dialect patterns
        --top-down                                      - Seed the worklist in general top-down order
      --test-pdl-bytecode-pass                          -   Test PDL ByteCode functionality
      --test-pdll-pass                                  -   Test PDLL functionality
      --test-print-callgraph                            -   Print the contents of a constructed callgraph.
      --test-print-defuse                               -   Test various printing.
      --test-print-dominance                            -   Print the dominance information for multiple regions.
      --test-print-invalid                              -   Test printing invalid ops.
      --test-print-liveness                             -   Print the contents of a constructed liveness information.
      --test-print-nesting                              -   Test various printing.
      --test-print-topological-sort                     -   Print operations in topological order
      --test-recursive-types                            -   Test support for recursive types
      --test-remapped-value                             -   Test public remapped value mechanism in ConversionPatternRewriter
      --test-return-type                                -   Run return type functions
      --test-rewrite-dynamic-op                         -   Test rewritting on dynamic operations
      --test-scf-for-utils                              -   test scf.for utils
        --test-replace-with-new-yields                  - Test replacing a loop with a new loop that returns new additional yeild values
      --test-scf-if-utils                               -   test scf.if utils
      --test-scf-pipelining                             -   test scf.forOp pipelining
        --annotate                                      - Annote operations during loop pipelining transformation
        --no-epilogue-peeling                           - Use predicates instead of peeling the epilogue.
      --test-shape-function-report                      -   Test pass to report associated shape functions
      --test-side-effects                               -   Test side effects interfaces
      --test-spirv-entry-point-abi                      -   Set the spv.entry_point_abi attribute on GPU kernel function within the module, intended for testing only
        --workgroup-size=<int>                          - Workgroup size to use for all gpu.func kernels in the module, specified with x-dimension first, y-dimension next and z-dimension last. Unspecified dimensions will be set to 1
      --test-spirv-module-combiner                      -   Tests SPIR-V module combiner library
      --test-spirv-op-availability                      -   Test SPIR-V op availability
      --test-spirv-target-env                           -   Test SPIR-V target environment
      --test-stats-pass                                 -   Test pass statistics
      --test-strict-pattern-driver                      -   Run strict mode of pattern driver
      --test-symbol-rauw                                -   Test replacement of symbol uses
      --test-symbol-uses                                -   Test detection of symbol uses
      --test-take-body                                  -   Test Region's takeBody
      --test-target-materialization-with-no-uses        -   Test a special case of target materialization in DialectConversion
      --test-tensor-transform-patterns                  -   Test Tensor transformation patterns by applying them greedily.
        --test-fold-constant-extract-slice              - Test folding arith.constant and tensor.extract_slice
        --test-split-padding-patterns                   - Test patterns to split tensor.pad ops
      --test-tiling-interface                           -   Test tiling using TilingInterface
        --tile-consumer-and-fuse-producer-using-scf-for - Test tile and fuse transformation using TilingInterface with scf.for operations
        --tile-using-scf-for                            - Test tiling using TilingInterface with scf.for operations
      --test-trait-folder                               -   Run trait folding
      --test-transform-dialect-interpreter              -   apply transform dialect operations one by one
        --enable-expensive-checks                       - perform expensive checks to better report errors in the transform IR
      --test-type-interfaces                            -   Test type interface support.
      --test-vector-contraction-lowering                -   Test lowering patterns that lower contract ops in the vector dialect
        --vector-filter-outerproduct                    - Lower vector.contract to vector.outerproduct but not for vectors of size 4.
        --vector-lower-matrix-intrinsics                - Lower vector.contract to llvm.intr.matrix.multiply
        --vector-outerproduct                           - Lower vector.contract to vector.outerproduct
        --vector-parallel-arith                         - Lower vector.contract to elementwise vector ops.
      --test-vector-distribute-patterns                 -   Test lowering patterns to distribute vector ops in the vector dialect
        --distribution-multiplicity=<int>               - Set the multiplicity used for distributing vector
      --test-vector-multi-reduction-lowering-patterns   -   Test lowering patterns to lower vector.multi_reduction to other vector ops
        --use-outer-reductions                          - Move reductions to outer most dimensions
      --test-vector-reduction-to-contract-patterns      -   Test patterns to convert multireduce op to contract and combine broadcast/transpose to contract
      --test-vector-scan-lowering                       -   Test lowering patterns that lower the scan op in the vector dialect
      --test-vector-to-forloop                          -   Test lowering patterns to break up a vector op into a for loop
        --distribution-multiplicity=<int>               - Set the multiplicity used for distributing vector
      --test-vector-to-vector-lowering                  -   Test lowering patterns between ops in the vector dialect
        --unroll                                        - Include unrolling
      --test-vector-transfer-collapse-inner-most-dims   -   Test lowering patterns that reducedes the rank of the vector transfer memory and vector operands.
      --test-vector-transfer-drop-unit-dims-patterns    -   
      --test-vector-transfer-flatten-patterns           -   Test patterns to rewrite contiguous row-major N-dimensional vector.transfer_{read,write} ops into 1D transfers
      --test-vector-transfer-full-partial-split         -   Test lowering patterns to split transfer ops via scf.if + linalg ops
        --use-memref-copy                               - Split using a unmasked vector.transfer + linalg.fill + memref.copy operations.
      --test-vector-transfer-lowering-patterns          -   Test lowering patterns to lower transfer ops to other vector ops
      --test-vector-transfer-unrolling-patterns         -   Test lowering patterns to unroll transfer ops in the vector dialect
        --reverse-unroll-order                          - reverse the order of unrolling of vector transfer operations
      --test-vector-transferop-opt                      -   Test optimization transformations for transfer ops
      --test-vector-transpose-lowering                  -   Test lowering patterns that lower contract ops in the vector dialect
        --avx2                                          - Lower vector.transpose to avx2-specific patterns
        --eltwise                                       - Lower 2-D vector.transpose to eltwise insert/extract
        --flat                                          - Lower 2-D vector.transpose to vector.flat_transpose
        --shuffle                                       - Lower 2-D vector.transpose to shape_cast + shuffle
      --test-vector-unrolling-patterns                  -   Test lowering patterns to unroll contract ops in the vector dialect
        --unroll-based-on-type                          - Set the unroll factor based on type of the operation
        --unroll-order=<long>                           - set the unroll order
      --test-vector-warp-distribute                     -   Test vector warp distribute transformation and lowering patterns
        --distribute-transfer-write                     - Test distribution of transfer write
        --hoist-uniform                                 - Test hoist uniform
        --propagate-distribution                        - Test distribution propgation
        --rewrite-warp-ops-to-scf-if                    - Lower vector.warp_execute_on_lane0 to scf.if op
      --topological-sort                                -   Sort regions without SSA dominance in topological order
      --tosa-infer-shapes                               -   Propagate shapes across TOSA operations
      --tosa-layerwise-constant-fold                    -   Fold layerwise operations on constant tensors
      --tosa-make-broadcastable                         -   TOSA rank Reshape to enable Broadcasting
      --tosa-optional-decompositions                    -   Applies Tosa operations optional decompositions
      --tosa-test-quant-utils                           -   TOSA Test: Exercise the APIs in QuantUtils.cpp.
      --tosa-to-arith                                   -   Lower TOSA to the Arith dialect
        --include-apply-rescale                         - Whether to include the lowering for tosa.apply_rescale to arith
        --use-32-bit                                    - Whether to prioritze lowering to 32-bit operations
      --tosa-to-linalg                                  -   Lower TOSA to LinAlg on tensors
      --tosa-to-linalg-named                            -   Lower TOSA to LinAlg named operations
      --tosa-to-scf                                     -   Lower TOSA to the SCF dialect
      --tosa-to-tensor                                  -   Lower TOSA to the Tensor dialect
      --transform-dialect-check-uses                    -   warn about potential use-after-free in the transform dialect
      --vector-bufferize                                -   Bufferize Vector dialect ops
      --view-op-graph                                   -   Print Graphviz visualization of an operation
        --max-label-len=<uint>                          - Limit attribute/type length to number of chars
        --print-attrs                                   - Print attributes of operations
        --print-control-flow-edges                      - Print control flow edges
        --print-data-flow-edges                         - Print data flow edges
        --print-result-types                            - Print result types of operations
    Pass Pipelines:
      --sparse-compiler                                 -   The standard pipeline for taking sparsity-agnostic IR using the sparse-tensor type, and lowering it to LLVM IR with concrete representations and algorithms for sparse tensors.
        --enable-amx                                    - Enables the use of AMX dialect while lowering the vector dialect.
        --enable-arm-neon                               - Enables the use of ArmNeon dialect while lowering the vector dialect.
        --enable-arm-sve                                - Enables the use of ArmSVE dialect while lowering the vector dialect.
        --enable-index-optimizations                    - Allows compiler to assume indices fit in 32-bit if that yields faster code
        --enable-simd-index32                           - Enable i32 indexing into vectors (for efficiency)
        --enable-vla-vectorization                      - Enable vector length agnostic vectorization
        --enable-x86vector                              - Enables the use of X86Vector dialect while lowering the vector dialect.
        --parallelization-strategy=<int>                - Set the parallelization strategy
        --reassociate-fp-reductions                     - Allows llvm to reassociate floating-point reductions for speed
        --s2s-strategy=<int>                            - Set the strategy for sparse-to-sparse conversion
        --test-bufferization-analysis-only              - Run only the inplacability analysis
        --vectorization-strategy=<int>                  - Set the vectorization strategy
        --vl=<int>                                      - Set the vector length
      --test-dump-pipeline                              -   Dumps the pipeline build so far for debugging purposes
      --test-options-pass-pipeline                      -   Parses options using pass pipeline registration
        --list=<int>                                    - Example list option
        --string=<string>                               - Example string option
        --string-list=<string>                          - Example string list option
      --test-pm-nested-pipeline                         -   Test a nested pipeline in the pass manager
      --test-textual-pm-nested-pipeline                 -   Test a nested pipeline in the pass manager
  --show-dialects                                       - Print the list of registered dialects
  --skip-ret-exit-block                                 - Suppress counter promotion if exit blocks contain ret.
  --speculative-counter-promotion-max-exiting=<uint>    - The max number of exiting blocks of a loop to allow  speculative counter promotion
  --speculative-counter-promotion-to-loop               - When the option is false, if the target block is in a loop, the promotion will be disallowed unless the promoted counter  update can be further/iteratively promoted into an acyclic  region.
  --split-input-file                                    - Split the input file into pieces and process each chunk independently
  --summary-file=<string>                               - The summary file to use for function importing.
  --test-legalize-mode=<value>                          - The legalization mode to use with the test driver
    =analysis                                           -   Perform an analysis conversion
    =full                                               -   Perform a full conversion
    =partial                                            -   Perform a partial conversion
  --type-based-intrinsic-cost                           - Calculate intrinsics cost based only on argument types
  --verify-diagnostics                                  - Check that emitted diagnostics match expected-* lines on the corresponding line
  --verify-each                                         - Run the verifier after each transformation pass
  --verify-legalizer-debug-locs=<value>                 - Verify that debug locations are handled
    =none                                               -   No verification
    =legalizations                                      -   Verify legalizations
    =legalizations+artifactcombiners                    -   Verify legalizations and artifact combines
  --verify-region-info                                  - Verify region info (time consuming)
  --vp-counters-per-site=<number>                       - The average number of profile counters allocated per value profiling site.
  --vp-static-alloc                                     - Do static counter allocation for value profiler

Generic Options:

  --help                                                - Display available options (--help-hidden for more)
  --help-list                                           - Display list of available options (--help-list-hidden for more)
  --version                                             - Display the version of this program

affine-super-vectorizer-test options:

  --backward-slicing                                    - Enable testing backward static slicing and topological sort functionalities
  --compose-maps                                        - Enable testing the composition of AffineMap where each AffineMap in the composition is specified as the affine_map attribute in a constant op.
  --forward-slicing                                     - Enable testing forward static slicing and topological sort functionalities
  --slicing                                             - Enable testing static slicing and topological sort functionalities
  --vector-shape-ratio=<int>                            - Specify the HW vector size for vectorization
  --vectorize-affine-loop-nest                          - Enable testing for the 'vectorizeAffineLoopNest' utility by vectorizing the outermost loops found

test-loop-fusion options:

  --test-loop-fusion-dependence-check                   - Enable testing of loop fusion dependence check
  --test-loop-fusion-slice-computation                  - Enable testing of loop fusion slice computation
  --test-loop-fusion-transformation                     - Enable testing of loop fusion transformation
