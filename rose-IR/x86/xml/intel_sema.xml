<intrinsics_list version="3.5.2" date="06/05/2020">
<intrinsic tech="AVX" name="_mm256_extractf128_si256">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTF128" form="xmm, ymm, imm8" xed="VEXTRACTF128_XMMdq_YMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" name="_mm256_permute2f128_si256">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M256"/>
	<parameter type="__m256i" varname="a" etype="M256"/>
	<parameter type="__m256i" varname="b" etype="M256"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of integer data) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERM2F128" form="ymm, ymm, ymm, imm8" xed="VPERM2F128_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX" name="_mm256_insertf128_si256">
	<type>Integer</type>
	<CPUID>AVX</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M256"/>
	<parameter type="__m128i" varname="b" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 128 bits from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTF128" form="ymm, ymm, xmm, imm8" xed="VINSERTF128_YMMqq_YMMqq_XMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="5"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPALIGNR" form="ymm, ymm, ymm, imm8" xed="VPALIGNR_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blend_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Blend packed 16-bit integers from "a" and "b" within 128-bit lanes using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[j%8]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDW" form="ymm, ymm, ymm, imm8" xed="VPBLENDW_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4"/>
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPBLENDD" form="xmm, xmm, xmm, imm8" xed="VPBLENDD_XMMdq_XMMdq_XMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blend_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Blend packed 32-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[j]
		dst[i+31:i] := b[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDD" form="ymm, ymm, ymm, imm8" xed="VPBLENDD_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_blendv_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="__m256i" varname="mask" etype="MASK"/>
	<description>Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPBLENDVB" form="ymm, ymm, ymm, ymm" xed="VPBLENDVB_YMMqq_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_extracti128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of integer data) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI128" form="xmm, ymm, imm8" xed="VEXTRACTI128_XMMdq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_inserti128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M256"/>
	<parameter type="__m128i" varname="b" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of integer data) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI128" form="ymm, ymm, xmm, imm8" xed="VINSERTI128_YMMqq_YMMqq_XMMdq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_mpsadbw_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Eight SADs are performed for each 128-bit lane using one quadruplet from "b" and eight quadruplets from "a". One quadruplet is selected from "b" starting at on the offset specified in "imm8". Eight quadruplets are formed from sequential 8-bit integers selected from "a" starting at the offset specified in "imm8".</description>
	<operation>
DEFINE MPSADBW(a[127:0], b[127:0], imm8[2:0]) {
	a_offset := imm8[2]*32
	b_offset := imm8[1:0]*32
	FOR j := 0 to 7
		i := j*8
		k := a_offset+i
		l := b_offset
		tmp[i*2+15:i*2] := ABS(Signed(a[k+7:k] - b[l+7:l])) + ABS(Signed(a[k+15:k+8] - b[l+15:l+8])) + \
		                   ABS(Signed(a[k+23:k+16] - b[l+23:l+16])) + ABS(Signed(a[k+31:k+24] - b[l+31:l+24]))
	ENDFOR
	RETURN tmp[127:0]
}
dst[127:0] := MPSADBW(a[127:0], b[127:0], imm8[2:0])
dst[255:128] := MPSADBW(a[255:128], b[255:128], imm8[5:3])
dst[MAX:256] := 0
	</operation>
	<instruction name="VMPSADBW" form="ymm, ymm, ymm, imm8" xed="VMPSADBW_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_permute2x128_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="M256"/>
	<parameter type="__m256i" varname="a" etype="M256"/>
	<parameter type="__m256i" varname="b" etype="M256"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of integer data) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src1, src2, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src1[127:0]
	1:	tmp[127:0] := src1[255:128]
	2:	tmp[127:0] := src2[127:0]
	3:	tmp[127:0] := src2[255:128]
	ESAC
	IF control[3]
		tmp[127:0] := 0
	FI
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[255:0], b[255:0], imm8[3:0])
dst[255:128] := SELECT4(a[255:0], b[255:0], imm8[7:4])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERM2I128" form="ymm, ymm, ymm, imm8" xed="VPERM2I128_YMMqq_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_permute4x64_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
dst[63:0] := SELECT4(a[255:0], imm8[1:0])
dst[127:64] := SELECT4(a[255:0], imm8[3:2])
dst[191:128] := SELECT4(a[255:0], imm8[5:4])
dst[255:192] := SELECT4(a[255:0], imm8[7:6])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERMQ" form="ymm, ymm, imm8" xed="VPERMQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sad_epu8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 3
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] + \
	               tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSADBW" form="ymm, ymm, ymm" xed="VPSADBW_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
dst[159:128] := SELECT4(a[255:128], imm8[1:0])
dst[191:160] := SELECT4(a[255:128], imm8[3:2])
dst[223:192] := SELECT4(a[255:128], imm8[5:4])
dst[255:224] := SELECT4(a[255:128], imm8[7:6])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFD" form="ymm, ymm, imm8" xed="VPSHUFD_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Shuffle 8-bit integers in "a" within 128-bit lanes according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[3:0] := b[i+3:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
	IF b[128+i+7] == 1
		dst[128+i+7:128+i] := 0
	ELSE
		index[3:0] := b[128+i+3:128+i]
		dst[128+i+7:128+i] := a[128+index*8+7:128+index*8]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFB" form="ymm, ymm, ymm" xed="VPSHUFB_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi8">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="SI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Negate packed signed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGNB" form="ymm, ymm, ymm" xed="VPSIGNB_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Negate packed signed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGNW" form="ymm, ymm, ymm" xed="VPSIGNW_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sign_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="b" etype="SI32"/>
	<description>Negate packed signed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSIGND" form="ymm, ymm, ymm" xed="VPSIGND_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
dst[255:128] := a[255:128] &lt;&lt; (tmp*8)
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLDQ" form="ymm, ymm, imm8" xed="VPSLLDQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_bslli_epi128">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
dst[255:128] := a[255:128] &lt;&lt; (tmp*8)
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLDQ" form="ymm, ymm, imm8" xed="VPSLLDQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm, ymm, xmm" xed="VPSLLW_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm, ymm, imm8" xed="VPSLLW_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm, ymm, xmm" xed="VPSLLD_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm, ymm, imm8" xed="VPSLLD_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm, ymm, xmm" xed="VPSLLQ_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm, ymm, imm8" xed="VPSLLQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm, xmm, xmm" xed="VPSLLVD_XMMdq_XMMdq_XMMdq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm, ymm, ymm" xed="VPSLLVD_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm, xmm, xmm" xed="VPSLLVQ_XMMdq_XMMdq_XMMdq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm, ymm, ymm" xed="VPSLLVQ_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm, ymm, xmm" xed="VPSRAW_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm, ymm, imm8" xed="VPSRAW_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm, ymm, xmm" xed="VPSRAD_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm, ymm, imm8" xed="VPSRAD_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm, xmm, xmm" xed="VPSRAVD_XMMdq_XMMdq_XMMdq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm, ymm, ymm" xed="VPSRAVD_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_si256">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
dst[255:128] := a[255:128] &gt;&gt; (tmp*8)
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLDQ" form="ymm, ymm, imm8" xed="VPSRLDQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_bsrli_epi128">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="M128"/>
	<parameter type="__m256i" varname="a" etype="M128"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
dst[255:128] := a[255:128] &gt;&gt; (tmp*8)
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLDQ" form="ymm, ymm, imm8" xed="VPSRLDQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm, ymm, xmm" xed="VPSRLW_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm, ymm, imm8" xed="VPSRLW_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm, ymm, xmm" xed="VPSRLD_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm, ymm, imm8" xed="VPSRLD_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm, ymm, xmm" xed="VPSRLQ_YMMqq_YMMqq_XMMq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm, ymm, imm8" xed="VPSRLQ_YMMqq_YMMqq_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm, xmm, xmm" xed="VPSRLVD_XMMdq_XMMdq_XMMdq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm, ymm, ymm" xed="VPSRLVD_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm, xmm, xmm" xed="VPSRLVQ_XMMdq_XMMdq_XMMdq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX2" name="_mm256_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX2</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm, ymm, ymm" xed="VPSRLVQ_YMMqq_YMMqq_YMMqq"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 1
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 3
	i := j*64
	dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	               ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                  ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                  ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                  ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VDBPSADBW" form="ymm, ymm, ymm, imm8" xed="VDBPSADBW_YMMu16_MASKmskw_YMMu8_YMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 1
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 3
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VDBPSADBW" form="ymm {k}, ymm, ymm, imm8" xed="VDBPSADBW_YMMu16_MASKmskw_YMMu8_YMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 1
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 3
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VDBPSADBW" form="ymm {z}, ymm, ymm, imm8" xed="VDBPSADBW_YMMu16_MASKmskw_YMMu8_YMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 3
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 7
	i := j*64
	dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	               ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                  ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                  ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                  ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VDBPSADBW" form="zmm, zmm, zmm, imm8" xed="VDBPSADBW_ZMMu16_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 3
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 7
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VDBPSADBW" form="zmm {k}, zmm, zmm, imm8" xed="VDBPSADBW_ZMMu16_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected from within 128-bit lanes according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
FOR i := 0 to 3
	tmp.m128[i].dword[0] := b.m128[i].dword[ imm8[1:0] ]
	tmp.m128[i].dword[1] := b.m128[i].dword[ imm8[3:2] ]
	tmp.m128[i].dword[2] := b.m128[i].dword[ imm8[5:4] ]
	tmp.m128[i].dword[3] := b.m128[i].dword[ imm8[7:6] ]
ENDFOR
FOR j := 0 to 7
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VDBPSADBW" form="zmm {z}, zmm, zmm, imm8" xed="VDBPSADBW_ZMMu16_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
tmp.dword[0] := b.dword[ imm8[1:0] ]
tmp.dword[1] := b.dword[ imm8[3:2] ]
tmp.dword[2] := b.dword[ imm8[5:4] ]
tmp.dword[3] := b.dword[ imm8[7:6] ]
FOR j := 0 to 1
	i := j*64
	dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	               ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                  ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                  ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                  ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VDBPSADBW" form="xmm, xmm, xmm, imm8" xed="VDBPSADBW_XMMu16_MASKmskw_XMMu8_XMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
tmp.dword[0] := b.dword[ imm8[1:0] ]
tmp.dword[1] := b.dword[ imm8[3:2] ]
tmp.dword[2] := b.dword[ imm8[5:4] ]
tmp.dword[3] := b.dword[ imm8[7:6] ]
FOR j := 0 to 1
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VDBPSADBW" form="xmm {k}, xmm, xmm, imm8" xed="VDBPSADBW_XMMu16_MASKmskw_XMMu8_XMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dbsad_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).
	Four SADs are performed on four 8-bit quadruplets for each 64-bit lane. The first two SADs use the lower 8-bit quadruplet of the lane from "a", and the last two SADs use the uppper 8-bit quadruplet of the lane from "a". Quadruplets from "b" are selected according to the control in "imm8", and each SAD in each 64-bit lane uses the selected quadruplet at 8-bit offsets.</description>
	<operation>
tmp.dword[0] := b.dword[ imm8[1:0] ]
tmp.dword[1] := b.dword[ imm8[3:2] ]
tmp.dword[2] := b.dword[ imm8[5:4] ]
tmp.dword[3] := b.dword[ imm8[7:6] ]
FOR j := 0 to 1
	i := j*64
	tmp_dst[i+15:i] := ABS(a[i+7:i] - tmp[i+7:i]) + ABS(a[i+15:i+8] - tmp[i+15:i+8]) +\
	                   ABS(a[i+23:i+16] - tmp[i+23:i+16]) + ABS(a[i+31:i+24] - tmp[i+31:i+24])
	
	tmp_dst[i+31:i+16] := ABS(a[i+7:i] - tmp[i+15:i+8]) + ABS(a[i+15:i+8] - tmp[i+23:i+16]) +\
	                      ABS(a[i+23:i+16] - tmp[i+31:i+24]) + ABS(a[i+31:i+24] - tmp[i+39:i+32])
	
	tmp_dst[i+47:i+32] := ABS(a[i+39:i+32] - tmp[i+23:i+16]) + ABS(a[i+47:i+40] - tmp[i+31:i+24]) +\
	                      ABS(a[i+55:i+48] - tmp[i+39:i+32]) + ABS(a[i+63:i+56] - tmp[i+47:i+40])
	
	tmp_dst[i+63:i+48] := ABS(a[i+39:i+32] - tmp[i+31:i+24]) + ABS(a[i+47:i+40] - tmp[i+39:i+32]) +\
	                      ABS(a[i+55:i+48] - tmp[i+47:i+40]) + ABS(a[i+63:i+56] - tmp[i+55:i+48])
ENDFOR
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VDBPSADBW" form="xmm {z}, xmm, xmm, imm8" xed="VDBPSADBW_XMMu16_MASKmskw_XMMu8_XMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU16" form="ymm {k}, ymm" xed="VMOVDQU16_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU16" form="ymm {z}, ymm" xed="VMOVDQU16_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU16" form="zmm {k}, zmm" xed="VMOVDQU16_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU16" form="zmm {z}, zmm" xed="VMOVDQU16_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU16" form="xmm {k}, xmm" xed="VMOVDQU16_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Move packed 16-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU16" form="xmm {z}, xmm" xed="VMOVDQU16_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU8" form="ymm {k}, ymm" xed="VMOVDQU8_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VMOVDQU8" form="ymm {z}, ymm" xed="VMOVDQU8_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU8" form="zmm {k}, zmm" xed="VMOVDQU8_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VMOVDQU8" form="zmm {z}, zmm" xed="VMOVDQU8_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU8" form="xmm {k}, xmm" xed="VMOVDQU8_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_mov_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Move</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Move packed 8-bit integers from "a" into "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VMOVDQU8" form="xmm {z}, xmm" xed="VMOVDQU8_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSB" form="ymm {k}, ymm" xed="VPABSB_YMMi8_MASKmskw_YMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSB" form="ymm {z}, ymm" xed="VPABSB_YMMi8_MASKmskw_YMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSB" form="zmm {k}, zmm" xed="VPABSB_ZMMi8_MASKmskw_ZMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSB" form="zmm {z}, zmm" xed="VPABSB_ZMMi8_MASKmskw_ZMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSB" form="xmm {k}, xmm" xed="VPABSB_XMMi8_MASKmskw_XMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI8"/>
	<description>Compute the absolute value of packed signed 8-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSB" form="xmm {z}, xmm" xed="VPABSB_XMMi8_MASKmskw_XMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSW" form="ymm {k}, ymm" xed="VPABSW_YMMi16_MASKmskw_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPABSW" form="ymm {z}, ymm" xed="VPABSW_YMMi16_MASKmskw_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSW" form="zmm {k}, zmm" xed="VPABSW_ZMMi16_MASKmskw_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPABSW" form="zmm {z}, zmm" xed="VPABSW_ZMMi16_MASKmskw_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSW" form="xmm {k}, xmm" xed="VPABSW_XMMi16_MASKmskw_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_abs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<description>Compute the absolute value of packed signed 16-bit integers in "a", and store the unsigned results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPABSW" form="xmm {z}, xmm" xed="VPABSW_XMMi16_MASKmskw_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI16"/>
	<parameter type="__m256i" varname="src" etype="SI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSDW" form="ymm {k}, ymm, ymm" xed="VPACKSSDW_YMMi16_MASKmskw_YMMi32_YMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSDW" form="ymm {z}, ymm, ymm" xed="VPACKSSDW_YMMi16_MASKmskw_YMMi32_YMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI16"/>
	<parameter type="__m512i" varname="src" etype="SI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
tmp_dst[271:256] := Saturate16(a[287:256])
tmp_dst[287:272] := Saturate16(a[319:288])
tmp_dst[303:288] := Saturate16(a[351:320])
tmp_dst[319:304] := Saturate16(a[383:352])
tmp_dst[335:320] := Saturate16(b[287:256])
tmp_dst[351:336] := Saturate16(b[319:288])
tmp_dst[367:352] := Saturate16(b[351:320])
tmp_dst[383:368] := Saturate16(b[383:352])
tmp_dst[399:384] := Saturate16(a[415:384])
tmp_dst[415:400] := Saturate16(a[447:416])
tmp_dst[431:416] := Saturate16(a[479:448])
tmp_dst[447:432] := Saturate16(a[511:480])
tmp_dst[463:448] := Saturate16(b[415:384])
tmp_dst[479:464] := Saturate16(b[447:416])
tmp_dst[495:480] := Saturate16(b[479:448])
tmp_dst[511:496] := Saturate16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSDW" form="zmm {k}, zmm, zmm" xed="VPACKSSDW_ZMMi16_MASKmskw_ZMMi32_ZMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
tmp_dst[143:128] := Saturate16(a[159:128])
tmp_dst[159:144] := Saturate16(a[191:160])
tmp_dst[175:160] := Saturate16(a[223:192])
tmp_dst[191:176] := Saturate16(a[255:224])
tmp_dst[207:192] := Saturate16(b[159:128])
tmp_dst[223:208] := Saturate16(b[191:160])
tmp_dst[239:224] := Saturate16(b[223:192])
tmp_dst[255:240] := Saturate16(b[255:224])
tmp_dst[271:256] := Saturate16(a[287:256])
tmp_dst[287:272] := Saturate16(a[319:288])
tmp_dst[303:288] := Saturate16(a[351:320])
tmp_dst[319:304] := Saturate16(a[383:352])
tmp_dst[335:320] := Saturate16(b[287:256])
tmp_dst[351:336] := Saturate16(b[319:288])
tmp_dst[367:352] := Saturate16(b[351:320])
tmp_dst[383:368] := Saturate16(b[383:352])
tmp_dst[399:384] := Saturate16(a[415:384])
tmp_dst[415:400] := Saturate16(a[447:416])
tmp_dst[431:416] := Saturate16(a[479:448])
tmp_dst[447:432] := Saturate16(a[511:480])
tmp_dst[463:448] := Saturate16(b[415:384])
tmp_dst[479:464] := Saturate16(b[447:416])
tmp_dst[495:480] := Saturate16(b[479:448])
tmp_dst[511:496] := Saturate16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSDW" form="zmm {z}, zmm, zmm" xed="VPACKSSDW_ZMMi16_MASKmskw_ZMMi32_ZMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI16"/>
	<parameter type="__m128i" varname="src" etype="SI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSDW" form="xmm {k}, xmm, xmm" xed="VPACKSSDW_XMMi16_MASKmskw_XMMi32_XMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packs_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := Saturate16(a[31:0])
tmp_dst[31:16] := Saturate16(a[63:32])
tmp_dst[47:32] := Saturate16(a[95:64])
tmp_dst[63:48] := Saturate16(a[127:96])
tmp_dst[79:64] := Saturate16(b[31:0])
tmp_dst[95:80] := Saturate16(b[63:32])
tmp_dst[111:96] := Saturate16(b[95:64])
tmp_dst[127:112] := Saturate16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSDW" form="xmm {z}, xmm, xmm" xed="VPACKSSDW_XMMi16_MASKmskw_XMMi32_XMMi32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI8"/>
	<parameter type="__m256i" varname="src" etype="SI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSWB" form="ymm {k}, ymm, ymm" xed="VPACKSSWB_YMMi8_MASKmskw_YMMi16_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="SI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKSSWB" form="ymm {z}, ymm, ymm" xed="VPACKSSWB_YMMi8_MASKmskw_YMMi16_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI8"/>
	<parameter type="__m512i" varname="src" etype="SI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
tmp_dst[263:256] := Saturate8(a[271:256])
tmp_dst[271:264] := Saturate8(a[287:272])
tmp_dst[279:272] := Saturate8(a[303:288])
tmp_dst[287:280] := Saturate8(a[319:304])
tmp_dst[295:288] := Saturate8(a[335:320])
tmp_dst[303:296] := Saturate8(a[351:336])
tmp_dst[311:304] := Saturate8(a[367:352])
tmp_dst[319:312] := Saturate8(a[383:368])
tmp_dst[327:320] := Saturate8(b[271:256])
tmp_dst[335:328] := Saturate8(b[287:272])
tmp_dst[343:336] := Saturate8(b[303:288])
tmp_dst[351:344] := Saturate8(b[319:304])
tmp_dst[359:352] := Saturate8(b[335:320])
tmp_dst[367:360] := Saturate8(b[351:336])
tmp_dst[375:368] := Saturate8(b[367:352])
tmp_dst[383:376] := Saturate8(b[383:368])
tmp_dst[391:384] := Saturate8(a[399:384])
tmp_dst[399:392] := Saturate8(a[415:400])
tmp_dst[407:400] := Saturate8(a[431:416])
tmp_dst[415:408] := Saturate8(a[447:432])
tmp_dst[423:416] := Saturate8(a[463:448])
tmp_dst[431:424] := Saturate8(a[479:464])
tmp_dst[439:432] := Saturate8(a[495:480])
tmp_dst[447:440] := Saturate8(a[511:496])
tmp_dst[455:448] := Saturate8(b[399:384])
tmp_dst[463:456] := Saturate8(b[415:400])
tmp_dst[471:464] := Saturate8(b[431:416])
tmp_dst[479:472] := Saturate8(b[447:432])
tmp_dst[487:480] := Saturate8(b[463:448])
tmp_dst[495:488] := Saturate8(b[479:464])
tmp_dst[503:496] := Saturate8(b[495:480])
tmp_dst[511:504] := Saturate8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSWB" form="zmm {k}, zmm, zmm" xed="VPACKSSWB_ZMMi8_MASKmskw_ZMMi16_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="SI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
tmp_dst[135:128] := Saturate8(a[143:128])
tmp_dst[143:136] := Saturate8(a[159:144])
tmp_dst[151:144] := Saturate8(a[175:160])
tmp_dst[159:152] := Saturate8(a[191:176])
tmp_dst[167:160] := Saturate8(a[207:192])
tmp_dst[175:168] := Saturate8(a[223:208])
tmp_dst[183:176] := Saturate8(a[239:224])
tmp_dst[191:184] := Saturate8(a[255:240])
tmp_dst[199:192] := Saturate8(b[143:128])
tmp_dst[207:200] := Saturate8(b[159:144])
tmp_dst[215:208] := Saturate8(b[175:160])
tmp_dst[223:216] := Saturate8(b[191:176])
tmp_dst[231:224] := Saturate8(b[207:192])
tmp_dst[239:232] := Saturate8(b[223:208])
tmp_dst[247:240] := Saturate8(b[239:224])
tmp_dst[255:248] := Saturate8(b[255:240])
tmp_dst[263:256] := Saturate8(a[271:256])
tmp_dst[271:264] := Saturate8(a[287:272])
tmp_dst[279:272] := Saturate8(a[303:288])
tmp_dst[287:280] := Saturate8(a[319:304])
tmp_dst[295:288] := Saturate8(a[335:320])
tmp_dst[303:296] := Saturate8(a[351:336])
tmp_dst[311:304] := Saturate8(a[367:352])
tmp_dst[319:312] := Saturate8(a[383:368])
tmp_dst[327:320] := Saturate8(b[271:256])
tmp_dst[335:328] := Saturate8(b[287:272])
tmp_dst[343:336] := Saturate8(b[303:288])
tmp_dst[351:344] := Saturate8(b[319:304])
tmp_dst[359:352] := Saturate8(b[335:320])
tmp_dst[367:360] := Saturate8(b[351:336])
tmp_dst[375:368] := Saturate8(b[367:352])
tmp_dst[383:376] := Saturate8(b[383:368])
tmp_dst[391:384] := Saturate8(a[399:384])
tmp_dst[399:392] := Saturate8(a[415:400])
tmp_dst[407:400] := Saturate8(a[431:416])
tmp_dst[415:408] := Saturate8(a[447:432])
tmp_dst[423:416] := Saturate8(a[463:448])
tmp_dst[431:424] := Saturate8(a[479:464])
tmp_dst[439:432] := Saturate8(a[495:480])
tmp_dst[447:440] := Saturate8(a[511:496])
tmp_dst[455:448] := Saturate8(b[399:384])
tmp_dst[463:456] := Saturate8(b[415:400])
tmp_dst[471:464] := Saturate8(b[431:416])
tmp_dst[479:472] := Saturate8(b[447:432])
tmp_dst[487:480] := Saturate8(b[463:448])
tmp_dst[495:488] := Saturate8(b[479:464])
tmp_dst[503:496] := Saturate8(b[495:480])
tmp_dst[511:504] := Saturate8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKSSWB" form="zmm {z}, zmm, zmm" xed="VPACKSSWB_ZMMi8_MASKmskw_ZMMi16_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI8"/>
	<parameter type="__m128i" varname="src" etype="SI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSWB" form="xmm {k}, xmm, xmm" xed="VPACKSSWB_XMMi8_MASKmskw_XMMi16_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packs_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="SI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using signed saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := Saturate8(a[15:0])
tmp_dst[15:8] := Saturate8(a[31:16])
tmp_dst[23:16] := Saturate8(a[47:32])
tmp_dst[31:24] := Saturate8(a[63:48])
tmp_dst[39:32] := Saturate8(a[79:64])
tmp_dst[47:40] := Saturate8(a[95:80])
tmp_dst[55:48] := Saturate8(a[111:96])
tmp_dst[63:56] := Saturate8(a[127:112])
tmp_dst[71:64] := Saturate8(b[15:0])
tmp_dst[79:72] := Saturate8(b[31:16])
tmp_dst[87:80] := Saturate8(b[47:32])
tmp_dst[95:88] := Saturate8(b[63:48])
tmp_dst[103:96] := Saturate8(b[79:64])
tmp_dst[111:104] := Saturate8(b[95:80])
tmp_dst[119:112] := Saturate8(b[111:96])
tmp_dst[127:120] := Saturate8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKSSWB" form="xmm {z}, xmm, xmm" xed="VPACKSSWB_XMMi8_MASKmskw_XMMi16_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSDW" form="ymm {k}, ymm, ymm" xed="VPACKUSDW_YMMu16_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSDW" form="ymm {z}, ymm, ymm" xed="VPACKUSDW_YMMu16_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
tmp_dst[271:256] := SaturateU16(a[287:256])
tmp_dst[287:272] := SaturateU16(a[319:288])
tmp_dst[303:288] := SaturateU16(a[351:320])
tmp_dst[319:304] := SaturateU16(a[383:352])
tmp_dst[335:320] := SaturateU16(b[287:256])
tmp_dst[351:336] := SaturateU16(b[319:288])
tmp_dst[367:352] := SaturateU16(b[351:320])
tmp_dst[383:368] := SaturateU16(b[383:352])
tmp_dst[399:384] := SaturateU16(a[415:384])
tmp_dst[415:400] := SaturateU16(a[447:416])
tmp_dst[431:416] := SaturateU16(a[479:448])
tmp_dst[447:432] := SaturateU16(a[511:480])
tmp_dst[463:448] := SaturateU16(b[415:384])
tmp_dst[479:464] := SaturateU16(b[447:416])
tmp_dst[495:480] := SaturateU16(b[479:448])
tmp_dst[511:496] := SaturateU16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSDW" form="zmm {k}, zmm, zmm" xed="VPACKUSDW_ZMMu16_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
tmp_dst[143:128] := SaturateU16(a[159:128])
tmp_dst[159:144] := SaturateU16(a[191:160])
tmp_dst[175:160] := SaturateU16(a[223:192])
tmp_dst[191:176] := SaturateU16(a[255:224])
tmp_dst[207:192] := SaturateU16(b[159:128])
tmp_dst[223:208] := SaturateU16(b[191:160])
tmp_dst[239:224] := SaturateU16(b[223:192])
tmp_dst[255:240] := SaturateU16(b[255:224])
tmp_dst[271:256] := SaturateU16(a[287:256])
tmp_dst[287:272] := SaturateU16(a[319:288])
tmp_dst[303:288] := SaturateU16(a[351:320])
tmp_dst[319:304] := SaturateU16(a[383:352])
tmp_dst[335:320] := SaturateU16(b[287:256])
tmp_dst[351:336] := SaturateU16(b[319:288])
tmp_dst[367:352] := SaturateU16(b[351:320])
tmp_dst[383:368] := SaturateU16(b[383:352])
tmp_dst[399:384] := SaturateU16(a[415:384])
tmp_dst[415:400] := SaturateU16(a[447:416])
tmp_dst[431:416] := SaturateU16(a[479:448])
tmp_dst[447:432] := SaturateU16(a[511:480])
tmp_dst[463:448] := SaturateU16(b[415:384])
tmp_dst[479:464] := SaturateU16(b[447:416])
tmp_dst[495:480] := SaturateU16(b[479:448])
tmp_dst[511:496] := SaturateU16(b[511:480])
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSDW" form="zmm {z}, zmm, zmm" xed="VPACKUSDW_ZMMu16_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSDW" form="xmm {k}, xmm, xmm" xed="VPACKUSDW_XMMu16_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packus_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="b" etype="SI32"/>
	<description>Convert packed signed 32-bit integers from "a" and "b" to packed 16-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[15:0] := SaturateU16(a[31:0])
tmp_dst[31:16] := SaturateU16(a[63:32])
tmp_dst[47:32] := SaturateU16(a[95:64])
tmp_dst[63:48] := SaturateU16(a[127:96])
tmp_dst[79:64] := SaturateU16(b[31:0])
tmp_dst[95:80] := SaturateU16(b[63:32])
tmp_dst[111:96] := SaturateU16(b[95:64])
tmp_dst[127:112] := SaturateU16(b[127:96])
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := tmp_dst[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSDW" form="xmm {z}, xmm, xmm" xed="VPACKUSDW_XMMu16_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSWB" form="ymm {k}, ymm, ymm" xed="VPACKUSWB_YMMu8_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPACKUSWB" form="ymm {z}, ymm, ymm" xed="VPACKUSWB_YMMu8_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
tmp_dst[263:256] := SaturateU8(a[271:256])
tmp_dst[271:264] := SaturateU8(a[287:272])
tmp_dst[279:272] := SaturateU8(a[303:288])
tmp_dst[287:280] := SaturateU8(a[319:304])
tmp_dst[295:288] := SaturateU8(a[335:320])
tmp_dst[303:296] := SaturateU8(a[351:336])
tmp_dst[311:304] := SaturateU8(a[367:352])
tmp_dst[319:312] := SaturateU8(a[383:368])
tmp_dst[327:320] := SaturateU8(b[271:256])
tmp_dst[335:328] := SaturateU8(b[287:272])
tmp_dst[343:336] := SaturateU8(b[303:288])
tmp_dst[351:344] := SaturateU8(b[319:304])
tmp_dst[359:352] := SaturateU8(b[335:320])
tmp_dst[367:360] := SaturateU8(b[351:336])
tmp_dst[375:368] := SaturateU8(b[367:352])
tmp_dst[383:376] := SaturateU8(b[383:368])
tmp_dst[391:384] := SaturateU8(a[399:384])
tmp_dst[399:392] := SaturateU8(a[415:400])
tmp_dst[407:400] := SaturateU8(a[431:416])
tmp_dst[415:408] := SaturateU8(a[447:432])
tmp_dst[423:416] := SaturateU8(a[463:448])
tmp_dst[431:424] := SaturateU8(a[479:464])
tmp_dst[439:432] := SaturateU8(a[495:480])
tmp_dst[447:440] := SaturateU8(a[511:496])
tmp_dst[455:448] := SaturateU8(b[399:384])
tmp_dst[463:456] := SaturateU8(b[415:400])
tmp_dst[471:464] := SaturateU8(b[431:416])
tmp_dst[479:472] := SaturateU8(b[447:432])
tmp_dst[487:480] := SaturateU8(b[463:448])
tmp_dst[495:488] := SaturateU8(b[479:464])
tmp_dst[503:496] := SaturateU8(b[495:480])
tmp_dst[511:504] := SaturateU8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSWB" form="zmm {k}, zmm, zmm" xed="VPACKUSWB_ZMMu8_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
tmp_dst[135:128] := SaturateU8(a[143:128])
tmp_dst[143:136] := SaturateU8(a[159:144])
tmp_dst[151:144] := SaturateU8(a[175:160])
tmp_dst[159:152] := SaturateU8(a[191:176])
tmp_dst[167:160] := SaturateU8(a[207:192])
tmp_dst[175:168] := SaturateU8(a[223:208])
tmp_dst[183:176] := SaturateU8(a[239:224])
tmp_dst[191:184] := SaturateU8(a[255:240])
tmp_dst[199:192] := SaturateU8(b[143:128])
tmp_dst[207:200] := SaturateU8(b[159:144])
tmp_dst[215:208] := SaturateU8(b[175:160])
tmp_dst[223:216] := SaturateU8(b[191:176])
tmp_dst[231:224] := SaturateU8(b[207:192])
tmp_dst[239:232] := SaturateU8(b[223:208])
tmp_dst[247:240] := SaturateU8(b[239:224])
tmp_dst[255:248] := SaturateU8(b[255:240])
tmp_dst[263:256] := SaturateU8(a[271:256])
tmp_dst[271:264] := SaturateU8(a[287:272])
tmp_dst[279:272] := SaturateU8(a[303:288])
tmp_dst[287:280] := SaturateU8(a[319:304])
tmp_dst[295:288] := SaturateU8(a[335:320])
tmp_dst[303:296] := SaturateU8(a[351:336])
tmp_dst[311:304] := SaturateU8(a[367:352])
tmp_dst[319:312] := SaturateU8(a[383:368])
tmp_dst[327:320] := SaturateU8(b[271:256])
tmp_dst[335:328] := SaturateU8(b[287:272])
tmp_dst[343:336] := SaturateU8(b[303:288])
tmp_dst[351:344] := SaturateU8(b[319:304])
tmp_dst[359:352] := SaturateU8(b[335:320])
tmp_dst[367:360] := SaturateU8(b[351:336])
tmp_dst[375:368] := SaturateU8(b[367:352])
tmp_dst[383:376] := SaturateU8(b[383:368])
tmp_dst[391:384] := SaturateU8(a[399:384])
tmp_dst[399:392] := SaturateU8(a[415:400])
tmp_dst[407:400] := SaturateU8(a[431:416])
tmp_dst[415:408] := SaturateU8(a[447:432])
tmp_dst[423:416] := SaturateU8(a[463:448])
tmp_dst[431:424] := SaturateU8(a[479:464])
tmp_dst[439:432] := SaturateU8(a[495:480])
tmp_dst[447:440] := SaturateU8(a[511:496])
tmp_dst[455:448] := SaturateU8(b[399:384])
tmp_dst[463:456] := SaturateU8(b[415:400])
tmp_dst[471:464] := SaturateU8(b[431:416])
tmp_dst[479:472] := SaturateU8(b[447:432])
tmp_dst[487:480] := SaturateU8(b[463:448])
tmp_dst[495:488] := SaturateU8(b[479:464])
tmp_dst[503:496] := SaturateU8(b[495:480])
tmp_dst[511:504] := SaturateU8(b[511:496])
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPACKUSWB" form="zmm {z}, zmm, zmm" xed="VPACKUSWB_ZMMu8_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSWB" form="xmm {k}, xmm, xmm" xed="VPACKUSWB_XMMu8_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_packus_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Convert</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Convert packed signed 16-bit integers from "a" and "b" to packed 8-bit integers using unsigned saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[7:0] := SaturateU8(a[15:0])
tmp_dst[15:8] := SaturateU8(a[31:16])
tmp_dst[23:16] := SaturateU8(a[47:32])
tmp_dst[31:24] := SaturateU8(a[63:48])
tmp_dst[39:32] := SaturateU8(a[79:64])
tmp_dst[47:40] := SaturateU8(a[95:80])
tmp_dst[55:48] := SaturateU8(a[111:96])
tmp_dst[63:56] := SaturateU8(a[127:112])
tmp_dst[71:64] := SaturateU8(b[15:0])
tmp_dst[79:72] := SaturateU8(b[31:16])
tmp_dst[87:80] := SaturateU8(b[47:32])
tmp_dst[95:88] := SaturateU8(b[63:48])
tmp_dst[103:96] := SaturateU8(b[79:64])
tmp_dst[111:104] := SaturateU8(b[95:80])
tmp_dst[119:112] := SaturateU8(b[111:96])
tmp_dst[127:120] := SaturateU8(b[127:112])
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPACKUSWB" form="xmm {z}, xmm, xmm" xed="VPACKUSWB_XMMu8_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDB" form="ymm {k}, ymm, ymm" xed="VPADDB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDB" form="ymm {z}, ymm, ymm" xed="VPADDB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDB" form="zmm {k}, zmm, zmm" xed="VPADDB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDB" form="zmm {z}, zmm, zmm" xed="VPADDB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDB" form="xmm {k}, xmm, xmm" xed="VPADDB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Add packed 8-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDB" form="xmm {z}, xmm, xmm" xed="VPADDB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSB" form="ymm {k}, ymm, ymm" xed="VPADDSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSB" form="ymm {z}, ymm, ymm" xed="VPADDSB_YMMi8_MASKmskw_YMMi8_YMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSB" form="zmm {k}, zmm, zmm" xed="VPADDSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSB" form="zmm {z}, zmm, zmm" xed="VPADDSB_ZMMi8_MASKmskw_ZMMi8_ZMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSB" form="xmm {k}, xmm, xmm" xed="VPADDSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Add packed signed 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSB" form="xmm {z}, xmm, xmm" xed="VPADDSB_XMMi8_MASKmskw_XMMi8_XMMi8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSW" form="ymm {k}, ymm, ymm" xed="VPADDSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDSW" form="ymm {z}, ymm, ymm" xed="VPADDSW_YMMi16_MASKmskw_YMMi16_YMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSW" form="zmm {k}, zmm, zmm" xed="VPADDSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSW" form="zmm {z}, zmm, zmm" xed="VPADDSW_ZMMi16_MASKmskw_ZMMi16_ZMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSW" form="xmm {k}, xmm, xmm" xed="VPADDSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Add packed signed 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDSW" form="xmm {z}, xmm, xmm" xed="VPADDSW_XMMi16_MASKmskw_XMMi16_XMMi16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSB" form="ymm {k}, ymm, ymm" xed="VPADDUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSB" form="ymm {z}, ymm, ymm" xed="VPADDUSB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSB" form="zmm {k}, zmm, zmm" xed="VPADDUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSB" form="zmm {z}, zmm, zmm" xed="VPADDUSB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSB" form="xmm {k}, xmm, xmm" xed="VPADDUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epu8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Add packed unsigned 8-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := SaturateU8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSB" form="xmm {z}, xmm, xmm" xed="VPADDUSB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSW" form="ymm {k}, ymm, ymm" xed="VPADDUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDUSW" form="ymm {z}, ymm, ymm" xed="VPADDUSW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSW" form="zmm {k}, zmm, zmm" xed="VPADDUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDUSW" form="zmm {z}, zmm, zmm" xed="VPADDUSW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSW" form="xmm {k}, xmm, xmm" xed="VPADDUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_adds_epu16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<description>Add packed unsigned 16-bit integers in "a" and "b" using saturation, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := SaturateU16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDUSW" form="xmm {z}, xmm, xmm" xed="VPADDUSW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDW" form="ymm {k}, ymm, ymm" xed="VPADDW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPADDW" form="ymm {z}, ymm, ymm" xed="VPADDW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDW" form="zmm {k}, zmm, zmm" xed="VPADDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDW" form="zmm {z}, zmm, zmm" xed="VPADDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDW" form="xmm {k}, xmm, xmm" xed="VPADDW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_add_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<description>Add packed 16-bit integers in "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPADDW" form="xmm {z}, xmm, xmm" xed="VPADDW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	tmp_dst[i+127:i] := tmp[127:0]
ENDFOR
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPALIGNR" form="ymm {k}, ymm, ymm, imm8" xed="VPALIGNR_YMMu8_MASKmskw_YMMu8_YMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	tmp_dst[i+127:i] := tmp[127:0]
ENDFOR
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPALIGNR" form="ymm {z}, ymm, ymm, imm8" xed="VPALIGNR_YMMu8_MASKmskw_YMMu8_YMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="5"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	dst[i+127:i] := tmp[127:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPALIGNR" form="zmm, zmm, zmm, imm8" xed="VPALIGNR_ZMMu8_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	tmp_dst[i+127:i] := tmp[127:0]
ENDFOR
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPALIGNR" form="zmm {k}, zmm, zmm, imm8" xed="VPALIGNR_ZMMu8_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*128
	tmp[255:0] := ((a[i+127:i] &lt;&lt; 128)[255:0] OR b[i+127:i]) &gt;&gt; (imm8*8)
	tmp_dst[i+127:i] := tmp[127:0]
ENDFOR
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPALIGNR" form="zmm {z}, zmm, zmm, imm8" xed="VPALIGNR_ZMMu8_MASKmskw_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[255:0] := ((a[127:0] &lt;&lt; 128)[255:0] OR b[127:0]) &gt;&gt; (imm8*8)
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPALIGNR" form="xmm {k}, xmm, xmm, imm8" xed="VPALIGNR_XMMu8_MASKmskw_XMMu8_XMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_alignr_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate pairs of 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst[255:0] := ((a[127:0] &lt;&lt; 128)[255:0] OR b[127:0]) &gt;&gt; (imm8*8)
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := tmp_dst[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPALIGNR" form="xmm {z}, xmm, xmm, imm8" xed="VPALIGNR_XMMu8_MASKmskw_XMMu8_XMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sad_epu8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce eight unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 7
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] + \
	               tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSADBW" form="zmm, zmm, zmm" xed="VPSADBW_ZMMu16_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[4:0] := b[i+3:i] + (j &amp; 0x10)
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFB" form="ymm {k}, ymm, ymm" xed="VPSHUFB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[4:0] := b[i+3:i] + (j &amp; 0x10)
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFB" form="ymm {z}, ymm, ymm" xed="VPSHUFB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Shuffle 8-bit integers in "a" within 128-bit lanes using the control in the corresponding 8-bit element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[5:0] := b[i+3:i] + (j &amp; 0x30)
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFB" form="zmm {k}, zmm, zmm" xed="VPSHUFB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[5:0] := b[i+3:i] + (j &amp; 0x30)
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFB" form="zmm {z}, zmm, zmm" xed="VPSHUFB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 63
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[5:0] := b[i+3:i] + (j &amp; 0x30)
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFB" form="zmm, zmm, zmm" xed="VPSHUFB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[3:0] := b[i+3:i]
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHUFB" form="xmm {k}, xmm, xmm" xed="VPSHUFB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shuffle_epi8">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF k[j]
		IF b[i+7] == 1
			dst[i+7:i] := 0
		ELSE
			index[3:0] := b[i+3:i]
			dst[i+7:i] := a[index*8+7:index*8]
		FI
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHUFB" form="xmm {z}, xmm, xmm" xed="VPSHUFB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_bslli_epi128">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="M128"/>
	<parameter type="__m512i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
dst[255:128] := a[255:128] &lt;&lt; (tmp*8)
dst[383:256] := a[383:256] &lt;&lt; (tmp*8)
dst[511:384] := a[511:384] &lt;&lt; (tmp*8)
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLDQ" form="zmm, zmm, imm8" xed="VPSLLDQ_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm {k}, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm {z}, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVW" form="ymm, ymm, ymm" xed="VPSLLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm {k}, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm {z}, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVW" form="zmm, zmm, zmm" xed="VPSLLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVW" form="xmm {k}, xmm, xmm" xed="VPSLLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVW" form="xmm {z}, xmm, xmm" xed="VPSLLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {k}, ymm, xmm" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {k}, ymm, imm8" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {z}, ymm, xmm" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLW" form="ymm {z}, ymm, imm8" xed="VPSLLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {k}, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {k}, zmm, imm8" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {z}, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm {z}, zmm, imm8" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLW" form="zmm, zmm, xmm" xed="VPSLLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {k}, xmm, xmm" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {k}, xmm, imm8" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {z}, xmm, xmm" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLW" form="xmm {z}, xmm, imm8" xed="VPSLLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm {k}, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm {z}, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVW" form="ymm, ymm, ymm" xed="VPSRAVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm {k}, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm {z}, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVW" form="zmm, zmm, zmm" xed="VPSRAVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm {k}, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm {z}, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srav_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0)
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVW" form="xmm, xmm, xmm" xed="VPSRAVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {k}, ymm, xmm" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {k}, ymm, imm8" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {z}, ymm, xmm" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAW" form="ymm {z}, ymm, imm8" xed="VPSRAW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {k}, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {k}, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {z}, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm {z}, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm, zmm, xmm" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAW" form="zmm, zmm, imm8" xed="VPSRAW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {k}, xmm, xmm" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {k}, xmm, imm8" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {z}, xmm, xmm" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
		ELSE
			dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAW" form="xmm {z}, xmm, imm8" xed="VPSRAW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_bsrli_epi128">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="M128"/>
	<parameter type="__m512i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 128-bit lanes in "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
dst[255:128] := a[255:128] &gt;&gt; (tmp*8)
dst[383:256] := a[383:256] &gt;&gt; (tmp*8)
dst[511:384] := a[511:384] &gt;&gt; (tmp*8)
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLDQ" form="zmm, zmm, imm8" xed="VPSRLDQ_ZMMu8_ZMMu8_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm {k}, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm {z}, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVW" form="ymm, ymm, ymm" xed="VPSRLVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm {k}, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm {z}, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[i+15:i] &lt; 16
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVW" form="zmm, zmm, zmm" xed="VPSRLVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVW" form="xmm {k}, xmm, xmm" xed="VPSRLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[i+15:i] &lt; 16
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[i+15:i])
		ELSE
			dst[i+15:i] := 0
		FI
	ELSE
		dst[i+15:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVW" form="xmm {z}, xmm, xmm" xed="VPSRLVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {k}, ymm, xmm" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {k}, ymm, imm8" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {z}, ymm, xmm" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLW" form="ymm {z}, ymm, imm8" xed="VPSRLW_YMMu16_MASKmskw_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {k}, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {k}, zmm, imm8" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {z}, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm {z}, zmm, imm8" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLW" form="zmm, zmm, xmm" xed="VPSRLW_ZMMu16_MASKmskw_ZMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {k}, xmm, xmm" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {k}, xmm, imm8" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF count[63:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {z}, xmm, xmm" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi16">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512BW</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		IF imm8[7:0] &gt; 15
			dst[i+15:i] := 0
		ELSE
			dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLW" form="xmm {z}, xmm, imm8" xed="VPSRLW_XMMu16_MASKmskw_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftli_mask64">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 64-bit mask "a" left by "count" while shifting in zeros, and store the least significant 64 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 63
	k[63:0] := a[63:0] &lt;&lt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTLQ" form="k, k, imm8" xed="KSHIFTLQ_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftri_mask32">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__mmask32" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 32-bit mask "a" right by "count" while shifting in zeros, and store the least significant 32 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 31
	k[31:0] := a[31:0] &gt;&gt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTRD" form="k, k, imm8" xed="KSHIFTRD_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftri_mask64">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 64-bit mask "a" right by "count" while shifting in zeros, and store the least significant 64 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 63
	k[63:0] := a[63:0] &gt;&gt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTRQ" form="k, k, imm8" xed="KSHIFTRQ_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestz_mask32_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="a" etype="MASK"/>
	<parameter type="__mmask32" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 32-bit masks "a" and "b". If the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[31:0] := a[31:0] OR b[31:0]
IF tmp[31:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTD" form="k, k" xed="KORTESTD_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestc_mask32_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="a" etype="MASK"/>
	<parameter type="__mmask32" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 32-bit masks "a" and "b". If the result is all ones, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[31:0] := a[31:0] OR b[31:0]
IF tmp[31:0] == 0xFFFFFFFF
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTD" form="k, k" xed="KORTESTD_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestz_mask64_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="__mmask64" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 64-bit masks "a" and "b". If the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[63:0] := a[63:0] OR b[63:0]
IF tmp[63:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTQ" form="k, k" xed="KORTESTQ_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestc_mask64_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="__mmask64" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 64-bit masks "a" and "b". If the result is all ones, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[63:0] := a[63:0] OR b[63:0]
IF tmp[63:0] == 0xFFFFFFFFFFFFFFFF
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTQ" form="k, k" xed="KORTESTQ_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestz_mask32_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="a" etype="MASK"/>
	<parameter type="__mmask32" varname="b" etype="MASK"/>
	<description>Compute the bitwise AND of 32-bit masks "a" and "b", and if the result is all zeros, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[31:0] := a[31:0] AND b[31:0]
IF tmp[31:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTD" form="k, k" xed="KTESTD_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestc_mask32_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="a" etype="MASK"/>
	<parameter type="__mmask32" varname="b" etype="MASK"/>
	<description>Compute the bitwise NOT of 32-bit mask "a" and then AND with "b", if the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[31:0] := (NOT a[31:0]) AND b[31:0]
IF tmp[31:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTD" form="k, k" xed="KTESTD_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestz_mask64_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="__mmask64" varname="b" etype="MASK"/>
	<description>Compute the bitwise AND of 64-bit masks "a" and "b", and if the result is all zeros, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[63:0] := a[63:0] AND b[63:0]
IF tmp[63:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTQ" form="k, k" xed="KTESTQ_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestc_mask64_u8">
	<type>Mask</type>
	<CPUID>AVX512BW</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="a" etype="MASK"/>
	<parameter type="__mmask64" varname="b" etype="MASK"/>
	<description>Compute the bitwise NOT of 64-bit mask "a" and then AND with "b", if the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[63:0] := (NOT a[63:0]) AND b[63:0]
IF tmp[63:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTQ" form="k, k" xed="KTESTQ_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	FOR k := 0 to j-1
		m := k*32
		dst[i+k] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
	ENDFOR
	dst[i+31:i+j] := 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="ymm, ymm" xed="VPCONFLICTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="ymm {k}, ymm" xed="VPCONFLICTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="ymm {z}, ymm" xed="VPCONFLICTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	FOR k := 0 to j-1
		m := k*32
		dst[i+k] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
	ENDFOR
	dst[i+31:i+j] := 0
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="xmm, xmm" xed="VPCONFLICTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="xmm {k}, xmm" xed="VPCONFLICTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="xmm {z}, xmm" xed="VPCONFLICTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	FOR k := 0 to j-1
		m := k*64
		dst[i+k] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
	ENDFOR
	dst[i+63:i+j] := 0
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="ymm, ymm" xed="VPCONFLICTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="ymm {k}, ymm" xed="VPCONFLICTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="ymm {z}, ymm" xed="VPCONFLICTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	FOR k := 0 to j-1
		m := k*64
		dst[i+k] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
	ENDFOR
	dst[i+63:i+j] := 0
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="xmm, xmm" xed="VPCONFLICTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="xmm {k}, xmm" xed="VPCONFLICTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="xmm {z}, xmm" xed="VPCONFLICTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	tmp := 31
	dst[i+31:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+31:i] := dst[i+31:i] + 1
	OD
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTD" form="ymm, ymm" xed="VPLZCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTD" form="ymm {k}, ymm" xed="VPLZCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTD" form="ymm {z}, ymm" xed="VPLZCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	tmp := 31
	dst[i+31:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+31:i] := dst[i+31:i] + 1
	OD
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTD" form="xmm, xmm" xed="VPLZCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTD" form="xmm {k}, xmm" xed="VPLZCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTD" form="xmm {z}, xmm" xed="VPLZCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp := 63
	dst[i+63:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+63:i] := dst[i+63:i] + 1
	OD
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="ymm, ymm" xed="VPLZCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="ymm {k}, ymm" xed="VPLZCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="ymm {z}, ymm" xed="VPLZCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp := 63
	dst[i+63:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+63:i] := dst[i+63:i] + 1
	OD
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="xmm, xmm" xed="VPLZCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="xmm {k}, xmm" xed="VPLZCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="xmm {z}, xmm" xed="VPLZCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	FOR k := 0 to j-1
		m := k*32
		dst[i+k] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
	ENDFOR
	dst[i+31:i+j] := 0
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="zmm, zmm" xed="VPCONFLICTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="zmm {k}, zmm" xed="VPCONFLICTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_conflict_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Test each 32-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR l := 0 to j-1
			m := l*32
			dst[i+l] := (a[i+31:i] == a[m+31:m]) ? 1 : 0
		ENDFOR
		dst[i+31:i+j] := 0
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTD" form="zmm {z}, zmm" xed="VPCONFLICTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit. Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	FOR k := 0 to j-1
		m := k*64
		dst[i+k] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
	ENDFOR
	dst[i+63:i+j] := 0
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="zmm, zmm" xed="VPCONFLICTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="zmm {k}, zmm" xed="VPCONFLICTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_conflict_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Compare</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Test each 64-bit element of "a" for equality with all other elements in "a" closer to the least significant bit using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). Each element's comparison forms a zero extended bit vector in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR l := 0 to j-1
			m := l*64
			dst[i+l] := (a[i+63:i] == a[m+63:m]) ? 1 : 0
		ENDFOR
		dst[i+63:i+j] := 0
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCONFLICTQ" form="zmm {z}, zmm" xed="VPCONFLICTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	tmp := 31
	dst[i+31:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+31:i] := dst[i+31:i] + 1
	OD
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTD" form="zmm, zmm" xed="VPLZCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTD" form="zmm {k}, zmm" xed="VPLZCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_lzcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Counts the number of leading zero bits in each packed 32-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp := 31
		dst[i+31:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+31:i] := dst[i+31:i] + 1
		OD
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTD" form="zmm {z}, zmm" xed="VPLZCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp := 63
	dst[i+63:i] := 0
	DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
		tmp := tmp - 1
		dst[i+63:i] := dst[i+63:i] + 1
	OD
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="zmm, zmm" xed="VPLZCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="zmm {k}, zmm" xed="VPLZCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_lzcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512CD</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Counts the number of leading zero bits in each packed 64-bit integer in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp := 63
		dst[i+63:i] := 0
		DO WHILE (tmp &gt;= 0 AND a[i+tmp] == 0)
			tmp := tmp - 1
			dst[i+63:i] := dst[i+63:i] + 1
		OD
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPLZCNTQ" form="zmm {z}, zmm" xed="VPLZCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512CD"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[255:0] := a[255:0]
1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm {k}, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti32x8_epi32">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 8 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI32X8" form="ymm {z}, zmm, imm8" xed="VEXTRACTI32X8_YMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {k}, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {z}, ymm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[1:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
2: dst[127:0] := a[383:256]
3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {k}, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti64x2_epi64">
	<type>Integer</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 2 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI64X2" form="xmm {z}, zmm, imm8" xed="VEXTRACTI64X2_XMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE imm8[0] OF
0: dst[255:0] := b[255:0]
1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm {k}, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti32x8">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 8 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X8" form="zmm {z}, zmm, ymm, imm8" xed="VINSERTI32X8_ZMMu32_MASKmskw_ZMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE imm8[0] OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm {k}, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_inserti64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="ymm {z}, ymm, xmm, imm8" xed="VINSERTI64X2_YMMu64_MASKmskw_YMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE imm8[1:0] OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
2: dst[383:256] := b[127:0]
3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm {k}, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti64x2">
	<CPUID>AVX512DQ</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 2 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X2" form="zmm {z}, zmm, xmm, imm8" xed="VINSERTI64X2_ZMMu64_MASKmskw_ZMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftli_mask8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 8-bit mask "a" left by "count" while shifting in zeros, and store the least significant 8 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 7
	k[7:0] := a[7:0] &lt;&lt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTLB" form="k, k, imm8" xed="KSHIFTLB_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftri_mask8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 8-bit mask "a" right by "count" while shifting in zeros, and store the least significant 8 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 7
	k[7:0] := a[7:0] &gt;&gt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTRB" form="k, k, imm8" xed="KSHIFTRB_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestz_mask8_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="__mmask8" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 8-bit masks "a" and "b". If the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[7:0] := a[7:0] OR b[7:0]
IF tmp[7:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTB" form="k, k" xed="KORTESTB_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestc_mask8_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="__mmask8" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 8-bit masks "a" and "b". If the result is all ones, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[7:0] := a[7:0] OR b[7:0]
IF tmp[7:0] == 0xFF
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTB" form="k, k" xed="KORTESTB_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestz_mask8_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="__mmask8" varname="b" etype="MASK"/>
	<description>Compute the bitwise AND of 8-bit masks "a" and "b", and if the result is all zeros, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[7:0] := a[7:0] AND b[7:0]
IF tmp[7:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTB" form="k, k" xed="KTESTB_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestc_mask8_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask8" varname="a" etype="MASK"/>
	<parameter type="__mmask8" varname="b" etype="MASK"/>
	<description>Compute the bitwise NOT of 8-bit mask "a" and then AND with "b", if the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[7:0] := (NOT a[7:0]) AND b[7:0]
IF tmp[7:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTB" form="k, k" xed="KTESTB_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestz_mask16_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="__mmask16" varname="b" etype="MASK"/>
	<description>Compute the bitwise AND of 16-bit masks "a" and "b", and if the result is all zeros, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[15:0] := a[15:0] AND b[15:0]
IF tmp[15:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTW" form="k, k" xed="KTESTW_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_ktestc_mask16_u8">
	<type>Mask</type>
	<CPUID>AVX512DQ</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="__mmask16" varname="b" etype="MASK"/>
	<description>Compute the bitwise NOT of 16-bit mask "a" and then AND with "b", if the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[15:0] := (NOT a[15:0]) AND b[15:0]
IF tmp[15:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KTESTW" form="k, k" xed="KTESTW_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {k}, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {z}, ymm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[255:0] := a[255:0]
CASE (imm8[0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm {k}, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_inserti32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[255:0] := a[255:0]
CASE (imm8[0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
ESAC
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="ymm {z}, ymm, xmm, imm8" xed="VINSERTI32X4_YMMu32_MASKmskw_YMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := src[255:m]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="ymm {k}, ymm" xed="VPCOMPRESSD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := 0
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="ymm {z}, ymm" xed="VPCOMPRESSD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := src[127:m]
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="xmm {k}, xmm" xed="VPCOMPRESSD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := 0
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="xmm {z}, xmm" xed="VPCOMPRESSD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := src[255:m]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="ymm {k}, ymm" xed="VPCOMPRESSQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := 0
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="ymm {z}, ymm" xed="VPCOMPRESSQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := src[127:m]
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="xmm {k}, xmm" xed="VPCOMPRESSQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := 0
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="xmm {z}, xmm" xed="VPCOMPRESSQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" across lanes lanes using the control in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
tmp_dst[63:0] := SELECT4(a[255:0], imm8[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm8[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm8[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm8[7:6])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERMQ" form="ymm {k}, ymm, imm8" xed="VPERMQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the control in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
tmp_dst[63:0] := SELECT4(a[255:0], imm8[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm8[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm8[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm8[7:6])
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERMQ" form="ymm {z}, ymm, imm8" xed="VPERMQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" across lanes using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
dst[63:0] := SELECT4(a[255:0], imm8[1:0])
dst[127:64] := SELECT4(a[255:0], imm8[3:2])
dst[191:128] := SELECT4(a[255:0], imm8[5:4])
dst[255:192] := SELECT4(a[255:0], imm8[7:6])
dst[MAX:256] := 0
	</operation>
	<instruction name="VPERMQ" form="ymm, ymm, imm8" xed="VPERMQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDD" form="ymm {k}, ymm" xed="VPEXPANDD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDD" form="ymm {z}, ymm" xed="VPEXPANDD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDD" form="xmm {k}, xmm" xed="VPEXPANDD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDD" form="xmm {z}, xmm" xed="VPEXPANDD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="ymm {k}, ymm" xed="VPEXPANDQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="ymm {z}, ymm" xed="VPEXPANDQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="xmm {k}, xmm" xed="VPEXPANDQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="xmm {z}, xmm" xed="VPEXPANDQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm {k}, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm {z}, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLD" form="ymm, ymm, imm8" xed="VPROLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm {k}, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm {z}, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLD" form="xmm, xmm, imm8" xed="VPROLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm {k}, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm {z}, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLQ" form="ymm, ymm, imm8" xed="VPROLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm {k}, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm {z}, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLQ" form="xmm, xmm, imm8" xed="VPROLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm {k}, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm {z}, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVD" form="ymm, ymm, ymm" xed="VPROLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm {k}, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm {z}, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVD" form="xmm, xmm, xmm" xed="VPROLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm {k}, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm {z}, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPROLVQ" form="ymm, ymm, ymm" xed="VPROLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm {k}, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm {z}, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPROLVQ" form="xmm, xmm, xmm" xed="VPROLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm {k}, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm {z}, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORD" form="ymm, ymm, imm8" xed="VPRORD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm {k}, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm {z}, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORD" form="xmm, xmm, imm8" xed="VPRORD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm {k}, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm {z}, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORQ" form="ymm, ymm, imm8" xed="VPRORQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm {k}, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm {z}, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORQ" form="xmm, xmm, imm8" xed="VPRORQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm {k}, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm {z}, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVD" form="ymm, ymm, ymm" xed="VPRORVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm {k}, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm {z}, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVD" form="xmm, xmm, xmm" xed="VPRORVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm {k}, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm {z}, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPRORVQ" form="ymm, ymm, ymm" xed="VPRORVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm {k}, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm {z}, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPRORVQ" form="xmm, xmm, xmm" xed="VPRORVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm8[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm8[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm8[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm8[7:6])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFD" form="ymm {k}, ymm, imm8" xed="VPSHUFD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm8[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm8[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm8[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm8[7:6])
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHUFD" form="ymm {z}, ymm, imm8" xed="VPSHUFD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" using the control in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHUFD" form="xmm {k}, xmm, imm8" xed="VPSHUFD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" using the control in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHUFD" form="xmm {z}, xmm, imm8" xed="VPSHUFD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {k}, ymm, xmm" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {k}, ymm, imm8" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {z}, ymm, xmm" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLD" form="ymm {z}, ymm, imm8" xed="VPSLLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {k}, xmm, xmm" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {k}, xmm, imm8" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {z}, xmm, xmm" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLD" form="xmm {z}, xmm, imm8" xed="VPSLLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {k}, ymm, xmm" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {k}, ymm, imm8" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {z}, ymm, xmm" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLQ" form="ymm {z}, ymm, imm8" xed="VPSLLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {k}, xmm, xmm" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {k}, xmm, imm8" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {z}, xmm, xmm" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLQ" form="xmm {z}, xmm, imm8" xed="VPSLLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm {k}, ymm, ymm" xed="VPSLLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVD" form="ymm {z}, ymm, ymm" xed="VPSLLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm {k}, xmm, xmm" xed="VPSLLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVD" form="xmm {z}, xmm, xmm" xed="VPSLLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm {k}, ymm, ymm" xed="VPSLLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSLLVQ" form="ymm {z}, ymm, ymm" xed="VPSLLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm {k}, xmm, xmm" xed="VPSLLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSLLVQ" form="xmm {z}, xmm, xmm" xed="VPSLLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {k}, ymm, xmm" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {k}, ymm, imm8" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {z}, ymm, xmm" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAD" form="ymm {z}, ymm, imm8" xed="VPSRAD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {k}, xmm, xmm" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {k}, xmm, imm8" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {z}, xmm, xmm" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="6"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAD" form="xmm {z}, xmm, imm8" xed="VPSRAD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {k}, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {k}, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {z}, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm {z}, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm, ymm, xmm" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAQ" form="ymm, ymm, imm8" xed="VPSRAQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {k}, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {k}, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {z}, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="7"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm {z}, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm, xmm, xmm" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="7"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAQ" form="xmm, xmm, imm8" xed="VPSRAQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm {k}, ymm, ymm" xed="VPSRAVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVD" form="ymm {z}, ymm, ymm" xed="VPSRAVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm {k}, xmm, xmm" xed="VPSRAVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVD" form="xmm {z}, xmm, xmm" xed="VPSRAVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm {k}, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm {z}, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="SI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRAVQ" form="ymm, ymm, ymm" xed="VPSRAVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm {k}, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm {z}, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="SI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRAVQ" form="xmm, xmm, xmm" xed="VPSRAVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {k}, ymm, xmm" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {k}, ymm, imm8" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {z}, ymm, xmm" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLD" form="ymm {z}, ymm, imm8" xed="VPSRLD_YMMu32_MASKmskw_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {k}, xmm, xmm" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {k}, xmm, imm8" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {z}, xmm, xmm" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLD" form="xmm {z}, xmm, imm8" xed="VPSRLD_XMMu32_MASKmskw_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {k}, ymm, xmm" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {k}, ymm, imm8" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {z}, ymm, xmm" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLQ" form="ymm {z}, ymm, imm8" xed="VPSRLQ_YMMu64_MASKmskw_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {k}, xmm, xmm" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {k}, xmm, imm8" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {z}, xmm, xmm" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLQ" form="xmm {z}, xmm, imm8" xed="VPSRLQ_XMMu64_MASKmskw_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm {k}, ymm, ymm" xed="VPSRLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVD" form="ymm {z}, ymm, ymm" xed="VPSRLVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm {k}, xmm, xmm" xed="VPSRLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVD" form="xmm {z}, xmm, xmm" xed="VPSRLVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm {k}, ymm, ymm" xed="VPSRLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSRLVQ" form="ymm {z}, ymm, ymm" xed="VPSRLVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm {k}, xmm, xmm" xed="VPSRLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSRLVQ" form="xmm {z}, xmm, xmm" xed="VPSRLVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 32-bit granularity (32-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="ymm {k}, ymm, ymm, imm8" xed="VPTERNLOGD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="ymm {z}, ymm, ymm, imm8" xed="VPTERNLOGD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	FOR h := 0 to 31
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="ymm, ymm, ymm, imm8" xed="VPTERNLOGD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 32-bit granularity (32-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="xmm {k}, xmm, xmm, imm8" xed="VPTERNLOGD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="xmm {z}, xmm, xmm, imm8" xed="VPTERNLOGD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	FOR h := 0 to 31
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="xmm, xmm, xmm, imm8" xed="VPTERNLOGD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 64-bit granularity (64-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="ymm {k}, ymm, ymm, imm8" xed="VPTERNLOGQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="ymm {z}, ymm, ymm, imm8" xed="VPTERNLOGQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	FOR h := 0 to 63
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="ymm, ymm, ymm, imm8" xed="VPTERNLOGQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 64-bit granularity (64-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="xmm {k}, xmm, xmm, imm8" xed="VPTERNLOGQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="xmm {z}, xmm, xmm, imm8" xed="VPTERNLOGQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	FOR h := 0 to 63
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="xmm, xmm, xmm, imm8" xed="VPTERNLOGQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shuffle_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst.m128[0] := a.m128[imm8[0]]
tmp_dst.m128[1] := b.m128[imm8[1]]
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="ymm {k}, ymm, ymm, imm8" xed="VSHUFI32X4_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shuffle_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst.m128[0] := a.m128[imm8[0]]
tmp_dst.m128[1] := b.m128[imm8[1]]
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="ymm {z}, ymm, ymm, imm8" xed="VSHUFI32X4_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shuffle_i32x4">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
dst.m128[0] := a.m128[imm8[0]]
dst.m128[1] := b.m128[imm8[1]]
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="ymm, ymm, ymm, imm8" xed="VSHUFI32X4_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shuffle_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst.m128[0] := a.m128[imm8[0]]
tmp_dst.m128[1] := b.m128[imm8[1]]
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="ymm {k}, ymm, ymm, imm8" xed="VSHUFI64X2_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shuffle_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp_dst.m128[0] := a.m128[imm8[0]]
tmp_dst.m128[1] := b.m128[imm8[1]]
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="ymm {z}, ymm, ymm, imm8" xed="VSHUFI64X2_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shuffle_i64x2">
	<CPUID>AVX512VL</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
dst.m128[0] := a.m128[imm8[0]]
dst.m128[1] := b.m128[imm8[1]]
dst[MAX:256] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="ymm, ymm, ymm, imm8" xed="VSHUFI64X2_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftli_mask16">
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Mask</category>
	<return type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 16-bit mask "a" left by "count" while shifting in zeros, and store the least significant 16 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 15
	k[15:0] := a[15:0] &lt;&lt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTLW" form="k, k, imm8" xed="KSHIFTLW_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kshiftri_mask16">
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Mask</category>
	<return type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="unsigned int" varname="count" etype="IMM" immwidth="8"/>
	<description>Shift the bits of 16-bit mask "a" right by "count" while shifting in zeros, and store the least significant 16 bits of the result in "k".</description>
	<operation>
k[MAX:0] := 0
IF count[7:0] &lt;= 15
	k[15:0] := a[15:0] &gt;&gt; count[7:0]
FI
	</operation>
	<instruction name="KSHIFTRW" form="k, k, imm8" xed="KSHIFTRW_MASKmskw_MASKmskw_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestz_mask16_u8">
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="__mmask16" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 16-bit masks "a" and "b". If the result is all zeroes, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[15:0] := a[15:0] OR b[15:0]
IF tmp[15:0] == 0x0
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTW" form="k, k" xed="KORTESTW_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_kortestc_mask16_u8">
	<type>Mask</type>
	<CPUID>AVX512F</CPUID>
	<category>Mask</category>
	<return type="unsigned char" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="a" etype="MASK"/>
	<parameter type="__mmask16" varname="b" etype="MASK"/>
	<description>Compute the bitwise OR of 16-bit masks "a" and "b". If the result is all ones, store 1 in "dst", otherwise store 0 in "dst".</description>
	<operation>
tmp[15:0] := a[15:0] OR b[15:0]
IF tmp[15:0] == 0xFFFF
	dst := 1
ELSE
	dst := 0
FI
	</operation>
	<instruction name="KORTESTW" form="k, k" xed="KORTESTW_MASKmskw_MASKmskw_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_alignr_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "imm8" 32-bit elements, and stores the low 64 bytes (16 elements) in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (32*imm8[3:0])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := temp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VALIGND" form="zmm {z}, zmm, zmm, imm8" xed="VALIGND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_alignr_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="3"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "imm8" 64-bit elements, and store the low 64 bytes (8 elements) in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (64*imm8[2:0])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := temp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VALIGNQ" form="zmm {k}, zmm, zmm, imm8" xed="VALIGNQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_alignr_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="3"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "imm8" 64-bit elements, and stores the low 64 bytes (8 elements) in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (64*imm8[2:0])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := temp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VALIGNQ" form="zmm {z}, zmm, zmm, imm8" xed="VALIGNQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="zmm {k}, m128" xed="VBROADCASTI32X4_ZMMu32_MASKmskw_MEMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcast_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Broadcast the 4 packed 32-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	n := (j % 4)*32
	IF k[j]
		dst[i+31:i] := a[n+31:n]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI32X4" form="zmm {z}, m128" xed="VBROADCASTI32X4_ZMMu32_MASKmskw_MEMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X4" form="zmm {k}, m256" xed="VBROADCASTI64X4_ZMMu64_MASKmskw_MEMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_broadcast_i64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Broadcast the 4 packed 64-bit integers from "a" to all elements of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	n := (j % 4)*64
	IF k[j]
		dst[i+63:i] := a[n+63:n]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VBROADCASTI64X4" form="zmm {z}, m256" xed="VBROADCASTI64X4_ZMMu64_MASKmskw_MEMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[1:0] OF
0: dst[127:0] := a[127:0]
1: dst[127:0] := a[255:128]
2: dst[127:0] := a[383:256]
3: dst[127:0] := a[511:384]
ESAC
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {k}, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti32x4_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract 128 bits (composed of 4 packed 32-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[1:0] OF
0: tmp[127:0] := a[127:0]
1: tmp[127:0] := a[255:128]
2: tmp[127:0] := a[383:256]
3: tmp[127:0] := a[511:384]
ESAC
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VEXTRACTI32X4" form="xmm {z}, zmm, imm8" xed="VEXTRACTI32X4_XMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
CASE imm8[0] OF
0: dst[255:0] := a[255:0]
1: dst[255:0] := a[511:256]
ESAC
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm {k}, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_extracti64x4_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract 256 bits (composed of 4 packed 64-bit integers) from "a", selected with "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
CASE imm8[0] OF
0: tmp[255:0] := a[255:0]
1: tmp[255:0] := a[511:256]
ESAC
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VEXTRACTI64X4" form="ymm {z}, zmm, imm8" xed="VEXTRACTI64X4_YMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "dst", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: dst[127:0] := b[127:0]
1: dst[255:128] := b[127:0]
2: dst[383:256] := b[127:0]
3: dst[511:384] := b[127:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm {k}, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Copy "a" to "tmp", then insert 128 bits (composed of 4 packed 32-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[1:0]) OF
0: tmp[127:0] := b[127:0]
1: tmp[255:128] := b[127:0]
2: tmp[383:256] := b[127:0]
3: tmp[511:384] := b[127:0]
ESAC
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI32X4" form="zmm {z}, zmm, xmm, imm8" xed="VINSERTI32X4_ZMMu32_MASKmskw_ZMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "dst", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "dst" at the location specified by "imm8".</description>
	<operation>
dst[511:0] := a[511:0]
CASE (imm8[0]) OF
0: dst[255:0] := b[255:0]
1: dst[511:256] := b[255:0]
ESAC
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm {k}, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_inserti64x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Copy "a" to "tmp", then insert 256 bits (composed of 4 packed 64-bit integers) from "b" into "tmp" at the location specified by "imm8".  Store "tmp" to "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
tmp[511:0] := a[511:0]
CASE (imm8[0]) OF
0: tmp[255:0] := b[255:0]
1: tmp[511:256] := b[255:0]
ESAC
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VINSERTI64X4" form="zmm {z}, zmm, ymm, imm8" xed="VINSERTI64X4_ZMMu64_MASKmskw_ZMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="zmm {k}, zmm" xed="VPCOMPRESSD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_compress_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Contiguously store the active 32-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 32
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[m+size-1:m] := a[i+31:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSD" form="zmm {z}, zmm" xed="VPCOMPRESSD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="zmm {k}, zmm" xed="VPCOMPRESSQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_compress_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Contiguously store the active 64-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 64
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[m+size-1:m] := a[i+63:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSQ" form="zmm {z}, zmm" xed="VPCOMPRESSQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
tmp_dst[63:0] := SELECT4(a[255:0], imm8[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm8[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm8[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm8[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm8[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm8[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm8[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm8[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPERMQ" form="zmm {k}, zmm, imm8" xed="VPERMQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
tmp_dst[63:0] := SELECT4(a[255:0], imm8[1:0])
tmp_dst[127:64] := SELECT4(a[255:0], imm8[3:2])
tmp_dst[191:128] := SELECT4(a[255:0], imm8[5:4])
tmp_dst[255:192] := SELECT4(a[255:0], imm8[7:6])
tmp_dst[319:256] := SELECT4(a[511:256], imm8[1:0])
tmp_dst[383:320] := SELECT4(a[511:256], imm8[3:2])
tmp_dst[447:384] := SELECT4(a[511:256], imm8[5:4])
tmp_dst[511:448] := SELECT4(a[511:256], imm8[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPERMQ" form="zmm {z}, zmm, imm8" xed="VPERMQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_permutex_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 64-bit integers in "a" within 256-bit lanes using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[63:0] := src[63:0]
	1:	tmp[63:0] := src[127:64]
	2:	tmp[63:0] := src[191:128]
	3:	tmp[63:0] := src[255:192]
	ESAC
	RETURN tmp[63:0]
}
dst[63:0] := SELECT4(a[255:0], imm8[1:0])
dst[127:64] := SELECT4(a[255:0], imm8[3:2])
dst[191:128] := SELECT4(a[255:0], imm8[5:4])
dst[255:192] := SELECT4(a[255:0], imm8[7:6])
dst[319:256] := SELECT4(a[511:256], imm8[1:0])
dst[383:320] := SELECT4(a[511:256], imm8[3:2])
dst[447:384] := SELECT4(a[511:256], imm8[5:4])
dst[511:448] := SELECT4(a[511:256], imm8[7:6])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPERMQ" form="zmm, zmm, imm8" xed="VPERMQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDD" form="zmm {k}, zmm" xed="VPEXPANDD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_expand_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Load contiguous active 32-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[m+31:m]
		m := m + 32
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDD" form="zmm {z}, zmm" xed="VPEXPANDD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="zmm {k}, zmm" xed="VPEXPANDQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_expand_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Load contiguous active 64-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[m+63:m]
		m := m + 64
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDQ" form="zmm {z}, zmm" xed="VPEXPANDQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm {k}, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm {z}, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rol_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLD" form="zmm, zmm, imm8" xed="VPROLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm {k}, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm {z}, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rol_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLQ" form="zmm, zmm, imm8" xed="VPROLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm {k}, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm {z}, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rolv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := LEFT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVD" form="zmm, zmm, zmm" xed="VPROLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm {k}, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm {z}, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rolv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the left by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE LEFT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &lt;&lt; count) OR (src &gt;&gt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := LEFT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPROLVQ" form="zmm, zmm, zmm" xed="VPROLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm {k}, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm {z}, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ror_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORD" form="zmm, zmm, imm8" xed="VPRORD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm {k}, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm {z}, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ror_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], imm8[7:0])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORQ" form="zmm, zmm, imm8" xed="VPRORQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm {k}, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm {z}, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rorv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Rotate the bits in each packed 32-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_DWORDS(src, count_src) {
	count := count_src % 32
	RETURN (src &gt;&gt;count) OR (src &lt;&lt; (32 - count))
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := RIGHT_ROTATE_DWORDS(a[i+31:i], b[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVD" form="zmm, zmm, zmm" xed="VPRORVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm {k}, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm {z}, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_rorv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Rotate the bits in each packed 64-bit integer in "a" to the right by the number of bits specified in the corresponding element of "b", and store the results in "dst".</description>
	<operation>
DEFINE RIGHT_ROTATE_QWORDS(src, count_src) {
	count := count_src % 64
	RETURN (src &gt;&gt; count) OR (src &lt;&lt; (64 - count))
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := RIGHT_ROTATE_QWORDS(a[i+63:i], b[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPRORVQ" form="zmm, zmm, zmm" xed="VPRORVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm8[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm8[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm8[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm8[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm8[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm8[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm8[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm8[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm8[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm8[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm8[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm8[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFD" form="zmm {z}, zmm, imm8" xed="VPSHUFD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {k}, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {z}, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {z}, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm, zmm, xmm" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {k}, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {k}, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {z}, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm {z}, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sll_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm, zmm, xmm" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_slli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLQ" form="zmm, zmm, imm8" xed="VPSLLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm {z}, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm {k}, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm {z}, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sllv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVQ" form="zmm, zmm, zmm" xed="VPSLLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {k}, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {z}, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {z}, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm, zmm, xmm" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {k}, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {k}, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {z}, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
		ELSE
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm {z}, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_sra_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm, zmm, xmm" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srai_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0x0)
	ELSE
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAQ" form="zmm, zmm, imm8" xed="VPSRAQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm {z}, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm {k}, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm {z}, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srav_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="SI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := SignExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := (a[i+63] ? 0xFFFFFFFFFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVQ" form="zmm, zmm, zmm" xed="VPSRAVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {k}, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[63:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {z}, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {z}, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm, zmm, xmm" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {k}, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {k}, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[63:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {z}, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF imm8[7:0] &gt; 63
			dst[i+63:i] := 0
		ELSE
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm {z}, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srl_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm, zmm, xmm" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srli_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLQ" form="zmm, zmm, imm8" xed="VPSRLQ_ZMMu64_MASKmskw_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm {z}, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm {k}, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		IF count[i+63:i] &lt; 64
			dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
		ELSE
			dst[i+63:i] := 0
		FI
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm {z}, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_srlv_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF count[i+63:i] &lt; 64
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVQ" form="zmm, zmm, zmm" xed="VPSRLVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Subtract packed 32-bit integers in "b" from packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] - b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBD" form="zmm {z}, zmm, zmm" xed="VPSUBD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBQ" form="zmm {k}, zmm, zmm" xed="VPSUBQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_sub_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<description>Subtract packed 64-bit integers in "b" from packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] - b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSUBQ" form="zmm {z}, zmm, zmm" xed="VPSUBQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 32-bit granularity (32-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="zmm {k}, zmm, zmm, imm8" xed="VPTERNLOGD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 32-bit granularity (32-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		FOR h := 0 to 31
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="zmm {z}, zmm, zmm, imm8" xed="VPTERNLOGD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ternarylogic_epi32">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 32-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	FOR h := 0 to 31
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGD" form="zmm, zmm, zmm, imm8" xed="VPTERNLOGD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "src", "a", and "b" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using writemask "k" at 64-bit granularity (64-bit elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (src[i+h] &lt;&lt; 2) OR (a[i+h] &lt;&lt; 1) OR b[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="zmm {k}, zmm, zmm, imm8" xed="VPTERNLOGQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst" using zeromask "k" at 64-bit granularity (64-bit elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		FOR h := 0 to 63
			index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
			dst[i+h] := imm8[index[2:0]]
		ENDFOR
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="zmm {z}, zmm, zmm, imm8" xed="VPTERNLOGQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_ternarylogic_epi64">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Logical</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Bitwise ternary logic that provides the capability to implement any three-operand binary function; the specific binary function is specified by value in "imm8". For each bit in each packed 64-bit integer, the corresponding bit from "a", "b", and "c" are used to form a 3 bit index into "imm8", and the value at that bit in "imm8" is written to the corresponding bit in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	FOR h := 0 to 63
		index[2:0] := (a[i+h] &lt;&lt; 2) OR (b[i+h] &lt;&lt; 1) OR c[i+h]
		dst[i+h] := imm8[index[2:0]]
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPTERNLOGQ" form="zmm, zmm, zmm, imm8" xed="VPTERNLOGQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
tmp_dst[127:0] := SELECT4(a[511:0], imm8[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm8[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm8[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm8[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="zmm {k}, zmm, zmm, imm8" xed="VSHUFI32X4_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
tmp_dst[127:0] := SELECT4(a[511:0], imm8[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm8[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm8[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm8[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="zmm {z}, zmm, zmm, imm8" xed="VSHUFI32X4_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shuffle_i32x4">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 4 32-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[511:0], imm8[1:0])
dst[255:128] := SELECT4(a[511:0], imm8[3:2])
dst[383:256] := SELECT4(b[511:0], imm8[5:4])
dst[511:384] := SELECT4(b[511:0], imm8[7:6])
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI32X4" form="zmm, zmm, zmm, imm8" xed="VSHUFI32X4_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
tmp_dst[127:0] := SELECT4(a[511:0], imm8[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm8[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm8[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm8[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="zmm {k}, zmm, zmm, imm8" xed="VSHUFI64X2_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
tmp_dst[127:0] := SELECT4(a[511:0], imm8[1:0])
tmp_dst[255:128] := SELECT4(a[511:0], imm8[3:2])
tmp_dst[383:256] := SELECT4(b[511:0], imm8[5:4])
tmp_dst[511:384] := SELECT4(b[511:0], imm8[7:6])
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := tmp_dst[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="zmm {z}, zmm, zmm, imm8" xed="VSHUFI64X2_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shuffle_i64x2">
	<type>Integer</type>
	<CPUID>AVX512F</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 128-bits (composed of 2 64-bit integers) selected by "imm8" from "a" and "b", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[127:0] := src[127:0]
	1:	tmp[127:0] := src[255:128]
	2:	tmp[127:0] := src[383:256]
	3:	tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
dst[127:0] := SELECT4(a[511:0], imm8[1:0])
dst[255:128] := SELECT4(a[511:0], imm8[3:2])
dst[383:256] := SELECT4(b[511:0], imm8[5:4])
dst[511:384] := SELECT4(b[511:0], imm8[7:6])
dst[MAX:512] := 0
	</operation>
	<instruction name="VSHUFI64X2" form="zmm, zmm, zmm, imm8" xed="VSHUFI64X2_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_alignr_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Miscellaneous</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4"/>
	<description>Concatenate "a" and "b" into a 128-byte immediate result, shift the result right by "imm8" 32-bit elements, and store the low 64 bytes (16 elements) in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
temp[1023:512] := a[511:0]
temp[511:0] := b[511:0]
temp[1023:0] := temp[1023:0] &gt;&gt; (32*imm8[3:0])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := temp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VALIGND" form="zmm {k}, zmm, zmm, imm8" xed="VALIGND_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
tmp_dst[31:0] := SELECT4(a[127:0], imm8[1:0])
tmp_dst[63:32] := SELECT4(a[127:0], imm8[3:2])
tmp_dst[95:64] := SELECT4(a[127:0], imm8[5:4])
tmp_dst[127:96] := SELECT4(a[127:0], imm8[7:6])
tmp_dst[159:128] := SELECT4(a[255:128], imm8[1:0])
tmp_dst[191:160] := SELECT4(a[255:128], imm8[3:2])
tmp_dst[223:192] := SELECT4(a[255:128], imm8[5:4])
tmp_dst[255:224] := SELECT4(a[255:128], imm8[7:6])
tmp_dst[287:256] := SELECT4(a[383:256], imm8[1:0])
tmp_dst[319:288] := SELECT4(a[383:256], imm8[3:2])
tmp_dst[351:320] := SELECT4(a[383:256], imm8[5:4])
tmp_dst[383:352] := SELECT4(a[383:256], imm8[7:6])
tmp_dst[415:384] := SELECT4(a[511:384], imm8[1:0])
tmp_dst[447:416] := SELECT4(a[511:384], imm8[3:2])
tmp_dst[479:448] := SELECT4(a[511:384], imm8[5:4])
tmp_dst[511:480] := SELECT4(a[511:384], imm8[7:6])
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := tmp_dst[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFD" form="zmm {k}, zmm, imm8" xed="VPSHUFD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_shuffle_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Shuffle 32-bit integers in "a" within 128-bit lanes using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
dst[159:128] := SELECT4(a[255:128], imm8[1:0])
dst[191:160] := SELECT4(a[255:128], imm8[3:2])
dst[223:192] := SELECT4(a[255:128], imm8[5:4])
dst[255:224] := SELECT4(a[255:128], imm8[7:6])
dst[287:256] := SELECT4(a[383:256], imm8[1:0])
dst[319:288] := SELECT4(a[383:256], imm8[3:2])
dst[351:320] := SELECT4(a[383:256], imm8[5:4])
dst[383:352] := SELECT4(a[383:256], imm8[7:6])
dst[415:384] := SELECT4(a[511:384], imm8[1:0])
dst[447:416] := SELECT4(a[511:384], imm8[3:2])
dst[479:448] := SELECT4(a[511:384], imm8[5:4])
dst[511:480] := SELECT4(a[511:384], imm8[7:6])
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHUFD" form="zmm, zmm, imm8" xed="VPSHUFD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm {k}, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_slli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLD" form="zmm, zmm, imm8" xed="VPSLLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm {k}, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_sllv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSLLVD" form="zmm, zmm, zmm" xed="VPSLLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
		ELSE
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm {k}, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srai_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="6"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAD" form="zmm, zmm, imm8" xed="VPSRAD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm {k}, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srav_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="SI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0)
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRAVD" form="zmm, zmm, zmm" xed="VPSRAVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF imm8[7:0] &gt; 31
			dst[i+31:i] := 0
		ELSE
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm {k}, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srli_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLD" form="zmm, zmm, imm8" xed="VPSRLD_ZMMu32_MASKmskw_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_mask_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		IF count[i+31:i] &lt; 32
			dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
		ELSE
			dst[i+31:i] := 0
		FI
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI	
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm {k}, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512/KNC" name="_mm512_srlv_epi32">
	<type>Integer</type>
	<CPUID>AVX512F/KNCNI</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by the amount specified by the corresponding element in "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF count[i+31:i] &lt; 32
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSRLVD" form="zmm, zmm, zmm" xed="VPSRLVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="ymm {z}, ymm" xed="VPOPCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="ymm {k}, ymm" xed="VPOPCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := POPCNT(a[i+63:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="ymm, ymm" xed="VPOPCNTQ_YMMu64_MASKmskw_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="xmm {z}, xmm" xed="VPOPCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="xmm {k}, xmm" xed="VPOPCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := POPCNT(a[i+63:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="xmm, xmm" xed="VPOPCNTQ_XMMu64_MASKmskw_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := POPCNT(a[i+31:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTD" form="ymm, ymm" xed="VPOPCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_mask_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTD" form="ymm {k}, ymm" xed="VPOPCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_maskz_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTD" form="ymm {z}, ymm" xed="VPOPCNTD_YMMu32_MASKmskw_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := POPCNT(a[i+31:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTD" form="xmm, xmm" xed="VPOPCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_mask_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTD" form="xmm {k}, xmm" xed="VPOPCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_maskz_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTD" form="xmm {z}, xmm" xed="VPOPCNTD_XMMu32_MASKmskw_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := POPCNT(a[i+31:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTD" form="zmm, zmm" xed="VPOPCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_mask_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTD" form="zmm {k}, zmm" xed="VPOPCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_maskz_popcnt_epi32">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<description>Count the number of logical 1 bits in packed 32-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := POPCNT(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTD" form="zmm {z}, zmm" xed="VPOPCNTD_ZMMu32_MASKmskw_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := POPCNT(a[i+63:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="zmm, zmm" xed="VPOPCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_mask_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="zmm {k}, zmm" xed="VPOPCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_maskz_popcnt_epi64">
	<type>Integer</type>
	<CPUID>AVX512VPOPCNTDQ</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<description>Count the number of logical 1 bits in packed 64-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := POPCNT(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTQ" form="zmm {z}, zmm" xed="VPOPCNTQ_ZMMu64_MASKmskw_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask64" varname="dst" etype="MASK"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 7 //Qword
	FOR j := 0 to 7 // Byte
		IF k[i*8+j]
			m := c.qword[i].byte[j] &amp; 0x3F
			dst[i*8+j] := b.qword[i].bit[m]
		ELSE
			dst[i*8+j] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k {k}, zmm, zmm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_ZMMu64_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask64" varname="dst" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst".</description>
	<operation>
FOR i := 0 to 7 //Qword
	FOR j := 0 to 7 // Byte
		m := c.qword[i].byte[j] &amp; 0x3F
		dst[i*8+j] := b.qword[i].bit[m]
	ENDFOR
ENDFOR
dst[MAX:64] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k, zmm, zmm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_ZMMu64_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask32" varname="dst" etype="MASK"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 3 //Qword
	FOR j := 0 to 7 // Byte
		IF k[i*8+j]
			m := c.qword[i].byte[j] &amp; 0x3F
			dst[i*8+j] := b.qword[i].bit[m]
		ELSE
			dst[i*8+j] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k {k}, ymm, ymm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_YMMu64_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask32" varname="dst" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst".</description>
	<operation>
FOR i := 0 to 3 //Qword
	FOR j := 0 to 7 // Byte
		m := c.qword[i].byte[j] &amp; 0x3F
		dst[i*8+j] := b.qword[i].bit[m]
	ENDFOR
ENDFOR
dst[MAX:32] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k, ymm, ymm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_YMMu64_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask16" varname="dst" etype="MASK"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 1 //Qword
	FOR j := 0 to 7 // Byte
		IF k[i*8+j]
			m := c.qword[i].byte[j] &amp; 0x3F
			dst[i*8+j] := b.qword[i].bit[m]
		ELSE
			dst[i*8+j] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k {k}, xmm, xmm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_XMMu64_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_bitshuffle_epi64_mask">
	<type>Integer</type>
	<type>Mask</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__mmask16" varname="dst" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Gather 64 bits from "b" using selection bits in "c". For each 64-bit element in "b", gather 8 bits from the 64-bit element in "b" at 8 bit position controlled by the 8 corresponding 8-bit elements of "c", and store the result in the corresponding 8-bit element of "dst".</description>
	<operation>
FOR i := 0 to 1 //Qword
	FOR j := 0 to 7 // Byte
		m := c.qword[i].byte[j] &amp; 0x3F
		dst[i*8+j] := b.qword[i].bit[m]
	ENDFOR
ENDFOR
dst[MAX:16] := 0
	</operation>
	<instruction name="VPSHUFBITQMB" form="k, xmm, xmm" xed="VPSHUFBITQMB_MASKmskw_MASKmskw_XMMu64_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := POPCNT(a[i+15:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTW" form="zmm, zmm" xed="VPOPCNTW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_mask_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTW" form="zmm {k}, zmm" xed="VPOPCNTW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_maskz_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTW" form="zmm {z}, zmm" xed="VPOPCNTW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := POPCNT(a[i+15:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTW" form="ymm, ymm" xed="VPOPCNTW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_mask_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTW" form="ymm {k}, ymm" xed="VPOPCNTW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_maskz_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTW" form="ymm {z}, ymm" xed="VPOPCNTW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := POPCNT(a[i+15:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTW" form="xmm, xmm" xed="VPOPCNTW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_mask_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTW" form="xmm {k}, xmm" xed="VPOPCNTW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_maskz_popcnt_epi16">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Count the number of logical 1 bits in packed 16-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := POPCNT(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTW" form="xmm {z}, xmm" xed="VPOPCNTW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := POPCNT(a[i+7:i])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTB" form="zmm, zmm" xed="VPOPCNTB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_mask_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTB" form="zmm {k}, zmm" xed="VPOPCNTB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm512_maskz_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPOPCNTB" form="zmm {z}, zmm" xed="VPOPCNTB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := POPCNT(a[i+7:i])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTB" form="ymm, ymm" xed="VPOPCNTB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_mask_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTB" form="ymm {k}, ymm" xed="VPOPCNTB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm256_maskz_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPOPCNTB" form="ymm {z}, ymm" xed="VPOPCNTB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst".</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := POPCNT(a[i+7:i])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTB" form="xmm, xmm" xed="VPOPCNTB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_mask_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTB" form="xmm {k}, xmm" xed="VPOPCNTB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" vexEq="TRUE" name="_mm_maskz_popcnt_epi8">
	<type>Integer</type>
	<CPUID>AVX512_BITALG</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Count the number of logical 1 bits in packed 8-bit integers in "a", and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
DEFINE POPCNT(a) {
	count := 0
	DO WHILE a &gt; 0
		count += a[0]
		a &gt;&gt;= 1
	OD
	RETURN count
}
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := POPCNT(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPOPCNTB" form="xmm {z}, xmm" xed="VPOPCNTB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst".</description>
	<operation>
FOR i := 0 to 7
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		dst[q+j*8+7:q+j*8] := tmp8[7:0]
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="zmm, zmm, zmm" xed="VPMULTISHIFTQB_ZMMu8_MASKmskw_ZMMu8_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 7
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := src[q+j*8+7:q+j*8]
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="zmm {k}, zmm, zmm" xed="VPMULTISHIFTQB_ZMMu8_MASKmskw_ZMMu8_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 7
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="zmm {z}, zmm, zmm" xed="VPMULTISHIFTQB_ZMMu8_MASKmskw_ZMMu8_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst".</description>
	<operation>
FOR i := 0 to 3
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		dst[q+j*8+7:q+j*8] := tmp8[7:0]
	ENDFOR
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="ymm, ymm, ymm" xed="VPMULTISHIFTQB_YMMu8_MASKmskw_YMMu8_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 3
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := src[q+j*8+7:q+j*8]
		FI
	ENDFOR
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="ymm {k}, ymm, ymm" xed="VPMULTISHIFTQB_YMMu8_MASKmskw_YMMu8_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 3
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="ymm {z}, ymm, ymm" xed="VPMULTISHIFTQB_YMMu8_MASKmskw_YMMu8_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst".</description>
	<operation>
FOR i := 0 to 1
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		dst[q+j*8+7:q+j*8] := tmp8[7:0]
	ENDFOR
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="xmm, xmm, xmm" xed="VPMULTISHIFTQB_XMMu8_MASKmskw_XMMu8_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 1
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := src[q+j*8+7:q+j*8]
		FI
	ENDFOR
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="xmm {k}, xmm, xmm" xed="VPMULTISHIFTQB_XMMu8_MASKmskw_XMMu8_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_multishift_epi64_epi8">
	<CPUID>AVX512_VBMI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Bit Manipulation</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>For each 64-bit element in "b", select 8 unaligned bytes using a byte-granular shift control within the corresponding 64-bit element of "a", and store the 8 assembled bytes to the corresponding 64-bit element of "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR i := 0 to 1
	q := i * 64
	FOR j := 0 to 7
		tmp8 := 0
		ctrl := a[q+j*8+7:q+j*8] &amp; 63
		FOR l := 0 to 7
			tmp8[l] := b[q+((ctrl+l) &amp; 63)]
		ENDFOR
		IF k[i*8+j]
			dst[q+j*8+7:q+j*8] := tmp8[7:0]
		ELSE
			dst[q+j*8+7:q+j*8] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPMULTISHIFTQB" form="xmm {z}, xmm, xmm" xed="VPMULTISHIFTQB_XMMu8_MASKmskw_XMMu8_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="zmm {z}, zmm, zmm" xed="VPSHRDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="zmm {k}, zmm, zmm" xed="VPSHRDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="zmm, zmm, zmm" xed="VPSHRDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="ymm {z}, ymm, ymm" xed="VPSHRDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="ymm {k}, ymm, ymm" xed="VPSHRDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="ymm, ymm, ymm" xed="VPSHRDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="xmm {z}, xmm, xmm" xed="VPSHRDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="xmm {k}, xmm, xmm" xed="VPSHRDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; (c[i+63:i] &amp; 63)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVQ" form="xmm, xmm, xmm" xed="VPSHRDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVD" form="zmm {z}, zmm, zmm" xed="VPSHRDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVD" form="zmm {k}, zmm, zmm" xed="VPSHRDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVD" form="zmm, zmm, zmm" xed="VPSHRDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVD" form="ymm {z}, ymm, ymm" xed="VPSHRDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVD" form="ymm {k}, ymm, ymm" xed="VPSHRDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVD" form="ymm, ymm, ymm" xed="VPSHRDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVD" form="xmm {z}, xmm, xmm" xed="VPSHRDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVD" form="xmm {k}, xmm, xmm" xed="VPSHRDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; (c[i+31:i] &amp; 31)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVD" form="xmm, xmm, xmm" xed="VPSHRDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVW" form="zmm {z}, zmm, zmm" xed="VPSHRDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVW" form="zmm {k}, zmm, zmm" xed="VPSHRDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDVW" form="zmm, zmm, zmm" xed="VPSHRDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVW" form="ymm {z}, ymm, ymm" xed="VPSHRDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVW" form="ymm {k}, ymm, ymm" xed="VPSHRDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDVW" form="ymm, ymm, ymm" xed="VPSHRDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVW" form="xmm {z}, xmm, xmm" xed="VPSHRDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVW" form="xmm {k}, xmm, xmm" xed="VPSHRDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by the amount specified in the corresponding element of "c", and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; (c[i+15:i] &amp; 15)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDVW" form="xmm, xmm, xmm" xed="VPSHRDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDQ" form="zmm {z}, zmm, zmm, imm8" xed="VPSHRDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDQ" form="zmm {k}, zmm, zmm, imm8" xed="VPSHRDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDQ" form="zmm, zmm, zmm, imm8" xed="VPSHRDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDQ" form="ymm {z}, ymm, ymm, imm8" xed="VPSHRDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDQ" form="ymm {k}, ymm, ymm, imm8" xed="VPSHRDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDQ" form="ymm, ymm, ymm, imm8" xed="VPSHRDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDQ" form="xmm {z}, xmm, xmm, imm8" xed="VPSHRDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDQ" form="xmm {k}, xmm, xmm, imm8" xed="VPSHRDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "b" and "a" producing an intermediate 128-bit result. Shift the result right by "imm8" bits, and store the lower 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ((b[i+63:i] &lt;&lt; 64)[127:0] | a[i+63:i]) &gt;&gt; imm8[5:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDQ" form="xmm, xmm, xmm, imm8" xed="VPSHRDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDD" form="zmm {z}, zmm, zmm, imm8" xed="VPSHRDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDD" form="zmm {k}, zmm, zmm, imm8" xed="VPSHRDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDD" form="zmm, zmm, zmm, imm8" xed="VPSHRDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDD" form="ymm {z}, ymm, ymm, imm8" xed="VPSHRDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDD" form="ymm {k}, ymm, ymm, imm8" xed="VPSHRDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDD" form="ymm, ymm, ymm, imm8" xed="VPSHRDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDD" form="xmm {z}, xmm, xmm, imm8" xed="VPSHRDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDD" form="xmm {k}, xmm, xmm, imm8" xed="VPSHRDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "b" and "a" producing an intermediate 64-bit result. Shift the result right by "imm8" bits, and store the lower 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ((b[i+31:i] &lt;&lt; 32)[63:0] | a[i+31:i]) &gt;&gt; imm8[4:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDD" form="xmm, xmm, xmm, imm8" xed="VPSHRDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDW" form="zmm {z}, zmm, zmm, imm8" xed="VPSHRDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDW" form="zmm {k}, zmm, zmm, imm8" xed="VPSHRDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHRDW" form="zmm, zmm, zmm, imm8" xed="VPSHRDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDW" form="ymm {z}, ymm, ymm, imm8" xed="VPSHRDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDW" form="ymm {k}, ymm, ymm, imm8" xed="VPSHRDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHRDW" form="ymm, ymm, ymm, imm8" xed="VPSHRDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDW" form="xmm {z}, xmm, xmm, imm8" xed="VPSHRDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDW" form="xmm {k}, xmm, xmm, imm8" xed="VPSHRDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shrdi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "b" and "a" producing an intermediate 32-bit result. Shift the result right by "imm8" bits, and store the lower 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ((b[i+15:i] &lt;&lt; 16)[31:0] | a[i+15:i]) &gt;&gt; imm8[3:0]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHRDW" form="xmm, xmm, xmm, imm8" xed="VPSHRDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="zmm {z}, zmm, zmm" xed="VPSHLDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="zmm {k}, zmm, zmm" xed="VPSHLDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="__m512i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="zmm, zmm, zmm" xed="VPSHLDVQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="ymm {z}, ymm, ymm" xed="VPSHLDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="ymm {k}, ymm, ymm" xed="VPSHLDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="__m256i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="ymm, ymm, ymm" xed="VPSHLDVQ_YMMu64_MASKmskw_YMMu64_YMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="xmm {z}, xmm, xmm" xed="VPSHLDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := a[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="xmm {k}, xmm, xmm" xed="VPSHLDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldv_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="__m128i" varname="c" etype="UI64"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 64-bits in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; (c[i+63:i] &amp; 63)
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVQ" form="xmm, xmm, xmm" xed="VPSHLDVQ_XMMu64_MASKmskw_XMMu64_XMMu64_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVD" form="zmm {z}, zmm, zmm" xed="VPSHLDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVD" form="zmm {k}, zmm, zmm" xed="VPSHLDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVD" form="zmm, zmm, zmm" xed="VPSHLDVD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVD" form="ymm {z}, ymm, ymm" xed="VPSHLDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVD" form="ymm {k}, ymm, ymm" xed="VPSHLDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="__m256i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVD" form="ymm, ymm, ymm" xed="VPSHLDVD_YMMu32_MASKmskw_YMMu32_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVD" form="xmm {z}, xmm, xmm" xed="VPSHLDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVD" form="xmm {k}, xmm, xmm" xed="VPSHLDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldv_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="__m128i" varname="c" etype="UI32"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; (c[i+31:i] &amp; 31)
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVD" form="xmm, xmm, xmm" xed="VPSHLDVD_XMMu32_MASKmskw_XMMu32_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVW" form="zmm {z}, zmm, zmm" xed="VPSHLDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVW" form="zmm {k}, zmm, zmm" xed="VPSHLDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="__m512i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDVW" form="zmm, zmm, zmm" xed="VPSHLDVW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVW" form="ymm {z}, ymm, ymm" xed="VPSHLDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVW" form="ymm {k}, ymm, ymm" xed="VPSHLDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="__m256i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDVW" form="ymm, ymm, ymm" xed="VPSHLDVW_YMMu16_MASKmskw_YMMu16_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVW" form="xmm {z}, xmm, xmm" xed="VPSHLDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVW" form="xmm {k}, xmm, xmm" xed="VPSHLDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldv_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="__m128i" varname="c" etype="UI16"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by the amount specified in the corresponding element of "c", and store the upper 16-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; (c[i+15:i] &amp; 15)
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDVW" form="xmm, xmm, xmm" xed="VPSHLDVW_XMMu16_MASKmskw_XMMu16_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDQ" form="zmm {z}, zmm, zmm, imm8" xed="VPSHLDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDQ" form="zmm {k}, zmm, zmm, imm8" xed="VPSHLDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI64"/>
	<parameter type="__m512i" varname="a" etype="UI64"/>
	<parameter type="__m512i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst").</description>
	<operation>
FOR j := 0 to 7
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDQ" form="zmm, zmm, zmm, imm8" xed="VPSHLDQ_ZMMu64_MASKmskw_ZMMu64_ZMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDQ" form="ymm {z}, ymm, ymm, imm8" xed="VPSHLDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDQ" form="ymm {k}, ymm, ymm, imm8" xed="VPSHLDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI64"/>
	<parameter type="__m256i" varname="a" etype="UI64"/>
	<parameter type="__m256i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst").</description>
	<operation>
FOR j := 0 to 3
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDQ" form="ymm, ymm, ymm, imm8" xed="VPSHLDQ_YMMu64_MASKmskw_YMMu64_YMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDQ" form="xmm {z}, xmm, xmm, imm8" xed="VPSHLDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="src" etype="UI64"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF k[j]
		tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
		dst[i+63:i] := tmp[127:64]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDQ" form="xmm {k}, xmm, xmm, imm8" xed="VPSHLDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldi_epi64">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="b" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 64-bit integers in "a" and "b" producing an intermediate 128-bit result. Shift the result left by "imm8" bits, and store the upper 64-bits in "dst").</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	tmp[127:0] := ((a[i+63:i] &lt;&lt; 64)[127:0] | b[i+63:i]) &lt;&lt; imm8[5:0]
	dst[i+63:i] := tmp[127:64]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDQ" form="xmm, xmm, xmm, imm8" xed="VPSHLDQ_XMMu64_MASKmskw_XMMu64_XMMu64_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDD" form="zmm {z}, zmm, zmm, imm8" xed="VPSHLDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDD" form="zmm {k}, zmm, zmm, imm8" xed="VPSHLDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDD" form="zmm, zmm, zmm, imm8" xed="VPSHLDD_ZMMu32_MASKmskw_ZMMu32_ZMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDD" form="ymm {z}, ymm, ymm, imm8" xed="VPSHLDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDD" form="ymm {k}, ymm, ymm, imm8" xed="VPSHLDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI32"/>
	<parameter type="__m256i" varname="a" etype="UI32"/>
	<parameter type="__m256i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDD" form="ymm, ymm, ymm, imm8" xed="VPSHLDD_YMMu32_MASKmskw_YMMu32_YMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDD" form="xmm {z}, xmm, xmm, imm8" xed="VPSHLDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="src" etype="UI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF k[j]
		tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
		dst[i+31:i] := tmp[63:32]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDD" form="xmm {k}, xmm, xmm, imm8" xed="VPSHLDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldi_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="b" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 32-bit integers in "a" and "b" producing an intermediate 64-bit result. Shift the result left by "imm8" bits, and store the upper 32-bits in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	tmp[63:0] := ((a[i+31:i] &lt;&lt; 32)[63:0] | b[i+31:i]) &lt;&lt; imm8[4:0]
	dst[i+31:i] := tmp[63:32]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDD" form="xmm, xmm, xmm, imm8" xed="VPSHLDD_XMMu32_MASKmskw_XMMu32_XMMu32_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDW" form="zmm {z}, zmm, zmm, imm8" xed="VPSHLDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDW" form="zmm {k}, zmm, zmm, imm8" xed="VPSHLDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Shift</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<parameter type="__m512i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst").</description>
	<operation>
FOR j := 0 to 31
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPSHLDW" form="zmm, zmm, zmm, imm8" xed="VPSHLDW_ZMMu16_MASKmskw_ZMMu16_ZMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDW" form="ymm {z}, ymm, ymm, imm8" xed="VPSHLDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDW" form="ymm {k}, ymm, ymm, imm8" xed="VPSHLDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<parameter type="__m256i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst").</description>
	<operation>
FOR j := 0 to 15
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPSHLDW" form="ymm, ymm, ymm, imm8" xed="VPSHLDW_YMMu16_MASKmskw_YMMu16_YMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDW" form="xmm {z}, xmm, xmm, imm8" xed="VPSHLDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF k[j]
		tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
		dst[i+15:i] := tmp[31:16]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDW" form="xmm {k}, xmm, xmm, imm8" xed="VPSHLDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_shldi_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Concatenate packed 16-bit integers in "a" and "b" producing an intermediate 32-bit result. Shift the result left by "imm8" bits, and store the upper 16-bits in "dst").</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	tmp[31:0] := ((a[i+15:i] &lt;&lt; 16)[31:0] | b[i+15:i]) &lt;&lt; imm8[3:0]
	dst[i+15:i] := tmp[31:16]
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPSHLDW" form="xmm, xmm, xmm, imm8" xed="VPSHLDW_XMMu16_MASKmskw_XMMu16_XMMu16_IMM8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDW" form="zmm {z}, zmm" xed="VPEXPANDW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDW" form="zmm {k}, zmm" xed="VPEXPANDW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDW" form="ymm {z}, ymm" xed="VPEXPANDW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDW" form="ymm {k}, ymm" xed="VPEXPANDW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDW" form="xmm {z}, xmm" xed="VPEXPANDW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_expand_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Load contiguous active 16-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[m+15:m]
		m := m + 16
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDW" form="xmm {k}, xmm" xed="VPEXPANDW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDB" form="zmm {z}, zmm" xed="VPEXPANDB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPEXPANDB" form="zmm {k}, zmm" xed="VPEXPANDB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDB" form="ymm {z}, ymm" xed="VPEXPANDB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPEXPANDB" form="ymm {k}, ymm" xed="VPEXPANDB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDB" form="xmm {z}, xmm" xed="VPEXPANDB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_expand_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Load contiguous active 8-bit integers from "a" (those with their respective bit set in mask "k"), and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
m := 0
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[m+7:m]
		m := m + 8
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPEXPANDB" form="xmm {k}, xmm" xed="VPEXPANDB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="zmm {z}, zmm" xed="VPCOMPRESSW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI16"/>
	<parameter type="__m512i" varname="src" etype="UI16"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="zmm {k}, zmm" xed="VPCOMPRESSW_ZMMu16_MASKmskw_ZMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := 0
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="ymm {z}, ymm" xed="VPCOMPRESSW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI16"/>
	<parameter type="__m256i" varname="src" etype="UI16"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := src[255:m]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="ymm {k}, ymm" xed="VPCOMPRESSW_YMMu16_MASKmskw_YMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := 0
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="xmm {z}, xmm" xed="VPCOMPRESSW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_compress_epi16">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="src" etype="UI16"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Contiguously store the active 16-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 16
m := 0
FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[m+size-1:m] := a[i+15:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := src[127:m]
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSW" form="xmm {k}, xmm" xed="VPCOMPRESSW_XMMu16_MASKmskw_XMMu16_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := 0
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="zmm {z}, zmm" xed="VPCOMPRESSB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[511:m] := src[511:m]
dst[MAX:512] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="zmm {k}, zmm" xed="VPCOMPRESSB_ZMMu8_MASKmskw_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := 0
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="ymm {z}, ymm" xed="VPCOMPRESSB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[255:m] := src[255:m]
dst[MAX:256] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="ymm {k}, ymm" xed="VPCOMPRESSB_YMMu8_MASKmskw_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in zeromask "k") to "dst", and set the remaining elements to zero.</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := 0
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="xmm {z}, xmm" xed="VPCOMPRESSB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_compress_epi8">
	<type>Integer</type>
	<CPUID>AVX512_VBMI2</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<description>Contiguously store the active 8-bit integers in "a" (those with their respective bit set in writemask "k") to "dst", and pass through the remaining elements from "src".</description>
	<operation>
size := 8
m := 0
FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[m+size-1:m] := a[i+7:i]
		m := m + size
	FI
ENDFOR
dst[127:m] := src[127:m]
dst[MAX:128] := 0
	</operation>
	<instruction name="VPCOMPRESSB" form="xmm {k}, xmm" xed="VPCOMPRESSB_XMMu8_MASKmskw_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm {z}, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm {k}, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="zmm, zmm, zmm" xed="VPDPWSSDS_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm {z}, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm {k}, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="ymm, ymm, ymm" xed="VPDPWSSDS_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm {z}, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm {k}, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpwssds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSDS" form="xmm, xmm, xmm" xed="VPDPWSSDS_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm {z}, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm {k}, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="SI16"/>
	<parameter type="__m512i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPWSSD" form="zmm, zmm, zmm" xed="VPDPWSSD_ZMMi32_MASKmskw_ZMMi16_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm {z}, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm {k}, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="SI16"/>
	<parameter type="__m256i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPWSSD" form="ymm, ymm, ymm" xed="VPDPWSSD_YMMi32_MASKmskw_YMMi16_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm {z}, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
		tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
		dst.dword[j] := src.dword[j] + tmp1 + tmp2
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm {k}, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpwssd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Multiply groups of 2 adjacent pairs of signed 16-bit integers in "a" with corresponding 16-bit integers in "b", producing 2 intermediate signed 32-bit results. Sum these 2 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.dword := SignExtend32(a.word[2*j]) * SignExtend32(b.word[2*j])
	tmp2.dword := SignExtend32(a.word[2*j+1]) * SignExtend32(b.word[2*j+1])
	dst.dword[j] := src.dword[j] + tmp1 + tmp2
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPWSSD" form="xmm, xmm, xmm" xed="VPDPWSSD_XMMi32_MASKmskw_XMMi16_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm {z}, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm {k}, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="zmm, zmm, zmm" xed="VPDPBUSDS_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm {z}, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm {k}, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="ymm, ymm, ymm" xed="VPDPBUSDS_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm {z}, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm {k}, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpbusds_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src" using signed saturation, and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := Saturate32(src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4)
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSDS" form="xmm, xmm, xmm" xed="VPDPBUSDS_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm {z}, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm {k}, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm512_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="SI32"/>
	<parameter type="__m512i" varname="src" etype="SI32"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 15
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPDPBUSD" form="zmm, zmm, zmm" xed="VPDPBUSD_ZMMi32_MASKmskw_ZMMu8_ZMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm {z}, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 7
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm {k}, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm256_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="SI32"/>
	<parameter type="__m256i" varname="src" etype="SI32"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 7
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VPDPBUSD" form="ymm, ymm, ymm" xed="VPDPBUSD_YMMi32_MASKmskw_YMMu8_YMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_maskz_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm {z}, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_mask_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__mmask8" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 3
	IF k[j]
		tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
		tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
		tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
		tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
		dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
	ELSE
		dst.dword[j] := src.dword[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm {k}, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="AVX-512" name="_mm_dpbusd_epi32">
	<type>Integer</type>
	<CPUID>AVX512_VNNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="SI32"/>
	<parameter type="__m128i" varname="src" etype="SI32"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Multiply groups of 4 adjacent pairs of unsigned 8-bit integers in "a" with corresponding signed 8-bit integers in "b", producing 4 intermediate signed 16-bit results. Sum these 4 results with the corresponding 32-bit integer in "src", and store the packed 32-bit results in "dst".</description>
	<operation>
FOR j := 0 to 3
	tmp1.word := Signed(ZeroExtend16(a.byte[4*j]) * SignExtend16(b.byte[4*j]))
	tmp2.word := Signed(ZeroExtend16(a.byte[4*j+1]) * SignExtend16(b.byte[4*j+1]))
	tmp3.word := Signed(ZeroExtend16(a.byte[4*j+2]) * SignExtend16(b.byte[4*j+2]))
	tmp4.word := Signed(ZeroExtend16(a.byte[4*j+3]) * SignExtend16(b.byte[4*j+3]))
	dst.dword[j] := src.dword[j] + tmp1 + tmp2 + tmp3 + tmp4
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VPDPBUSD" form="xmm, xmm, xmm" xed="VPDPBUSD_XMMi32_MASKmskw_XMMu8_XMMu32_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bextr_u32">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="start" etype="UI32"/>
	<parameter type="unsigned int" varname="len" etype="UI32"/>
	<description>Extract contiguous bits from unsigned 32-bit integer "a", and store the result in "dst". Extract the number of bits specified by "len", starting at the bit specified by "start".</description>
	<operation>
tmp[511:0] := a
dst[31:0] := ZeroExtend32(tmp[(start[7:0] + len[7:0] - 1):start[7:0]])
	</operation>
	<instruction name="BEXTR" form="r32, r32, r32" xed="BEXTR_VGPR32d_VGPR32d_VGPR32d"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bextr2_u32">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="control" etype="UI32"/>
	<description>Extract contiguous bits from unsigned 32-bit integer "a", and store the result in "dst". Extract the number of bits specified by bits 15:8 of "control", starting at the bit specified by bits 0:7 of "control".</description>
	<operation>
start := control[7:0]
len := control[15:8]
tmp[511:0] := a
dst[31:0] := ZeroExtend32(tmp[(start[7:0] + len[7:0] - 1):start[7:0]])
	</operation>
	<instruction name="BEXTR" form="r32, r32, r32" xed="BEXTR_VGPR32d_VGPR32d_VGPR32d"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bextr_u64">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="start" etype="UI32"/>
	<parameter type="unsigned int" varname="len" etype="UI32"/>
	<description>Extract contiguous bits from unsigned 64-bit integer "a", and store the result in "dst". Extract the number of bits specified by "len", starting at the bit specified by "start".</description>
	<operation>
tmp[511:0] := a
dst[63:0] := ZeroExtend64(tmp[(start[7:0] + len[7:0] - 1):start[7:0]])
	</operation>
	<instruction name="BEXTR" form="r64, r64, r64" xed="BEXTR_VGPR64q_VGPR64q_VGPR64q"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bextr2_u64">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="unsigned __int64" varname="control" etype="UI64"/>
	<description>Extract contiguous bits from unsigned 64-bit integer "a", and store the result in "dst". Extract the number of bits specified by bits 15:8 of "control", starting at the bit specified by bits 0:7 of "control"..</description>
	<operation>
start := control[7:0]
len := control[15:8]
tmp[511:0] := a
dst[63:0] := ZeroExtend64(tmp[(start[7:0] + len[7:0] - 1):start[7:0]])
	</operation>
	<instruction name="BEXTR" form="r64, r64, r64" xed="BEXTR_VGPR64q_VGPR64q_VGPR64q"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_tzcnt_u32">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<description>Count the number of trailing zero bits in unsigned 32-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 0
dst := 0
DO WHILE ((tmp &lt; 32) AND a[tmp] == 0)
	tmp := tmp + 1
	dst := dst + 1
OD
	</operation>
	<instruction name="TZCNT" form="r32, r32" xed="TZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_tzcnt_u64">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<description>Count the number of trailing zero bits in unsigned 64-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 0
dst := 0
DO WHILE ((tmp &lt; 64) AND a[tmp] == 0)
	tmp := tmp + 1
	dst := dst + 1
OD
	</operation>
	<instruction name="TZCNT" form="r64, r64" xed="TZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_tzcnt_32">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<description>Count the number of trailing zero bits in unsigned 32-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 0
dst := 0
DO WHILE ((tmp &lt; 32) AND a[tmp] == 0)
	tmp := tmp + 1
	dst := dst + 1
OD
	</operation>
	<instruction name="TZCNT" form="r32, r32" xed="TZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_tzcnt_64">
	<type>Integer</type>
	<CPUID>BMI1</CPUID>
	<category>Bit Manipulation</category>
	<return type="__int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<description>Count the number of trailing zero bits in unsigned 64-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 0
dst := 0
DO WHILE ((tmp &lt; 64) AND a[tmp] == 0)
	tmp := tmp + 1
	dst := dst + 1
OD
	</operation>
	<instruction name="TZCNT" form="r64, r64" xed="TZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bzhi_u32">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="index" etype="UI32"/>
	<description>Copy all bits from unsigned 32-bit integer "a" to "dst", and reset (set to 0) the high bits in "dst" starting at "index".</description>
	<operation>
n := index[7:0]
dst := a
IF (n &lt; 32)
	dst[31:n] := 0
FI
	</operation>
	<instruction name="BZHI" form="r32, r32, r32" xed="BZHI_VGPR32d_VGPR32d_VGPR32d"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_bzhi_u64">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="unsigned int" varname="index" etype="UI32"/>
	<description>Copy all bits from unsigned 64-bit integer "a" to "dst", and reset (set to 0) the high bits in "dst" starting at "index".</description>
	<operation>
n := index[7:0]
dst := a
IF (n &lt; 64)
	dst[63:n] := 0
FI
	</operation>
	<instruction name="BZHI" form="r64, r64, r64" xed="BZHI_VGPR64q_VGPR64q_VGPR64q"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_pdep_u32">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="mask" etype="UI32"/>
	<description>Deposit contiguous low bits from unsigned 32-bit integer "a" to "dst" at the corresponding bit locations specified by "mask"; all other bits in "dst" are set to zero.</description>
	<operation>
tmp := a
dst := 0
m := 0
k := 0
DO WHILE m &lt; 32
	IF mask[m] == 1
		dst[m] := tmp[k]
		k := k + 1
	FI
	m := m + 1
OD
	</operation>
	<instruction name="PDEP" form="r32, r32, r32" xed="PDEP_VGPR32d_VGPR32d_VGPR32d"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_pdep_u64">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="unsigned __int64" varname="mask" etype="UI64"/>
	<description>Deposit contiguous low bits from unsigned 64-bit integer "a" to "dst" at the corresponding bit locations specified by "mask"; all other bits in "dst" are set to zero.</description>
	<operation>
tmp := a
dst := 0
m := 0
k := 0
DO WHILE m &lt; 64
	IF mask[m] == 1
		dst[m] := tmp[k]
		k := k + 1
	FI
	m := m + 1
OD
	</operation>
	<instruction name="PDEP" form="r64, r64, r64" xed="PDEP_VGPR64q_VGPR64q_VGPR64q"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_pext_u32">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="unsigned int" varname="mask" etype="UI32"/>
	<description>Extract bits from unsigned 32-bit integer "a" at the corresponding bit locations specified by "mask" to contiguous low bits in "dst"; the remaining upper bits in "dst" are set to zero.</description>
	<operation>
tmp := a
dst := 0
m := 0
k := 0
DO WHILE m &lt; 32
	IF mask[m] == 1
		dst[k] := tmp[m]
		k := k + 1
	FI
	m := m + 1
OD
	</operation>
	<instruction name="PEXT" form="r32, r32, r32" xed="PEXT_VGPR32d_VGPR32d_VGPR32d"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_pext_u64">
	<type>Integer</type>
	<CPUID>BMI2</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="unsigned __int64" varname="mask" etype="UI64"/>
	<description>Extract bits from unsigned 64-bit integer "a" at the corresponding bit locations specified by "mask" to contiguous low bits in "dst"; the remaining upper bits in "dst" are set to zero.</description>
	<operation>
tmp := a
dst := 0
m := 0
k := 0
DO WHILE m &lt; 64
	IF mask[m] == 1
		dst[k] := tmp[m]
		k := k + 1
	FI
	m := m + 1
OD
	</operation>
	<instruction name="PEXT" form="r64, r64, r64" xed="PEXT_VGPR64q_VGPR64q_VGPR64q"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm512_maskz_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 63
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := 0
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="zmm {z}, zmm, zmm" xed="VGF2P8MULB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm512_mask_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="src" etype="UI8"/>
	<parameter type="__mmask64" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 63
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := src.byte[j]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="zmm {k}, zmm, zmm" xed="VGF2P8MULB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm512_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512F</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI8"/>
	<parameter type="__m512i" varname="a" etype="UI8"/>
	<parameter type="__m512i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst". The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 63
	dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="zmm, zmm, zmm" xed="VGF2P8MULB_ZMMu8_MASKmskw_ZMMu8_ZMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm256_maskz_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 31
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := 0
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="ymm {z}, ymm, ymm" xed="VGF2P8MULB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm256_mask_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="src" etype="UI8"/>
	<parameter type="__mmask32" varname="k" etype="MASK"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 31
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := src.byte[j]
	FI
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="ymm {k}, ymm, ymm" xed="VGF2P8MULB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm256_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m256i" varname="dst" etype="UI8"/>
	<parameter type="__m256i" varname="a" etype="UI8"/>
	<parameter type="__m256i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst". The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 31
	dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
ENDFOR
dst[MAX:256] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="ymm, ymm, ymm" xed="VGF2P8MULB_YMMu8_MASKmskw_YMMu8_YMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_maskz_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using zeromask "k" (elements are zeroed out when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 15
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := 0
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="xmm {z}, xmm, xmm" xed="VGF2P8MULB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_mask_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="src" etype="UI8"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst" using writemask "k" (elements are copied from "src"" when the corresponding mask bit is not set). The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 15
	IF k[j]
		dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
	ELSE
		dst.byte[j] := src.byte[j]
	FI
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="xmm {k}, xmm, xmm" xed="VGF2P8MULB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_gf2p8mul_epi8">
	<type>Integer</type>
	<CPUID>GFNI</CPUID>
	<CPUID>AVX512VL</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Multiply the packed 8-bit integers in "a" and "b" in the finite field GF(2^8), and store the results in "dst". The field GF(2^8) is represented in polynomial representation with the reduction polynomial x^8 + x^4 + x^3 + x + 1.</description>
	<operation>
DEFINE gf2p8mul_byte(src1byte, src2byte) {
	tword := 0
	FOR i := 0 to 7
		IF src2byte.bit[i]
			tword := tword XOR (src1byte &lt;&lt; i)
		FI
	ENDFOR
	FOR i := 14 downto 8
		p := 0x11B &lt;&lt; (i-8)
		IF tword.bit[i]
			tword := tword XOR p
		FI
	ENDFOR
	RETURN tword.byte[0]
}
FOR j := 0 TO 15
	dst.byte[j] := gf2p8mul_byte(a.byte[j], b.byte[j])
ENDFOR
dst[MAX:128] := 0
	</operation>
	<instruction name="VGF2P8MULB" form="xmm, xmm, xmm" xed="VGF2P8MULB_XMMu8_MASKmskw_XMMu8_XMMu8_AVX512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_addsets_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="v2" etype="UI32"/>
	<parameter type="__m512i" varname="v3" etype="UI32"/>
	<parameter type="__mmask16 *" varname="sign" etype="MASK" memwidth="16"/>
	<description>Performs an element-by-element addition of packed 32-bit integer elements in "v2" and "v3", storing the results in "dst" and the sign of the sum in "sign" (sign flag).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := v2[i+31:i] + v3[i+31:i]
	sign[j] := v2[i+31:i] &amp; v3[i+31:i] &amp; 0x80000000
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSETSD" form="zmm, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_addsets_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="v2" etype="UI32"/>
	<parameter type="__m512i" varname="v3" etype="UI32"/>
	<parameter type="__mmask16 *" varname="sign" etype="MASK" memwidth="16"/>
	<description>Performs an element-by-element addition of packed 32-bit integer elements in "v2" and "v3", storing the results in "dst" and the sign of the sum in "sign" (sign flag). Results are stored using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := v2[i+31:i] + v3[i+31:i]
		sign[j] := v2[i+31:i] &amp; v3[i+31:i] &amp; 0x80000000
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPADDSETSD" form="zmm {k}, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_fmadd_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<description>Multiply packed 32-bit integer elements in "a" and "b", add the intermediate result to packed elements in "c" and store the results in "dst" using writemask "k" (elements are copied from "a" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD231D" form="zmm {k}, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask3_fmadd_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<parameter type="__m512i" varname="c" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<description>Multiply packed 32-bit integer elements in "a" and "b", add the intermediate result to packed elements in "c" and store the results in "dst" using writemask "k" (elements are copied from "c" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) + c[i+31:i]
	ELSE
		dst[i+31:i] := c[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD231D" form="zmm {k}, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_fmadd233_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Multiply packed 32-bit integer elements in each 4-element set of "a" and by element 1 of the corresponding 4-element set from "b", add the intermediate result to element 0 of the corresponding 4-element set from "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	base := (j &amp; ~0x3) * 32
	scale[31:0] := b[base+63:base+32]
	bias[31:0]  := b[base+31:base]
	dst[i+31:i] := (a[i+31:i] * scale[31:0]) + bias[31:0]
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD233D" form="zmm, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_fmadd233_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Multiply packed 32-bit integer elements in each 4-element set of "a" and by element 1 of the corresponding 4-element set from "b", add the intermediate result to element 0 of the corresponding 4-element set from "b", and store the results in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		base := (j &amp; ~0x3) * 32
		scale[31:0] := b[base+63:base+32]
		bias[31:0]  := b[base+31:base]
		dst[i+31:i] := (a[i+31:i] * scale[31:0]) + bias[31:0]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMADD233D" form="zmm {k}, zmm, zmm"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_mulhi_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Performs element-by-element multiplication between packed 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHD" form="zmm {k}, zmm, m512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_mulhi_epu32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Arithmetic</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="__m512i" varname="b" etype="UI32"/>
	<description>Performs element-by-element multiplication between packed unsigned 32-bit integer elements in "a" and "b" and stores the high 32 bits of each result into "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := (a[i+31:i] * b[i+31:i]) &gt;&gt; 32
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPMULHUD" form="zmm {k}, zmm, m512"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_permute4f128_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Permutes 128-bit blocks of the packed 32-bit integer vector "a" using constant "imm8". The results are stored in "dst".</description>
	<operation>
DEFINE SELECT4(src, control)  {
	CASE control[1:0] OF
	0: tmp[127:0] := src[127:0]
	1: tmp[127:0] := src[255:128]
	2: tmp[127:0] := src[383:256]
	3: tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
FOR j := 0 to 3
	i := j*128
	n := j*2
	dst[i+127:i] := SELECT4(a[511:0], imm8[n+1:n])
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPERMF32X4" form="zmm, m512, imm8"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_mask_permute4f128_epi32">
	<type>Integer</type>
	<CPUID>KNCNI</CPUID>
	<category>Swizzle</category>
	<return type="__m512i" varname="dst" etype="UI32"/>
	<parameter type="__m512i" varname="src" etype="UI32"/>
	<parameter type="__mmask16" varname="k" etype="MASK"/>
	<parameter type="__m512i" varname="a" etype="UI32"/>
	<parameter type="_MM_PERM_ENUM" varname="imm8" etype="IMM" immtype="_MM_PERM"/>
	<description>Permutes 128-bit blocks of the packed 32-bit integer vector "a" using constant "imm8". The results are stored in "dst" using writemask "k" (elements are copied from "src" when the corresponding mask bit is not set).</description>
	<operation>
DEFINE SELECT4(src, control)  {
	CASE control[1:0] OF
	0: tmp[127:0] := src[127:0]
	1: tmp[127:0] := src[255:128]
	2: tmp[127:0] := src[383:256]
	3: tmp[127:0] := src[511:384]
	ESAC
	RETURN tmp[127:0]
}
tmp[511:0] := 0
FOR j := 0 to 3
	i := j*128
	n := j*2
	tmp[i+127:i] := SELECT4(a[511:0], imm8[n+1:n])
ENDFOR
FOR j := 0 to 15
	IF k[j]
		dst[i+31:i] := tmp[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0
	</operation>
	<instruction name="VPERMF32X4" form="zmm {k}, m512, imm8"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm_tzcnti_32">
	<CPUID>KNCNI</CPUID>
	<category>Bit Manipulation</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="int" varname="a" etype="SI32"/>
	<parameter type="unsigned int" varname="x" etype="UI32"/>
	<description>Count the number of trailing zero bits in unsigned 32-bit integer "x" starting at bit "a", and return that count in "dst".</description>
	<operation>
tmp := a
IF tmp &lt; 0
	tmp := 0
FI
dst := 0
IF tmp &gt; 31
	dst := 32
ELSE
	DO WHILE ((tmp &lt; 32) AND x[tmp] == 0)
		tmp := tmp + 1
		dst := dst + 1
	OD
FI
	</operation>
	<instruction name="TZCNTI" form="r32, r32"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm_tzcnti_64">
	<CPUID>KNCNI</CPUID>
	<category>Bit Manipulation</category>
	<return type="__int64" varname="dst" etype="UI64"/>
	<parameter type="__int64" varname="a" etype="SI64"/>
	<parameter type="unsigned __int64" varname="x" etype="UI64"/>
	<description>Count the number of trailing zero bits in unsigned 64-bit integer "x" starting at bit "a", and return that count in "dst".</description>
	<operation>
tmp := a
IF tmp &lt; 0
	tmp := 0
FI
dst := 0
IF tmp &gt; 63
	dst := 64
ELSE
	DO WHILE ((tmp &lt; 64) AND x[tmp] == 0)
		tmp := tmp + 1
		dst := dst + 1
	OD
FI
	</operation>
	<instruction name="TZCNTI" form="r64, r64"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_kandnr">
	<type>Mask</type>
	<CPUID>KNCNI</CPUID>
	<category>Mask</category>
	<return type="__mmask16" varname="dst" etype="MASK"/>
	<parameter type="__mmask16" varname="k1" etype="MASK"/>
	<parameter type="__mmask16" varname="k2" etype="MASK"/>
	<description>Performs a bitwise AND operation between NOT of "k2" and "k1", storing the result in "dst".</description>
	<operation>dst[15:0] := NOT(k2[15:0]) &amp; k1[15:0]
	</operation>
	<instruction name="KANDNR" form="k, k"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="KNC" name="_mm512_kextract_64">
	<type>Mask</type>
	<CPUID>KNCNI</CPUID>
	<category>Mask</category>
	<return type="__mmask16" varname="dst" etype="MASK"/>
	<parameter type="__int64" varname="a" etype="UI64"/>
	<parameter type="const int" varname="b" etype="UI32"/>
	<description>Extracts 16-bit value "b" from 64-bit integer "a", storing the result in "dst".</description>
	<operation>
CASE b[1:0] OF
0: dst[15:0] := a[63:48]
1: dst[15:0] := a[47:32]
2: dst[15:0] := a[31:16]
3: dst[15:0] := a[15:0]
ESAC
dst[MAX:15] := 0
	</operation>
	<instruction name="KEXTRACT" form="k, r64, imm8"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_lzcnt_u32">
	<type>Integer</type>
	<CPUID>LZCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<description>Count the number of leading zero bits in unsigned 32-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 31
dst := 0
DO WHILE (tmp &gt;= 0 AND a[tmp] == 0)
	tmp := tmp - 1
	dst := dst + 1
OD
	</operation>
	<instruction name="LZCNT" form="r32, r32" xed="LZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_lzcnt_u64">
	<type>Integer</type>
	<CPUID>LZCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<description>Count the number of leading zero bits in unsigned 64-bit integer "a", and return that count in "dst".</description>
	<operation>
tmp := 63
dst := 0
DO WHILE (tmp &gt;= 0 AND a[tmp] == 0)
	tmp := tmp - 1
	dst := dst + 1
OD
	</operation>
	<instruction name="LZCNT" form="r64, r64" xed="LZCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sll_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="__m64" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, mm" xed="PSLLW_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_slli_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="mm, imm8" xed="PSLLW_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sll_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="__m64" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, mm" xed="PSLLD_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_slli_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="mm, imm8" xed="PSLLD_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sll_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI64"/>
	<parameter type="__m64" varname="count" etype="UI64"/>
	<description>Shift 64-bit integer "a" left by "count" while shifting in zeros, and store the result in "dst".</description>
	<operation>
IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend64(a[63:0] &lt;&lt; count[63:0])
FI
	</operation>
	<instruction name="PSLLQ" form="mm, mm" xed="PSLLQ_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_slli_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 64-bit integer "a" left by "imm8" while shifting in zeros, and store the result in "dst".</description>
	<operation>
IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend64(a[63:0] &lt;&lt; imm8[7:0])
FI
	</operation>
	<instruction name="PSLLQ" form="mm, imm8" xed="PSLLQ_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sra_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="__m64" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, mm" xed="PSRAW_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srai_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="mm, imm8" xed="PSRAW_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_sra_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="__m64" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, mm" xed="PSRAD_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srai_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="mm, imm8" xed="PSRAD_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srl_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="__m64" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, mm" xed="PSRLW_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srli_pi16">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="mm, imm8" xed="PSRLW_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srl_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="__m64" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, mm" xed="PSRLD_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srli_pi32">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="mm, imm8" xed="PSRLD_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srl_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI64"/>
	<parameter type="__m64" varname="count" etype="UI64"/>
	<description>Shift 64-bit integer "a" right by "count" while shifting in zeros, and store the result in "dst".</description>
	<operation>
IF count[63:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend64(a[63:0] &gt;&gt; count[63:0])
FI
	</operation>
	<instruction name="PSRLQ" form="mm, mm" xed="PSRLQ_MMXq_MMXq"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="MMX" name="_mm_srli_si64">
	<type>Integer</type>
	<CPUID>MMX</CPUID>
	<category>Shift</category>
	<return type="__m64" varname="dst" etype="FP32"/>
	<parameter type="__m64" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift 64-bit integer "a" right by "imm8" while shifting in zeros, and store the result in "dst".</description>
	<operation>
IF imm8[7:0] &gt; 63
	dst[63:0] := 0
ELSE
	dst[63:0] := ZeroExtend64(a[63:0] &gt;&gt; imm8[7:0])
FI
	</operation>
	<instruction name="PSRLQ" form="mm, imm8" xed="PSRLQ_MMXq_IMMb"/>
	<header>mmintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_lrotl">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned long" varname="dst" etype="UI32"/>
	<parameter type="unsigned long" varname="a" etype="UI32"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="8"/>
	<description>Shift the bits of unsigned long integer "a" left by the number of bits specified in "shift", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in "dst".</description>
	<operation>// size := 32 or 64
dst := a
count := shift AND (size - 1)
DO WHILE (count &gt; 0)
	tmp[0] := dst[size - 1]
	dst := (dst &lt;&lt; 1) OR tmp[0]
	count := count - 1
OD
	</operation>
	<instruction name="ROL" form="r64, imm8" xed="ROL_GPRv_IMMb"/>
	<instruction name="ROL" form="r32, imm8" xed="ROL_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_lrotr">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned long" varname="dst" etype="UI32"/>
	<parameter type="unsigned long" varname="a" etype="UI32"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="8"/>
	<description>Shift the bits of unsigned long integer "a" right by the number of bits specified in "shift", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in "dst".</description>
	<operation>// size := 32 or 64
dst := a
count := shift AND (size - 1)
DO WHILE (count &gt; 0)
	tmp[size - 1] := dst[0]
	dst := (dst &gt;&gt; 1) OR tmp[size - 1]
	count := count - 1
OD
	</operation>
	<instruction name="ROR" form="r64, imm8" xed="ROR_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotl">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="5"/>
	<description>Shift the bits of unsigned 32-bit integer "a" left by the number of bits specified in "shift", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 31
DO WHILE (count &gt; 0)
	tmp[0] := dst[31]
	dst := (dst &lt;&lt; 1) OR tmp[0]
	count := count - 1
OD
	</operation>
	<instruction name="ROL" form="r32, imm8" xed="ROL_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotr">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="5"/>
	<description>Shift the bits of unsigned 32-bit integer "a" right by the number of bits specified in "shift", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 31
DO WHILE (count &gt; 0)
	tmp[31] := dst[0]
	dst := (dst &gt;&gt; 1) OR tmp
	count := count - 1
OD
	</operation>
	<instruction name="ROR" form="r32, imm8" xed="ROR_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotwl">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned short" varname="dst" etype="UI16"/>
	<parameter type="unsigned short" varname="a" etype="UI16"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="4"/>
	<description>Shift the bits of unsigned 16-bit integer "a" left by the number of bits specified in "shift", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 15
DO WHILE (count &gt; 0)
	tmp[0] := dst[15]
	dst := (dst &lt;&lt; 1) OR tmp[0]
	count := count - 1
OD
	</operation>
	<instruction name="ROL" form="r16, imm8" xed="ROL_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotwr">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned short" varname="dst" etype="UI16"/>
	<parameter type="unsigned short" varname="a" etype="UI16"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="4"/>
	<description>Shift the bits of unsigned 16-bit integer "a" right by the number of bits specified in "shift", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 15
DO WHILE (count &gt; 0)
	tmp[15] := dst[0]
	dst := (dst &gt;&gt; 1) OR tmp
	count := count - 1
OD
	</operation>
	<instruction name="ROR" form="r16, imm8" xed="ROR_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotl64">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="6"/>
	<description>Shift the bits of unsigned 64-bit integer "a" left by the number of bits specified in "shift", rotating the most-significant bit to the least-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 63
DO WHILE (count &gt; 0)
	tmp[0] := dst[63]
	dst := (dst &lt;&lt; 1) OR tmp[0]
	count := count - 1
OD
	</operation>
	<instruction name="ROL" form="r64, imm8" xed="ROL_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_rotr64">
	<type>Integer</type>
	<category>Shift</category>
	<return type="unsigned __int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<parameter type="int" varname="shift" etype="IMM" immwidth="6"/>
	<description>Shift the bits of unsigned 64-bit integer "a" right by the number of bits specified in "shift", rotating the least-significant bit to the most-significant bit location, and store the unsigned result in "dst".</description>
	<operation>
dst := a
count := shift AND 63
DO WHILE (count &gt; 0)
	tmp[63] := dst[0]
	dst := (dst &gt;&gt; 1) OR tmp[63]
	count := count - 1
OD
	</operation>
	<instruction name="ROR" form="r64, imm8" xed="ROR_GPRv_IMMb"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_popcnt_u32">
	<type>Integer</type>
	<type>Flag</type>
	<CPUID>POPCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="unsigned int" varname="a" etype="UI32"/>
	<description>Count the number of bits set to 1 in unsigned 32-bit integer "a", and return that count in "dst".</description>
	<operation>
dst := 0
FOR i := 0 to 31
	IF a[i]
		dst := dst + 1
	FI
ENDFOR
	</operation>
	<instruction name="POPCNT" form="r32, r32" xed="POPCNT_GPRv_GPRv"/>
	<header>nmmintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_mm_popcnt_u64">
	<type>Integer</type>
	<type>Flag</type>
	<CPUID>POPCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="__int64" varname="dst" etype="UI64"/>
	<parameter type="unsigned __int64" varname="a" etype="UI64"/>
	<description>Count the number of bits set to 1 in unsigned 64-bit integer "a", and return that count in "dst".</description>
	<operation>
dst := 0
FOR i := 0 to 63
	IF a[i]
		dst := dst + 1
	FI
ENDFOR
	</operation>
	<instruction name="POPCNT" form="r64, r64" xed="POPCNT_GPRv_GPRv"/>
	<header>nmmintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_popcnt32">
	<type>Integer</type>
	<type>Flag</type>
	<CPUID>POPCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="int" varname="a" etype="UI32"/>
	<description>Count the number of bits set to 1 in 32-bit integer "a", and return that count in "dst".</description>
	<operation>
dst := 0
FOR i := 0 to 31
	IF a[i]
		dst := dst + 1
	FI
ENDFOR
	</operation>
	<instruction name="POPCNT" form="r32, r32" xed="POPCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="Other" name="_popcnt64">
	<type>Integer</type>
	<type>Flag</type>
	<CPUID>POPCNT</CPUID>
	<category>Bit Manipulation</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="__int64" varname="a" etype="UI64"/>
	<description>Count the number of bits set to 1 in 64-bit integer "a", and return that count in "dst".</description>
	<operation>
dst := 0
FOR i := 0 to 63
	IF a[i]
		dst := dst + 1
	FI
ENDFOR
	</operation>
	<instruction name="POPCNT" form="r64, r64" xed="POPCNT_GPRv_GPRv"/>
	<header>immintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_sad_pu8">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Arithmetic</category>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="UI16"/>
	<parameter type="__m64" varname="a" etype="UI8"/>
	<parameter type="__m64" varname="b" etype="UI8"/>
	<description>Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
dst[15:0] := tmp[7:0] + tmp[15:8] + tmp[23:16] + tmp[31:24] + tmp[39:32] + tmp[47:40] + tmp[55:48] + tmp[63:56]
dst[63:16] := 0
	</operation>
	<instruction name="PSADBW" form="mm, mm" xed="PSADBW_MMXq_MMXq"/>
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE" name="_mm_shuffle_pi16">
	<type>Integer</type>
	<CPUID>SSE</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="UI16"/>
	<parameter type="__m64" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 16-bit integers in "a" using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[15:0] := src[15:0]
	1:	tmp[15:0] := src[31:16]
	2:	tmp[15:0] := src[47:32]
	3:	tmp[15:0] := src[63:48]
	ESAC
	RETURN tmp[15:0]
}
dst[15:0] := SELECT4(a[63:0], imm8[1:0])
dst[31:16] := SELECT4(a[63:0], imm8[3:2])
dst[47:32] := SELECT4(a[63:0], imm8[5:4])
dst[63:48] := SELECT4(a[63:0], imm8[7:6])
	</operation>
	<instruction name="PSHUFW" form="mm, mm, imm8" xed="PSHUFW_MMXq_MMXq_IMMb"/>
	<header>xmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sad_epu8">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Arithmetic</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Compute the absolute differences of packed unsigned 8-bit integers in "a" and "b", then horizontally sum each consecutive 8 differences to produce two unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	tmp[i+7:i] := ABS(a[i+7:i] - b[i+7:i])
ENDFOR
FOR j := 0 to 1
	i := j*64
	dst[i+15:i] := tmp[i+7:i] + tmp[i+15:i+8] + tmp[i+23:i+16] + tmp[i+31:i+24] + \
	               tmp[i+39:i+32] + tmp[i+47:i+40] + tmp[i+55:i+48] + tmp[i+63:i+56]
	dst[i+63:i+16] := 0
ENDFOR
	</operation>
	<instruction name="PSADBW" form="xmm, xmm" xed="PSADBW_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
	</operation>
	<instruction name="PSLLDQ" form="xmm, imm8" xed="PSLLDQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_bslli_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift "a" left by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &lt;&lt; (tmp*8)
	</operation>
	<instruction name="PSLLDQ" form="xmm, imm8" xed="PSLLDQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_bsrli_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
	</operation>
	<instruction name="PSRLDQ" form="xmm, imm8" xed="PSRLDQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="xmm, imm8" xed="PSLLW_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLW" form="xmm, xmm" xed="PSLLW_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="xmm, imm8" xed="PSLLD_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLD" form="xmm, xmm" xed="PSLLD_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_slli_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" left by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLQ" form="xmm, imm8" xed="PSLLQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sll_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" left by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &lt;&lt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSLLQ" form="xmm, xmm" xed="PSLLQ_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srai_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="5"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="xmm, imm8" xed="PSRAW_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sra_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := (a[i+15] ? 0xFFFF : 0x0)
	ELSE
		dst[i+15:i] := SignExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAW" form="xmm, xmm" xed="PSRAW_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srai_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="xmm, imm8" xed="PSRAD_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_sra_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in sign bits, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := (a[i+31] ? 0xFFFFFFFF : 0x0)
	ELSE
		dst[i+31:i] := SignExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRAD" form="xmm, xmm" xed="PSRAD_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_si128">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="M128"/>
	<parameter type="__m128i" varname="a" etype="M128"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift "a" right by "imm8" bytes while shifting in zeros, and store the results in "dst".</description>
	<operation>
tmp := imm8[7:0]
IF tmp &gt; 15
	tmp := 16
FI
dst[127:0] := a[127:0] &gt;&gt; (tmp*8)
	</operation>
	<instruction name="PSRLDQ" form="xmm, imm8" xed="PSRLDQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 16-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[7:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="xmm, imm8" xed="PSRLW_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="count" etype="UI16"/>
	<description>Shift packed 16-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF count[63:0] &gt; 15
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := ZeroExtend16(a[i+15:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLW" form="xmm, xmm" xed="PSRLW_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 32-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF imm8[7:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="xmm, imm8" xed="PSRLD_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="__m128i" varname="count" etype="UI32"/>
	<description>Shift packed 32-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF count[63:0] &gt; 31
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := ZeroExtend32(a[i+31:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLD" form="xmm, xmm" xed="PSRLD_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srli_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shift packed 64-bit integers in "a" right by "imm8" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF imm8[7:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; imm8[7:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLQ" form="xmm, imm8" xed="PSRLQ_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_srl_epi64">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Shift</category>
	<return type="__m128i" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="__m128i" varname="count" etype="UI64"/>
	<description>Shift packed 64-bit integers in "a" right by "count" while shifting in zeros, and store the results in "dst".</description>
	<operation>
FOR j := 0 to 1
	i := j*64
	IF count[63:0] &gt; 63
		dst[i+63:i] := 0
	ELSE
		dst[i+63:i] := ZeroExtend64(a[i+63:i] &gt;&gt; count[63:0])
	FI
ENDFOR
	</operation>
	<instruction name="PSRLQ" form="xmm, xmm" xed="PSRLQ_XMMdq_XMMdq"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_extract_epi16">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="3"/>
	<description>Extract a 16-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[15:0] := (a[127:0] &gt;&gt; (imm8[2:0] * 16))[15:0]
dst[31:16] := 0
	</operation>
	<instruction name="PEXTRW" form="r32, xmm, imm8" xed="PEXTRW_GPR32_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE2" vexEq="TRUE" name="_mm_shuffle_epi32">
	<type>Integer</type>
	<CPUID>SSE2</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Shuffle 32-bit integers in "a" using the control in "imm8", and store the results in "dst".</description>
	<operation>
DEFINE SELECT4(src, control) {
	CASE(control[1:0]) OF
	0:	tmp[31:0] := src[31:0]
	1:	tmp[31:0] := src[63:32]
	2:	tmp[31:0] := src[95:64]
	3:	tmp[31:0] := src[127:96]
	ESAC
	RETURN tmp[31:0]
}
dst[31:0] := SELECT4(a[127:0], imm8[1:0])
dst[63:32] := SELECT4(a[127:0], imm8[3:2])
dst[95:64] := SELECT4(a[127:0], imm8[5:4])
dst[127:96] := SELECT4(a[127:0], imm8[7:6])
	</operation>
	<instruction name="PSHUFD" form="xmm, xmm, imm8" xed="PSHUFD_XMMdq_XMMdq_IMMb"/>
	<header>emmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_blendv_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="__m128i" varname="mask" etype="UI8"/>
	<description>Blend packed 8-bit integers from "a" and "b" using "mask", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF mask[i+7]
		dst[i+7:i] := b[i+7:i]
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PBLENDVB" form="xmm, xmm" xed="PBLENDVB_XMMdq_XMMdq"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_blend_epi16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<parameter type="__m128i" varname="b" etype="UI16"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Blend packed 16-bit integers from "a" and "b" using control mask "imm8", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF imm8[j]
		dst[i+15:i] := b[i+15:i]
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PBLENDW" form="xmm, xmm, imm8" xed="PBLENDW_XMMdq_XMMdq_IMMb"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="4"/>
	<description>Extract an 8-bit integer from "a", selected with "imm8", and store the result in the lower element of "dst".</description>
	<operation>
dst[7:0] := (a[127:0] &gt;&gt; (imm8[3:0] * 8))[7:0]
dst[31:8] := 0
	</operation>
	<instruction name="PEXTRB" form="r32, xmm, imm8" xed="PEXTRB_GPR32d_XMMdq_IMMb"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi32">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="int" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="UI32"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="2"/>
	<description>Extract a 32-bit integer from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
dst[31:0] := (a[127:0] &gt;&gt; (imm8[1:0] * 32))[31:0]
	</operation>
	<instruction name="PEXTRD" form="r32, xmm, imm8" xed="PEXTRD_GPR32d_XMMdq_IMMb"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_extract_epi64">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Swizzle</category>
	<return type="__int64" varname="dst" etype="UI64"/>
	<parameter type="__m128i" varname="a" etype="UI64"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="1"/>
	<description>Extract a 64-bit integer from "a", selected with "imm8", and store the result in "dst".</description>
	<operation>
dst[63:0] := (a[127:0] &gt;&gt; (imm8[0] * 64))[63:0]
	</operation>
	<instruction name="PEXTRQ" form="r64, xmm, imm8" xed="PEXTRQ_GPR64q_XMMdq_IMMb"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_minpos_epu16">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="UI16"/>
	<description>Horizontally compute the minimum amongst the packed unsigned 16-bit integers in "a", store the minimum and index in "dst", and zero the remaining bits in "dst".</description>
	<operation>
index[2:0] := 0
min[15:0] := a[15:0]
FOR j := 0 to 7
	i := j*16
	IF a[i+15:i] &lt; min[15:0]
		index[2:0] := j
		min[15:0] := a[i+15:i]
	FI
ENDFOR
dst[15:0] := min[15:0]
dst[18:16] := index[2:0]
dst[127:19] := 0
	</operation>
	<instruction name="PHMINPOSUW" form="xmm, xmm" xed="PHMINPOSUW_XMMdq_XMMdq"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSE4.1" vexEq="TRUE" name="_mm_mpsadbw_epu8">
	<type>Integer</type>
	<CPUID>SSE4.1</CPUID>
	<category>Arithmetic</category>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="const int" varname="imm8" etype="IMM" immwidth="8"/>
	<description>Compute the sum of absolute differences (SADs) of quadruplets of unsigned 8-bit integers in "a" compared to those in "b", and store the 16-bit results in "dst".
	Eight SADs are performed using one quadruplet from "b" and eight quadruplets from "a". One quadruplet is selected from "b" starting at on the offset specified in "imm8". Eight quadruplets are formed from sequential 8-bit integers selected from "a" starting at the offset specified in "imm8".</description>
	<operation>
DEFINE MPSADBW(a[127:0], b[127:0], imm8[2:0]) {
	a_offset := imm8[2]*32
	b_offset := imm8[1:0]*32
	FOR j := 0 to 7
		i := j*8
		k := a_offset+i
		l := b_offset
		tmp[i*2+15:i*2] := ABS(Signed(a[k+7:k] - b[l+7:l])) + ABS(Signed(a[k+15:k+8] - b[l+15:l+8])) + \
		                   ABS(Signed(a[k+23:k+16] - b[l+23:l+16])) + ABS(Signed(a[k+31:k+24] - b[l+31:l+24]))
	ENDFOR
	RETURN tmp[127:0]
}
dst[127:0] := MPSADBW(a[127:0], b[127:0], imm8[2:0])
	</operation>
	<instruction name="MPSADBW" form="xmm, xmm, imm8" xed="MPSADBW_XMMdq_XMMdq_IMMb"/>
	<header>smmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_shuffle_epi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Swizzle</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[3:0] := b[i+3:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR
	</operation>
	<instruction name="PSHUFB" form="xmm, xmm" xed="PSHUFB_XMMdq_XMMdq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_shuffle_pi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Swizzle</category>
	<return type="__m64" varname="dst" etype="UI8"/>
	<parameter type="__m64" varname="a" etype="UI8"/>
	<parameter type="__m64" varname="b" etype="UI8"/>
	<description>Shuffle packed 8-bit integers in "a" according to shuffle control mask in the corresponding 8-bit element of "b", and store the results in "dst".</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	IF b[i+7] == 1
		dst[i+7:i] := 0
	ELSE
		index[2:0] := b[i+2:i]
		dst[i+7:i] := a[index*8+7:index*8]
	FI
ENDFOR
	</operation>
	<instruction name="PSHUFB" form="mm, mm" xed="PSHUFB_MMXq_MMXq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_alignr_epi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Miscellaneous</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="UI8"/>
	<parameter type="__m128i" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="5"/>
	<description>Concatenate 16-byte blocks in "a" and "b" into a 32-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst".</description>
	<operation>
tmp[255:0] := ((a[127:0] &lt;&lt; 128)[255:0] OR b[127:0]) &gt;&gt; (imm8*8)
dst[127:0] := tmp[127:0]
	</operation>
	<instruction name="PALIGNR" form="xmm, xmm, imm8" xed="PALIGNR_XMMdq_XMMdq_IMMb"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_alignr_pi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Miscellaneous</category>
	<return type="__m64" varname="dst" etype="UI8"/>
	<parameter type="__m64" varname="a" etype="UI8"/>
	<parameter type="__m64" varname="b" etype="UI8"/>
	<parameter type="int" varname="imm8" etype="IMM" immwidth="4"/>
	<description>Concatenate 8-byte blocks in "a" and "b" into a 16-byte temporary result, shift the result right by "imm8" bytes, and store the low 16 bytes in "dst".</description>
	<operation>
tmp[127:0] := ((a[63:0] &lt;&lt; 64)[127:0] OR b[63:0]) &gt;&gt; (imm8*8)
dst[63:0] := tmp[63:0]
	</operation>
	<instruction name="PALIGNR" form="mm, mm, imm8" xed="PALIGNR_MMXq_MMXq_IMMb"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI8"/>
	<parameter type="__m128i" varname="a" etype="SI8"/>
	<parameter type="__m128i" varname="b" etype="SI8"/>
	<description>Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 15
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNB" form="xmm, xmm" xed="PSIGNB_XMMdq_XMMdq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI16"/>
	<parameter type="__m128i" varname="a" etype="SI16"/>
	<parameter type="__m128i" varname="b" etype="SI16"/>
	<description>Negate packed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNW" form="xmm, xmm" xed="PSIGNW_XMMdq_XMMdq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" vexEq="TRUE" name="_mm_sign_epi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m128i" varname="dst" etype="UI32"/>
	<parameter type="__m128i" varname="a" etype="SI32"/>
	<parameter type="__m128i" varname="b" etype="SI32"/>
	<description>Negate packed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGND" form="xmm, xmm" xed="PSIGND_XMMdq_XMMdq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi8">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI8"/>
	<parameter type="__m64" varname="a" etype="SI8"/>
	<parameter type="__m64" varname="b" etype="SI8"/>
	<description>Negate packed 8-bit integers in "a" when the corresponding signed 8-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 7
	i := j*8
	IF b[i+7:i] &lt; 0
		dst[i+7:i] := -(a[i+7:i])
	ELSE IF b[i+7:i] == 0
		dst[i+7:i] := 0
	ELSE
		dst[i+7:i] := a[i+7:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNB" form="mm, mm" xed="PSIGNB_MMXq_MMXq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi16">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI16"/>
	<parameter type="__m64" varname="a" etype="SI16"/>
	<parameter type="__m64" varname="b" etype="SI16"/>
	<description>Negate packed 16-bit integers in "a" when the corresponding signed 16-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 3
	i := j*16
	IF b[i+15:i] &lt; 0
		dst[i+15:i] := -(a[i+15:i])
	ELSE IF b[i+15:i] == 0
		dst[i+15:i] := 0
	ELSE
		dst[i+15:i] := a[i+15:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGNW" form="mm, mm" xed="PSIGNW_MMXq_MMXq"/>
	<header>tmmintrin.h</header>
</intrinsic>
<intrinsic tech="SSSE3" name="_mm_sign_pi32">
	<type>Integer</type>
	<CPUID>SSSE3</CPUID>
	<category>Arithmetic</category>
	<return type="__m64" varname="dst" etype="UI32"/>
	<parameter type="__m64" varname="a" etype="SI32"/>
	<parameter type="__m64" varname="b" etype="SI32"/>
	<description>Negate packed 32-bit integers in "a" when the corresponding signed 32-bit integer in "b" is negative, and store the results in "dst". Element in "dst" are zeroed out when the corresponding element in "b" is zero.</description>
	<operation>
FOR j := 0 to 1
	i := j*32
	IF b[i+31:i] &lt; 0
		dst[i+31:i] := -(a[i+31:i])
	ELSE IF b[i+31:i] == 0
		dst[i+31:i] := 0
	ELSE
		dst[i+31:i] := a[i+31:i]
	FI
ENDFOR
	</operation>
	<instruction name="PSIGND" form="mm, mm" xed="PSIGND_MMXq_MMXq"/>
	<header>tmmintrin.h</header>
</intrinsic>
</intrinsics_list>
